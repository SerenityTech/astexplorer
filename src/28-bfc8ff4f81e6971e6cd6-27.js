/*! For license information please see 28-bfc8ff4f81e6971e6cd6-27.js.LICENSE.txt */
(window.webpackJsonp = window.webpackJsonp || []).push([[28], {
    "+4SP": function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.nodes = r.list = void 0;
        var a = i("JSq2");
        const {FLIPPED_ALIAS_KEYS: o, isArrayExpression: l, isAssignmentExpression: u, isBinary: p, isBlockStatement: c, isCallExpression: d, isFunction: y, isIdentifier: h, isLiteral: m, isMemberExpression: T, isObjectExpression: S, isOptionalCallExpression: g, isOptionalMemberExpression: b, isStringLiteral: v} = a;
        function crawl(t, r={}) {
            return T(t) || b(t) ? (crawl(t.object, r),
            t.computed && crawl(t.property, r)) : p(t) || u(t) ? (crawl(t.left, r),
            crawl(t.right, r)) : d(t) || g(t) ? (r.hasCall = !0,
            crawl(t.callee, r)) : y(t) ? r.hasFunction = !0 : h(t) && (r.hasHelper = r.hasHelper || isHelper(t.callee)),
            r
        }
        function isHelper(t) {
            return T(t) ? isHelper(t.object) || isHelper(t.property) : h(t) ? "require" === t.name || "_" === t.name[0] : d(t) ? isHelper(t.callee) : !(!p(t) && !u(t)) && (h(t.left) && isHelper(t.left) || isHelper(t.right))
        }
        function isType(t) {
            return m(t) || S(t) || l(t) || h(t) || T(t)
        }
        const E = {
            AssignmentExpression(t) {
                const r = crawl(t.right);
                if (r.hasCall && r.hasHelper || r.hasFunction)
                    return {
                        before: r.hasFunction,
                        after: !0
                    }
            },
            SwitchCase: (t,r)=>({
                before: !!t.consequent.length || r.cases[0] === t,
                after: !t.consequent.length && r.cases[r.cases.length - 1] === t
            }),
            LogicalExpression(t) {
                if (y(t.left) || y(t.right))
                    return {
                        after: !0
                    }
            },
            Literal(t) {
                if (v(t) && "use strict" === t.value)
                    return {
                        after: !0
                    }
            },
            CallExpression(t) {
                if (y(t.callee) || isHelper(t))
                    return {
                        before: !0,
                        after: !0
                    }
            },
            OptionalCallExpression(t) {
                if (y(t.callee))
                    return {
                        before: !0,
                        after: !0
                    }
            },
            VariableDeclaration(t) {
                for (let r = 0; r < t.declarations.length; r++) {
                    const i = t.declarations[r];
                    let a = isHelper(i.id) && !isType(i.init);
                    if (!a) {
                        const t = crawl(i.init);
                        a = isHelper(i.init) && t.hasCall || t.hasFunction
                    }
                    if (a)
                        return {
                            before: !0,
                            after: !0
                        }
                }
            },
            IfStatement(t) {
                if (c(t.consequent))
                    return {
                        before: !0,
                        after: !0
                    }
            }
        };
        r.nodes = E,
        E.ObjectProperty = E.ObjectTypeProperty = E.ObjectMethod = function(t, r) {
            if (r.properties[0] === t)
                return {
                    before: !0
                }
        }
        ,
        E.ObjectTypeCallProperty = function(t, r) {
            var i;
            if (r.callProperties[0] === t && (null == (i = r.properties) || !i.length))
                return {
                    before: !0
                }
        }
        ,
        E.ObjectTypeIndexer = function(t, r) {
            var i, a;
            if (!(r.indexers[0] !== t || null != (i = r.properties) && i.length || null != (a = r.callProperties) && a.length))
                return {
                    before: !0
                }
        }
        ,
        E.ObjectTypeInternalSlot = function(t, r) {
            var i, a, o;
            if (!(r.internalSlots[0] !== t || null != (i = r.properties) && i.length || null != (a = r.callProperties) && a.length || null != (o = r.indexers) && o.length))
                return {
                    before: !0
                }
        }
        ;
        const P = {
            VariableDeclaration: t=>t.declarations.map(t=>t.init),
            ArrayExpression: t=>t.elements,
            ObjectExpression: t=>t.properties
        };
        r.list = P,
        [["Function", !0], ["Class", !0], ["Loop", !0], ["LabeledStatement", !0], ["SwitchStatement", !0], ["TryStatement", !0]].forEach((function([t,r]) {
            "boolean" == typeof r && (r = {
                after: r,
                before: r
            }),
            [t].concat(o[t] || []).forEach((function(t) {
                E[t] = function() {
                    return r
                }
            }
            ))
        }
        ))
    },
    "+DtF": function(t, r, i) {
        "use strict";
        var a = i("e5Hd")
          , o = i("O9f4")
          , l = i("Xd/d")
          , u = i("Hczm");
        t.exports = function(t, r, i, p) {
            t.tokens = l(t.tokens, i, p),
            o(t.comments),
            u(t, r, p),
            t.type = "Program",
            t.sourceType = t.program.sourceType,
            t.directives = t.program.directives,
            t.body = t.program.body,
            delete t.program,
            a(t, t.comments, t.tokens)
        }
    },
    "+FIw": function(t, r, i) {
        "use strict";
        function _createForOfIteratorHelper(t, r) {
            var i = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
            if (!i) {
                if (Array.isArray(t) || (i = function _unsupportedIterableToArray(t, r) {
                    if (!t)
                        return;
                    if ("string" == typeof t)
                        return _arrayLikeToArray(t, r);
                    var i = Object.prototype.toString.call(t).slice(8, -1);
                    "Object" === i && t.constructor && (i = t.constructor.name);
                    if ("Map" === i || "Set" === i)
                        return Array.from(t);
                    if ("Arguments" === i || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i))
                        return _arrayLikeToArray(t, r)
                }(t)) || r && t && "number" == typeof t.length) {
                    i && (t = i);
                    var a = 0
                      , o = function F() {};
                    return {
                        s: o,
                        n: function n() {
                            return a >= t.length ? {
                                done: !0
                            } : {
                                done: !1,
                                value: t[a++]
                            }
                        },
                        e: function e(t) {
                            throw t
                        },
                        f: o
                    }
                }
                throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
            }
            var l, u = !0, p = !1;
            return {
                s: function s() {
                    i = i.call(t)
                },
                n: function n() {
                    var t = i.next();
                    return u = t.done,
                    t
                },
                e: function e(t) {
                    p = !0,
                    l = t
                },
                f: function f() {
                    try {
                        u || null == i.return || i.return()
                    } finally {
                        if (p)
                            throw l
                    }
                }
            }
        }
        function _arrayLikeToArray(t, r) {
            (null == r || r > t.length) && (r = t.length);
            for (var i = 0, a = new Array(r); i < r; i++)
                a[i] = t[i];
            return a
        }
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function traverseFast(t, r, i) {
            if (!t)
                return;
            var o = a.VISITOR_KEYS[t.type];
            if (!o)
                return;
            r(t, i = i || {});
            var l, u = _createForOfIteratorHelper(o);
            try {
                for (u.s(); !(l = u.n()).done; ) {
                    var p = l.value
                      , c = t[p];
                    if (Array.isArray(c)) {
                        var d, y = _createForOfIteratorHelper(c);
                        try {
                            for (y.s(); !(d = y.n()).done; ) {
                                var h = d.value;
                                traverseFast(h, r, i)
                            }
                        } catch (t) {
                            y.e(t)
                        } finally {
                            y.f()
                        }
                    } else
                        traverseFast(c, r, i)
                }
            } catch (t) {
                u.e(t)
            } finally {
                u.f()
            }
        }
        ;
        var a = i("UHlb")
    },
    "+l3Y": function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function inheritLeadingComments(t, r) {
            (0,
            a.default)("leadingComments", t, r)
        }
        ;
        var a = i("ExWc")
    },
    "+v0W": function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function traverseFast(t, r, i) {
            if (!t)
                return;
            const o = a.VISITOR_KEYS[t.type];
            if (!o)
                return;
            r(t, i = i || {});
            for (const a of o) {
                const o = t[a];
                if (Array.isArray(o))
                    for (const t of o)
                        traverseFast(t, r, i);
                else
                    traverseFast(o, r, i)
            }
        }
        ;
        var a = i("uXiX")
    },
    "+zpO": function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.merge = function merge(t, r) {
            const {placeholderWhitelist: i=t.placeholderWhitelist, placeholderPattern: a=t.placeholderPattern, preserveComments: o=t.preserveComments, syntacticPlaceholders: l=t.syntacticPlaceholders} = r;
            return {
                parser: Object.assign({}, t.parser, r.parser),
                placeholderWhitelist: i,
                placeholderPattern: a,
                preserveComments: o,
                syntacticPlaceholders: l
            }
        }
        ,
        r.normalizeReplacements = function normalizeReplacements(t) {
            if (Array.isArray(t))
                return t.reduce((t,r,i)=>(t["$" + i] = r,
                t), {});
            if ("object" == typeof t || null == t)
                return t || void 0;
            throw new Error("Template replacements must be an array, object, null, or undefined")
        }
        ,
        r.validate = function validate(t) {
            if (null != t && "object" != typeof t)
                throw new Error("Unknown template options.");
            const r = t || {}
              , {placeholderWhitelist: i, placeholderPattern: o, preserveComments: l, syntacticPlaceholders: u} = r
              , p = function _objectWithoutPropertiesLoose(t, r) {
                if (null == t)
                    return {};
                var i, a, o = {}, l = Object.keys(t);
                for (a = 0; a < l.length; a++)
                    i = l[a],
                    r.indexOf(i) >= 0 || (o[i] = t[i]);
                return o
            }(r, a);
            if (null != i && !(i instanceof Set))
                throw new Error("'.placeholderWhitelist' must be a Set, null, or undefined");
            if (null != o && !(o instanceof RegExp) && !1 !== o)
                throw new Error("'.placeholderPattern' must be a RegExp, false, null, or undefined");
            if (null != l && "boolean" != typeof l)
                throw new Error("'.preserveComments' must be a boolean, null, or undefined");
            if (null != u && "boolean" != typeof u)
                throw new Error("'.syntacticPlaceholders' must be a boolean, null, or undefined");
            if (!0 === u && (null != i || null != o))
                throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible with '.syntacticPlaceholders: true'");
            return {
                parser: p,
                placeholderWhitelist: i || void 0,
                placeholderPattern: null == o ? void 0 : o,
                preserveComments: null == l ? void 0 : l,
                syntacticPlaceholders: null == u ? void 0 : u
            }
        }
        ;
        const a = ["placeholderWhitelist", "placeholderPattern", "preserveComments", "syntacticPlaceholders"]
    },
    "/YTm": function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.statements = r.statement = r.smart = r.program = r.expression = r.default = void 0;
        var a = i("Maqe")
          , o = i("jwsk");
        const l = (0,
        o.default)(a.smart);
        r.smart = l;
        const u = (0,
        o.default)(a.statement);
        r.statement = u;
        const p = (0,
        o.default)(a.statements);
        r.statements = p;
        const c = (0,
        o.default)(a.expression);
        r.expression = c;
        const d = (0,
        o.default)(a.program);
        r.program = d;
        var y = Object.assign(l.bind(void 0), {
            smart: l,
            statement: u,
            statements: p,
            expression: c,
            program: d,
            ast: l.ast
        });
        r.default = y
    },
    "/erN": function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function ensureBlock(t) {
            var r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "body";
            return t[r] = (0,
            a.default)(t[r], t)
        }
        ;
        var a = i("dtFd")
    },
    "/g1/": function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function matchesPattern(t, r, i) {
            if (!(0,
            a.isMemberExpression)(t))
                return !1;
            const o = Array.isArray(r) ? r : r.split(".")
              , l = [];
            let u;
            for (u = t; (0,
            a.isMemberExpression)(u); u = u.object)
                l.push(u.property);
            if (l.push(u),
            l.length < o.length)
                return !1;
            if (!i && l.length > o.length)
                return !1;
            for (let t = 0, r = l.length - 1; t < o.length; t++,
            r--) {
                const i = l[r];
                let u;
                if ((0,
                a.isIdentifier)(i))
                    u = i.name;
                else if ((0,
                a.isStringLiteral)(i))
                    u = i.value;
                else {
                    if (!(0,
                    a.isThisExpression)(i))
                        return !1;
                    u = "this"
                }
                if (o[t] !== u)
                    return !1
            }
            return !0
        }
        ;
        var a = i("xIU+")
    },
    "/nHh": function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function buildChildren(t) {
            for (var r = [], i = 0; i < t.children.length; i++) {
                var l = t.children[i];
                (0,
                a.isJSXText)(l) ? (0,
                o.default)(l, r) : ((0,
                a.isJSXExpressionContainer)(l) && (l = l.expression),
                (0,
                a.isJSXEmptyExpression)(l) || r.push(l))
            }
            return r
        }
        ;
        var a = i("pbIU")
          , o = i("nYh1")
    },
    "01Gy": function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function buildChildren(t) {
            for (var r = [], i = 0; i < t.children.length; i++) {
                var l = t.children[i];
                (0,
                a.isJSXText)(l) ? (0,
                o.default)(l, r) : ((0,
                a.isJSXExpressionContainer)(l) && (l = l.expression),
                (0,
                a.isJSXEmptyExpression)(l) || r.push(l))
            }
            return r
        }
        ;
        var a = i("FUES")
          , o = i("X2aU")
    },
    "0Awz": function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function toBlock(t, r) {
            if ((0,
            a.isBlockStatement)(t))
                return t;
            var i = [];
            (0,
            a.isEmptyStatement)(t) ? i = [] : ((0,
            a.isStatement)(t) || (t = (0,
            a.isFunction)(r) ? (0,
            o.returnStatement)(t) : (0,
            o.expressionStatement)(t)),
            i = [t]);
            return (0,
            o.blockStatement)(i)
        }
        ;
        var a = i("pbIU")
          , o = i("UuI8")
    },
    "0Cqy": function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function shallowEqual(t, r) {
            for (var i = Object.keys(r), a = 0, o = i; a < o.length; a++) {
                var l = o[a];
                if (t[l] !== r[l])
                    return !1
            }
            return !0
        }
    },
    "0G7A": function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function is(t, r, i) {
            if (!r)
                return !1;
            if (!(0,
            o.default)(r.type, t))
                return !i && "Placeholder" === r.type && t in u.FLIPPED_ALIAS_KEYS && (0,
                l.default)(r.expectedNode, t);
            return void 0 === i || (0,
            a.default)(r, i)
        }
        ;
        var a = i("0Cqy")
          , o = i("Mrar")
          , l = i("Xz4/")
          , u = i("Resm")
    },
    "0GJC": function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.ArgumentPlaceholder = function ArgumentPlaceholder() {
            this.token("?")
        }
        ,
        r.ArrayPattern = r.ArrayExpression = function ArrayExpression(t) {
            const r = t.elements
              , i = r.length;
            this.token("["),
            this.printInnerComments(t);
            for (let a = 0; a < r.length; a++) {
                const o = r[a];
                o ? (a > 0 && this.space(),
                this.print(o, t),
                a < i - 1 && this.token(",")) : this.token(",")
            }
            this.token("]")
        }
        ,
        r.BigIntLiteral = function BigIntLiteral(t) {
            const r = this.getPossibleRaw(t);
            if (!this.format.minified && null != r)
                return void this.word(r);
            this.word(t.value + "n")
        }
        ,
        r.BooleanLiteral = function BooleanLiteral(t) {
            this.word(t.value ? "true" : "false")
        }
        ,
        r.DecimalLiteral = function DecimalLiteral(t) {
            const r = this.getPossibleRaw(t);
            if (!this.format.minified && null != r)
                return void this.word(r);
            this.word(t.value + "m")
        }
        ,
        r.Identifier = function Identifier(t) {
            this.exactSource(t.loc, ()=>{
                this.word(t.name)
            }
            )
        }
        ,
        r.NullLiteral = function NullLiteral() {
            this.word("null")
        }
        ,
        r.NumericLiteral = function NumericLiteral(t) {
            const r = this.getPossibleRaw(t)
              , i = this.format.jsescOption
              , a = t.value + "";
            i.numbers ? this.number(o(t.value, i)) : null == r ? this.number(a) : this.format.minified ? this.number(r.length < a.length ? r : a) : this.number(r)
        }
        ,
        r.ObjectPattern = r.ObjectExpression = function ObjectExpression(t) {
            const r = t.properties;
            this.token("{"),
            this.printInnerComments(t),
            r.length && (this.space(),
            this.printList(r, t, {
                indent: !0,
                statement: !0
            }),
            this.space());
            this.token("}")
        }
        ,
        r.ObjectMethod = function ObjectMethod(t) {
            this.printJoin(t.decorators, t),
            this._methodHead(t),
            this.space(),
            this.print(t.body, t)
        }
        ,
        r.ObjectProperty = function ObjectProperty(t) {
            if (this.printJoin(t.decorators, t),
            t.computed)
                this.token("["),
                this.print(t.key, t),
                this.token("]");
            else {
                if (l(t.value) && u(t.key) && t.key.name === t.value.left.name)
                    return void this.print(t.value, t);
                if (this.print(t.key, t),
                t.shorthand && u(t.key) && u(t.value) && t.key.name === t.value.name)
                    return
            }
            this.token(":"),
            this.space(),
            this.print(t.value, t)
        }
        ,
        r.PipelineBareFunction = function PipelineBareFunction(t) {
            this.print(t.callee, t)
        }
        ,
        r.PipelinePrimaryTopicReference = function PipelinePrimaryTopicReference() {
            this.token("#")
        }
        ,
        r.PipelineTopicExpression = function PipelineTopicExpression(t) {
            this.print(t.expression, t)
        }
        ,
        r.RecordExpression = function RecordExpression(t) {
            const r = t.properties;
            let i, a;
            if ("bar" === this.format.recordAndTupleSyntaxType)
                i = "{|",
                a = "|}";
            else {
                if ("hash" !== this.format.recordAndTupleSyntaxType)
                    throw new Error(`The "recordAndTupleSyntaxType" generator option must be "bar" or "hash" (${JSON.stringify(this.format.recordAndTupleSyntaxType)} received).`);
                i = "#{",
                a = "}"
            }
            this.token(i),
            this.printInnerComments(t),
            r.length && (this.space(),
            this.printList(r, t, {
                indent: !0,
                statement: !0
            }),
            this.space());
            this.token(a)
        }
        ,
        r.RegExpLiteral = function RegExpLiteral(t) {
            this.word(`/${t.pattern}/${t.flags}`)
        }
        ,
        r.SpreadElement = r.RestElement = function RestElement(t) {
            this.token("..."),
            this.print(t.argument, t)
        }
        ,
        r.StringLiteral = function StringLiteral(t) {
            const r = this.getPossibleRaw(t);
            if (!this.format.minified && null != r)
                return void this.token(r);
            const i = o(t.value, Object.assign(this.format.jsescOption, this.format.jsonCompatibleStrings && {
                json: !0
            }));
            return this.token(i)
        }
        ,
        r.TopicReference = function TopicReference() {
            const {topicToken: t} = this.format;
            if (!p.has(t)) {
                const r = JSON.stringify(t)
                  , i = Array.from(p, t=>JSON.stringify(t));
                throw new Error(`The "topicToken" generator option must be one of ${i.join(", ")} (${r} received instead).`)
            }
            this.token(t)
        }
        ,
        r.TupleExpression = function TupleExpression(t) {
            const r = t.elements
              , i = r.length;
            let a, o;
            if ("bar" === this.format.recordAndTupleSyntaxType)
                a = "[|",
                o = "|]";
            else {
                if ("hash" !== this.format.recordAndTupleSyntaxType)
                    throw new Error(this.format.recordAndTupleSyntaxType + " is not a valid recordAndTuple syntax type");
                a = "#[",
                o = "]"
            }
            this.token(a),
            this.printInnerComments(t);
            for (let a = 0; a < r.length; a++) {
                const o = r[a];
                o && (a > 0 && this.space(),
                this.print(o, t),
                a < i - 1 && this.token(","))
            }
            this.token(o)
        }
        ;
        var a = i("JSq2")
          , o = i("tZ1K");
        const {isAssignmentPattern: l, isIdentifier: u} = a;
        const p = new Set(["^", "%", "#"])
    },
    "0JKf": function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function inheritsComments(t, r) {
            return (0,
            a.default)(t, r),
            (0,
            o.default)(t, r),
            (0,
            l.default)(t, r),
            t
        }
        ;
        var a = i("OLSu")
          , o = i("uDmM")
          , l = i("8iKV")
    },
    "0ZK1": function(t, r, i) {
        "use strict";
        let a = null;
        function FastObject(t) {
            if (null !== a && (a.property,
            1)) {
                const t = a;
                return a = FastObject.prototype = null,
                t
            }
            return a = FastObject.prototype = null == t ? Object.create(null) : t,
            new FastObject
        }
        FastObject(),
        t.exports = function toFastproperties(t) {
            return FastObject(t)
        }
    },
    "0dgS": function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function createFlowUnionType(t) {
            var r = (0,
            o.default)(t);
            return 1 === r.length ? r[0] : (0,
            a.unionTypeAnnotation)(r)
        }
        ;
        var a = i("57mi")
          , o = i("EOii")
    },
    "0fRI": function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function prependToMemberExpression(t, r) {
            return t.object = (0,
            a.memberExpression)(r, t.object),
            t
        }
        ;
        var a = i("61uC")
    },
    "0k9f": function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function inheritsComments(t, r) {
            return (0,
            a.default)(t, r),
            (0,
            o.default)(t, r),
            (0,
            l.default)(t, r),
            t
        }
        ;
        var a = i("Oz16")
          , o = i("IaKS")
          , l = i("NFYY")
    },
    "1/cg": function(t, r, i) {
        "use strict";
        function _createForOfIteratorHelper(t, r) {
            var i = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
            if (!i) {
                if (Array.isArray(t) || (i = function _unsupportedIterableToArray(t, r) {
                    if (!t)
                        return;
                    if ("string" == typeof t)
                        return _arrayLikeToArray(t, r);
                    var i = Object.prototype.toString.call(t).slice(8, -1);
                    "Object" === i && t.constructor && (i = t.constructor.name);
                    if ("Map" === i || "Set" === i)
                        return Array.from(t);
                    if ("Arguments" === i || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i))
                        return _arrayLikeToArray(t, r)
                }(t)) || r && t && "number" == typeof t.length) {
                    i && (t = i);
                    var a = 0
                      , o = function F() {};
                    return {
                        s: o,
                        n: function n() {
                            return a >= t.length ? {
                                done: !0
                            } : {
                                done: !1,
                                value: t[a++]
                            }
                        },
                        e: function e(t) {
                            throw t
                        },
                        f: o
                    }
                }
                throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
            }
            var l, u = !0, p = !1;
            return {
                s: function s() {
                    i = i.call(t)
                },
                n: function n() {
                    var t = i.next();
                    return u = t.done,
                    t
                },
                e: function e(t) {
                    p = !0,
                    l = t
                },
                f: function f() {
                    try {
                        u || null == i.return || i.return()
                    } finally {
                        if (p)
                            throw l
                    }
                }
            }
        }
        function _arrayLikeToArray(t, r) {
            (null == r || r > t.length) && (r = t.length);
            for (var i = 0, a = new Array(r); i < r; i++)
                a[i] = t[i];
            return a
        }
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.replaceWithMultiple = function replaceWithMultiple(t) {
            var r;
            this.resync(),
            t = this._verifyNodeList(t),
            c.inheritLeadingComments(t[0], this.node),
            c.inheritTrailingComments(t[t.length - 1], this.node),
            null == (r = u.path.get(this.parent)) || r.delete(this.node),
            this.node = this.container[this.key] = null;
            var i = this.insertAfter(t);
            this.node ? this.requeue() : this.remove();
            return i
        }
        ,
        r.replaceWithSourceString = function replaceWithSourceString(t) {
            this.resync();
            try {
                t = "(".concat(t, ")"),
                t = (0,
                p.parse)(t)
            } catch (i) {
                var r = i.loc;
                throw r && (i.message += " - make sure this is an expression.\n" + (0,
                a.codeFrameColumns)(t, {
                    start: {
                        line: r.line,
                        column: r.column + 1
                    }
                }),
                i.code = "BABEL_REPLACE_SOURCE_ERROR"),
                i
            }
            return t = t.program.body[0].expression,
            o.default.removeProperties(t),
            this.replaceWith(t)
        }
        ,
        r.replaceWith = function replaceWith(t) {
            if (this.resync(),
            this.removed)
                throw new Error("You can't replace this node, we've already removed it");
            t instanceof l.default && (t = t.node);
            if (!t)
                throw new Error("You passed `path.replaceWith()` a falsy node, use `path.remove()` instead");
            if (this.node === t)
                return [this];
            if (this.isProgram() && !c.isProgram(t))
                throw new Error("You can only replace a Program root node with another Program node");
            if (Array.isArray(t))
                throw new Error("Don't use `path.replaceWith()` with an array of nodes, use `path.replaceWithMultiple()`");
            if ("string" == typeof t)
                throw new Error("Don't use `path.replaceWith()` with a source string, use `path.replaceWithSourceString()`");
            var r = "";
            this.isNodeType("Statement") && c.isExpression(t) && (this.canHaveVariableDeclarationOrExpression() || this.canSwapBetweenExpressionAndStatement(t) || this.parentPath.isExportDefaultDeclaration() || (t = c.expressionStatement(t),
            r = "expression"));
            if (this.isNodeType("Expression") && c.isStatement(t) && !this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(t))
                return this.replaceExpressionWithStatements([t]);
            var i = this.node;
            i && (c.inheritsComments(t, i),
            c.removeComments(i));
            return this._replaceWith(t),
            this.type = t.type,
            this.setScope(),
            this.requeue(),
            [r ? this.get(r) : this]
        }
        ,
        r._replaceWith = function _replaceWith(t) {
            var r;
            if (!this.container)
                throw new ReferenceError("Container is falsy");
            this.inList ? c.validate(this.parent, this.key, [t]) : c.validate(this.parent, this.key, t);
            this.debug("Replace with ".concat(null == t ? void 0 : t.type)),
            null == (r = u.path.get(this.parent)) || r.set(t, this).delete(this.node),
            this.node = this.container[this.key] = t
        }
        ,
        r.replaceExpressionWithStatements = function replaceExpressionWithStatements(t) {
            var r = this;
            this.resync();
            var i = c.toSequenceExpression(t, this.scope);
            if (i)
                return this.replaceWith(i)[0].get("expressions");
            var a = this.getFunctionParent()
              , l = null == a ? void 0 : a.is("async")
              , u = null == a ? void 0 : a.is("generator")
              , p = c.arrowFunctionExpression([], c.blockStatement(t));
            this.replaceWith(c.callExpression(p, []));
            var y = this.get("callee");
            (0,
            d.default)(y.get("body"), (function(t) {
                r.scope.push({
                    id: t
                })
            }
            ), "var");
            var h, m = _createForOfIteratorHelper(this.get("callee").getCompletionRecords());
            try {
                for (m.s(); !(h = m.n()).done; ) {
                    var T = h.value;
                    if (T.isExpressionStatement()) {
                        var S = T.findParent((function(t) {
                            return t.isLoop()
                        }
                        ));
                        if (S) {
                            var g = S.getData("expressionReplacementReturnUid");
                            g ? g = c.identifier(g.name) : (g = y.scope.generateDeclaredUidIdentifier("ret"),
                            y.get("body").pushContainer("body", c.returnStatement(c.cloneNode(g))),
                            S.setData("expressionReplacementReturnUid", g)),
                            T.get("expression").replaceWith(c.assignmentExpression("=", c.cloneNode(g), T.node.expression))
                        } else
                            T.replaceWith(c.returnStatement(T.node.expression))
                    }
                }
            } catch (t) {
                m.e(t)
            } finally {
                m.f()
            }
            y.arrowFunctionToExpression();
            var b = y
              , v = l && o.default.hasType(this.get("callee.body").node, "AwaitExpression", c.FUNCTION_TYPES)
              , E = u && o.default.hasType(this.get("callee.body").node, "YieldExpression", c.FUNCTION_TYPES);
            v && (b.set("async", !0),
            E || this.replaceWith(c.awaitExpression(this.node)));
            E && (b.set("generator", !0),
            this.replaceWith(c.yieldExpression(this.node, !0)));
            return b.get("body.body")
        }
        ,
        r.replaceInline = function replaceInline(t) {
            if (this.resync(),
            Array.isArray(t)) {
                if (Array.isArray(this.container)) {
                    t = this._verifyNodeList(t);
                    var r = this._containerInsertAfter(t);
                    return this.remove(),
                    r
                }
                return this.replaceWithMultiple(t)
            }
            return this.replaceWith(t)
        }
        ;
        var a = i("2Per")
          , o = i("LR/y")
          , l = i("MBGo")
          , u = i("qMwM")
          , p = i("GGH7")
          , c = i("ZtNB")
          , d = i("5Qwp")
    },
    "1a3c": function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.LogicalExpression = r.BinaryExpression = r.AssignmentExpression = function AssignmentExpression(t, r) {
            const i = this.inForStatementInitCounter && "in" === t.operator && !o.needsParens(t, r);
            i && this.token("(");
            this.print(t.left, t),
            this.space(),
            "in" === t.operator || "instanceof" === t.operator ? this.word(t.operator) : this.token(t.operator);
            this.space(),
            this.print(t.right, t),
            i && this.token(")")
        }
        ,
        r.AssignmentPattern = function AssignmentPattern(t) {
            this.print(t.left, t),
            t.left.optional && this.token("?");
            this.print(t.left.typeAnnotation, t),
            this.space(),
            this.token("="),
            this.space(),
            this.print(t.right, t)
        }
        ,
        r.AwaitExpression = void 0,
        r.BindExpression = function BindExpression(t) {
            this.print(t.object, t),
            this.token("::"),
            this.print(t.callee, t)
        }
        ,
        r.CallExpression = function CallExpression(t) {
            this.print(t.callee, t),
            this.print(t.typeArguments, t),
            this.print(t.typeParameters, t),
            this.token("("),
            this.printList(t.arguments, t),
            this.token(")")
        }
        ,
        r.ConditionalExpression = function ConditionalExpression(t) {
            this.print(t.test, t),
            this.space(),
            this.token("?"),
            this.space(),
            this.print(t.consequent, t),
            this.space(),
            this.token(":"),
            this.space(),
            this.print(t.alternate, t)
        }
        ,
        r.Decorator = function Decorator(t) {
            this.token("@"),
            this.print(t.expression, t),
            this.newline()
        }
        ,
        r.DoExpression = function DoExpression(t) {
            t.async && (this.word("async"),
            this.space());
            this.word("do"),
            this.space(),
            this.print(t.body, t)
        }
        ,
        r.EmptyStatement = function EmptyStatement() {
            this.semicolon(!0)
        }
        ,
        r.ExpressionStatement = function ExpressionStatement(t) {
            this.print(t.expression, t),
            this.semicolon()
        }
        ,
        r.Import = function Import() {
            this.word("import")
        }
        ,
        r.MemberExpression = function MemberExpression(t) {
            if (this.print(t.object, t),
            !t.computed && p(t.property))
                throw new TypeError("Got a MemberExpression for MemberExpression property");
            let r = t.computed;
            u(t.property) && "number" == typeof t.property.value && (r = !0);
            r ? (this.token("["),
            this.print(t.property, t),
            this.token("]")) : (this.token("."),
            this.print(t.property, t))
        }
        ,
        r.MetaProperty = function MetaProperty(t) {
            this.print(t.meta, t),
            this.token("."),
            this.print(t.property, t)
        }
        ,
        r.ModuleExpression = function ModuleExpression(t) {
            this.word("module"),
            this.space(),
            this.token("{"),
            0 === t.body.body.length ? this.token("}") : (this.newline(),
            this.printSequence(t.body.body, t, {
                indent: !0
            }),
            this.rightBrace())
        }
        ,
        r.NewExpression = function NewExpression(t, r) {
            if (this.word("new"),
            this.space(),
            this.print(t.callee, t),
            this.format.minified && 0 === t.arguments.length && !t.optional && !l(r, {
                callee: t
            }) && !p(r) && !c(r))
                return;
            this.print(t.typeArguments, t),
            this.print(t.typeParameters, t),
            t.optional && this.token("?.");
            this.token("("),
            this.printList(t.arguments, t),
            this.token(")")
        }
        ,
        r.OptionalCallExpression = function OptionalCallExpression(t) {
            this.print(t.callee, t),
            this.print(t.typeArguments, t),
            this.print(t.typeParameters, t),
            t.optional && this.token("?.");
            this.token("("),
            this.printList(t.arguments, t),
            this.token(")")
        }
        ,
        r.OptionalMemberExpression = function OptionalMemberExpression(t) {
            if (this.print(t.object, t),
            !t.computed && p(t.property))
                throw new TypeError("Got a MemberExpression for MemberExpression property");
            let r = t.computed;
            u(t.property) && "number" == typeof t.property.value && (r = !0);
            t.optional && this.token("?.");
            r ? (this.token("["),
            this.print(t.property, t),
            this.token("]")) : (t.optional || this.token("."),
            this.print(t.property, t))
        }
        ,
        r.ParenthesizedExpression = function ParenthesizedExpression(t) {
            this.token("("),
            this.print(t.expression, t),
            this.token(")")
        }
        ,
        r.PrivateName = function PrivateName(t) {
            this.token("#"),
            this.print(t.id, t)
        }
        ,
        r.SequenceExpression = function SequenceExpression(t) {
            this.printList(t.expressions, t)
        }
        ,
        r.Super = function Super() {
            this.word("super")
        }
        ,
        r.ThisExpression = function ThisExpression() {
            this.word("this")
        }
        ,
        r.UnaryExpression = function UnaryExpression(t) {
            "void" === t.operator || "delete" === t.operator || "typeof" === t.operator || "throw" === t.operator ? (this.word(t.operator),
            this.space()) : this.token(t.operator);
            this.print(t.argument, t)
        }
        ,
        r.UpdateExpression = function UpdateExpression(t) {
            t.prefix ? (this.token(t.operator),
            this.print(t.argument, t)) : (this.startTerminatorless(!0),
            this.print(t.argument, t),
            this.endTerminatorless(),
            this.token(t.operator))
        }
        ,
        r.V8IntrinsicIdentifier = function V8IntrinsicIdentifier(t) {
            this.token("%"),
            this.word(t.name)
        }
        ,
        r.YieldExpression = void 0;
        var a = i("JSq2")
          , o = i("Q/1+");
        const {isCallExpression: l, isLiteral: u, isMemberExpression: p, isNewExpression: c} = a;
        function buildYieldAwait(t) {
            return function(r) {
                if (this.word(t),
                r.delegate && this.token("*"),
                r.argument) {
                    this.space();
                    const t = this.startTerminatorless();
                    this.print(r.argument, r),
                    this.endTerminatorless(t)
                }
            }
        }
        const d = buildYieldAwait("yield");
        r.YieldExpression = d;
        const y = buildYieldAwait("await");
        r.AwaitExpression = y
    },
    "1gqn": function(t, r) {
        t.exports = function isBuffer(t) {
            return t && "object" == typeof t && "function" == typeof t.copy && "function" == typeof t.fill && "function" == typeof t.readUInt8
        }
    },
    "1h53": function(t, r, i) {
        "use strict";
        function spaceSeparator() {
            this.space()
        }
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.JSXAttribute = function JSXAttribute(t) {
            this.print(t.name, t),
            t.value && (this.token("="),
            this.print(t.value, t))
        }
        ,
        r.JSXClosingElement = function JSXClosingElement(t) {
            this.token("</"),
            this.print(t.name, t),
            this.token(">")
        }
        ,
        r.JSXClosingFragment = function JSXClosingFragment() {
            this.token("</"),
            this.token(">")
        }
        ,
        r.JSXElement = function JSXElement(t) {
            const r = t.openingElement;
            if (this.print(r, t),
            r.selfClosing)
                return;
            this.indent();
            for (const r of t.children)
                this.print(r, t);
            this.dedent(),
            this.print(t.closingElement, t)
        }
        ,
        r.JSXEmptyExpression = function JSXEmptyExpression(t) {
            this.printInnerComments(t)
        }
        ,
        r.JSXExpressionContainer = function JSXExpressionContainer(t) {
            this.token("{"),
            this.print(t.expression, t),
            this.token("}")
        }
        ,
        r.JSXFragment = function JSXFragment(t) {
            this.print(t.openingFragment, t),
            this.indent();
            for (const r of t.children)
                this.print(r, t);
            this.dedent(),
            this.print(t.closingFragment, t)
        }
        ,
        r.JSXIdentifier = function JSXIdentifier(t) {
            this.word(t.name)
        }
        ,
        r.JSXMemberExpression = function JSXMemberExpression(t) {
            this.print(t.object, t),
            this.token("."),
            this.print(t.property, t)
        }
        ,
        r.JSXNamespacedName = function JSXNamespacedName(t) {
            this.print(t.namespace, t),
            this.token(":"),
            this.print(t.name, t)
        }
        ,
        r.JSXOpeningElement = function JSXOpeningElement(t) {
            this.token("<"),
            this.print(t.name, t),
            this.print(t.typeParameters, t),
            t.attributes.length > 0 && (this.space(),
            this.printJoin(t.attributes, t, {
                separator: spaceSeparator
            }));
            t.selfClosing ? (this.space(),
            this.token("/>")) : this.token(">")
        }
        ,
        r.JSXOpeningFragment = function JSXOpeningFragment() {
            this.token("<"),
            this.token(">")
        }
        ,
        r.JSXSpreadAttribute = function JSXSpreadAttribute(t) {
            this.token("{"),
            this.token("..."),
            this.print(t.argument, t),
            this.token("}")
        }
        ,
        r.JSXSpreadChild = function JSXSpreadChild(t) {
            this.token("{"),
            this.token("..."),
            this.print(t.expression, t),
            this.token("}")
        }
        ,
        r.JSXText = function JSXText(t) {
            const r = this.getPossibleRaw(t);
            null != r ? this.token(r) : this.token(t.value)
        }
    },
    "1kGC": function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = void 0;
        var a = i("FUES")
          , o = i("57mi")
          , l = function toStatement(t, r) {
            if ((0,
            a.isStatement)(t))
                return t;
            var i, l = !1;
            if ((0,
            a.isClass)(t))
                l = !0,
                i = "ClassDeclaration";
            else if ((0,
            a.isFunction)(t))
                l = !0,
                i = "FunctionDeclaration";
            else if ((0,
            a.isAssignmentExpression)(t))
                return (0,
                o.expressionStatement)(t);
            l && !t.id && (i = !1);
            if (!i) {
                if (r)
                    return !1;
                throw new Error("cannot turn ".concat(t.type, " to a statement"))
            }
            return t.type = i,
            t
        };
        r.default = l
    },
    "230T": function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function toComputedKey(t) {
            var r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : t.key || t.property;
            !t.computed && (0,
            a.isIdentifier)(r) && (r = (0,
            o.stringLiteral)(r.name));
            return r
        }
        ;
        var a = i("pbIU")
          , o = i("UuI8")
    },
    "2Cc0": function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function isSpecifierDefault(t) {
            return (0,
            a.isImportDefaultSpecifier)(t) || (0,
            a.isIdentifier)(t.imported || t.exported, {
                name: "default"
            })
        }
        ;
        var a = i("pbIU")
    },
    "2HQm": function(t, r, i) {
        "use strict";
        function _createForOfIteratorHelper(t, r) {
            var i = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
            if (!i) {
                if (Array.isArray(t) || (i = function _unsupportedIterableToArray(t, r) {
                    if (!t)
                        return;
                    if ("string" == typeof t)
                        return _arrayLikeToArray(t, r);
                    var i = Object.prototype.toString.call(t).slice(8, -1);
                    "Object" === i && t.constructor && (i = t.constructor.name);
                    if ("Map" === i || "Set" === i)
                        return Array.from(t);
                    if ("Arguments" === i || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i))
                        return _arrayLikeToArray(t, r)
                }(t)) || r && t && "number" == typeof t.length) {
                    i && (t = i);
                    var a = 0
                      , o = function F() {};
                    return {
                        s: o,
                        n: function n() {
                            return a >= t.length ? {
                                done: !0
                            } : {
                                done: !1,
                                value: t[a++]
                            }
                        },
                        e: function e(t) {
                            throw t
                        },
                        f: o
                    }
                }
                throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
            }
            var l, u = !0, p = !1;
            return {
                s: function s() {
                    i = i.call(t)
                },
                n: function n() {
                    var t = i.next();
                    return u = t.done,
                    t
                },
                e: function e(t) {
                    p = !0,
                    l = t
                },
                f: function f() {
                    try {
                        u || null == i.return || i.return()
                    } finally {
                        if (p)
                            throw l
                    }
                }
            }
        }
        function _arrayLikeToArray(t, r) {
            (null == r || r > t.length) && (r = t.length);
            for (var i = 0, a = new Array(r); i < r; i++)
                a[i] = t[i];
            return a
        }
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function gatherSequenceExpressions(t, r, i) {
            var p, c = [], d = !0, y = _createForOfIteratorHelper(t);
            try {
                for (y.s(); !(p = y.n()).done; ) {
                    var h = p.value;
                    if ((0,
                    o.isEmptyStatement)(h) || (d = !1),
                    (0,
                    o.isExpression)(h))
                        c.push(h);
                    else if ((0,
                    o.isExpressionStatement)(h))
                        c.push(h.expression);
                    else if ((0,
                    o.isVariableDeclaration)(h)) {
                        if ("var" !== h.kind)
                            return;
                        var m, T = _createForOfIteratorHelper(h.declarations);
                        try {
                            for (T.s(); !(m = T.n()).done; ) {
                                for (var S = m.value, g = (0,
                                a.default)(S), b = 0, v = Object.keys(g); b < v.length; b++) {
                                    var E = v[b];
                                    i.push({
                                        kind: h.kind,
                                        id: (0,
                                        u.default)(g[E])
                                    })
                                }
                                S.init && c.push((0,
                                l.assignmentExpression)("=", S.id, S.init))
                            }
                        } catch (t) {
                            T.e(t)
                        } finally {
                            T.f()
                        }
                        d = !0
                    } else if ((0,
                    o.isIfStatement)(h)) {
                        var P = h.consequent ? gatherSequenceExpressions([h.consequent], r, i) : r.buildUndefinedNode()
                          , x = h.alternate ? gatherSequenceExpressions([h.alternate], r, i) : r.buildUndefinedNode();
                        if (!P || !x)
                            return;
                        c.push((0,
                        l.conditionalExpression)(h.test, P, x))
                    } else if ((0,
                    o.isBlockStatement)(h)) {
                        var A = gatherSequenceExpressions(h.body, r, i);
                        if (!A)
                            return;
                        c.push(A)
                    } else {
                        if (!(0,
                        o.isEmptyStatement)(h))
                            return;
                        0 === t.indexOf(h) && (d = !0)
                    }
                }
            } catch (t) {
                y.e(t)
            } finally {
                y.f()
            }
            d && c.push(r.buildUndefinedNode());
            return 1 === c.length ? c[0] : (0,
            l.sequenceExpression)(c)
        }
        ;
        var a = i("oUnQ")
          , o = i("FUES")
          , l = i("57mi")
          , u = i("sN7J")
    },
    "2Hwn": function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = void 0;
        var a = i("xIU+")
          , o = function toExpression(t) {
            (0,
            a.isExpressionStatement)(t) && (t = t.expression);
            if ((0,
            a.isExpression)(t))
                return t;
            (0,
            a.isClass)(t) ? t.type = "ClassExpression" : (0,
            a.isFunction)(t) && (t.type = "FunctionExpression");
            if (!(0,
            a.isExpression)(t))
                throw new Error(`cannot turn ${t.type} to an expression`);
            return t
        };
        r.default = o
    },
    "2Per": function(t, r, i) {
        "use strict";
        (function(t) {
            Object.defineProperty(r, "__esModule", {
                value: !0
            }),
            r.codeFrameColumns = codeFrameColumns,
            r.default = function _default(r, i, a) {
                var l = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {};
                if (!o) {
                    o = !0;
                    var u = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
                    if (t.emitWarning)
                        t.emitWarning(u, "DeprecationWarning");
                    else {
                        var p = new Error(u);
                        p.name = "DeprecationWarning",
                        console.warn(new Error(u))
                    }
                }
                var c = {
                    start: {
                        column: a = Math.max(a, 0),
                        line: i
                    }
                };
                return codeFrameColumns(r, c, l)
            }
            ;
            var a = i("yKvr")
              , o = !1;
            function getDefs(t) {
                return {
                    gutter: t.grey,
                    marker: t.red.bold,
                    message: t.red.bold
                }
            }
            var l = /\r\n|[\n\r\u2028\u2029]/;
            function getMarkerLines(t, r, i) {
                var a = Object.assign({
                    column: 0,
                    line: -1
                }, t.start)
                  , o = Object.assign({}, a, t.end)
                  , l = i || {}
                  , u = l.linesAbove
                  , p = void 0 === u ? 2 : u
                  , c = l.linesBelow
                  , d = void 0 === c ? 3 : c
                  , y = a.line
                  , h = a.column
                  , m = o.line
                  , T = o.column
                  , S = Math.max(y - (p + 1), 0)
                  , g = Math.min(r.length, m + d);
                -1 === y && (S = 0),
                -1 === m && (g = r.length);
                var b = m - y
                  , v = {};
                if (b)
                    for (var E = 0; E <= b; E++) {
                        var P = E + y;
                        if (h)
                            if (0 === E) {
                                var x = r[P - 1].length;
                                v[P] = [h, x - h + 1]
                            } else if (E === b)
                                v[P] = [0, T];
                            else {
                                var A = r[P - E].length;
                                v[P] = [0, A]
                            }
                        else
                            v[P] = !0
                    }
                else
                    v[y] = h === T ? !h || [h, 0] : [h, T - h];
                return {
                    start: S,
                    end: g,
                    markerLines: v
                }
            }
            function codeFrameColumns(t, r) {
                var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}
                  , o = (i.highlightCode || i.forceColor) && (0,
                a.shouldHighlight)(i)
                  , u = (0,
                a.getChalk)(i)
                  , p = getDefs(u)
                  , c = function maybeHighlight(t, r) {
                    return o ? t(r) : r
                }
                  , d = t.split(l)
                  , y = getMarkerLines(r, d, i)
                  , h = y.start
                  , m = y.end
                  , T = y.markerLines
                  , S = r.start && "number" == typeof r.start.column
                  , g = String(m).length
                  , b = o ? (0,
                a.default)(t, i) : t
                  , v = b.split(l, m).slice(h, m).map((function(t, r) {
                    var a = h + 1 + r
                      , o = " ".concat(a).slice(-g)
                      , l = " ".concat(o, " |")
                      , u = T[a]
                      , d = !T[a + 1];
                    if (u) {
                        var y = "";
                        if (Array.isArray(u)) {
                            var m = t.slice(0, Math.max(u[0] - 1, 0)).replace(/[^\t]/g, " ")
                              , S = u[1] || 1;
                            y = ["\n ", c(p.gutter, l.replace(/\d/g, " ")), " ", m, c(p.marker, "^").repeat(S)].join(""),
                            d && i.message && (y += " " + c(p.message, i.message))
                        }
                        return [c(p.marker, ">"), c(p.gutter, l), t.length > 0 ? " ".concat(t) : "", y].join("")
                    }
                    return " ".concat(c(p.gutter, l)).concat(t.length > 0 ? " ".concat(t) : "")
                }
                )).join("\n");
                return i.message && !S && (v = "".concat(" ".repeat(g + 1)).concat(i.message, "\n").concat(v)),
                o ? u.reset(v) : v
            }
        }
        ).call(this, i("8oxB"))
    },
    "2n+e": function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = void 0;
        var a = (0,
        i("V/pm").default)("React.Component");
        r.default = a
    },
    "2xV5": function(t, r, i) {
        "use strict";
        const a = /(?:\\(u[a-f\d]{4}|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi
          , o = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g
          , l = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/
          , u = /\\(u[a-f\d]{4}|x[a-f\d]{2}|.)|([^\\])/gi
          , p = new Map([["n", "\n"], ["r", "\r"], ["t", "\t"], ["b", "\b"], ["f", "\f"], ["v", "\v"], ["0", "\0"], ["\\", "\\"], ["e", ""], ["a", ""]]);
        function unescape(t) {
            return "u" === t[0] && 5 === t.length || "x" === t[0] && 3 === t.length ? String.fromCharCode(parseInt(t.slice(1), 16)) : p.get(t) || t
        }
        function parseArguments(t, r) {
            const i = []
              , a = r.trim().split(/\s*,\s*/g);
            let o;
            for (const r of a)
                if (isNaN(r)) {
                    if (!(o = r.match(l)))
                        throw new Error(`Invalid Chalk template style argument: ${r} (in style '${t}')`);
                    i.push(o[2].replace(u, (t,r,i)=>r ? unescape(r) : i))
                } else
                    i.push(Number(r));
            return i
        }
        function parseStyle(t) {
            o.lastIndex = 0;
            const r = [];
            let i;
            for (; null !== (i = o.exec(t)); ) {
                const t = i[1];
                if (i[2]) {
                    const a = parseArguments(t, i[2]);
                    r.push([t].concat(a))
                } else
                    r.push([t])
            }
            return r
        }
        function buildStyle(t, r) {
            const i = {};
            for (const t of r)
                for (const r of t.styles)
                    i[r[0]] = t.inverse ? null : r.slice(1);
            let a = t;
            for (const t of Object.keys(i))
                if (Array.isArray(i[t])) {
                    if (!(t in a))
                        throw new Error("Unknown Chalk style: " + t);
                    a = i[t].length > 0 ? a[t].apply(a, i[t]) : a[t]
                }
            return a
        }
        t.exports = (t,r)=>{
            const i = []
              , o = [];
            let l = [];
            if (r.replace(a, (r,a,u,p,c,d)=>{
                if (a)
                    l.push(unescape(a));
                else if (p) {
                    const r = l.join("");
                    l = [],
                    o.push(0 === i.length ? r : buildStyle(t, i)(r)),
                    i.push({
                        inverse: u,
                        styles: parseStyle(p)
                    })
                } else if (c) {
                    if (0 === i.length)
                        throw new Error("Found extraneous } in Chalk template literal");
                    o.push(buildStyle(t, i)(l.join(""))),
                    l = [],
                    i.pop()
                } else
                    l.push(d)
            }
            ),
            o.push(l.join("")),
            i.length > 0) {
                const t = `Chalk template literal is missing ${i.length} closing bracket${1 === i.length ? "" : "s"} (\`}\`)`;
                throw new Error(t)
            }
            return o.join("")
        }
    },
    "33yf": function(t, r, i) {
        (function(t) {
            function normalizeArray(t, r) {
                for (var i = 0, a = t.length - 1; a >= 0; a--) {
                    var o = t[a];
                    "." === o ? t.splice(a, 1) : ".." === o ? (t.splice(a, 1),
                    i++) : i && (t.splice(a, 1),
                    i--)
                }
                if (r)
                    for (; i--; i)
                        t.unshift("..");
                return t
            }
            function filter(t, r) {
                if (t.filter)
                    return t.filter(r);
                for (var i = [], a = 0; a < t.length; a++)
                    r(t[a], a, t) && i.push(t[a]);
                return i
            }
            r.resolve = function() {
                for (var r = "", i = !1, a = arguments.length - 1; a >= -1 && !i; a--) {
                    var o = a >= 0 ? arguments[a] : t.cwd();
                    if ("string" != typeof o)
                        throw new TypeError("Arguments to path.resolve must be strings");
                    o && (r = o + "/" + r,
                    i = "/" === o.charAt(0))
                }
                return (i ? "/" : "") + (r = normalizeArray(filter(r.split("/"), (function(t) {
                    return !!t
                }
                )), !i).join("/")) || "."
            }
            ,
            r.normalize = function(t) {
                var a = r.isAbsolute(t)
                  , o = "/" === i(t, -1);
                return (t = normalizeArray(filter(t.split("/"), (function(t) {
                    return !!t
                }
                )), !a).join("/")) || a || (t = "."),
                t && o && (t += "/"),
                (a ? "/" : "") + t
            }
            ,
            r.isAbsolute = function(t) {
                return "/" === t.charAt(0)
            }
            ,
            r.join = function() {
                var t = Array.prototype.slice.call(arguments, 0);
                return r.normalize(filter(t, (function(t, r) {
                    if ("string" != typeof t)
                        throw new TypeError("Arguments to path.join must be strings");
                    return t
                }
                )).join("/"))
            }
            ,
            r.relative = function(t, i) {
                function trim(t) {
                    for (var r = 0; r < t.length && "" === t[r]; r++)
                        ;
                    for (var i = t.length - 1; i >= 0 && "" === t[i]; i--)
                        ;
                    return r > i ? [] : t.slice(r, i - r + 1)
                }
                t = r.resolve(t).substr(1),
                i = r.resolve(i).substr(1);
                for (var a = trim(t.split("/")), o = trim(i.split("/")), l = Math.min(a.length, o.length), u = l, p = 0; p < l; p++)
                    if (a[p] !== o[p]) {
                        u = p;
                        break
                    }
                var c = [];
                for (p = u; p < a.length; p++)
                    c.push("..");
                return (c = c.concat(o.slice(u))).join("/")
            }
            ,
            r.sep = "/",
            r.delimiter = ":",
            r.dirname = function(t) {
                if ("string" != typeof t && (t += ""),
                0 === t.length)
                    return ".";
                for (var r = t.charCodeAt(0), i = 47 === r, a = -1, o = !0, l = t.length - 1; l >= 1; --l)
                    if (47 === (r = t.charCodeAt(l))) {
                        if (!o) {
                            a = l;
                            break
                        }
                    } else
                        o = !1;
                return -1 === a ? i ? "/" : "." : i && 1 === a ? "/" : t.slice(0, a)
            }
            ,
            r.basename = function(t, r) {
                var i = function basename(t) {
                    "string" != typeof t && (t += "");
                    var r, i = 0, a = -1, o = !0;
                    for (r = t.length - 1; r >= 0; --r)
                        if (47 === t.charCodeAt(r)) {
                            if (!o) {
                                i = r + 1;
                                break
                            }
                        } else
                            -1 === a && (o = !1,
                            a = r + 1);
                    return -1 === a ? "" : t.slice(i, a)
                }(t);
                return r && i.substr(-1 * r.length) === r && (i = i.substr(0, i.length - r.length)),
                i
            }
            ,
            r.extname = function(t) {
                "string" != typeof t && (t += "");
                for (var r = -1, i = 0, a = -1, o = !0, l = 0, u = t.length - 1; u >= 0; --u) {
                    var p = t.charCodeAt(u);
                    if (47 !== p)
                        -1 === a && (o = !1,
                        a = u + 1),
                        46 === p ? -1 === r ? r = u : 1 !== l && (l = 1) : -1 !== r && (l = -1);
                    else if (!o) {
                        i = u + 1;
                        break
                    }
                }
                return -1 === r || -1 === a || 0 === l || 1 === l && r === a - 1 && r === i + 1 ? "" : t.slice(r, a)
            }
            ;
            var i = "b" === "ab".substr(-1) ? function(t, r, i) {
                return t.substr(r, i)
            }
            : function(t, r, i) {
                return r < 0 && (r = t.length + r),
                t.substr(r, i)
            }
        }
        ).call(this, i("8oxB"))
    },
    "3MYS": function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function _default(t) {
            const r = t.params;
            for (let t = 0; t < r.length; t++) {
                const i = r[t];
                if (o(i) || l(i))
                    return t
            }
            return r.length
        }
        ;
        var a = i("JSq2");
        const {isAssignmentPattern: o, isRestElement: l} = a
    },
    "3YeA": function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function removeComments(t) {
            return a.COMMENT_KEYS.forEach(r=>{
                t[r] = null
            }
            ),
            t
        }
        ;
        var a = i("kEZX")
    },
    "41WB": function(t, r, i) {
        "use strict";
        t.exports = function(t, r) {
            var i = null
              , a = []
              , o = [];
            function addTemplateType() {
                var t = a[0]
                  , i = a[a.length - 1]
                  , l = a.reduce((function(t, i) {
                    return i.value ? t += i.value : i.type !== r.template && (t += i.type.label),
                    t
                }
                ), "");
                o.push({
                    type: "Template",
                    value: l,
                    start: t.start,
                    end: i.end,
                    loc: {
                        start: t.loc.start,
                        end: i.loc.end
                    }
                }),
                a = []
            }
            return t.forEach((function(t) {
                switch (t.type) {
                case r.backQuote:
                    i && (o.push(i),
                    i = null),
                    a.push(t),
                    a.length > 1 && addTemplateType();
                    break;
                case r.dollarBraceL:
                    a.push(t),
                    addTemplateType();
                    break;
                case r.braceR:
                    i && o.push(i),
                    i = t;
                    break;
                case r.template:
                    i && (a.push(i),
                    i = null),
                    a.push(t);
                    break;
                case r.eof:
                    i && o.push(i);
                    break;
                default:
                    i && (o.push(i),
                    i = null),
                    o.push(t)
                }
            }
            )),
            o
        }
    },
    "49gG": function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function isPlaceholderType(t, r) {
            if (t === r)
                return !0;
            const i = a.PLACEHOLDERS_ALIAS[t];
            if (i)
                for (const t of i)
                    if (r === t)
                        return !0;
            return !1
        }
        ;
        var a = i("uXiX")
    },
    "49sm": function(t, r) {
        var i = {}.toString;
        t.exports = Array.isArray || function(t) {
            return "[object Array]" == i.call(t)
        }
    },
    "4E18": function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function isCompatTag(t) {
            return !!t && /^[a-z]/.test(t)
        }
    },
    "4HAq": function(t, r, i) {
        "use strict";
        var a = i("TqRt")(i("RIqP"));
        t.exports = function setup(t) {
            function createDebug(t) {
                var r, i, a, o = null;
                function debug() {
                    for (var t = arguments.length, i = new Array(t), a = 0; a < t; a++)
                        i[a] = arguments[a];
                    if (debug.enabled) {
                        var o = debug
                          , l = Number(new Date)
                          , u = l - (r || l);
                        o.diff = u,
                        o.prev = r,
                        o.curr = l,
                        r = l,
                        i[0] = createDebug.coerce(i[0]),
                        "string" != typeof i[0] && i.unshift("%O");
                        var p = 0;
                        i[0] = i[0].replace(/%([a-zA-Z%])/g, (function(t, r) {
                            if ("%%" === t)
                                return "%";
                            p++;
                            var a = createDebug.formatters[r];
                            if ("function" == typeof a) {
                                var l = i[p];
                                t = a.call(o, l),
                                i.splice(p, 1),
                                p--
                            }
                            return t
                        }
                        )),
                        createDebug.formatArgs.call(o, i);
                        var c = o.log || createDebug.log;
                        c.apply(o, i)
                    }
                }
                return debug.namespace = t,
                debug.useColors = createDebug.useColors(),
                debug.color = createDebug.selectColor(t),
                debug.extend = extend,
                debug.destroy = createDebug.destroy,
                Object.defineProperty(debug, "enabled", {
                    enumerable: !0,
                    configurable: !1,
                    get: function get() {
                        return null !== o ? o : (i !== createDebug.namespaces && (i = createDebug.namespaces,
                        a = createDebug.enabled(t)),
                        a)
                    },
                    set: function set(t) {
                        o = t
                    }
                }),
                "function" == typeof createDebug.init && createDebug.init(debug),
                debug
            }
            function extend(t, r) {
                var i = createDebug(this.namespace + (void 0 === r ? ":" : r) + t);
                return i.log = this.log,
                i
            }
            function toNamespace(t) {
                return t.toString().substring(2, t.toString().length - 2).replace(/\.\*\?$/, "*")
            }
            return createDebug.debug = createDebug,
            createDebug.default = createDebug,
            createDebug.coerce = function coerce(t) {
                if (t instanceof Error)
                    return t.stack || t.message;
                return t
            }
            ,
            createDebug.disable = function disable() {
                var t = [].concat((0,
                a.default)(createDebug.names.map(toNamespace)), (0,
                a.default)(createDebug.skips.map(toNamespace).map((function(t) {
                    return "-" + t
                }
                )))).join(",");
                return createDebug.enable(""),
                t
            }
            ,
            createDebug.enable = function enable(t) {
                var r;
                createDebug.save(t),
                createDebug.namespaces = t,
                createDebug.names = [],
                createDebug.skips = [];
                var i = ("string" == typeof t ? t : "").split(/[\s,]+/)
                  , a = i.length;
                for (r = 0; r < a; r++)
                    i[r] && ("-" === (t = i[r].replace(/\*/g, ".*?"))[0] ? createDebug.skips.push(new RegExp("^" + t.substr(1) + "$")) : createDebug.names.push(new RegExp("^" + t + "$")))
            }
            ,
            createDebug.enabled = function enabled(t) {
                if ("*" === t[t.length - 1])
                    return !0;
                var r, i;
                for (r = 0,
                i = createDebug.skips.length; r < i; r++)
                    if (createDebug.skips[r].test(t))
                        return !1;
                for (r = 0,
                i = createDebug.names.length; r < i; r++)
                    if (createDebug.names[r].test(t))
                        return !0;
                return !1
            }
            ,
            createDebug.humanize = i("FGiv"),
            createDebug.destroy = function destroy() {
                console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.")
            }
            ,
            Object.keys(t).forEach((function(r) {
                createDebug[r] = t[r]
            }
            )),
            createDebug.names = [],
            createDebug.skips = [],
            createDebug.formatters = {},
            createDebug.selectColor = function selectColor(t) {
                for (var r = 0, i = 0; i < t.length; i++)
                    r = (r << 5) - r + t.charCodeAt(i),
                    r |= 0;
                return createDebug.colors[Math.abs(r) % createDebug.colors.length]
            }
            ,
            createDebug.enable(createDebug.load()),
            createDebug
        }
    },
    "4JQ2": function(t, r, i) {
        "use strict";
        (function(r) {
            const a = i("oxjq")
              , o = i("ijAY")
              , l = i("5e9W").stdout
              , u = i("2xV5")
              , p = "win32" === r.platform && !(r.env.TERM || "").toLowerCase().startsWith("xterm")
              , c = ["ansi", "ansi", "ansi256", "ansi16m"]
              , d = new Set(["gray"])
              , y = Object.create(null);
            function applyOptions(t, r) {
                r = r || {};
                const i = l ? l.level : 0;
                t.level = void 0 === r.level ? i : r.level,
                t.enabled = "enabled"in r ? r.enabled : t.level > 0
            }
            function Chalk(t) {
                if (!this || !(this instanceof Chalk) || this.template) {
                    const r = {};
                    return applyOptions(r, t),
                    r.template = function() {
                        const t = [].slice.call(arguments);
                        return chalkTag.apply(null, [r.template].concat(t))
                    }
                    ,
                    Object.setPrototypeOf(r, Chalk.prototype),
                    Object.setPrototypeOf(r.template, r),
                    r.template.constructor = Chalk,
                    r.template
                }
                applyOptions(this, t)
            }
            p && (o.blue.open = "[94m");
            for (const t of Object.keys(o))
                o[t].closeRe = new RegExp(a(o[t].close),"g"),
                y[t] = {
                    get() {
                        const r = o[t];
                        return build.call(this, this._styles ? this._styles.concat(r) : [r], this._empty, t)
                    }
                };
            y.visible = {
                get() {
                    return build.call(this, this._styles || [], !0, "visible")
                }
            },
            o.color.closeRe = new RegExp(a(o.color.close),"g");
            for (const t of Object.keys(o.color.ansi))
                d.has(t) || (y[t] = {
                    get() {
                        const r = this.level;
                        return function() {
                            const i = o.color[c[r]][t].apply(null, arguments)
                              , a = {
                                open: i,
                                close: o.color.close,
                                closeRe: o.color.closeRe
                            };
                            return build.call(this, this._styles ? this._styles.concat(a) : [a], this._empty, t)
                        }
                    }
                });
            o.bgColor.closeRe = new RegExp(a(o.bgColor.close),"g");
            for (const t of Object.keys(o.bgColor.ansi)) {
                if (d.has(t))
                    continue;
                y["bg" + t[0].toUpperCase() + t.slice(1)] = {
                    get() {
                        const r = this.level;
                        return function() {
                            const i = o.bgColor[c[r]][t].apply(null, arguments)
                              , a = {
                                open: i,
                                close: o.bgColor.close,
                                closeRe: o.bgColor.closeRe
                            };
                            return build.call(this, this._styles ? this._styles.concat(a) : [a], this._empty, t)
                        }
                    }
                }
            }
            const h = Object.defineProperties(()=>{}
            , y);
            function build(t, r, i) {
                const builder = function() {
                    return applyStyle.apply(builder, arguments)
                };
                builder._styles = t,
                builder._empty = r;
                const a = this;
                return Object.defineProperty(builder, "level", {
                    enumerable: !0,
                    get: ()=>a.level,
                    set(t) {
                        a.level = t
                    }
                }),
                Object.defineProperty(builder, "enabled", {
                    enumerable: !0,
                    get: ()=>a.enabled,
                    set(t) {
                        a.enabled = t
                    }
                }),
                builder.hasGrey = this.hasGrey || "gray" === i || "grey" === i,
                builder.__proto__ = h,
                builder
            }
            function applyStyle() {
                const t = arguments
                  , r = t.length;
                let i = String(arguments[0]);
                if (0 === r)
                    return "";
                if (r > 1)
                    for (let a = 1; a < r; a++)
                        i += " " + t[a];
                if (!this.enabled || this.level <= 0 || !i)
                    return this._empty ? "" : i;
                const a = o.dim.open;
                p && this.hasGrey && (o.dim.open = "");
                for (const t of this._styles.slice().reverse())
                    i = t.open + i.replace(t.closeRe, t.open) + t.close,
                    i = i.replace(/\r?\n/g, `${t.close}$&${t.open}`);
                return o.dim.open = a,
                i
            }
            function chalkTag(t, r) {
                if (!Array.isArray(r))
                    return [].slice.call(arguments, 1).join(" ");
                const i = [].slice.call(arguments, 2)
                  , a = [r.raw[0]];
                for (let t = 1; t < r.length; t++)
                    a.push(String(i[t - 1]).replace(/[{}\\]/g, "\\$&")),
                    a.push(String(r.raw[t]));
                return u(t, a.join(""))
            }
            Object.defineProperties(Chalk.prototype, y),
            t.exports = Chalk(),
            t.exports.supportsColor = l,
            t.exports.default = t.exports
        }
        ).call(this, i("8oxB"))
    },
    "4RZc": function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function isVar(t) {
            return (0,
            a.isVariableDeclaration)(t, {
                kind: "var"
            }) && !t[o.BLOCK_SCOPED_SYMBOL]
        }
        ;
        var a = i("FUES")
          , o = i("RS7Y")
    },
    "4r8k": function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function removeTypeDuplicates(t) {
            for (var r = {}, i = {}, o = new Set, l = [], u = 0; u < t.length; u++) {
                var p = t[u];
                if (p && !(l.indexOf(p) >= 0)) {
                    if ((0,
                    a.isAnyTypeAnnotation)(p))
                        return [p];
                    if ((0,
                    a.isFlowBaseAnnotation)(p))
                        i[p.type] = p;
                    else if ((0,
                    a.isUnionTypeAnnotation)(p))
                        o.has(p.types) || (t = t.concat(p.types),
                        o.add(p.types));
                    else if ((0,
                    a.isGenericTypeAnnotation)(p)) {
                        var c = getQualifiedName(p.id);
                        if (r[c]) {
                            var d = r[c];
                            d.typeParameters ? p.typeParameters && (d.typeParameters.params = removeTypeDuplicates(d.typeParameters.params.concat(p.typeParameters.params))) : d = p.typeParameters
                        } else
                            r[c] = p
                    } else
                        l.push(p)
                }
            }
            for (var y = 0, h = Object.keys(i); y < h.length; y++) {
                var m = h[y];
                l.push(i[m])
            }
            for (var T = 0, S = Object.keys(r); T < S.length; T++) {
                var g = S[T];
                l.push(r[g])
            }
            return l
        }
        ;
        var a = i("pbIU");
        function getQualifiedName(t) {
            return (0,
            a.isIdentifier)(t) ? t.name : "".concat(t.id.name, ".").concat(getQualifiedName(t.qualification))
        }
    },
    "4tS7": function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.isIdentifierChar = isIdentifierChar,
        r.isIdentifierName = function isIdentifierName(t) {
            let r = !0;
            for (let i = 0; i < t.length; i++) {
                let a = t.charCodeAt(i);
                if (55296 == (64512 & a) && i + 1 < t.length) {
                    const r = t.charCodeAt(++i);
                    56320 == (64512 & r) && (a = 65536 + ((1023 & a) << 10) + (1023 & r))
                }
                if (r) {
                    if (r = !1,
                    !isIdentifierStart(a))
                        return !1
                } else if (!isIdentifierChar(a))
                    return !1
            }
            return !r
        }
        ,
        r.isIdentifierStart = isIdentifierStart;
        let a = "ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࡰ-ࢇࢉ-ࢎࢠ-ࣉऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౝౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೝೞೠೡೱೲഄ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜑᜟ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭌᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲈᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳳᳵᳶᳺᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆿㇰ-ㇿ㐀-䶿一-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꟊꟐꟑꟓꟕ-ꟙꟲ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭩꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ"
          , o = "‌‍·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛࢘-࢟࣊-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍୕-ୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఄ఼ా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ඁ-ඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ຼ່-ໍ໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜕ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠏-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᪿ-ᫎᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭᳴᳷-᳹᷀-᷿‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧ꠬ꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱ꣿ-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿";
        const l = new RegExp("[" + a + "]")
          , u = new RegExp("[" + a + o + "]");
        a = o = null;
        const p = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 190, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1070, 4050, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 46, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 482, 44, 11, 6, 17, 0, 322, 29, 19, 43, 1269, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4152, 8, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938]
          , c = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 154, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 357, 0, 62, 13, 1495, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
        function isInAstralSet(t, r) {
            let i = 65536;
            for (let a = 0, o = r.length; a < o; a += 2) {
                if (i += r[a],
                i > t)
                    return !1;
                if (i += r[a + 1],
                i >= t)
                    return !0
            }
            return !1
        }
        function isIdentifierStart(t) {
            return t < 65 ? 36 === t : t <= 90 || (t < 97 ? 95 === t : t <= 122 || (t <= 65535 ? t >= 170 && l.test(String.fromCharCode(t)) : isInAstralSet(t, p)))
        }
        function isIdentifierChar(t) {
            return t < 48 ? 36 === t : t < 58 || !(t < 65) && (t <= 90 || (t < 97 ? 95 === t : t <= 122 || (t <= 65535 ? t >= 170 && u.test(String.fromCharCode(t)) : isInAstralSet(t, p) || isInAstralSet(t, c))))
        }
    },
    "57mi": function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.arrayExpression = function arrayExpression(t) {
            return a.default.apply(void 0, ["ArrayExpression"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.assignmentExpression = function assignmentExpression(t, r, i) {
            return a.default.apply(void 0, ["AssignmentExpression"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.binaryExpression = function binaryExpression(t, r, i) {
            return a.default.apply(void 0, ["BinaryExpression"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.interpreterDirective = function interpreterDirective(t) {
            return a.default.apply(void 0, ["InterpreterDirective"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.directive = function directive(t) {
            return a.default.apply(void 0, ["Directive"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.directiveLiteral = function directiveLiteral(t) {
            return a.default.apply(void 0, ["DirectiveLiteral"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.blockStatement = function blockStatement(t, r) {
            return a.default.apply(void 0, ["BlockStatement"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.breakStatement = function breakStatement(t) {
            return a.default.apply(void 0, ["BreakStatement"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.callExpression = function callExpression(t, r) {
            return a.default.apply(void 0, ["CallExpression"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.catchClause = function catchClause(t, r) {
            return a.default.apply(void 0, ["CatchClause"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.conditionalExpression = function conditionalExpression(t, r, i) {
            return a.default.apply(void 0, ["ConditionalExpression"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.continueStatement = function continueStatement(t) {
            return a.default.apply(void 0, ["ContinueStatement"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.debuggerStatement = function debuggerStatement() {
            return a.default.apply(void 0, ["DebuggerStatement"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.doWhileStatement = function doWhileStatement(t, r) {
            return a.default.apply(void 0, ["DoWhileStatement"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.emptyStatement = function emptyStatement() {
            return a.default.apply(void 0, ["EmptyStatement"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.expressionStatement = function expressionStatement(t) {
            return a.default.apply(void 0, ["ExpressionStatement"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.file = function file(t, r, i) {
            return a.default.apply(void 0, ["File"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.forInStatement = function forInStatement(t, r, i) {
            return a.default.apply(void 0, ["ForInStatement"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.forStatement = function forStatement(t, r, i, o) {
            return a.default.apply(void 0, ["ForStatement"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.functionDeclaration = function functionDeclaration(t, r, i, o, l) {
            return a.default.apply(void 0, ["FunctionDeclaration"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.functionExpression = function functionExpression(t, r, i, o, l) {
            return a.default.apply(void 0, ["FunctionExpression"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.identifier = function identifier(t) {
            return a.default.apply(void 0, ["Identifier"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.ifStatement = function ifStatement(t, r, i) {
            return a.default.apply(void 0, ["IfStatement"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.labeledStatement = function labeledStatement(t, r) {
            return a.default.apply(void 0, ["LabeledStatement"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.stringLiteral = function stringLiteral(t) {
            return a.default.apply(void 0, ["StringLiteral"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.numericLiteral = function numericLiteral(t) {
            return a.default.apply(void 0, ["NumericLiteral"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.nullLiteral = function nullLiteral() {
            return a.default.apply(void 0, ["NullLiteral"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.booleanLiteral = function booleanLiteral(t) {
            return a.default.apply(void 0, ["BooleanLiteral"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.regExpLiteral = function regExpLiteral(t, r) {
            return a.default.apply(void 0, ["RegExpLiteral"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.logicalExpression = function logicalExpression(t, r, i) {
            return a.default.apply(void 0, ["LogicalExpression"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.memberExpression = function memberExpression(t, r, i, o) {
            return a.default.apply(void 0, ["MemberExpression"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.newExpression = function newExpression(t, r) {
            return a.default.apply(void 0, ["NewExpression"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.program = function program(t, r, i, o) {
            return a.default.apply(void 0, ["Program"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.objectExpression = function objectExpression(t) {
            return a.default.apply(void 0, ["ObjectExpression"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.objectMethod = function objectMethod(t, r, i, o, l, u, p) {
            return a.default.apply(void 0, ["ObjectMethod"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.objectProperty = function objectProperty(t, r, i, o, l) {
            return a.default.apply(void 0, ["ObjectProperty"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.restElement = function restElement(t) {
            return a.default.apply(void 0, ["RestElement"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.returnStatement = function returnStatement(t) {
            return a.default.apply(void 0, ["ReturnStatement"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.sequenceExpression = function sequenceExpression(t) {
            return a.default.apply(void 0, ["SequenceExpression"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.parenthesizedExpression = function parenthesizedExpression(t) {
            return a.default.apply(void 0, ["ParenthesizedExpression"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.switchCase = function switchCase(t, r) {
            return a.default.apply(void 0, ["SwitchCase"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.switchStatement = function switchStatement(t, r) {
            return a.default.apply(void 0, ["SwitchStatement"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.thisExpression = function thisExpression() {
            return a.default.apply(void 0, ["ThisExpression"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.throwStatement = function throwStatement(t) {
            return a.default.apply(void 0, ["ThrowStatement"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.tryStatement = function tryStatement(t, r, i) {
            return a.default.apply(void 0, ["TryStatement"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.unaryExpression = function unaryExpression(t, r, i) {
            return a.default.apply(void 0, ["UnaryExpression"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.updateExpression = function updateExpression(t, r, i) {
            return a.default.apply(void 0, ["UpdateExpression"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.variableDeclaration = function variableDeclaration(t, r) {
            return a.default.apply(void 0, ["VariableDeclaration"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.variableDeclarator = function variableDeclarator(t, r) {
            return a.default.apply(void 0, ["VariableDeclarator"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.whileStatement = function whileStatement(t, r) {
            return a.default.apply(void 0, ["WhileStatement"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.withStatement = function withStatement(t, r) {
            return a.default.apply(void 0, ["WithStatement"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.assignmentPattern = function assignmentPattern(t, r) {
            return a.default.apply(void 0, ["AssignmentPattern"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.arrayPattern = function arrayPattern(t) {
            return a.default.apply(void 0, ["ArrayPattern"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.arrowFunctionExpression = function arrowFunctionExpression(t, r, i) {
            return a.default.apply(void 0, ["ArrowFunctionExpression"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.classBody = function classBody(t) {
            return a.default.apply(void 0, ["ClassBody"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.classExpression = function classExpression(t, r, i, o) {
            return a.default.apply(void 0, ["ClassExpression"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.classDeclaration = function classDeclaration(t, r, i, o) {
            return a.default.apply(void 0, ["ClassDeclaration"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.exportAllDeclaration = function exportAllDeclaration(t) {
            return a.default.apply(void 0, ["ExportAllDeclaration"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.exportDefaultDeclaration = function exportDefaultDeclaration(t) {
            return a.default.apply(void 0, ["ExportDefaultDeclaration"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.exportNamedDeclaration = function exportNamedDeclaration(t, r, i) {
            return a.default.apply(void 0, ["ExportNamedDeclaration"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.exportSpecifier = function exportSpecifier(t, r) {
            return a.default.apply(void 0, ["ExportSpecifier"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.forOfStatement = function forOfStatement(t, r, i, o) {
            return a.default.apply(void 0, ["ForOfStatement"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.importDeclaration = function importDeclaration(t, r) {
            return a.default.apply(void 0, ["ImportDeclaration"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.importDefaultSpecifier = function importDefaultSpecifier(t) {
            return a.default.apply(void 0, ["ImportDefaultSpecifier"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.importNamespaceSpecifier = function importNamespaceSpecifier(t) {
            return a.default.apply(void 0, ["ImportNamespaceSpecifier"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.importSpecifier = function importSpecifier(t, r) {
            return a.default.apply(void 0, ["ImportSpecifier"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.metaProperty = function metaProperty(t, r) {
            return a.default.apply(void 0, ["MetaProperty"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.classMethod = function classMethod(t, r, i, o, l, u, p, c) {
            return a.default.apply(void 0, ["ClassMethod"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.objectPattern = function objectPattern(t) {
            return a.default.apply(void 0, ["ObjectPattern"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.spreadElement = function spreadElement(t) {
            return a.default.apply(void 0, ["SpreadElement"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.super = function _super() {
            return a.default.apply(void 0, ["Super"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.taggedTemplateExpression = function taggedTemplateExpression(t, r) {
            return a.default.apply(void 0, ["TaggedTemplateExpression"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.templateElement = function templateElement(t, r) {
            return a.default.apply(void 0, ["TemplateElement"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.templateLiteral = function templateLiteral(t, r) {
            return a.default.apply(void 0, ["TemplateLiteral"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.yieldExpression = function yieldExpression(t, r) {
            return a.default.apply(void 0, ["YieldExpression"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.awaitExpression = function awaitExpression(t) {
            return a.default.apply(void 0, ["AwaitExpression"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.import = function _import() {
            return a.default.apply(void 0, ["Import"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.bigIntLiteral = function bigIntLiteral(t) {
            return a.default.apply(void 0, ["BigIntLiteral"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.exportNamespaceSpecifier = function exportNamespaceSpecifier(t) {
            return a.default.apply(void 0, ["ExportNamespaceSpecifier"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.optionalMemberExpression = function optionalMemberExpression(t, r, i, o) {
            return a.default.apply(void 0, ["OptionalMemberExpression"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.optionalCallExpression = function optionalCallExpression(t, r, i) {
            return a.default.apply(void 0, ["OptionalCallExpression"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.classProperty = function classProperty(t, r, i, o, l, u) {
            return a.default.apply(void 0, ["ClassProperty"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.classPrivateProperty = function classPrivateProperty(t, r, i, o) {
            return a.default.apply(void 0, ["ClassPrivateProperty"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.classPrivateMethod = function classPrivateMethod(t, r, i, o, l) {
            return a.default.apply(void 0, ["ClassPrivateMethod"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.privateName = function privateName(t) {
            return a.default.apply(void 0, ["PrivateName"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.anyTypeAnnotation = function anyTypeAnnotation() {
            return a.default.apply(void 0, ["AnyTypeAnnotation"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.arrayTypeAnnotation = function arrayTypeAnnotation(t) {
            return a.default.apply(void 0, ["ArrayTypeAnnotation"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.booleanTypeAnnotation = function booleanTypeAnnotation() {
            return a.default.apply(void 0, ["BooleanTypeAnnotation"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.booleanLiteralTypeAnnotation = function booleanLiteralTypeAnnotation(t) {
            return a.default.apply(void 0, ["BooleanLiteralTypeAnnotation"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.nullLiteralTypeAnnotation = function nullLiteralTypeAnnotation() {
            return a.default.apply(void 0, ["NullLiteralTypeAnnotation"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.classImplements = function classImplements(t, r) {
            return a.default.apply(void 0, ["ClassImplements"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.declareClass = function declareClass(t, r, i, o) {
            return a.default.apply(void 0, ["DeclareClass"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.declareFunction = function declareFunction(t) {
            return a.default.apply(void 0, ["DeclareFunction"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.declareInterface = function declareInterface(t, r, i, o) {
            return a.default.apply(void 0, ["DeclareInterface"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.declareModule = function declareModule(t, r, i) {
            return a.default.apply(void 0, ["DeclareModule"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.declareModuleExports = function declareModuleExports(t) {
            return a.default.apply(void 0, ["DeclareModuleExports"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.declareTypeAlias = function declareTypeAlias(t, r, i) {
            return a.default.apply(void 0, ["DeclareTypeAlias"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.declareOpaqueType = function declareOpaqueType(t, r, i) {
            return a.default.apply(void 0, ["DeclareOpaqueType"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.declareVariable = function declareVariable(t) {
            return a.default.apply(void 0, ["DeclareVariable"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.declareExportDeclaration = function declareExportDeclaration(t, r, i) {
            return a.default.apply(void 0, ["DeclareExportDeclaration"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.declareExportAllDeclaration = function declareExportAllDeclaration(t) {
            return a.default.apply(void 0, ["DeclareExportAllDeclaration"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.declaredPredicate = function declaredPredicate(t) {
            return a.default.apply(void 0, ["DeclaredPredicate"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.existsTypeAnnotation = function existsTypeAnnotation() {
            return a.default.apply(void 0, ["ExistsTypeAnnotation"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.functionTypeAnnotation = function functionTypeAnnotation(t, r, i, o) {
            return a.default.apply(void 0, ["FunctionTypeAnnotation"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.functionTypeParam = function functionTypeParam(t, r) {
            return a.default.apply(void 0, ["FunctionTypeParam"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.genericTypeAnnotation = function genericTypeAnnotation(t, r) {
            return a.default.apply(void 0, ["GenericTypeAnnotation"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.inferredPredicate = function inferredPredicate() {
            return a.default.apply(void 0, ["InferredPredicate"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.interfaceExtends = function interfaceExtends(t, r) {
            return a.default.apply(void 0, ["InterfaceExtends"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.interfaceDeclaration = function interfaceDeclaration(t, r, i, o) {
            return a.default.apply(void 0, ["InterfaceDeclaration"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.interfaceTypeAnnotation = function interfaceTypeAnnotation(t, r) {
            return a.default.apply(void 0, ["InterfaceTypeAnnotation"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.intersectionTypeAnnotation = function intersectionTypeAnnotation(t) {
            return a.default.apply(void 0, ["IntersectionTypeAnnotation"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.mixedTypeAnnotation = function mixedTypeAnnotation() {
            return a.default.apply(void 0, ["MixedTypeAnnotation"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.emptyTypeAnnotation = function emptyTypeAnnotation() {
            return a.default.apply(void 0, ["EmptyTypeAnnotation"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.nullableTypeAnnotation = function nullableTypeAnnotation(t) {
            return a.default.apply(void 0, ["NullableTypeAnnotation"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.numberLiteralTypeAnnotation = function numberLiteralTypeAnnotation(t) {
            return a.default.apply(void 0, ["NumberLiteralTypeAnnotation"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.numberTypeAnnotation = function numberTypeAnnotation() {
            return a.default.apply(void 0, ["NumberTypeAnnotation"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.objectTypeAnnotation = function objectTypeAnnotation(t, r, i, o, l) {
            return a.default.apply(void 0, ["ObjectTypeAnnotation"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.objectTypeInternalSlot = function objectTypeInternalSlot(t, r, i, o, l) {
            return a.default.apply(void 0, ["ObjectTypeInternalSlot"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.objectTypeCallProperty = function objectTypeCallProperty(t) {
            return a.default.apply(void 0, ["ObjectTypeCallProperty"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.objectTypeIndexer = function objectTypeIndexer(t, r, i, o) {
            return a.default.apply(void 0, ["ObjectTypeIndexer"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.objectTypeProperty = function objectTypeProperty(t, r, i) {
            return a.default.apply(void 0, ["ObjectTypeProperty"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.objectTypeSpreadProperty = function objectTypeSpreadProperty(t) {
            return a.default.apply(void 0, ["ObjectTypeSpreadProperty"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.opaqueType = function opaqueType(t, r, i, o) {
            return a.default.apply(void 0, ["OpaqueType"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.qualifiedTypeIdentifier = function qualifiedTypeIdentifier(t, r) {
            return a.default.apply(void 0, ["QualifiedTypeIdentifier"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.stringLiteralTypeAnnotation = function stringLiteralTypeAnnotation(t) {
            return a.default.apply(void 0, ["StringLiteralTypeAnnotation"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.stringTypeAnnotation = function stringTypeAnnotation() {
            return a.default.apply(void 0, ["StringTypeAnnotation"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.symbolTypeAnnotation = function symbolTypeAnnotation() {
            return a.default.apply(void 0, ["SymbolTypeAnnotation"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.thisTypeAnnotation = function thisTypeAnnotation() {
            return a.default.apply(void 0, ["ThisTypeAnnotation"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.tupleTypeAnnotation = function tupleTypeAnnotation(t) {
            return a.default.apply(void 0, ["TupleTypeAnnotation"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.typeofTypeAnnotation = function typeofTypeAnnotation(t) {
            return a.default.apply(void 0, ["TypeofTypeAnnotation"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.typeAlias = function typeAlias(t, r, i) {
            return a.default.apply(void 0, ["TypeAlias"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.typeAnnotation = function typeAnnotation(t) {
            return a.default.apply(void 0, ["TypeAnnotation"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.typeCastExpression = function typeCastExpression(t, r) {
            return a.default.apply(void 0, ["TypeCastExpression"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.typeParameter = function typeParameter(t, r, i) {
            return a.default.apply(void 0, ["TypeParameter"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.typeParameterDeclaration = function typeParameterDeclaration(t) {
            return a.default.apply(void 0, ["TypeParameterDeclaration"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.typeParameterInstantiation = function typeParameterInstantiation(t) {
            return a.default.apply(void 0, ["TypeParameterInstantiation"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.unionTypeAnnotation = function unionTypeAnnotation(t) {
            return a.default.apply(void 0, ["UnionTypeAnnotation"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.variance = function variance(t) {
            return a.default.apply(void 0, ["Variance"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.voidTypeAnnotation = function voidTypeAnnotation() {
            return a.default.apply(void 0, ["VoidTypeAnnotation"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.enumDeclaration = function enumDeclaration(t, r) {
            return a.default.apply(void 0, ["EnumDeclaration"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.enumBooleanBody = function enumBooleanBody(t) {
            return a.default.apply(void 0, ["EnumBooleanBody"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.enumNumberBody = function enumNumberBody(t) {
            return a.default.apply(void 0, ["EnumNumberBody"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.enumStringBody = function enumStringBody(t) {
            return a.default.apply(void 0, ["EnumStringBody"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.enumSymbolBody = function enumSymbolBody(t) {
            return a.default.apply(void 0, ["EnumSymbolBody"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.enumBooleanMember = function enumBooleanMember(t) {
            return a.default.apply(void 0, ["EnumBooleanMember"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.enumNumberMember = function enumNumberMember(t, r) {
            return a.default.apply(void 0, ["EnumNumberMember"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.enumStringMember = function enumStringMember(t, r) {
            return a.default.apply(void 0, ["EnumStringMember"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.enumDefaultedMember = function enumDefaultedMember(t) {
            return a.default.apply(void 0, ["EnumDefaultedMember"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.indexedAccessType = function indexedAccessType(t, r) {
            return a.default.apply(void 0, ["IndexedAccessType"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.optionalIndexedAccessType = function optionalIndexedAccessType(t, r) {
            return a.default.apply(void 0, ["OptionalIndexedAccessType"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.jSXAttribute = r.jsxAttribute = function jsxAttribute(t, r) {
            return a.default.apply(void 0, ["JSXAttribute"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.jSXClosingElement = r.jsxClosingElement = function jsxClosingElement(t) {
            return a.default.apply(void 0, ["JSXClosingElement"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.jSXElement = r.jsxElement = function jsxElement(t, r, i, o) {
            return a.default.apply(void 0, ["JSXElement"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.jSXEmptyExpression = r.jsxEmptyExpression = function jsxEmptyExpression() {
            return a.default.apply(void 0, ["JSXEmptyExpression"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.jSXExpressionContainer = r.jsxExpressionContainer = function jsxExpressionContainer(t) {
            return a.default.apply(void 0, ["JSXExpressionContainer"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.jSXSpreadChild = r.jsxSpreadChild = function jsxSpreadChild(t) {
            return a.default.apply(void 0, ["JSXSpreadChild"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.jSXIdentifier = r.jsxIdentifier = function jsxIdentifier(t) {
            return a.default.apply(void 0, ["JSXIdentifier"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.jSXMemberExpression = r.jsxMemberExpression = function jsxMemberExpression(t, r) {
            return a.default.apply(void 0, ["JSXMemberExpression"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.jSXNamespacedName = r.jsxNamespacedName = function jsxNamespacedName(t, r) {
            return a.default.apply(void 0, ["JSXNamespacedName"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.jSXOpeningElement = r.jsxOpeningElement = function jsxOpeningElement(t, r, i) {
            return a.default.apply(void 0, ["JSXOpeningElement"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.jSXSpreadAttribute = r.jsxSpreadAttribute = function jsxSpreadAttribute(t) {
            return a.default.apply(void 0, ["JSXSpreadAttribute"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.jSXText = r.jsxText = function jsxText(t) {
            return a.default.apply(void 0, ["JSXText"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.jSXFragment = r.jsxFragment = function jsxFragment(t, r, i) {
            return a.default.apply(void 0, ["JSXFragment"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.jSXOpeningFragment = r.jsxOpeningFragment = function jsxOpeningFragment() {
            return a.default.apply(void 0, ["JSXOpeningFragment"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.jSXClosingFragment = r.jsxClosingFragment = function jsxClosingFragment() {
            return a.default.apply(void 0, ["JSXClosingFragment"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.noop = function noop() {
            return a.default.apply(void 0, ["Noop"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.placeholder = function placeholder(t, r) {
            return a.default.apply(void 0, ["Placeholder"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.v8IntrinsicIdentifier = function v8IntrinsicIdentifier(t) {
            return a.default.apply(void 0, ["V8IntrinsicIdentifier"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.argumentPlaceholder = function argumentPlaceholder() {
            return a.default.apply(void 0, ["ArgumentPlaceholder"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.bindExpression = function bindExpression(t, r) {
            return a.default.apply(void 0, ["BindExpression"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.importAttribute = function importAttribute(t, r) {
            return a.default.apply(void 0, ["ImportAttribute"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.decorator = function decorator(t) {
            return a.default.apply(void 0, ["Decorator"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.doExpression = function doExpression(t, r) {
            return a.default.apply(void 0, ["DoExpression"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.exportDefaultSpecifier = function exportDefaultSpecifier(t) {
            return a.default.apply(void 0, ["ExportDefaultSpecifier"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.recordExpression = function recordExpression(t) {
            return a.default.apply(void 0, ["RecordExpression"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.tupleExpression = function tupleExpression(t) {
            return a.default.apply(void 0, ["TupleExpression"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.decimalLiteral = function decimalLiteral(t) {
            return a.default.apply(void 0, ["DecimalLiteral"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.staticBlock = function staticBlock(t) {
            return a.default.apply(void 0, ["StaticBlock"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.moduleExpression = function moduleExpression(t) {
            return a.default.apply(void 0, ["ModuleExpression"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.topicReference = function topicReference() {
            return a.default.apply(void 0, ["TopicReference"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.pipelineTopicExpression = function pipelineTopicExpression(t) {
            return a.default.apply(void 0, ["PipelineTopicExpression"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.pipelineBareFunction = function pipelineBareFunction(t) {
            return a.default.apply(void 0, ["PipelineBareFunction"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.pipelinePrimaryTopicReference = function pipelinePrimaryTopicReference() {
            return a.default.apply(void 0, ["PipelinePrimaryTopicReference"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.tSParameterProperty = r.tsParameterProperty = function tsParameterProperty(t) {
            return a.default.apply(void 0, ["TSParameterProperty"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.tSDeclareFunction = r.tsDeclareFunction = function tsDeclareFunction(t, r, i, o) {
            return a.default.apply(void 0, ["TSDeclareFunction"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.tSDeclareMethod = r.tsDeclareMethod = function tsDeclareMethod(t, r, i, o, l) {
            return a.default.apply(void 0, ["TSDeclareMethod"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.tSQualifiedName = r.tsQualifiedName = function tsQualifiedName(t, r) {
            return a.default.apply(void 0, ["TSQualifiedName"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.tSCallSignatureDeclaration = r.tsCallSignatureDeclaration = function tsCallSignatureDeclaration(t, r, i) {
            return a.default.apply(void 0, ["TSCallSignatureDeclaration"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.tSConstructSignatureDeclaration = r.tsConstructSignatureDeclaration = function tsConstructSignatureDeclaration(t, r, i) {
            return a.default.apply(void 0, ["TSConstructSignatureDeclaration"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.tSPropertySignature = r.tsPropertySignature = function tsPropertySignature(t, r, i) {
            return a.default.apply(void 0, ["TSPropertySignature"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.tSMethodSignature = r.tsMethodSignature = function tsMethodSignature(t, r, i, o) {
            return a.default.apply(void 0, ["TSMethodSignature"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.tSIndexSignature = r.tsIndexSignature = function tsIndexSignature(t, r) {
            return a.default.apply(void 0, ["TSIndexSignature"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.tSAnyKeyword = r.tsAnyKeyword = function tsAnyKeyword() {
            return a.default.apply(void 0, ["TSAnyKeyword"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.tSBooleanKeyword = r.tsBooleanKeyword = function tsBooleanKeyword() {
            return a.default.apply(void 0, ["TSBooleanKeyword"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.tSBigIntKeyword = r.tsBigIntKeyword = function tsBigIntKeyword() {
            return a.default.apply(void 0, ["TSBigIntKeyword"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.tSIntrinsicKeyword = r.tsIntrinsicKeyword = function tsIntrinsicKeyword() {
            return a.default.apply(void 0, ["TSIntrinsicKeyword"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.tSNeverKeyword = r.tsNeverKeyword = function tsNeverKeyword() {
            return a.default.apply(void 0, ["TSNeverKeyword"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.tSNullKeyword = r.tsNullKeyword = function tsNullKeyword() {
            return a.default.apply(void 0, ["TSNullKeyword"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.tSNumberKeyword = r.tsNumberKeyword = function tsNumberKeyword() {
            return a.default.apply(void 0, ["TSNumberKeyword"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.tSObjectKeyword = r.tsObjectKeyword = function tsObjectKeyword() {
            return a.default.apply(void 0, ["TSObjectKeyword"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.tSStringKeyword = r.tsStringKeyword = function tsStringKeyword() {
            return a.default.apply(void 0, ["TSStringKeyword"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.tSSymbolKeyword = r.tsSymbolKeyword = function tsSymbolKeyword() {
            return a.default.apply(void 0, ["TSSymbolKeyword"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.tSUndefinedKeyword = r.tsUndefinedKeyword = function tsUndefinedKeyword() {
            return a.default.apply(void 0, ["TSUndefinedKeyword"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.tSUnknownKeyword = r.tsUnknownKeyword = function tsUnknownKeyword() {
            return a.default.apply(void 0, ["TSUnknownKeyword"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.tSVoidKeyword = r.tsVoidKeyword = function tsVoidKeyword() {
            return a.default.apply(void 0, ["TSVoidKeyword"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.tSThisType = r.tsThisType = function tsThisType() {
            return a.default.apply(void 0, ["TSThisType"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.tSFunctionType = r.tsFunctionType = function tsFunctionType(t, r, i) {
            return a.default.apply(void 0, ["TSFunctionType"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.tSConstructorType = r.tsConstructorType = function tsConstructorType(t, r, i) {
            return a.default.apply(void 0, ["TSConstructorType"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.tSTypeReference = r.tsTypeReference = function tsTypeReference(t, r) {
            return a.default.apply(void 0, ["TSTypeReference"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.tSTypePredicate = r.tsTypePredicate = function tsTypePredicate(t, r, i) {
            return a.default.apply(void 0, ["TSTypePredicate"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.tSTypeQuery = r.tsTypeQuery = function tsTypeQuery(t) {
            return a.default.apply(void 0, ["TSTypeQuery"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.tSTypeLiteral = r.tsTypeLiteral = function tsTypeLiteral(t) {
            return a.default.apply(void 0, ["TSTypeLiteral"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.tSArrayType = r.tsArrayType = function tsArrayType(t) {
            return a.default.apply(void 0, ["TSArrayType"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.tSTupleType = r.tsTupleType = function tsTupleType(t) {
            return a.default.apply(void 0, ["TSTupleType"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.tSOptionalType = r.tsOptionalType = function tsOptionalType(t) {
            return a.default.apply(void 0, ["TSOptionalType"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.tSRestType = r.tsRestType = function tsRestType(t) {
            return a.default.apply(void 0, ["TSRestType"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.tSNamedTupleMember = r.tsNamedTupleMember = function tsNamedTupleMember(t, r, i) {
            return a.default.apply(void 0, ["TSNamedTupleMember"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.tSUnionType = r.tsUnionType = function tsUnionType(t) {
            return a.default.apply(void 0, ["TSUnionType"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.tSIntersectionType = r.tsIntersectionType = function tsIntersectionType(t) {
            return a.default.apply(void 0, ["TSIntersectionType"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.tSConditionalType = r.tsConditionalType = function tsConditionalType(t, r, i, o) {
            return a.default.apply(void 0, ["TSConditionalType"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.tSInferType = r.tsInferType = function tsInferType(t) {
            return a.default.apply(void 0, ["TSInferType"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.tSParenthesizedType = r.tsParenthesizedType = function tsParenthesizedType(t) {
            return a.default.apply(void 0, ["TSParenthesizedType"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.tSTypeOperator = r.tsTypeOperator = function tsTypeOperator(t) {
            return a.default.apply(void 0, ["TSTypeOperator"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.tSIndexedAccessType = r.tsIndexedAccessType = function tsIndexedAccessType(t, r) {
            return a.default.apply(void 0, ["TSIndexedAccessType"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.tSMappedType = r.tsMappedType = function tsMappedType(t, r, i) {
            return a.default.apply(void 0, ["TSMappedType"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.tSLiteralType = r.tsLiteralType = function tsLiteralType(t) {
            return a.default.apply(void 0, ["TSLiteralType"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.tSExpressionWithTypeArguments = r.tsExpressionWithTypeArguments = function tsExpressionWithTypeArguments(t, r) {
            return a.default.apply(void 0, ["TSExpressionWithTypeArguments"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.tSInterfaceDeclaration = r.tsInterfaceDeclaration = function tsInterfaceDeclaration(t, r, i, o) {
            return a.default.apply(void 0, ["TSInterfaceDeclaration"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.tSInterfaceBody = r.tsInterfaceBody = function tsInterfaceBody(t) {
            return a.default.apply(void 0, ["TSInterfaceBody"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.tSTypeAliasDeclaration = r.tsTypeAliasDeclaration = function tsTypeAliasDeclaration(t, r, i) {
            return a.default.apply(void 0, ["TSTypeAliasDeclaration"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.tSAsExpression = r.tsAsExpression = function tsAsExpression(t, r) {
            return a.default.apply(void 0, ["TSAsExpression"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.tSTypeAssertion = r.tsTypeAssertion = function tsTypeAssertion(t, r) {
            return a.default.apply(void 0, ["TSTypeAssertion"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.tSEnumDeclaration = r.tsEnumDeclaration = function tsEnumDeclaration(t, r) {
            return a.default.apply(void 0, ["TSEnumDeclaration"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.tSEnumMember = r.tsEnumMember = function tsEnumMember(t, r) {
            return a.default.apply(void 0, ["TSEnumMember"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.tSModuleDeclaration = r.tsModuleDeclaration = function tsModuleDeclaration(t, r) {
            return a.default.apply(void 0, ["TSModuleDeclaration"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.tSModuleBlock = r.tsModuleBlock = function tsModuleBlock(t) {
            return a.default.apply(void 0, ["TSModuleBlock"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.tSImportType = r.tsImportType = function tsImportType(t, r, i) {
            return a.default.apply(void 0, ["TSImportType"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.tSImportEqualsDeclaration = r.tsImportEqualsDeclaration = function tsImportEqualsDeclaration(t, r) {
            return a.default.apply(void 0, ["TSImportEqualsDeclaration"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.tSExternalModuleReference = r.tsExternalModuleReference = function tsExternalModuleReference(t) {
            return a.default.apply(void 0, ["TSExternalModuleReference"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.tSNonNullExpression = r.tsNonNullExpression = function tsNonNullExpression(t) {
            return a.default.apply(void 0, ["TSNonNullExpression"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.tSExportAssignment = r.tsExportAssignment = function tsExportAssignment(t) {
            return a.default.apply(void 0, ["TSExportAssignment"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.tSNamespaceExportDeclaration = r.tsNamespaceExportDeclaration = function tsNamespaceExportDeclaration(t) {
            return a.default.apply(void 0, ["TSNamespaceExportDeclaration"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.tSTypeAnnotation = r.tsTypeAnnotation = function tsTypeAnnotation(t) {
            return a.default.apply(void 0, ["TSTypeAnnotation"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.tSTypeParameterInstantiation = r.tsTypeParameterInstantiation = function tsTypeParameterInstantiation(t) {
            return a.default.apply(void 0, ["TSTypeParameterInstantiation"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.tSTypeParameterDeclaration = r.tsTypeParameterDeclaration = function tsTypeParameterDeclaration(t) {
            return a.default.apply(void 0, ["TSTypeParameterDeclaration"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.tSTypeParameter = r.tsTypeParameter = function tsTypeParameter(t, r, i) {
            return a.default.apply(void 0, ["TSTypeParameter"].concat(Array.prototype.slice.call(arguments)))
        }
        ,
        r.numberLiteral = function NumberLiteral() {
            console.trace("The node type NumberLiteral has been renamed to NumericLiteral");
            for (var t = arguments.length, r = new Array(t), i = 0; i < t; i++)
                r[i] = arguments[i];
            return a.default.apply(void 0, ["NumberLiteral"].concat(r))
        }
        ,
        r.regexLiteral = function RegexLiteral() {
            console.trace("The node type RegexLiteral has been renamed to RegExpLiteral");
            for (var t = arguments.length, r = new Array(t), i = 0; i < t; i++)
                r[i] = arguments[i];
            return a.default.apply(void 0, ["RegexLiteral"].concat(r))
        }
        ,
        r.restProperty = function RestProperty() {
            console.trace("The node type RestProperty has been renamed to RestElement");
            for (var t = arguments.length, r = new Array(t), i = 0; i < t; i++)
                r[i] = arguments[i];
            return a.default.apply(void 0, ["RestProperty"].concat(r))
        }
        ,
        r.spreadProperty = function SpreadProperty() {
            console.trace("The node type SpreadProperty has been renamed to SpreadElement");
            for (var t = arguments.length, r = new Array(t), i = 0; i < t; i++)
                r[i] = arguments[i];
            return a.default.apply(void 0, ["SpreadProperty"].concat(r))
        }
        ;
        var a = i("bEOD")
    },
    "583I": function(t, r, i) {
        "use strict";
        var a = i("TqRt")
          , o = a(i("lwsE"))
          , l = a(i("W8MJ"));
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = void 0;
        var u = function() {
            function Hub() {
                (0,
                o.default)(this, Hub)
            }
            return (0,
            l.default)(Hub, [{
                key: "getCode",
                value: function getCode() {}
            }, {
                key: "getScope",
                value: function getScope() {}
            }, {
                key: "addHelper",
                value: function addHelper() {
                    throw new Error("Helpers are not supported by the default hub.")
                }
            }, {
                key: "buildError",
                value: function buildError(t, r) {
                    var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : TypeError;
                    return new i(r)
                }
            }]),
            Hub
        }();
        r.default = u
    },
    "5Qwp": function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function hoistVariables(t, r, i="var") {
            t.traverse(p, {
                kind: i,
                emit: r
            })
        }
        ;
        var a = i("JSq2");
        const {assignmentExpression: o, expressionStatement: l, identifier: u} = a
          , p = {
            Scope(t, r) {
                "let" === r.kind && t.skip()
            },
            FunctionParent(t) {
                t.skip()
            },
            VariableDeclaration(t, r) {
                if (r.kind && t.node.kind !== r.kind)
                    return;
                const i = []
                  , a = t.get("declarations");
                let p;
                for (const t of a) {
                    p = t.node.id,
                    t.node.init && i.push(l(o("=", t.node.id, t.node.init)));
                    for (const i of Object.keys(t.getBindingIdentifiers()))
                        r.emit(u(i), i, null !== t.node.init)
                }
                t.parentPath.isFor({
                    left: t.node
                }) ? t.replaceWith(p) : t.replaceWithMultiple(i)
            }
        }
    },
    "5Y2g": function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.PLACEHOLDERS_FLIPPED_ALIAS = r.PLACEHOLDERS_ALIAS = r.PLACEHOLDERS = void 0;
        var a = i("7ePq")
          , o = ["Identifier", "StringLiteral", "Expression", "Statement", "Declaration", "BlockStatement", "ClassBody", "Pattern"];
        r.PLACEHOLDERS = o;
        var l = {
            Declaration: ["Statement"],
            Pattern: ["PatternLike", "LVal"]
        };
        r.PLACEHOLDERS_ALIAS = l;
        for (var u = 0, p = o; u < p.length; u++) {
            var c = p[u]
              , d = a.ALIAS_KEYS[c];
            null != d && d.length && (l[c] = d)
        }
        var y = {};
        r.PLACEHOLDERS_FLIPPED_ALIAS = y,
        Object.keys(l).forEach((function(t) {
            l[t].forEach((function(r) {
                Object.hasOwnProperty.call(y, r) || (y[r] = []),
                y[r].push(t)
            }
            ))
        }
        ))
    },
    "5Yb/": function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.isReservedWord = isReservedWord,
        r.isStrictReservedWord = isStrictReservedWord,
        r.isStrictBindOnlyReservedWord = isStrictBindOnlyReservedWord,
        r.isStrictBindReservedWord = function isStrictBindReservedWord(t, r) {
            return isStrictReservedWord(t, r) || isStrictBindOnlyReservedWord(t)
        }
        ,
        r.isKeyword = function isKeyword(t) {
            return l.has(t)
        }
        ;
        var a = ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"]
          , o = ["eval", "arguments"]
          , l = new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"])
          , u = new Set(a)
          , p = new Set(o);
        function isReservedWord(t, r) {
            return r && "await" === t || "enum" === t
        }
        function isStrictReservedWord(t, r) {
            return isReservedWord(t, r) || u.has(t)
        }
        function isStrictBindOnlyReservedWord(t) {
            return p.has(t)
        }
    },
    "5e9W": function(t, r, i) {
        "use strict";
        t.exports = {
            stdout: !1,
            stderr: !1
        }
    },
    "5kYL": function(t, r, i) {
        var a = i("TyJS")
          , o = {};
        for (var l in a)
            a.hasOwnProperty(l) && (o[a[l]] = l);
        var u = t.exports = {
            rgb: {
                channels: 3,
                labels: "rgb"
            },
            hsl: {
                channels: 3,
                labels: "hsl"
            },
            hsv: {
                channels: 3,
                labels: "hsv"
            },
            hwb: {
                channels: 3,
                labels: "hwb"
            },
            cmyk: {
                channels: 4,
                labels: "cmyk"
            },
            xyz: {
                channels: 3,
                labels: "xyz"
            },
            lab: {
                channels: 3,
                labels: "lab"
            },
            lch: {
                channels: 3,
                labels: "lch"
            },
            hex: {
                channels: 1,
                labels: ["hex"]
            },
            keyword: {
                channels: 1,
                labels: ["keyword"]
            },
            ansi16: {
                channels: 1,
                labels: ["ansi16"]
            },
            ansi256: {
                channels: 1,
                labels: ["ansi256"]
            },
            hcg: {
                channels: 3,
                labels: ["h", "c", "g"]
            },
            apple: {
                channels: 3,
                labels: ["r16", "g16", "b16"]
            },
            gray: {
                channels: 1,
                labels: ["gray"]
            }
        };
        for (var p in u)
            if (u.hasOwnProperty(p)) {
                if (!("channels"in u[p]))
                    throw new Error("missing channels property: " + p);
                if (!("labels"in u[p]))
                    throw new Error("missing channel labels property: " + p);
                if (u[p].labels.length !== u[p].channels)
                    throw new Error("channel and label counts mismatch: " + p);
                var c = u[p].channels
                  , d = u[p].labels;
                delete u[p].channels,
                delete u[p].labels,
                Object.defineProperty(u[p], "channels", {
                    value: c
                }),
                Object.defineProperty(u[p], "labels", {
                    value: d
                })
            }
        u.rgb.hsl = function(t) {
            var r, i, a = t[0] / 255, o = t[1] / 255, l = t[2] / 255, u = Math.min(a, o, l), p = Math.max(a, o, l), c = p - u;
            return p === u ? r = 0 : a === p ? r = (o - l) / c : o === p ? r = 2 + (l - a) / c : l === p && (r = 4 + (a - o) / c),
            (r = Math.min(60 * r, 360)) < 0 && (r += 360),
            i = (u + p) / 2,
            [r, 100 * (p === u ? 0 : i <= .5 ? c / (p + u) : c / (2 - p - u)), 100 * i]
        }
        ,
        u.rgb.hsv = function(t) {
            var r, i, a, o, l, u = t[0] / 255, p = t[1] / 255, c = t[2] / 255, d = Math.max(u, p, c), y = d - Math.min(u, p, c), diffc = function(t) {
                return (d - t) / 6 / y + .5
            };
            return 0 === y ? o = l = 0 : (l = y / d,
            r = diffc(u),
            i = diffc(p),
            a = diffc(c),
            u === d ? o = a - i : p === d ? o = 1 / 3 + r - a : c === d && (o = 2 / 3 + i - r),
            o < 0 ? o += 1 : o > 1 && (o -= 1)),
            [360 * o, 100 * l, 100 * d]
        }
        ,
        u.rgb.hwb = function(t) {
            var r = t[0]
              , i = t[1]
              , a = t[2];
            return [u.rgb.hsl(t)[0], 100 * (1 / 255 * Math.min(r, Math.min(i, a))), 100 * (a = 1 - 1 / 255 * Math.max(r, Math.max(i, a)))]
        }
        ,
        u.rgb.cmyk = function(t) {
            var r, i = t[0] / 255, a = t[1] / 255, o = t[2] / 255;
            return [100 * ((1 - i - (r = Math.min(1 - i, 1 - a, 1 - o))) / (1 - r) || 0), 100 * ((1 - a - r) / (1 - r) || 0), 100 * ((1 - o - r) / (1 - r) || 0), 100 * r]
        }
        ,
        u.rgb.keyword = function(t) {
            var r = o[t];
            if (r)
                return r;
            var i, l, u, p = 1 / 0;
            for (var c in a)
                if (a.hasOwnProperty(c)) {
                    var d = a[c]
                      , y = (l = t,
                    u = d,
                    Math.pow(l[0] - u[0], 2) + Math.pow(l[1] - u[1], 2) + Math.pow(l[2] - u[2], 2));
                    y < p && (p = y,
                    i = c)
                }
            return i
        }
        ,
        u.keyword.rgb = function(t) {
            return a[t]
        }
        ,
        u.rgb.xyz = function(t) {
            var r = t[0] / 255
              , i = t[1] / 255
              , a = t[2] / 255;
            return [100 * (.4124 * (r = r > .04045 ? Math.pow((r + .055) / 1.055, 2.4) : r / 12.92) + .3576 * (i = i > .04045 ? Math.pow((i + .055) / 1.055, 2.4) : i / 12.92) + .1805 * (a = a > .04045 ? Math.pow((a + .055) / 1.055, 2.4) : a / 12.92)), 100 * (.2126 * r + .7152 * i + .0722 * a), 100 * (.0193 * r + .1192 * i + .9505 * a)]
        }
        ,
        u.rgb.lab = function(t) {
            var r = u.rgb.xyz(t)
              , i = r[0]
              , a = r[1]
              , o = r[2];
            return a /= 100,
            o /= 108.883,
            i = (i /= 95.047) > .008856 ? Math.pow(i, 1 / 3) : 7.787 * i + 16 / 116,
            [116 * (a = a > .008856 ? Math.pow(a, 1 / 3) : 7.787 * a + 16 / 116) - 16, 500 * (i - a), 200 * (a - (o = o > .008856 ? Math.pow(o, 1 / 3) : 7.787 * o + 16 / 116))]
        }
        ,
        u.hsl.rgb = function(t) {
            var r, i, a, o, l, u = t[0] / 360, p = t[1] / 100, c = t[2] / 100;
            if (0 === p)
                return [l = 255 * c, l, l];
            r = 2 * c - (i = c < .5 ? c * (1 + p) : c + p - c * p),
            o = [0, 0, 0];
            for (var d = 0; d < 3; d++)
                (a = u + 1 / 3 * -(d - 1)) < 0 && a++,
                a > 1 && a--,
                l = 6 * a < 1 ? r + 6 * (i - r) * a : 2 * a < 1 ? i : 3 * a < 2 ? r + (i - r) * (2 / 3 - a) * 6 : r,
                o[d] = 255 * l;
            return o
        }
        ,
        u.hsl.hsv = function(t) {
            var r = t[0]
              , i = t[1] / 100
              , a = t[2] / 100
              , o = i
              , l = Math.max(a, .01);
            return i *= (a *= 2) <= 1 ? a : 2 - a,
            o *= l <= 1 ? l : 2 - l,
            [r, 100 * (0 === a ? 2 * o / (l + o) : 2 * i / (a + i)), 100 * ((a + i) / 2)]
        }
        ,
        u.hsv.rgb = function(t) {
            var r = t[0] / 60
              , i = t[1] / 100
              , a = t[2] / 100
              , o = Math.floor(r) % 6
              , l = r - Math.floor(r)
              , u = 255 * a * (1 - i)
              , p = 255 * a * (1 - i * l)
              , c = 255 * a * (1 - i * (1 - l));
            switch (a *= 255,
            o) {
            case 0:
                return [a, c, u];
            case 1:
                return [p, a, u];
            case 2:
                return [u, a, c];
            case 3:
                return [u, p, a];
            case 4:
                return [c, u, a];
            case 5:
                return [a, u, p]
            }
        }
        ,
        u.hsv.hsl = function(t) {
            var r, i, a, o = t[0], l = t[1] / 100, u = t[2] / 100, p = Math.max(u, .01);
            return a = (2 - l) * u,
            i = l * p,
            [o, 100 * (i = (i /= (r = (2 - l) * p) <= 1 ? r : 2 - r) || 0), 100 * (a /= 2)]
        }
        ,
        u.hwb.rgb = function(t) {
            var r, i, a, o, l, u, p, c = t[0] / 360, d = t[1] / 100, y = t[2] / 100, h = d + y;
            switch (h > 1 && (d /= h,
            y /= h),
            a = 6 * c - (r = Math.floor(6 * c)),
            0 != (1 & r) && (a = 1 - a),
            o = d + a * ((i = 1 - y) - d),
            r) {
            default:
            case 6:
            case 0:
                l = i,
                u = o,
                p = d;
                break;
            case 1:
                l = o,
                u = i,
                p = d;
                break;
            case 2:
                l = d,
                u = i,
                p = o;
                break;
            case 3:
                l = d,
                u = o,
                p = i;
                break;
            case 4:
                l = o,
                u = d,
                p = i;
                break;
            case 5:
                l = i,
                u = d,
                p = o
            }
            return [255 * l, 255 * u, 255 * p]
        }
        ,
        u.cmyk.rgb = function(t) {
            var r = t[0] / 100
              , i = t[1] / 100
              , a = t[2] / 100
              , o = t[3] / 100;
            return [255 * (1 - Math.min(1, r * (1 - o) + o)), 255 * (1 - Math.min(1, i * (1 - o) + o)), 255 * (1 - Math.min(1, a * (1 - o) + o))]
        }
        ,
        u.xyz.rgb = function(t) {
            var r, i, a, o = t[0] / 100, l = t[1] / 100, u = t[2] / 100;
            return i = -.9689 * o + 1.8758 * l + .0415 * u,
            a = .0557 * o + -.204 * l + 1.057 * u,
            r = (r = 3.2406 * o + -1.5372 * l + -.4986 * u) > .0031308 ? 1.055 * Math.pow(r, 1 / 2.4) - .055 : 12.92 * r,
            i = i > .0031308 ? 1.055 * Math.pow(i, 1 / 2.4) - .055 : 12.92 * i,
            a = a > .0031308 ? 1.055 * Math.pow(a, 1 / 2.4) - .055 : 12.92 * a,
            [255 * (r = Math.min(Math.max(0, r), 1)), 255 * (i = Math.min(Math.max(0, i), 1)), 255 * (a = Math.min(Math.max(0, a), 1))]
        }
        ,
        u.xyz.lab = function(t) {
            var r = t[0]
              , i = t[1]
              , a = t[2];
            return i /= 100,
            a /= 108.883,
            r = (r /= 95.047) > .008856 ? Math.pow(r, 1 / 3) : 7.787 * r + 16 / 116,
            [116 * (i = i > .008856 ? Math.pow(i, 1 / 3) : 7.787 * i + 16 / 116) - 16, 500 * (r - i), 200 * (i - (a = a > .008856 ? Math.pow(a, 1 / 3) : 7.787 * a + 16 / 116))]
        }
        ,
        u.lab.xyz = function(t) {
            var r, i, a, o = t[0];
            r = t[1] / 500 + (i = (o + 16) / 116),
            a = i - t[2] / 200;
            var l = Math.pow(i, 3)
              , u = Math.pow(r, 3)
              , p = Math.pow(a, 3);
            return i = l > .008856 ? l : (i - 16 / 116) / 7.787,
            r = u > .008856 ? u : (r - 16 / 116) / 7.787,
            a = p > .008856 ? p : (a - 16 / 116) / 7.787,
            [r *= 95.047, i *= 100, a *= 108.883]
        }
        ,
        u.lab.lch = function(t) {
            var r, i = t[0], a = t[1], o = t[2];
            return (r = 360 * Math.atan2(o, a) / 2 / Math.PI) < 0 && (r += 360),
            [i, Math.sqrt(a * a + o * o), r]
        }
        ,
        u.lch.lab = function(t) {
            var r, i = t[0], a = t[1];
            return r = t[2] / 360 * 2 * Math.PI,
            [i, a * Math.cos(r), a * Math.sin(r)]
        }
        ,
        u.rgb.ansi16 = function(t) {
            var r = t[0]
              , i = t[1]
              , a = t[2]
              , o = 1 in arguments ? arguments[1] : u.rgb.hsv(t)[2];
            if (0 === (o = Math.round(o / 50)))
                return 30;
            var l = 30 + (Math.round(a / 255) << 2 | Math.round(i / 255) << 1 | Math.round(r / 255));
            return 2 === o && (l += 60),
            l
        }
        ,
        u.hsv.ansi16 = function(t) {
            return u.rgb.ansi16(u.hsv.rgb(t), t[2])
        }
        ,
        u.rgb.ansi256 = function(t) {
            var r = t[0]
              , i = t[1]
              , a = t[2];
            return r === i && i === a ? r < 8 ? 16 : r > 248 ? 231 : Math.round((r - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(i / 255 * 5) + Math.round(a / 255 * 5)
        }
        ,
        u.ansi16.rgb = function(t) {
            var r = t % 10;
            if (0 === r || 7 === r)
                return t > 50 && (r += 3.5),
                [r = r / 10.5 * 255, r, r];
            var i = .5 * (1 + ~~(t > 50));
            return [(1 & r) * i * 255, (r >> 1 & 1) * i * 255, (r >> 2 & 1) * i * 255]
        }
        ,
        u.ansi256.rgb = function(t) {
            if (t >= 232) {
                var r = 10 * (t - 232) + 8;
                return [r, r, r]
            }
            var i;
            return t -= 16,
            [Math.floor(t / 36) / 5 * 255, Math.floor((i = t % 36) / 6) / 5 * 255, i % 6 / 5 * 255]
        }
        ,
        u.rgb.hex = function(t) {
            var r = (((255 & Math.round(t[0])) << 16) + ((255 & Math.round(t[1])) << 8) + (255 & Math.round(t[2]))).toString(16).toUpperCase();
            return "000000".substring(r.length) + r
        }
        ,
        u.hex.rgb = function(t) {
            var r = t.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
            if (!r)
                return [0, 0, 0];
            var i = r[0];
            3 === r[0].length && (i = i.split("").map((function(t) {
                return t + t
            }
            )).join(""));
            var a = parseInt(i, 16);
            return [a >> 16 & 255, a >> 8 & 255, 255 & a]
        }
        ,
        u.rgb.hcg = function(t) {
            var r, i = t[0] / 255, a = t[1] / 255, o = t[2] / 255, l = Math.max(Math.max(i, a), o), u = Math.min(Math.min(i, a), o), p = l - u;
            return r = p <= 0 ? 0 : l === i ? (a - o) / p % 6 : l === a ? 2 + (o - i) / p : 4 + (i - a) / p + 4,
            r /= 6,
            [360 * (r %= 1), 100 * p, 100 * (p < 1 ? u / (1 - p) : 0)]
        }
        ,
        u.hsl.hcg = function(t) {
            var r = t[1] / 100
              , i = t[2] / 100
              , a = 1
              , o = 0;
            return (a = i < .5 ? 2 * r * i : 2 * r * (1 - i)) < 1 && (o = (i - .5 * a) / (1 - a)),
            [t[0], 100 * a, 100 * o]
        }
        ,
        u.hsv.hcg = function(t) {
            var r = t[1] / 100
              , i = t[2] / 100
              , a = r * i
              , o = 0;
            return a < 1 && (o = (i - a) / (1 - a)),
            [t[0], 100 * a, 100 * o]
        }
        ,
        u.hcg.rgb = function(t) {
            var r = t[0] / 360
              , i = t[1] / 100
              , a = t[2] / 100;
            if (0 === i)
                return [255 * a, 255 * a, 255 * a];
            var o, l = [0, 0, 0], u = r % 1 * 6, p = u % 1, c = 1 - p;
            switch (Math.floor(u)) {
            case 0:
                l[0] = 1,
                l[1] = p,
                l[2] = 0;
                break;
            case 1:
                l[0] = c,
                l[1] = 1,
                l[2] = 0;
                break;
            case 2:
                l[0] = 0,
                l[1] = 1,
                l[2] = p;
                break;
            case 3:
                l[0] = 0,
                l[1] = c,
                l[2] = 1;
                break;
            case 4:
                l[0] = p,
                l[1] = 0,
                l[2] = 1;
                break;
            default:
                l[0] = 1,
                l[1] = 0,
                l[2] = c
            }
            return o = (1 - i) * a,
            [255 * (i * l[0] + o), 255 * (i * l[1] + o), 255 * (i * l[2] + o)]
        }
        ,
        u.hcg.hsv = function(t) {
            var r = t[1] / 100
              , i = r + t[2] / 100 * (1 - r)
              , a = 0;
            return i > 0 && (a = r / i),
            [t[0], 100 * a, 100 * i]
        }
        ,
        u.hcg.hsl = function(t) {
            var r = t[1] / 100
              , i = t[2] / 100 * (1 - r) + .5 * r
              , a = 0;
            return i > 0 && i < .5 ? a = r / (2 * i) : i >= .5 && i < 1 && (a = r / (2 * (1 - i))),
            [t[0], 100 * a, 100 * i]
        }
        ,
        u.hcg.hwb = function(t) {
            var r = t[1] / 100
              , i = r + t[2] / 100 * (1 - r);
            return [t[0], 100 * (i - r), 100 * (1 - i)]
        }
        ,
        u.hwb.hcg = function(t) {
            var r = t[1] / 100
              , i = 1 - t[2] / 100
              , a = i - r
              , o = 0;
            return a < 1 && (o = (i - a) / (1 - a)),
            [t[0], 100 * a, 100 * o]
        }
        ,
        u.apple.rgb = function(t) {
            return [t[0] / 65535 * 255, t[1] / 65535 * 255, t[2] / 65535 * 255]
        }
        ,
        u.rgb.apple = function(t) {
            return [t[0] / 255 * 65535, t[1] / 255 * 65535, t[2] / 255 * 65535]
        }
        ,
        u.gray.rgb = function(t) {
            return [t[0] / 100 * 255, t[0] / 100 * 255, t[0] / 100 * 255]
        }
        ,
        u.gray.hsl = u.gray.hsv = function(t) {
            return [0, 0, t[0]]
        }
        ,
        u.gray.hwb = function(t) {
            return [0, 100, t[0]]
        }
        ,
        u.gray.cmyk = function(t) {
            return [0, 0, 0, t[0]]
        }
        ,
        u.gray.lab = function(t) {
            return [t[0], 0, 0]
        }
        ,
        u.gray.hex = function(t) {
            var r = 255 & Math.round(t[0] / 100 * 255)
              , i = ((r << 16) + (r << 8) + r).toString(16).toUpperCase();
            return "000000".substring(i.length) + i
        }
        ,
        u.rgb.gray = function(t) {
            return [(t[0] + t[1] + t[2]) / 3 / 255 * 100]
        }
    },
    "5uIQ": function(t, r, i) {
        "use strict";
        (function(t) {
            var r = i("7ePq");
            (0,
            r.default)("ArgumentPlaceholder", {}),
            (0,
            r.default)("BindExpression", {
                visitor: ["object", "callee"],
                aliases: ["Expression"],
                fields: t.env.BABEL_TYPES_8_BREAKING ? {
                    object: {
                        validate: (0,
                        r.assertNodeType)("Expression")
                    },
                    callee: {
                        validate: (0,
                        r.assertNodeType)("Expression")
                    }
                } : {
                    object: {
                        validate: Object.assign((function() {}
                        ), {
                            oneOfNodeTypes: ["Expression"]
                        })
                    },
                    callee: {
                        validate: Object.assign((function() {}
                        ), {
                            oneOfNodeTypes: ["Expression"]
                        })
                    }
                }
            }),
            (0,
            r.default)("ImportAttribute", {
                visitor: ["key", "value"],
                fields: {
                    key: {
                        validate: (0,
                        r.assertNodeType)("Identifier", "StringLiteral")
                    },
                    value: {
                        validate: (0,
                        r.assertNodeType)("StringLiteral")
                    }
                }
            }),
            (0,
            r.default)("Decorator", {
                visitor: ["expression"],
                fields: {
                    expression: {
                        validate: (0,
                        r.assertNodeType)("Expression")
                    }
                }
            }),
            (0,
            r.default)("DoExpression", {
                visitor: ["body"],
                builder: ["body", "async"],
                aliases: ["Expression"],
                fields: {
                    body: {
                        validate: (0,
                        r.assertNodeType)("BlockStatement")
                    },
                    async: {
                        validate: (0,
                        r.assertValueType)("boolean"),
                        default: !1
                    }
                }
            }),
            (0,
            r.default)("ExportDefaultSpecifier", {
                visitor: ["exported"],
                aliases: ["ModuleSpecifier"],
                fields: {
                    exported: {
                        validate: (0,
                        r.assertNodeType)("Identifier")
                    }
                }
            }),
            (0,
            r.default)("RecordExpression", {
                visitor: ["properties"],
                aliases: ["Expression"],
                fields: {
                    properties: {
                        validate: (0,
                        r.chain)((0,
                        r.assertValueType)("array"), (0,
                        r.assertEach)((0,
                        r.assertNodeType)("ObjectProperty", "SpreadElement")))
                    }
                }
            }),
            (0,
            r.default)("TupleExpression", {
                fields: {
                    elements: {
                        validate: (0,
                        r.chain)((0,
                        r.assertValueType)("array"), (0,
                        r.assertEach)((0,
                        r.assertNodeType)("Expression", "SpreadElement"))),
                        default: []
                    }
                },
                visitor: ["elements"],
                aliases: ["Expression"]
            }),
            (0,
            r.default)("DecimalLiteral", {
                builder: ["value"],
                fields: {
                    value: {
                        validate: (0,
                        r.assertValueType)("string")
                    }
                },
                aliases: ["Expression", "Pureish", "Literal", "Immutable"]
            }),
            (0,
            r.default)("StaticBlock", {
                visitor: ["body"],
                fields: {
                    body: {
                        validate: (0,
                        r.chain)((0,
                        r.assertValueType)("array"), (0,
                        r.assertEach)((0,
                        r.assertNodeType)("Statement")))
                    }
                },
                aliases: ["Scopable", "BlockParent"]
            }),
            (0,
            r.default)("ModuleExpression", {
                visitor: ["body"],
                fields: {
                    body: {
                        validate: (0,
                        r.assertNodeType)("Program")
                    }
                },
                aliases: ["Expression"]
            }),
            (0,
            r.default)("TopicReference", {
                aliases: ["Expression"]
            }),
            (0,
            r.default)("PipelineTopicExpression", {
                builder: ["expression"],
                visitor: ["expression"],
                fields: {
                    expression: {
                        validate: (0,
                        r.assertNodeType)("Expression")
                    }
                },
                aliases: ["Expression"]
            }),
            (0,
            r.default)("PipelineBareFunction", {
                builder: ["callee"],
                visitor: ["callee"],
                fields: {
                    callee: {
                        validate: (0,
                        r.assertNodeType)("Expression")
                    }
                },
                aliases: ["Expression"]
            }),
            (0,
            r.default)("PipelinePrimaryTopicReference", {
                aliases: ["Expression"]
            })
        }
        ).call(this, i("8oxB"))
    },
    "61uC": function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.anyTypeAnnotation = function anyTypeAnnotation() {
            return a.default.apply("AnyTypeAnnotation", arguments)
        }
        ,
        r.argumentPlaceholder = function argumentPlaceholder() {
            return a.default.apply("ArgumentPlaceholder", arguments)
        }
        ,
        r.arrayExpression = function arrayExpression(t) {
            return a.default.apply("ArrayExpression", arguments)
        }
        ,
        r.arrayPattern = function arrayPattern(t) {
            return a.default.apply("ArrayPattern", arguments)
        }
        ,
        r.arrayTypeAnnotation = function arrayTypeAnnotation(t) {
            return a.default.apply("ArrayTypeAnnotation", arguments)
        }
        ,
        r.arrowFunctionExpression = function arrowFunctionExpression(t, r, i) {
            return a.default.apply("ArrowFunctionExpression", arguments)
        }
        ,
        r.assignmentExpression = function assignmentExpression(t, r, i) {
            return a.default.apply("AssignmentExpression", arguments)
        }
        ,
        r.assignmentPattern = function assignmentPattern(t, r) {
            return a.default.apply("AssignmentPattern", arguments)
        }
        ,
        r.awaitExpression = function awaitExpression(t) {
            return a.default.apply("AwaitExpression", arguments)
        }
        ,
        r.bigIntLiteral = function bigIntLiteral(t) {
            return a.default.apply("BigIntLiteral", arguments)
        }
        ,
        r.binaryExpression = function binaryExpression(t, r, i) {
            return a.default.apply("BinaryExpression", arguments)
        }
        ,
        r.bindExpression = function bindExpression(t, r) {
            return a.default.apply("BindExpression", arguments)
        }
        ,
        r.blockStatement = function blockStatement(t, r) {
            return a.default.apply("BlockStatement", arguments)
        }
        ,
        r.booleanLiteral = function booleanLiteral(t) {
            return a.default.apply("BooleanLiteral", arguments)
        }
        ,
        r.booleanLiteralTypeAnnotation = function booleanLiteralTypeAnnotation(t) {
            return a.default.apply("BooleanLiteralTypeAnnotation", arguments)
        }
        ,
        r.booleanTypeAnnotation = function booleanTypeAnnotation() {
            return a.default.apply("BooleanTypeAnnotation", arguments)
        }
        ,
        r.breakStatement = function breakStatement(t) {
            return a.default.apply("BreakStatement", arguments)
        }
        ,
        r.callExpression = function callExpression(t, r) {
            return a.default.apply("CallExpression", arguments)
        }
        ,
        r.catchClause = function catchClause(t, r) {
            return a.default.apply("CatchClause", arguments)
        }
        ,
        r.classBody = function classBody(t) {
            return a.default.apply("ClassBody", arguments)
        }
        ,
        r.classDeclaration = function classDeclaration(t, r, i, o) {
            return a.default.apply("ClassDeclaration", arguments)
        }
        ,
        r.classExpression = function classExpression(t, r, i, o) {
            return a.default.apply("ClassExpression", arguments)
        }
        ,
        r.classImplements = function classImplements(t, r) {
            return a.default.apply("ClassImplements", arguments)
        }
        ,
        r.classMethod = function classMethod(t, r, i, o, l, u, p, c) {
            return a.default.apply("ClassMethod", arguments)
        }
        ,
        r.classPrivateMethod = function classPrivateMethod(t, r, i, o, l) {
            return a.default.apply("ClassPrivateMethod", arguments)
        }
        ,
        r.classPrivateProperty = function classPrivateProperty(t, r, i, o) {
            return a.default.apply("ClassPrivateProperty", arguments)
        }
        ,
        r.classProperty = function classProperty(t, r, i, o, l, u) {
            return a.default.apply("ClassProperty", arguments)
        }
        ,
        r.conditionalExpression = function conditionalExpression(t, r, i) {
            return a.default.apply("ConditionalExpression", arguments)
        }
        ,
        r.continueStatement = function continueStatement(t) {
            return a.default.apply("ContinueStatement", arguments)
        }
        ,
        r.debuggerStatement = function debuggerStatement() {
            return a.default.apply("DebuggerStatement", arguments)
        }
        ,
        r.decimalLiteral = function decimalLiteral(t) {
            return a.default.apply("DecimalLiteral", arguments)
        }
        ,
        r.declareClass = function declareClass(t, r, i, o) {
            return a.default.apply("DeclareClass", arguments)
        }
        ,
        r.declareExportAllDeclaration = function declareExportAllDeclaration(t) {
            return a.default.apply("DeclareExportAllDeclaration", arguments)
        }
        ,
        r.declareExportDeclaration = function declareExportDeclaration(t, r, i) {
            return a.default.apply("DeclareExportDeclaration", arguments)
        }
        ,
        r.declareFunction = function declareFunction(t) {
            return a.default.apply("DeclareFunction", arguments)
        }
        ,
        r.declareInterface = function declareInterface(t, r, i, o) {
            return a.default.apply("DeclareInterface", arguments)
        }
        ,
        r.declareModule = function declareModule(t, r, i) {
            return a.default.apply("DeclareModule", arguments)
        }
        ,
        r.declareModuleExports = function declareModuleExports(t) {
            return a.default.apply("DeclareModuleExports", arguments)
        }
        ,
        r.declareOpaqueType = function declareOpaqueType(t, r, i) {
            return a.default.apply("DeclareOpaqueType", arguments)
        }
        ,
        r.declareTypeAlias = function declareTypeAlias(t, r, i) {
            return a.default.apply("DeclareTypeAlias", arguments)
        }
        ,
        r.declareVariable = function declareVariable(t) {
            return a.default.apply("DeclareVariable", arguments)
        }
        ,
        r.declaredPredicate = function declaredPredicate(t) {
            return a.default.apply("DeclaredPredicate", arguments)
        }
        ,
        r.decorator = function decorator(t) {
            return a.default.apply("Decorator", arguments)
        }
        ,
        r.directive = function directive(t) {
            return a.default.apply("Directive", arguments)
        }
        ,
        r.directiveLiteral = function directiveLiteral(t) {
            return a.default.apply("DirectiveLiteral", arguments)
        }
        ,
        r.doExpression = function doExpression(t, r) {
            return a.default.apply("DoExpression", arguments)
        }
        ,
        r.doWhileStatement = function doWhileStatement(t, r) {
            return a.default.apply("DoWhileStatement", arguments)
        }
        ,
        r.emptyStatement = function emptyStatement() {
            return a.default.apply("EmptyStatement", arguments)
        }
        ,
        r.emptyTypeAnnotation = function emptyTypeAnnotation() {
            return a.default.apply("EmptyTypeAnnotation", arguments)
        }
        ,
        r.enumBooleanBody = function enumBooleanBody(t) {
            return a.default.apply("EnumBooleanBody", arguments)
        }
        ,
        r.enumBooleanMember = function enumBooleanMember(t) {
            return a.default.apply("EnumBooleanMember", arguments)
        }
        ,
        r.enumDeclaration = function enumDeclaration(t, r) {
            return a.default.apply("EnumDeclaration", arguments)
        }
        ,
        r.enumDefaultedMember = function enumDefaultedMember(t) {
            return a.default.apply("EnumDefaultedMember", arguments)
        }
        ,
        r.enumNumberBody = function enumNumberBody(t) {
            return a.default.apply("EnumNumberBody", arguments)
        }
        ,
        r.enumNumberMember = function enumNumberMember(t, r) {
            return a.default.apply("EnumNumberMember", arguments)
        }
        ,
        r.enumStringBody = function enumStringBody(t) {
            return a.default.apply("EnumStringBody", arguments)
        }
        ,
        r.enumStringMember = function enumStringMember(t, r) {
            return a.default.apply("EnumStringMember", arguments)
        }
        ,
        r.enumSymbolBody = function enumSymbolBody(t) {
            return a.default.apply("EnumSymbolBody", arguments)
        }
        ,
        r.existsTypeAnnotation = function existsTypeAnnotation() {
            return a.default.apply("ExistsTypeAnnotation", arguments)
        }
        ,
        r.exportAllDeclaration = function exportAllDeclaration(t) {
            return a.default.apply("ExportAllDeclaration", arguments)
        }
        ,
        r.exportDefaultDeclaration = function exportDefaultDeclaration(t) {
            return a.default.apply("ExportDefaultDeclaration", arguments)
        }
        ,
        r.exportDefaultSpecifier = function exportDefaultSpecifier(t) {
            return a.default.apply("ExportDefaultSpecifier", arguments)
        }
        ,
        r.exportNamedDeclaration = function exportNamedDeclaration(t, r, i) {
            return a.default.apply("ExportNamedDeclaration", arguments)
        }
        ,
        r.exportNamespaceSpecifier = function exportNamespaceSpecifier(t) {
            return a.default.apply("ExportNamespaceSpecifier", arguments)
        }
        ,
        r.exportSpecifier = function exportSpecifier(t, r) {
            return a.default.apply("ExportSpecifier", arguments)
        }
        ,
        r.expressionStatement = function expressionStatement(t) {
            return a.default.apply("ExpressionStatement", arguments)
        }
        ,
        r.file = function file(t, r, i) {
            return a.default.apply("File", arguments)
        }
        ,
        r.forInStatement = function forInStatement(t, r, i) {
            return a.default.apply("ForInStatement", arguments)
        }
        ,
        r.forOfStatement = function forOfStatement(t, r, i, o) {
            return a.default.apply("ForOfStatement", arguments)
        }
        ,
        r.forStatement = function forStatement(t, r, i, o) {
            return a.default.apply("ForStatement", arguments)
        }
        ,
        r.functionDeclaration = function functionDeclaration(t, r, i, o, l) {
            return a.default.apply("FunctionDeclaration", arguments)
        }
        ,
        r.functionExpression = function functionExpression(t, r, i, o, l) {
            return a.default.apply("FunctionExpression", arguments)
        }
        ,
        r.functionTypeAnnotation = function functionTypeAnnotation(t, r, i, o) {
            return a.default.apply("FunctionTypeAnnotation", arguments)
        }
        ,
        r.functionTypeParam = function functionTypeParam(t, r) {
            return a.default.apply("FunctionTypeParam", arguments)
        }
        ,
        r.genericTypeAnnotation = function genericTypeAnnotation(t, r) {
            return a.default.apply("GenericTypeAnnotation", arguments)
        }
        ,
        r.identifier = function identifier(t) {
            return a.default.apply("Identifier", arguments)
        }
        ,
        r.ifStatement = function ifStatement(t, r, i) {
            return a.default.apply("IfStatement", arguments)
        }
        ,
        r.import = function _import() {
            return a.default.apply("Import", arguments)
        }
        ,
        r.importAttribute = function importAttribute(t, r) {
            return a.default.apply("ImportAttribute", arguments)
        }
        ,
        r.importDeclaration = function importDeclaration(t, r) {
            return a.default.apply("ImportDeclaration", arguments)
        }
        ,
        r.importDefaultSpecifier = function importDefaultSpecifier(t) {
            return a.default.apply("ImportDefaultSpecifier", arguments)
        }
        ,
        r.importNamespaceSpecifier = function importNamespaceSpecifier(t) {
            return a.default.apply("ImportNamespaceSpecifier", arguments)
        }
        ,
        r.importSpecifier = function importSpecifier(t, r) {
            return a.default.apply("ImportSpecifier", arguments)
        }
        ,
        r.indexedAccessType = function indexedAccessType(t, r) {
            return a.default.apply("IndexedAccessType", arguments)
        }
        ,
        r.inferredPredicate = function inferredPredicate() {
            return a.default.apply("InferredPredicate", arguments)
        }
        ,
        r.interfaceDeclaration = function interfaceDeclaration(t, r, i, o) {
            return a.default.apply("InterfaceDeclaration", arguments)
        }
        ,
        r.interfaceExtends = function interfaceExtends(t, r) {
            return a.default.apply("InterfaceExtends", arguments)
        }
        ,
        r.interfaceTypeAnnotation = function interfaceTypeAnnotation(t, r) {
            return a.default.apply("InterfaceTypeAnnotation", arguments)
        }
        ,
        r.interpreterDirective = function interpreterDirective(t) {
            return a.default.apply("InterpreterDirective", arguments)
        }
        ,
        r.intersectionTypeAnnotation = function intersectionTypeAnnotation(t) {
            return a.default.apply("IntersectionTypeAnnotation", arguments)
        }
        ,
        r.jSXAttribute = r.jsxAttribute = function jsxAttribute(t, r) {
            return a.default.apply("JSXAttribute", arguments)
        }
        ,
        r.jSXClosingElement = r.jsxClosingElement = function jsxClosingElement(t) {
            return a.default.apply("JSXClosingElement", arguments)
        }
        ,
        r.jSXClosingFragment = r.jsxClosingFragment = function jsxClosingFragment() {
            return a.default.apply("JSXClosingFragment", arguments)
        }
        ,
        r.jSXElement = r.jsxElement = function jsxElement(t, r, i, o) {
            return a.default.apply("JSXElement", arguments)
        }
        ,
        r.jSXEmptyExpression = r.jsxEmptyExpression = function jsxEmptyExpression() {
            return a.default.apply("JSXEmptyExpression", arguments)
        }
        ,
        r.jSXExpressionContainer = r.jsxExpressionContainer = function jsxExpressionContainer(t) {
            return a.default.apply("JSXExpressionContainer", arguments)
        }
        ,
        r.jSXFragment = r.jsxFragment = function jsxFragment(t, r, i) {
            return a.default.apply("JSXFragment", arguments)
        }
        ,
        r.jSXIdentifier = r.jsxIdentifier = function jsxIdentifier(t) {
            return a.default.apply("JSXIdentifier", arguments)
        }
        ,
        r.jSXMemberExpression = r.jsxMemberExpression = function jsxMemberExpression(t, r) {
            return a.default.apply("JSXMemberExpression", arguments)
        }
        ,
        r.jSXNamespacedName = r.jsxNamespacedName = function jsxNamespacedName(t, r) {
            return a.default.apply("JSXNamespacedName", arguments)
        }
        ,
        r.jSXOpeningElement = r.jsxOpeningElement = function jsxOpeningElement(t, r, i) {
            return a.default.apply("JSXOpeningElement", arguments)
        }
        ,
        r.jSXOpeningFragment = r.jsxOpeningFragment = function jsxOpeningFragment() {
            return a.default.apply("JSXOpeningFragment", arguments)
        }
        ,
        r.jSXSpreadAttribute = r.jsxSpreadAttribute = function jsxSpreadAttribute(t) {
            return a.default.apply("JSXSpreadAttribute", arguments)
        }
        ,
        r.jSXSpreadChild = r.jsxSpreadChild = function jsxSpreadChild(t) {
            return a.default.apply("JSXSpreadChild", arguments)
        }
        ,
        r.jSXText = r.jsxText = function jsxText(t) {
            return a.default.apply("JSXText", arguments)
        }
        ,
        r.labeledStatement = function labeledStatement(t, r) {
            return a.default.apply("LabeledStatement", arguments)
        }
        ,
        r.logicalExpression = function logicalExpression(t, r, i) {
            return a.default.apply("LogicalExpression", arguments)
        }
        ,
        r.memberExpression = function memberExpression(t, r, i, o) {
            return a.default.apply("MemberExpression", arguments)
        }
        ,
        r.metaProperty = function metaProperty(t, r) {
            return a.default.apply("MetaProperty", arguments)
        }
        ,
        r.mixedTypeAnnotation = function mixedTypeAnnotation() {
            return a.default.apply("MixedTypeAnnotation", arguments)
        }
        ,
        r.moduleExpression = function moduleExpression(t) {
            return a.default.apply("ModuleExpression", arguments)
        }
        ,
        r.newExpression = function newExpression(t, r) {
            return a.default.apply("NewExpression", arguments)
        }
        ,
        r.noop = function noop() {
            return a.default.apply("Noop", arguments)
        }
        ,
        r.nullLiteral = function nullLiteral() {
            return a.default.apply("NullLiteral", arguments)
        }
        ,
        r.nullLiteralTypeAnnotation = function nullLiteralTypeAnnotation() {
            return a.default.apply("NullLiteralTypeAnnotation", arguments)
        }
        ,
        r.nullableTypeAnnotation = function nullableTypeAnnotation(t) {
            return a.default.apply("NullableTypeAnnotation", arguments)
        }
        ,
        r.numberLiteral = function NumberLiteral(t) {
            return console.trace("The node type NumberLiteral has been renamed to NumericLiteral"),
            a.default.apply("NumberLiteral", arguments)
        }
        ,
        r.numberLiteralTypeAnnotation = function numberLiteralTypeAnnotation(t) {
            return a.default.apply("NumberLiteralTypeAnnotation", arguments)
        }
        ,
        r.numberTypeAnnotation = function numberTypeAnnotation() {
            return a.default.apply("NumberTypeAnnotation", arguments)
        }
        ,
        r.numericLiteral = function numericLiteral(t) {
            return a.default.apply("NumericLiteral", arguments)
        }
        ,
        r.objectExpression = function objectExpression(t) {
            return a.default.apply("ObjectExpression", arguments)
        }
        ,
        r.objectMethod = function objectMethod(t, r, i, o, l, u, p) {
            return a.default.apply("ObjectMethod", arguments)
        }
        ,
        r.objectPattern = function objectPattern(t) {
            return a.default.apply("ObjectPattern", arguments)
        }
        ,
        r.objectProperty = function objectProperty(t, r, i, o, l) {
            return a.default.apply("ObjectProperty", arguments)
        }
        ,
        r.objectTypeAnnotation = function objectTypeAnnotation(t, r, i, o, l) {
            return a.default.apply("ObjectTypeAnnotation", arguments)
        }
        ,
        r.objectTypeCallProperty = function objectTypeCallProperty(t) {
            return a.default.apply("ObjectTypeCallProperty", arguments)
        }
        ,
        r.objectTypeIndexer = function objectTypeIndexer(t, r, i, o) {
            return a.default.apply("ObjectTypeIndexer", arguments)
        }
        ,
        r.objectTypeInternalSlot = function objectTypeInternalSlot(t, r, i, o, l) {
            return a.default.apply("ObjectTypeInternalSlot", arguments)
        }
        ,
        r.objectTypeProperty = function objectTypeProperty(t, r, i) {
            return a.default.apply("ObjectTypeProperty", arguments)
        }
        ,
        r.objectTypeSpreadProperty = function objectTypeSpreadProperty(t) {
            return a.default.apply("ObjectTypeSpreadProperty", arguments)
        }
        ,
        r.opaqueType = function opaqueType(t, r, i, o) {
            return a.default.apply("OpaqueType", arguments)
        }
        ,
        r.optionalCallExpression = function optionalCallExpression(t, r, i) {
            return a.default.apply("OptionalCallExpression", arguments)
        }
        ,
        r.optionalIndexedAccessType = function optionalIndexedAccessType(t, r) {
            return a.default.apply("OptionalIndexedAccessType", arguments)
        }
        ,
        r.optionalMemberExpression = function optionalMemberExpression(t, r, i, o) {
            return a.default.apply("OptionalMemberExpression", arguments)
        }
        ,
        r.parenthesizedExpression = function parenthesizedExpression(t) {
            return a.default.apply("ParenthesizedExpression", arguments)
        }
        ,
        r.pipelineBareFunction = function pipelineBareFunction(t) {
            return a.default.apply("PipelineBareFunction", arguments)
        }
        ,
        r.pipelinePrimaryTopicReference = function pipelinePrimaryTopicReference() {
            return a.default.apply("PipelinePrimaryTopicReference", arguments)
        }
        ,
        r.pipelineTopicExpression = function pipelineTopicExpression(t) {
            return a.default.apply("PipelineTopicExpression", arguments)
        }
        ,
        r.placeholder = function placeholder(t, r) {
            return a.default.apply("Placeholder", arguments)
        }
        ,
        r.privateName = function privateName(t) {
            return a.default.apply("PrivateName", arguments)
        }
        ,
        r.program = function program(t, r, i, o) {
            return a.default.apply("Program", arguments)
        }
        ,
        r.qualifiedTypeIdentifier = function qualifiedTypeIdentifier(t, r) {
            return a.default.apply("QualifiedTypeIdentifier", arguments)
        }
        ,
        r.recordExpression = function recordExpression(t) {
            return a.default.apply("RecordExpression", arguments)
        }
        ,
        r.regExpLiteral = function regExpLiteral(t, r) {
            return a.default.apply("RegExpLiteral", arguments)
        }
        ,
        r.regexLiteral = function RegexLiteral(t, r) {
            return console.trace("The node type RegexLiteral has been renamed to RegExpLiteral"),
            a.default.apply("RegexLiteral", arguments)
        }
        ,
        r.restElement = function restElement(t) {
            return a.default.apply("RestElement", arguments)
        }
        ,
        r.restProperty = function RestProperty(t) {
            return console.trace("The node type RestProperty has been renamed to RestElement"),
            a.default.apply("RestProperty", arguments)
        }
        ,
        r.returnStatement = function returnStatement(t) {
            return a.default.apply("ReturnStatement", arguments)
        }
        ,
        r.sequenceExpression = function sequenceExpression(t) {
            return a.default.apply("SequenceExpression", arguments)
        }
        ,
        r.spreadElement = function spreadElement(t) {
            return a.default.apply("SpreadElement", arguments)
        }
        ,
        r.spreadProperty = function SpreadProperty(t) {
            return console.trace("The node type SpreadProperty has been renamed to SpreadElement"),
            a.default.apply("SpreadProperty", arguments)
        }
        ,
        r.staticBlock = function staticBlock(t) {
            return a.default.apply("StaticBlock", arguments)
        }
        ,
        r.stringLiteral = function stringLiteral(t) {
            return a.default.apply("StringLiteral", arguments)
        }
        ,
        r.stringLiteralTypeAnnotation = function stringLiteralTypeAnnotation(t) {
            return a.default.apply("StringLiteralTypeAnnotation", arguments)
        }
        ,
        r.stringTypeAnnotation = function stringTypeAnnotation() {
            return a.default.apply("StringTypeAnnotation", arguments)
        }
        ,
        r.super = function _super() {
            return a.default.apply("Super", arguments)
        }
        ,
        r.switchCase = function switchCase(t, r) {
            return a.default.apply("SwitchCase", arguments)
        }
        ,
        r.switchStatement = function switchStatement(t, r) {
            return a.default.apply("SwitchStatement", arguments)
        }
        ,
        r.symbolTypeAnnotation = function symbolTypeAnnotation() {
            return a.default.apply("SymbolTypeAnnotation", arguments)
        }
        ,
        r.taggedTemplateExpression = function taggedTemplateExpression(t, r) {
            return a.default.apply("TaggedTemplateExpression", arguments)
        }
        ,
        r.templateElement = function templateElement(t, r) {
            return a.default.apply("TemplateElement", arguments)
        }
        ,
        r.templateLiteral = function templateLiteral(t, r) {
            return a.default.apply("TemplateLiteral", arguments)
        }
        ,
        r.thisExpression = function thisExpression() {
            return a.default.apply("ThisExpression", arguments)
        }
        ,
        r.thisTypeAnnotation = function thisTypeAnnotation() {
            return a.default.apply("ThisTypeAnnotation", arguments)
        }
        ,
        r.throwStatement = function throwStatement(t) {
            return a.default.apply("ThrowStatement", arguments)
        }
        ,
        r.topicReference = function topicReference() {
            return a.default.apply("TopicReference", arguments)
        }
        ,
        r.tryStatement = function tryStatement(t, r, i) {
            return a.default.apply("TryStatement", arguments)
        }
        ,
        r.tSAnyKeyword = r.tsAnyKeyword = function tsAnyKeyword() {
            return a.default.apply("TSAnyKeyword", arguments)
        }
        ,
        r.tSArrayType = r.tsArrayType = function tsArrayType(t) {
            return a.default.apply("TSArrayType", arguments)
        }
        ,
        r.tSAsExpression = r.tsAsExpression = function tsAsExpression(t, r) {
            return a.default.apply("TSAsExpression", arguments)
        }
        ,
        r.tSBigIntKeyword = r.tsBigIntKeyword = function tsBigIntKeyword() {
            return a.default.apply("TSBigIntKeyword", arguments)
        }
        ,
        r.tSBooleanKeyword = r.tsBooleanKeyword = function tsBooleanKeyword() {
            return a.default.apply("TSBooleanKeyword", arguments)
        }
        ,
        r.tSCallSignatureDeclaration = r.tsCallSignatureDeclaration = function tsCallSignatureDeclaration(t, r, i) {
            return a.default.apply("TSCallSignatureDeclaration", arguments)
        }
        ,
        r.tSConditionalType = r.tsConditionalType = function tsConditionalType(t, r, i, o) {
            return a.default.apply("TSConditionalType", arguments)
        }
        ,
        r.tSConstructSignatureDeclaration = r.tsConstructSignatureDeclaration = function tsConstructSignatureDeclaration(t, r, i) {
            return a.default.apply("TSConstructSignatureDeclaration", arguments)
        }
        ,
        r.tSConstructorType = r.tsConstructorType = function tsConstructorType(t, r, i) {
            return a.default.apply("TSConstructorType", arguments)
        }
        ,
        r.tSDeclareFunction = r.tsDeclareFunction = function tsDeclareFunction(t, r, i, o) {
            return a.default.apply("TSDeclareFunction", arguments)
        }
        ,
        r.tSDeclareMethod = r.tsDeclareMethod = function tsDeclareMethod(t, r, i, o, l) {
            return a.default.apply("TSDeclareMethod", arguments)
        }
        ,
        r.tSEnumDeclaration = r.tsEnumDeclaration = function tsEnumDeclaration(t, r) {
            return a.default.apply("TSEnumDeclaration", arguments)
        }
        ,
        r.tSEnumMember = r.tsEnumMember = function tsEnumMember(t, r) {
            return a.default.apply("TSEnumMember", arguments)
        }
        ,
        r.tSExportAssignment = r.tsExportAssignment = function tsExportAssignment(t) {
            return a.default.apply("TSExportAssignment", arguments)
        }
        ,
        r.tSExpressionWithTypeArguments = r.tsExpressionWithTypeArguments = function tsExpressionWithTypeArguments(t, r) {
            return a.default.apply("TSExpressionWithTypeArguments", arguments)
        }
        ,
        r.tSExternalModuleReference = r.tsExternalModuleReference = function tsExternalModuleReference(t) {
            return a.default.apply("TSExternalModuleReference", arguments)
        }
        ,
        r.tSFunctionType = r.tsFunctionType = function tsFunctionType(t, r, i) {
            return a.default.apply("TSFunctionType", arguments)
        }
        ,
        r.tSImportEqualsDeclaration = r.tsImportEqualsDeclaration = function tsImportEqualsDeclaration(t, r) {
            return a.default.apply("TSImportEqualsDeclaration", arguments)
        }
        ,
        r.tSImportType = r.tsImportType = function tsImportType(t, r, i) {
            return a.default.apply("TSImportType", arguments)
        }
        ,
        r.tSIndexSignature = r.tsIndexSignature = function tsIndexSignature(t, r) {
            return a.default.apply("TSIndexSignature", arguments)
        }
        ,
        r.tSIndexedAccessType = r.tsIndexedAccessType = function tsIndexedAccessType(t, r) {
            return a.default.apply("TSIndexedAccessType", arguments)
        }
        ,
        r.tSInferType = r.tsInferType = function tsInferType(t) {
            return a.default.apply("TSInferType", arguments)
        }
        ,
        r.tSInterfaceBody = r.tsInterfaceBody = function tsInterfaceBody(t) {
            return a.default.apply("TSInterfaceBody", arguments)
        }
        ,
        r.tSInterfaceDeclaration = r.tsInterfaceDeclaration = function tsInterfaceDeclaration(t, r, i, o) {
            return a.default.apply("TSInterfaceDeclaration", arguments)
        }
        ,
        r.tSIntersectionType = r.tsIntersectionType = function tsIntersectionType(t) {
            return a.default.apply("TSIntersectionType", arguments)
        }
        ,
        r.tSIntrinsicKeyword = r.tsIntrinsicKeyword = function tsIntrinsicKeyword() {
            return a.default.apply("TSIntrinsicKeyword", arguments)
        }
        ,
        r.tSLiteralType = r.tsLiteralType = function tsLiteralType(t) {
            return a.default.apply("TSLiteralType", arguments)
        }
        ,
        r.tSMappedType = r.tsMappedType = function tsMappedType(t, r, i) {
            return a.default.apply("TSMappedType", arguments)
        }
        ,
        r.tSMethodSignature = r.tsMethodSignature = function tsMethodSignature(t, r, i, o) {
            return a.default.apply("TSMethodSignature", arguments)
        }
        ,
        r.tSModuleBlock = r.tsModuleBlock = function tsModuleBlock(t) {
            return a.default.apply("TSModuleBlock", arguments)
        }
        ,
        r.tSModuleDeclaration = r.tsModuleDeclaration = function tsModuleDeclaration(t, r) {
            return a.default.apply("TSModuleDeclaration", arguments)
        }
        ,
        r.tSNamedTupleMember = r.tsNamedTupleMember = function tsNamedTupleMember(t, r, i) {
            return a.default.apply("TSNamedTupleMember", arguments)
        }
        ,
        r.tSNamespaceExportDeclaration = r.tsNamespaceExportDeclaration = function tsNamespaceExportDeclaration(t) {
            return a.default.apply("TSNamespaceExportDeclaration", arguments)
        }
        ,
        r.tSNeverKeyword = r.tsNeverKeyword = function tsNeverKeyword() {
            return a.default.apply("TSNeverKeyword", arguments)
        }
        ,
        r.tSNonNullExpression = r.tsNonNullExpression = function tsNonNullExpression(t) {
            return a.default.apply("TSNonNullExpression", arguments)
        }
        ,
        r.tSNullKeyword = r.tsNullKeyword = function tsNullKeyword() {
            return a.default.apply("TSNullKeyword", arguments)
        }
        ,
        r.tSNumberKeyword = r.tsNumberKeyword = function tsNumberKeyword() {
            return a.default.apply("TSNumberKeyword", arguments)
        }
        ,
        r.tSObjectKeyword = r.tsObjectKeyword = function tsObjectKeyword() {
            return a.default.apply("TSObjectKeyword", arguments)
        }
        ,
        r.tSOptionalType = r.tsOptionalType = function tsOptionalType(t) {
            return a.default.apply("TSOptionalType", arguments)
        }
        ,
        r.tSParameterProperty = r.tsParameterProperty = function tsParameterProperty(t) {
            return a.default.apply("TSParameterProperty", arguments)
        }
        ,
        r.tSParenthesizedType = r.tsParenthesizedType = function tsParenthesizedType(t) {
            return a.default.apply("TSParenthesizedType", arguments)
        }
        ,
        r.tSPropertySignature = r.tsPropertySignature = function tsPropertySignature(t, r, i) {
            return a.default.apply("TSPropertySignature", arguments)
        }
        ,
        r.tSQualifiedName = r.tsQualifiedName = function tsQualifiedName(t, r) {
            return a.default.apply("TSQualifiedName", arguments)
        }
        ,
        r.tSRestType = r.tsRestType = function tsRestType(t) {
            return a.default.apply("TSRestType", arguments)
        }
        ,
        r.tSStringKeyword = r.tsStringKeyword = function tsStringKeyword() {
            return a.default.apply("TSStringKeyword", arguments)
        }
        ,
        r.tSSymbolKeyword = r.tsSymbolKeyword = function tsSymbolKeyword() {
            return a.default.apply("TSSymbolKeyword", arguments)
        }
        ,
        r.tSThisType = r.tsThisType = function tsThisType() {
            return a.default.apply("TSThisType", arguments)
        }
        ,
        r.tSTupleType = r.tsTupleType = function tsTupleType(t) {
            return a.default.apply("TSTupleType", arguments)
        }
        ,
        r.tSTypeAliasDeclaration = r.tsTypeAliasDeclaration = function tsTypeAliasDeclaration(t, r, i) {
            return a.default.apply("TSTypeAliasDeclaration", arguments)
        }
        ,
        r.tSTypeAnnotation = r.tsTypeAnnotation = function tsTypeAnnotation(t) {
            return a.default.apply("TSTypeAnnotation", arguments)
        }
        ,
        r.tSTypeAssertion = r.tsTypeAssertion = function tsTypeAssertion(t, r) {
            return a.default.apply("TSTypeAssertion", arguments)
        }
        ,
        r.tSTypeLiteral = r.tsTypeLiteral = function tsTypeLiteral(t) {
            return a.default.apply("TSTypeLiteral", arguments)
        }
        ,
        r.tSTypeOperator = r.tsTypeOperator = function tsTypeOperator(t) {
            return a.default.apply("TSTypeOperator", arguments)
        }
        ,
        r.tSTypeParameter = r.tsTypeParameter = function tsTypeParameter(t, r, i) {
            return a.default.apply("TSTypeParameter", arguments)
        }
        ,
        r.tSTypeParameterDeclaration = r.tsTypeParameterDeclaration = function tsTypeParameterDeclaration(t) {
            return a.default.apply("TSTypeParameterDeclaration", arguments)
        }
        ,
        r.tSTypeParameterInstantiation = r.tsTypeParameterInstantiation = function tsTypeParameterInstantiation(t) {
            return a.default.apply("TSTypeParameterInstantiation", arguments)
        }
        ,
        r.tSTypePredicate = r.tsTypePredicate = function tsTypePredicate(t, r, i) {
            return a.default.apply("TSTypePredicate", arguments)
        }
        ,
        r.tSTypeQuery = r.tsTypeQuery = function tsTypeQuery(t) {
            return a.default.apply("TSTypeQuery", arguments)
        }
        ,
        r.tSTypeReference = r.tsTypeReference = function tsTypeReference(t, r) {
            return a.default.apply("TSTypeReference", arguments)
        }
        ,
        r.tSUndefinedKeyword = r.tsUndefinedKeyword = function tsUndefinedKeyword() {
            return a.default.apply("TSUndefinedKeyword", arguments)
        }
        ,
        r.tSUnionType = r.tsUnionType = function tsUnionType(t) {
            return a.default.apply("TSUnionType", arguments)
        }
        ,
        r.tSUnknownKeyword = r.tsUnknownKeyword = function tsUnknownKeyword() {
            return a.default.apply("TSUnknownKeyword", arguments)
        }
        ,
        r.tSVoidKeyword = r.tsVoidKeyword = function tsVoidKeyword() {
            return a.default.apply("TSVoidKeyword", arguments)
        }
        ,
        r.tupleExpression = function tupleExpression(t) {
            return a.default.apply("TupleExpression", arguments)
        }
        ,
        r.tupleTypeAnnotation = function tupleTypeAnnotation(t) {
            return a.default.apply("TupleTypeAnnotation", arguments)
        }
        ,
        r.typeAlias = function typeAlias(t, r, i) {
            return a.default.apply("TypeAlias", arguments)
        }
        ,
        r.typeAnnotation = function typeAnnotation(t) {
            return a.default.apply("TypeAnnotation", arguments)
        }
        ,
        r.typeCastExpression = function typeCastExpression(t, r) {
            return a.default.apply("TypeCastExpression", arguments)
        }
        ,
        r.typeParameter = function typeParameter(t, r, i) {
            return a.default.apply("TypeParameter", arguments)
        }
        ,
        r.typeParameterDeclaration = function typeParameterDeclaration(t) {
            return a.default.apply("TypeParameterDeclaration", arguments)
        }
        ,
        r.typeParameterInstantiation = function typeParameterInstantiation(t) {
            return a.default.apply("TypeParameterInstantiation", arguments)
        }
        ,
        r.typeofTypeAnnotation = function typeofTypeAnnotation(t) {
            return a.default.apply("TypeofTypeAnnotation", arguments)
        }
        ,
        r.unaryExpression = function unaryExpression(t, r, i) {
            return a.default.apply("UnaryExpression", arguments)
        }
        ,
        r.unionTypeAnnotation = function unionTypeAnnotation(t) {
            return a.default.apply("UnionTypeAnnotation", arguments)
        }
        ,
        r.updateExpression = function updateExpression(t, r, i) {
            return a.default.apply("UpdateExpression", arguments)
        }
        ,
        r.v8IntrinsicIdentifier = function v8IntrinsicIdentifier(t) {
            return a.default.apply("V8IntrinsicIdentifier", arguments)
        }
        ,
        r.variableDeclaration = function variableDeclaration(t, r) {
            return a.default.apply("VariableDeclaration", arguments)
        }
        ,
        r.variableDeclarator = function variableDeclarator(t, r) {
            return a.default.apply("VariableDeclarator", arguments)
        }
        ,
        r.variance = function variance(t) {
            return a.default.apply("Variance", arguments)
        }
        ,
        r.voidTypeAnnotation = function voidTypeAnnotation() {
            return a.default.apply("VoidTypeAnnotation", arguments)
        }
        ,
        r.whileStatement = function whileStatement(t, r) {
            return a.default.apply("WhileStatement", arguments)
        }
        ,
        r.withStatement = function withStatement(t, r) {
            return a.default.apply("WithStatement", arguments)
        }
        ,
        r.yieldExpression = function yieldExpression(t, r) {
            return a.default.apply("YieldExpression", arguments)
        }
        ;
        var a = i("KZrR")
    },
    "63rZ": function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function isBlockScoped(t) {
            return (0,
            a.isFunctionDeclaration)(t) || (0,
            a.isClassDeclaration)(t) || (0,
            o.default)(t)
        }
        ;
        var a = i("FUES")
          , o = i("9gGh")
    },
    "6tYi": function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function removeTypeDuplicates(t) {
            const r = {}
              , i = {}
              , o = new Set
              , l = [];
            for (let u = 0; u < t.length; u++) {
                const p = t[u];
                if (p && !(l.indexOf(p) >= 0)) {
                    if ((0,
                    a.isAnyTypeAnnotation)(p))
                        return [p];
                    if ((0,
                    a.isFlowBaseAnnotation)(p))
                        i[p.type] = p;
                    else if ((0,
                    a.isUnionTypeAnnotation)(p))
                        o.has(p.types) || (t = t.concat(p.types),
                        o.add(p.types));
                    else if ((0,
                    a.isGenericTypeAnnotation)(p)) {
                        const t = getQualifiedName(p.id);
                        if (r[t]) {
                            let i = r[t];
                            i.typeParameters ? p.typeParameters && (i.typeParameters.params = removeTypeDuplicates(i.typeParameters.params.concat(p.typeParameters.params))) : i = p.typeParameters
                        } else
                            r[t] = p
                    } else
                        l.push(p)
                }
            }
            for (const t of Object.keys(i))
                l.push(i[t]);
            for (const t of Object.keys(r))
                l.push(r[t]);
            return l
        }
        ;
        var a = i("xIU+");
        function getQualifiedName(t) {
            return (0,
            a.isIdentifier)(t) ? t.name : `${t.id.name}.${getQualifiedName(t.qualification)}`
        }
    },
    "71/9": function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function cloneWithoutLoc(t) {
            return (0,
            a.default)(t, !1, !0)
        }
        ;
        var a = i("v3g0")
    },
    "782H": function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function toSequenceExpression(t, r) {
            if (null == t || !t.length)
                return;
            var i = []
              , o = (0,
            a.default)(t, r, i);
            if (!o)
                return;
            for (var l = 0, u = i; l < u.length; l++) {
                var p = u[l];
                r.push(p)
            }
            return o
        }
        ;
        var a = i("2HQm")
    },
    "7ePq": function(t, r, i) {
        "use strict";
        (function(t) {
            var a = i("TqRt")
              , o = a(i("RIqP"))
              , l = a(i("cDf5"));
            function _createForOfIteratorHelper(t, r) {
                var i = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
                if (!i) {
                    if (Array.isArray(t) || (i = function _unsupportedIterableToArray(t, r) {
                        if (!t)
                            return;
                        if ("string" == typeof t)
                            return _arrayLikeToArray(t, r);
                        var i = Object.prototype.toString.call(t).slice(8, -1);
                        "Object" === i && t.constructor && (i = t.constructor.name);
                        if ("Map" === i || "Set" === i)
                            return Array.from(t);
                        if ("Arguments" === i || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i))
                            return _arrayLikeToArray(t, r)
                    }(t)) || r && t && "number" == typeof t.length) {
                        i && (t = i);
                        var a = 0
                          , o = function F() {};
                        return {
                            s: o,
                            n: function n() {
                                return a >= t.length ? {
                                    done: !0
                                } : {
                                    done: !1,
                                    value: t[a++]
                                }
                            },
                            e: function e(t) {
                                throw t
                            },
                            f: o
                        }
                    }
                    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                }
                var l, u = !0, p = !1;
                return {
                    s: function s() {
                        i = i.call(t)
                    },
                    n: function n() {
                        var t = i.next();
                        return u = t.done,
                        t
                    },
                    e: function e(t) {
                        p = !0,
                        l = t
                    },
                    f: function f() {
                        try {
                            u || null == i.return || i.return()
                        } finally {
                            if (p)
                                throw l
                        }
                    }
                }
            }
            function _arrayLikeToArray(t, r) {
                (null == r || r > t.length) && (r = t.length);
                for (var i = 0, a = new Array(r); i < r; i++)
                    a[i] = t[i];
                return a
            }
            Object.defineProperty(r, "__esModule", {
                value: !0
            }),
            r.validate = validate,
            r.typeIs = typeIs,
            r.validateType = function validateType(t) {
                return validate(typeIs(t))
            }
            ,
            r.validateOptional = function validateOptional(t) {
                return {
                    validate: t,
                    optional: !0
                }
            }
            ,
            r.validateOptionalType = function validateOptionalType(t) {
                return {
                    validate: typeIs(t),
                    optional: !0
                }
            }
            ,
            r.arrayOf = arrayOf,
            r.arrayOfType = arrayOfType,
            r.validateArrayOfType = function validateArrayOfType(t) {
                return validate(arrayOfType(t))
            }
            ,
            r.assertEach = assertEach,
            r.assertOneOf = function assertOneOf() {
                for (var t = arguments.length, r = new Array(t), i = 0; i < t; i++)
                    r[i] = arguments[i];
                function validate(t, i, a) {
                    if (r.indexOf(a) < 0)
                        throw new TypeError("Property ".concat(i, " expected value to be one of ").concat(JSON.stringify(r), " but got ").concat(JSON.stringify(a)))
                }
                return validate.oneOf = r,
                validate
            }
            ,
            r.assertNodeType = assertNodeType,
            r.assertNodeOrValueType = function assertNodeOrValueType() {
                for (var t = arguments.length, r = new Array(t), i = 0; i < t; i++)
                    r[i] = arguments[i];
                function validate(t, i, a) {
                    var o, l = _createForOfIteratorHelper(r);
                    try {
                        for (l.s(); !(o = l.n()).done; ) {
                            var c = o.value;
                            if (getType(a) === c || (0,
                            u.default)(c, a))
                                return void (0,
                                p.validateChild)(t, i, a)
                        }
                    } catch (t) {
                        l.e(t)
                    } finally {
                        l.f()
                    }
                    throw new TypeError("Property ".concat(i, " of ").concat(t.type, " expected node to be of a type ").concat(JSON.stringify(r), " but instead got ").concat(JSON.stringify(null == a ? void 0 : a.type)))
                }
                return validate.oneOfNodeOrValueTypes = r,
                validate
            }
            ,
            r.assertValueType = assertValueType,
            r.assertShape = function assertShape(t) {
                function validate(r, i, a) {
                    for (var o = [], l = 0, u = Object.keys(t); l < u.length; l++) {
                        var c = u[l];
                        try {
                            (0,
                            p.validateField)(r, c, a[c], t[c])
                        } catch (t) {
                            if (t instanceof TypeError) {
                                o.push(t.message);
                                continue
                            }
                            throw t
                        }
                    }
                    if (o.length)
                        throw new TypeError("Property ".concat(i, " of ").concat(r.type, " expected to have the following:\n").concat(o.join("\n")))
                }
                return validate.shapeOf = t,
                validate
            }
            ,
            r.assertOptionalChainStart = function assertOptionalChainStart() {
                return function validate(t) {
                    for (var r, i = t; t; ) {
                        var a = i.type;
                        if ("OptionalCallExpression" !== a) {
                            if ("OptionalMemberExpression" !== a)
                                break;
                            if (i.optional)
                                return;
                            i = i.object
                        } else {
                            if (i.optional)
                                return;
                            i = i.callee
                        }
                    }
                    throw new TypeError("Non-optional ".concat(t.type, " must chain from an optional OptionalMemberExpression or OptionalCallExpression. Found chain from ").concat(null == (r = i) ? void 0 : r.type))
                }
            }
            ,
            r.chain = chain,
            r.default = function defineType(t) {
                var r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}
                  , i = r.inherits && v[r.inherits] || {}
                  , a = r.fields;
                if (!a && (a = {},
                i.fields)) {
                    var o, u = Object.getOwnPropertyNames(i.fields), p = _createForOfIteratorHelper(u);
                    try {
                        for (p.s(); !(o = p.n()).done; ) {
                            var E = o.value
                              , P = i.fields[E]
                              , x = P.default;
                            if (Array.isArray(x) ? x.length > 0 : x && "object" === (0,
                            l.default)(x))
                                throw new Error("field defaults can only be primitives or empty arrays currently");
                            a[E] = {
                                default: Array.isArray(x) ? [] : x,
                                optional: P.optional,
                                validate: P.validate
                            }
                        }
                    } catch (t) {
                        p.e(t)
                    } finally {
                        p.f()
                    }
                }
                for (var A = r.visitor || i.visitor || [], O = r.aliases || i.aliases || [], I = r.builder || i.builder || r.visitor || [], w = 0, C = Object.keys(r); w < C.length; w++) {
                    var N = C[w];
                    if (-1 === g.indexOf(N))
                        throw new Error('Unknown type option "'.concat(N, '" on ').concat(t))
                }
                r.deprecatedAlias && (T[r.deprecatedAlias] = t);
                var D, _ = _createForOfIteratorHelper(A.concat(I));
                try {
                    for (_.s(); !(D = _.n()).done; ) {
                        var L = D.value;
                        a[L] = a[L] || {}
                    }
                } catch (t) {
                    _.e(t)
                } finally {
                    _.f()
                }
                for (var k = 0, M = Object.keys(a); k < M.length; k++) {
                    var j = M[k]
                      , B = a[j];
                    void 0 !== B.default && -1 === I.indexOf(j) && (B.optional = !0),
                    void 0 === B.default ? B.default = null : B.validate || null == B.default || (B.validate = assertValueType(getType(B.default)));
                    for (var R = 0, K = Object.keys(B); R < K.length; R++) {
                        var V = K[R];
                        if (-1 === b.indexOf(V))
                            throw new Error('Unknown field key "'.concat(V, '" on ').concat(t, ".").concat(j))
                    }
                }
                c[t] = r.visitor = A,
                m[t] = r.builder = I,
                h[t] = r.fields = a,
                d[t] = r.aliases = O,
                O.forEach((function(r) {
                    y[r] = y[r] || [],
                    y[r].push(t)
                }
                )),
                r.validate && (S[t] = r.validate);
                v[t] = r
            }
            ,
            r.NODE_PARENT_VALIDATIONS = r.DEPRECATED_KEYS = r.BUILDER_KEYS = r.NODE_FIELDS = r.FLIPPED_ALIAS_KEYS = r.ALIAS_KEYS = r.VISITOR_KEYS = void 0;
            var u = i("0G7A")
              , p = i("kmK0")
              , c = {};
            r.VISITOR_KEYS = c;
            var d = {};
            r.ALIAS_KEYS = d;
            var y = {};
            r.FLIPPED_ALIAS_KEYS = y;
            var h = {};
            r.NODE_FIELDS = h;
            var m = {};
            r.BUILDER_KEYS = m;
            var T = {};
            r.DEPRECATED_KEYS = T;
            var S = {};
            function getType(t) {
                return Array.isArray(t) ? "array" : null === t ? "null" : (0,
                l.default)(t)
            }
            function validate(t) {
                return {
                    validate: t
                }
            }
            function typeIs(t) {
                return "string" == typeof t ? assertNodeType(t) : assertNodeType.apply(void 0, (0,
                o.default)(t))
            }
            function arrayOf(t) {
                return chain(assertValueType("array"), assertEach(t))
            }
            function arrayOfType(t) {
                return arrayOf(typeIs(t))
            }
            function assertEach(r) {
                function validator(i, a, o) {
                    if (Array.isArray(o))
                        for (var l = 0; l < o.length; l++) {
                            var u = "".concat(a, "[").concat(l, "]")
                              , c = o[l];
                            r(i, u, c),
                            t.env.BABEL_TYPES_8_BREAKING && (0,
                            p.validateChild)(i, u, c)
                        }
                }
                return validator.each = r,
                validator
            }
            function assertNodeType() {
                for (var t = arguments.length, r = new Array(t), i = 0; i < t; i++)
                    r[i] = arguments[i];
                function validate(t, i, a) {
                    var o, l = _createForOfIteratorHelper(r);
                    try {
                        for (l.s(); !(o = l.n()).done; ) {
                            var c = o.value;
                            if ((0,
                            u.default)(c, a))
                                return void (0,
                                p.validateChild)(t, i, a)
                        }
                    } catch (t) {
                        l.e(t)
                    } finally {
                        l.f()
                    }
                    throw new TypeError("Property ".concat(i, " of ").concat(t.type, " expected node to be of a type ").concat(JSON.stringify(r), " but instead got ").concat(JSON.stringify(null == a ? void 0 : a.type)))
                }
                return validate.oneOfNodeTypes = r,
                validate
            }
            function assertValueType(t) {
                function validate(r, i, a) {
                    if (!(getType(a) === t))
                        throw new TypeError("Property ".concat(i, " expected type of ").concat(t, " but got ").concat(getType(a)))
                }
                return validate.type = t,
                validate
            }
            function chain() {
                for (var t = arguments.length, r = new Array(t), i = 0; i < t; i++)
                    r[i] = arguments[i];
                function validate() {
                    var t, i = _createForOfIteratorHelper(r);
                    try {
                        for (i.s(); !(t = i.n()).done; ) {
                            var a = t.value;
                            a.apply(void 0, arguments)
                        }
                    } catch (t) {
                        i.e(t)
                    } finally {
                        i.f()
                    }
                }
                if (validate.chainOf = r,
                r.length >= 2 && "type"in r[0] && "array" === r[0].type && !("each"in r[1]))
                    throw new Error('An assertValueType("array") validator can only be followed by an assertEach(...) validator.');
                return validate
            }
            r.NODE_PARENT_VALIDATIONS = S;
            var g = ["aliases", "builder", "deprecatedAlias", "fields", "inherits", "visitor", "validate"]
              , b = ["default", "optional", "validate"];
            var v = {}
        }
        ).call(this, i("8oxB"))
    },
    "89jI": function(t, r, i) {
        "use strict";
        var a = i("YSHT").VISITOR_KEYS
          , o = i("Z6Aa").KEYS;
        t.exports = Object.assign({
            Literal: o.Literal,
            MethodDefinition: ["decorators"].concat(o.MethodDefinition),
            Property: ["decorators"].concat(o.Property)
        }, a)
    },
    "8PAM": function(t, r, i) {
        "use strict";
        r.parse = function(t, i) {
            return r.parseForESLint(t, i).ast
        }
        ,
        r.parseForESLint = function(t, r) {
            return (r = r || {}).ecmaVersion = r.ecmaVersion || 2018,
            r.sourceType = r.sourceType || "module",
            r.allowImportExportEverywhere = r.allowImportExportEverywhere || !1,
            r.eslintVisitorKeys && r.eslintScopeManager ? i("r+0P")(t, r) : {
                ast: i("Y0za")(t, r)
            }
        }
        ,
        r.parseNoPatch = function(t, r) {
            return i("PUqz")(t, r)
        }
    },
    "8YYJ": function(t, r, i) {
        "use strict";
        function _createForOfIteratorHelper(t, r) {
            var i = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
            if (!i) {
                if (Array.isArray(t) || (i = function _unsupportedIterableToArray(t, r) {
                    if (!t)
                        return;
                    if ("string" == typeof t)
                        return _arrayLikeToArray(t, r);
                    var i = Object.prototype.toString.call(t).slice(8, -1);
                    "Object" === i && t.constructor && (i = t.constructor.name);
                    if ("Map" === i || "Set" === i)
                        return Array.from(t);
                    if ("Arguments" === i || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i))
                        return _arrayLikeToArray(t, r)
                }(t)) || r && t && "number" == typeof t.length) {
                    i && (t = i);
                    var a = 0
                      , o = function F() {};
                    return {
                        s: o,
                        n: function n() {
                            return a >= t.length ? {
                                done: !0
                            } : {
                                done: !1,
                                value: t[a++]
                            }
                        },
                        e: function e(t) {
                            throw t
                        },
                        f: o
                    }
                }
                throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
            }
            var l, u = !0, p = !1;
            return {
                s: function s() {
                    i = i.call(t)
                },
                n: function n() {
                    var t = i.next();
                    return u = t.done,
                    t
                },
                e: function e(t) {
                    p = !0,
                    l = t
                },
                f: function f() {
                    try {
                        u || null == i.return || i.return()
                    } finally {
                        if (p)
                            throw l
                    }
                }
            }
        }
        function _arrayLikeToArray(t, r) {
            (null == r || r > t.length) && (r = t.length);
            for (var i = 0, a = new Array(r); i < r; i++)
                a[i] = t[i];
            return a
        }
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function traverseFast(t, r, i) {
            if (!t)
                return;
            var o = a.VISITOR_KEYS[t.type];
            if (!o)
                return;
            r(t, i = i || {});
            var l, u = _createForOfIteratorHelper(o);
            try {
                for (u.s(); !(l = u.n()).done; ) {
                    var p = l.value
                      , c = t[p];
                    if (Array.isArray(c)) {
                        var d, y = _createForOfIteratorHelper(c);
                        try {
                            for (y.s(); !(d = y.n()).done; ) {
                                var h = d.value;
                                traverseFast(h, r, i)
                            }
                        } catch (t) {
                            y.e(t)
                        } finally {
                            y.f()
                        }
                    } else
                        traverseFast(c, r, i)
                }
            } catch (t) {
                u.e(t)
            } finally {
                u.f()
            }
        }
        ;
        var a = i("Resm")
    },
    "8iKV": function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function inheritInnerComments(t, r) {
            (0,
            a.default)("innerComments", t, r)
        }
        ;
        var a = i("Df4y")
    },
    "8o0k": function(t, r, i) {
        "use strict";
        (function(t) {
            Object.defineProperty(r, "__esModule", {
                value: !0
            }),
            r.patternLikeCommon = r.functionTypeAnnotationCommon = r.functionDeclarationCommon = r.functionCommon = r.classMethodOrPropertyCommon = r.classMethodOrDeclareMethodCommon = void 0;
            var a = i("F3vi")
              , o = i("ucPi")
              , l = i("A27I")
              , u = i("kEZX")
              , p = i("V97+");
            const c = (0,
            p.defineAliasedType)("Standardized");
            c("ArrayExpression", {
                fields: {
                    elements: {
                        validate: (0,
                        p.chain)((0,
                        p.assertValueType)("array"), (0,
                        p.assertEach)((0,
                        p.assertNodeOrValueType)("null", "Expression", "SpreadElement"))),
                        default: t.env.BABEL_TYPES_8_BREAKING ? void 0 : []
                    }
                },
                visitor: ["elements"],
                aliases: ["Expression"]
            }),
            c("AssignmentExpression", {
                fields: {
                    operator: {
                        validate: function() {
                            if (!t.env.BABEL_TYPES_8_BREAKING)
                                return (0,
                                p.assertValueType)("string");
                            const r = (0,
                            p.assertOneOf)(...u.ASSIGNMENT_OPERATORS)
                              , i = (0,
                            p.assertOneOf)("=");
                            return function(t, o, l) {
                                ((0,
                                a.default)("Pattern", t.left) ? i : r)(t, o, l)
                            }
                        }()
                    },
                    left: {
                        validate: t.env.BABEL_TYPES_8_BREAKING ? (0,
                        p.assertNodeType)("Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern") : (0,
                        p.assertNodeType)("LVal")
                    },
                    right: {
                        validate: (0,
                        p.assertNodeType)("Expression")
                    }
                },
                builder: ["operator", "left", "right"],
                visitor: ["left", "right"],
                aliases: ["Expression"]
            }),
            c("BinaryExpression", {
                builder: ["operator", "left", "right"],
                fields: {
                    operator: {
                        validate: (0,
                        p.assertOneOf)(...u.BINARY_OPERATORS)
                    },
                    left: {
                        validate: function() {
                            const t = (0,
                            p.assertNodeType)("Expression")
                              , r = (0,
                            p.assertNodeType)("Expression", "PrivateName")
                              , validator = function(i, a, o) {
                                ("in" === i.operator ? r : t)(i, a, o)
                            };
                            return validator.oneOfNodeTypes = ["Expression", "PrivateName"],
                            validator
                        }()
                    },
                    right: {
                        validate: (0,
                        p.assertNodeType)("Expression")
                    }
                },
                visitor: ["left", "right"],
                aliases: ["Binary", "Expression"]
            }),
            c("InterpreterDirective", {
                builder: ["value"],
                fields: {
                    value: {
                        validate: (0,
                        p.assertValueType)("string")
                    }
                }
            }),
            c("Directive", {
                visitor: ["value"],
                fields: {
                    value: {
                        validate: (0,
                        p.assertNodeType)("DirectiveLiteral")
                    }
                }
            }),
            c("DirectiveLiteral", {
                builder: ["value"],
                fields: {
                    value: {
                        validate: (0,
                        p.assertValueType)("string")
                    }
                }
            }),
            c("BlockStatement", {
                builder: ["body", "directives"],
                visitor: ["directives", "body"],
                fields: {
                    directives: {
                        validate: (0,
                        p.chain)((0,
                        p.assertValueType)("array"), (0,
                        p.assertEach)((0,
                        p.assertNodeType)("Directive"))),
                        default: []
                    },
                    body: {
                        validate: (0,
                        p.chain)((0,
                        p.assertValueType)("array"), (0,
                        p.assertEach)((0,
                        p.assertNodeType)("Statement")))
                    }
                },
                aliases: ["Scopable", "BlockParent", "Block", "Statement"]
            }),
            c("BreakStatement", {
                visitor: ["label"],
                fields: {
                    label: {
                        validate: (0,
                        p.assertNodeType)("Identifier"),
                        optional: !0
                    }
                },
                aliases: ["Statement", "Terminatorless", "CompletionStatement"]
            }),
            c("CallExpression", {
                visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
                builder: ["callee", "arguments"],
                aliases: ["Expression"],
                fields: Object.assign({
                    callee: {
                        validate: (0,
                        p.assertNodeType)("Expression", "V8IntrinsicIdentifier")
                    },
                    arguments: {
                        validate: (0,
                        p.chain)((0,
                        p.assertValueType)("array"), (0,
                        p.assertEach)((0,
                        p.assertNodeType)("Expression", "SpreadElement", "JSXNamespacedName", "ArgumentPlaceholder")))
                    }
                }, t.env.BABEL_TYPES_8_BREAKING ? {} : {
                    optional: {
                        validate: (0,
                        p.assertOneOf)(!0, !1),
                        optional: !0
                    }
                }, {
                    typeArguments: {
                        validate: (0,
                        p.assertNodeType)("TypeParameterInstantiation"),
                        optional: !0
                    },
                    typeParameters: {
                        validate: (0,
                        p.assertNodeType)("TSTypeParameterInstantiation"),
                        optional: !0
                    }
                })
            }),
            c("CatchClause", {
                visitor: ["param", "body"],
                fields: {
                    param: {
                        validate: (0,
                        p.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern"),
                        optional: !0
                    },
                    body: {
                        validate: (0,
                        p.assertNodeType)("BlockStatement")
                    }
                },
                aliases: ["Scopable", "BlockParent"]
            }),
            c("ConditionalExpression", {
                visitor: ["test", "consequent", "alternate"],
                fields: {
                    test: {
                        validate: (0,
                        p.assertNodeType)("Expression")
                    },
                    consequent: {
                        validate: (0,
                        p.assertNodeType)("Expression")
                    },
                    alternate: {
                        validate: (0,
                        p.assertNodeType)("Expression")
                    }
                },
                aliases: ["Expression", "Conditional"]
            }),
            c("ContinueStatement", {
                visitor: ["label"],
                fields: {
                    label: {
                        validate: (0,
                        p.assertNodeType)("Identifier"),
                        optional: !0
                    }
                },
                aliases: ["Statement", "Terminatorless", "CompletionStatement"]
            }),
            c("DebuggerStatement", {
                aliases: ["Statement"]
            }),
            c("DoWhileStatement", {
                visitor: ["test", "body"],
                fields: {
                    test: {
                        validate: (0,
                        p.assertNodeType)("Expression")
                    },
                    body: {
                        validate: (0,
                        p.assertNodeType)("Statement")
                    }
                },
                aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"]
            }),
            c("EmptyStatement", {
                aliases: ["Statement"]
            }),
            c("ExpressionStatement", {
                visitor: ["expression"],
                fields: {
                    expression: {
                        validate: (0,
                        p.assertNodeType)("Expression")
                    }
                },
                aliases: ["Statement", "ExpressionWrapper"]
            }),
            c("File", {
                builder: ["program", "comments", "tokens"],
                visitor: ["program"],
                fields: {
                    program: {
                        validate: (0,
                        p.assertNodeType)("Program")
                    },
                    comments: {
                        validate: t.env.BABEL_TYPES_8_BREAKING ? (0,
                        p.assertEach)((0,
                        p.assertNodeType)("CommentBlock", "CommentLine")) : Object.assign(()=>{}
                        , {
                            each: {
                                oneOfNodeTypes: ["CommentBlock", "CommentLine"]
                            }
                        }),
                        optional: !0
                    },
                    tokens: {
                        validate: (0,
                        p.assertEach)(Object.assign(()=>{}
                        , {
                            type: "any"
                        })),
                        optional: !0
                    }
                }
            }),
            c("ForInStatement", {
                visitor: ["left", "right", "body"],
                aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
                fields: {
                    left: {
                        validate: t.env.BABEL_TYPES_8_BREAKING ? (0,
                        p.assertNodeType)("VariableDeclaration", "Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern") : (0,
                        p.assertNodeType)("VariableDeclaration", "LVal")
                    },
                    right: {
                        validate: (0,
                        p.assertNodeType)("Expression")
                    },
                    body: {
                        validate: (0,
                        p.assertNodeType)("Statement")
                    }
                }
            }),
            c("ForStatement", {
                visitor: ["init", "test", "update", "body"],
                aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop"],
                fields: {
                    init: {
                        validate: (0,
                        p.assertNodeType)("VariableDeclaration", "Expression"),
                        optional: !0
                    },
                    test: {
                        validate: (0,
                        p.assertNodeType)("Expression"),
                        optional: !0
                    },
                    update: {
                        validate: (0,
                        p.assertNodeType)("Expression"),
                        optional: !0
                    },
                    body: {
                        validate: (0,
                        p.assertNodeType)("Statement")
                    }
                }
            });
            const d = {
                params: {
                    validate: (0,
                    p.chain)((0,
                    p.assertValueType)("array"), (0,
                    p.assertEach)((0,
                    p.assertNodeType)("Identifier", "Pattern", "RestElement")))
                },
                generator: {
                    default: !1
                },
                async: {
                    default: !1
                }
            };
            r.functionCommon = d;
            const y = {
                returnType: {
                    validate: (0,
                    p.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
                    optional: !0
                },
                typeParameters: {
                    validate: (0,
                    p.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
                    optional: !0
                }
            };
            r.functionTypeAnnotationCommon = y;
            const h = Object.assign({}, d, {
                declare: {
                    validate: (0,
                    p.assertValueType)("boolean"),
                    optional: !0
                },
                id: {
                    validate: (0,
                    p.assertNodeType)("Identifier"),
                    optional: !0
                }
            });
            r.functionDeclarationCommon = h,
            c("FunctionDeclaration", {
                builder: ["id", "params", "body", "generator", "async"],
                visitor: ["id", "params", "body", "returnType", "typeParameters"],
                fields: Object.assign({}, h, y, {
                    body: {
                        validate: (0,
                        p.assertNodeType)("BlockStatement")
                    }
                }),
                aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Statement", "Pureish", "Declaration"],
                validate: function() {
                    if (!t.env.BABEL_TYPES_8_BREAKING)
                        return ()=>{}
                        ;
                    const r = (0,
                    p.assertNodeType)("Identifier");
                    return function(t, i, o) {
                        (0,
                        a.default)("ExportDefaultDeclaration", t) || r(o, "id", o.id)
                    }
                }()
            }),
            c("FunctionExpression", {
                inherits: "FunctionDeclaration",
                aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
                fields: Object.assign({}, d, y, {
                    id: {
                        validate: (0,
                        p.assertNodeType)("Identifier"),
                        optional: !0
                    },
                    body: {
                        validate: (0,
                        p.assertNodeType)("BlockStatement")
                    }
                })
            });
            const m = {
                typeAnnotation: {
                    validate: (0,
                    p.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
                    optional: !0
                },
                decorators: {
                    validate: (0,
                    p.chain)((0,
                    p.assertValueType)("array"), (0,
                    p.assertEach)((0,
                    p.assertNodeType)("Decorator")))
                }
            };
            r.patternLikeCommon = m,
            c("Identifier", {
                builder: ["name"],
                visitor: ["typeAnnotation", "decorators"],
                aliases: ["Expression", "PatternLike", "LVal", "TSEntityName"],
                fields: Object.assign({}, m, {
                    name: {
                        validate: (0,
                        p.chain)((0,
                        p.assertValueType)("string"), Object.assign((function(r, i, a) {
                            if (t.env.BABEL_TYPES_8_BREAKING && !(0,
                            o.default)(a, !1))
                                throw new TypeError(`"${a}" is not a valid identifier name`)
                        }
                        ), {
                            type: "string"
                        }))
                    },
                    optional: {
                        validate: (0,
                        p.assertValueType)("boolean"),
                        optional: !0
                    }
                }),
                validate(r, i, o) {
                    if (!t.env.BABEL_TYPES_8_BREAKING)
                        return;
                    const u = /\.(\w+)$/.exec(i);
                    if (!u)
                        return;
                    const [,p] = u
                      , c = {
                        computed: !1
                    };
                    if ("property" === p) {
                        if ((0,
                        a.default)("MemberExpression", r, c))
                            return;
                        if ((0,
                        a.default)("OptionalMemberExpression", r, c))
                            return
                    } else if ("key" === p) {
                        if ((0,
                        a.default)("Property", r, c))
                            return;
                        if ((0,
                        a.default)("Method", r, c))
                            return
                    } else if ("exported" === p) {
                        if ((0,
                        a.default)("ExportSpecifier", r))
                            return
                    } else if ("imported" === p) {
                        if ((0,
                        a.default)("ImportSpecifier", r, {
                            imported: o
                        }))
                            return
                    } else if ("meta" === p && (0,
                    a.default)("MetaProperty", r, {
                        meta: o
                    }))
                        return;
                    if (((0,
                    l.isKeyword)(o.name) || (0,
                    l.isReservedWord)(o.name, !1)) && "this" !== o.name)
                        throw new TypeError(`"${o.name}" is not a valid identifier`)
                }
            }),
            c("IfStatement", {
                visitor: ["test", "consequent", "alternate"],
                aliases: ["Statement", "Conditional"],
                fields: {
                    test: {
                        validate: (0,
                        p.assertNodeType)("Expression")
                    },
                    consequent: {
                        validate: (0,
                        p.assertNodeType)("Statement")
                    },
                    alternate: {
                        optional: !0,
                        validate: (0,
                        p.assertNodeType)("Statement")
                    }
                }
            }),
            c("LabeledStatement", {
                visitor: ["label", "body"],
                aliases: ["Statement"],
                fields: {
                    label: {
                        validate: (0,
                        p.assertNodeType)("Identifier")
                    },
                    body: {
                        validate: (0,
                        p.assertNodeType)("Statement")
                    }
                }
            }),
            c("StringLiteral", {
                builder: ["value"],
                fields: {
                    value: {
                        validate: (0,
                        p.assertValueType)("string")
                    }
                },
                aliases: ["Expression", "Pureish", "Literal", "Immutable"]
            }),
            c("NumericLiteral", {
                builder: ["value"],
                deprecatedAlias: "NumberLiteral",
                fields: {
                    value: {
                        validate: (0,
                        p.assertValueType)("number")
                    }
                },
                aliases: ["Expression", "Pureish", "Literal", "Immutable"]
            }),
            c("NullLiteral", {
                aliases: ["Expression", "Pureish", "Literal", "Immutable"]
            }),
            c("BooleanLiteral", {
                builder: ["value"],
                fields: {
                    value: {
                        validate: (0,
                        p.assertValueType)("boolean")
                    }
                },
                aliases: ["Expression", "Pureish", "Literal", "Immutable"]
            }),
            c("RegExpLiteral", {
                builder: ["pattern", "flags"],
                deprecatedAlias: "RegexLiteral",
                aliases: ["Expression", "Pureish", "Literal"],
                fields: {
                    pattern: {
                        validate: (0,
                        p.assertValueType)("string")
                    },
                    flags: {
                        validate: (0,
                        p.chain)((0,
                        p.assertValueType)("string"), Object.assign((function(r, i, a) {
                            if (!t.env.BABEL_TYPES_8_BREAKING)
                                return;
                            const o = /[^gimsuy]/.exec(a);
                            if (o)
                                throw new TypeError(`"${o[0]}" is not a valid RegExp flag`)
                        }
                        ), {
                            type: "string"
                        })),
                        default: ""
                    }
                }
            }),
            c("LogicalExpression", {
                builder: ["operator", "left", "right"],
                visitor: ["left", "right"],
                aliases: ["Binary", "Expression"],
                fields: {
                    operator: {
                        validate: (0,
                        p.assertOneOf)(...u.LOGICAL_OPERATORS)
                    },
                    left: {
                        validate: (0,
                        p.assertNodeType)("Expression")
                    },
                    right: {
                        validate: (0,
                        p.assertNodeType)("Expression")
                    }
                }
            }),
            c("MemberExpression", {
                builder: ["object", "property", "computed", ...t.env.BABEL_TYPES_8_BREAKING ? [] : ["optional"]],
                visitor: ["object", "property"],
                aliases: ["Expression", "LVal"],
                fields: Object.assign({
                    object: {
                        validate: (0,
                        p.assertNodeType)("Expression")
                    },
                    property: {
                        validate: function() {
                            const t = (0,
                            p.assertNodeType)("Identifier", "PrivateName")
                              , r = (0,
                            p.assertNodeType)("Expression")
                              , validator = function(i, a, o) {
                                (i.computed ? r : t)(i, a, o)
                            };
                            return validator.oneOfNodeTypes = ["Expression", "Identifier", "PrivateName"],
                            validator
                        }()
                    },
                    computed: {
                        default: !1
                    }
                }, t.env.BABEL_TYPES_8_BREAKING ? {} : {
                    optional: {
                        validate: (0,
                        p.assertOneOf)(!0, !1),
                        optional: !0
                    }
                })
            }),
            c("NewExpression", {
                inherits: "CallExpression"
            }),
            c("Program", {
                visitor: ["directives", "body"],
                builder: ["body", "directives", "sourceType", "interpreter"],
                fields: {
                    sourceFile: {
                        validate: (0,
                        p.assertValueType)("string")
                    },
                    sourceType: {
                        validate: (0,
                        p.assertOneOf)("script", "module"),
                        default: "script"
                    },
                    interpreter: {
                        validate: (0,
                        p.assertNodeType)("InterpreterDirective"),
                        default: null,
                        optional: !0
                    },
                    directives: {
                        validate: (0,
                        p.chain)((0,
                        p.assertValueType)("array"), (0,
                        p.assertEach)((0,
                        p.assertNodeType)("Directive"))),
                        default: []
                    },
                    body: {
                        validate: (0,
                        p.chain)((0,
                        p.assertValueType)("array"), (0,
                        p.assertEach)((0,
                        p.assertNodeType)("Statement")))
                    }
                },
                aliases: ["Scopable", "BlockParent", "Block"]
            }),
            c("ObjectExpression", {
                visitor: ["properties"],
                aliases: ["Expression"],
                fields: {
                    properties: {
                        validate: (0,
                        p.chain)((0,
                        p.assertValueType)("array"), (0,
                        p.assertEach)((0,
                        p.assertNodeType)("ObjectMethod", "ObjectProperty", "SpreadElement")))
                    }
                }
            }),
            c("ObjectMethod", {
                builder: ["kind", "key", "params", "body", "computed", "generator", "async"],
                fields: Object.assign({}, d, y, {
                    kind: Object.assign({
                        validate: (0,
                        p.assertOneOf)("method", "get", "set")
                    }, t.env.BABEL_TYPES_8_BREAKING ? {} : {
                        default: "method"
                    }),
                    computed: {
                        default: !1
                    },
                    key: {
                        validate: function() {
                            const t = (0,
                            p.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral")
                              , r = (0,
                            p.assertNodeType)("Expression")
                              , validator = function(i, a, o) {
                                (i.computed ? r : t)(i, a, o)
                            };
                            return validator.oneOfNodeTypes = ["Expression", "Identifier", "StringLiteral", "NumericLiteral"],
                            validator
                        }()
                    },
                    decorators: {
                        validate: (0,
                        p.chain)((0,
                        p.assertValueType)("array"), (0,
                        p.assertEach)((0,
                        p.assertNodeType)("Decorator"))),
                        optional: !0
                    },
                    body: {
                        validate: (0,
                        p.assertNodeType)("BlockStatement")
                    }
                }),
                visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
                aliases: ["UserWhitespacable", "Function", "Scopable", "BlockParent", "FunctionParent", "Method", "ObjectMember"]
            }),
            c("ObjectProperty", {
                builder: ["key", "value", "computed", "shorthand", ...t.env.BABEL_TYPES_8_BREAKING ? [] : ["decorators"]],
                fields: {
                    computed: {
                        default: !1
                    },
                    key: {
                        validate: function() {
                            const t = (0,
                            p.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral")
                              , r = (0,
                            p.assertNodeType)("Expression")
                              , validator = function(i, a, o) {
                                (i.computed ? r : t)(i, a, o)
                            };
                            return validator.oneOfNodeTypes = ["Expression", "Identifier", "StringLiteral", "NumericLiteral"],
                            validator
                        }()
                    },
                    value: {
                        validate: (0,
                        p.assertNodeType)("Expression", "PatternLike")
                    },
                    shorthand: {
                        validate: (0,
                        p.chain)((0,
                        p.assertValueType)("boolean"), Object.assign((function(r, i, a) {
                            if (t.env.BABEL_TYPES_8_BREAKING && a && r.computed)
                                throw new TypeError("Property shorthand of ObjectProperty cannot be true if computed is true")
                        }
                        ), {
                            type: "boolean"
                        }), (function(r, i, o) {
                            if (t.env.BABEL_TYPES_8_BREAKING && o && !(0,
                            a.default)("Identifier", r.key))
                                throw new TypeError("Property shorthand of ObjectProperty cannot be true if key is not an Identifier")
                        }
                        )),
                        default: !1
                    },
                    decorators: {
                        validate: (0,
                        p.chain)((0,
                        p.assertValueType)("array"), (0,
                        p.assertEach)((0,
                        p.assertNodeType)("Decorator"))),
                        optional: !0
                    }
                },
                visitor: ["key", "value", "decorators"],
                aliases: ["UserWhitespacable", "Property", "ObjectMember"],
                validate: function() {
                    const r = (0,
                    p.assertNodeType)("Identifier", "Pattern")
                      , i = (0,
                    p.assertNodeType)("Expression");
                    return function(o, l, u) {
                        if (!t.env.BABEL_TYPES_8_BREAKING)
                            return;
                        ((0,
                        a.default)("ObjectPattern", o) ? r : i)(u, "value", u.value)
                    }
                }()
            }),
            c("RestElement", {
                visitor: ["argument", "typeAnnotation"],
                builder: ["argument"],
                aliases: ["LVal", "PatternLike"],
                deprecatedAlias: "RestProperty",
                fields: Object.assign({}, m, {
                    argument: {
                        validate: t.env.BABEL_TYPES_8_BREAKING ? (0,
                        p.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern", "MemberExpression") : (0,
                        p.assertNodeType)("LVal")
                    },
                    optional: {
                        validate: (0,
                        p.assertValueType)("boolean"),
                        optional: !0
                    }
                }),
                validate(r, i) {
                    if (!t.env.BABEL_TYPES_8_BREAKING)
                        return;
                    const a = /(\w+)\[(\d+)\]/.exec(i);
                    if (!a)
                        throw new Error("Internal Babel error: malformed key.");
                    const [,o,l] = a;
                    if (r[o].length > l + 1)
                        throw new TypeError("RestElement must be last element of " + o)
                }
            }),
            c("ReturnStatement", {
                visitor: ["argument"],
                aliases: ["Statement", "Terminatorless", "CompletionStatement"],
                fields: {
                    argument: {
                        validate: (0,
                        p.assertNodeType)("Expression"),
                        optional: !0
                    }
                }
            }),
            c("SequenceExpression", {
                visitor: ["expressions"],
                fields: {
                    expressions: {
                        validate: (0,
                        p.chain)((0,
                        p.assertValueType)("array"), (0,
                        p.assertEach)((0,
                        p.assertNodeType)("Expression")))
                    }
                },
                aliases: ["Expression"]
            }),
            c("ParenthesizedExpression", {
                visitor: ["expression"],
                aliases: ["Expression", "ExpressionWrapper"],
                fields: {
                    expression: {
                        validate: (0,
                        p.assertNodeType)("Expression")
                    }
                }
            }),
            c("SwitchCase", {
                visitor: ["test", "consequent"],
                fields: {
                    test: {
                        validate: (0,
                        p.assertNodeType)("Expression"),
                        optional: !0
                    },
                    consequent: {
                        validate: (0,
                        p.chain)((0,
                        p.assertValueType)("array"), (0,
                        p.assertEach)((0,
                        p.assertNodeType)("Statement")))
                    }
                }
            }),
            c("SwitchStatement", {
                visitor: ["discriminant", "cases"],
                aliases: ["Statement", "BlockParent", "Scopable"],
                fields: {
                    discriminant: {
                        validate: (0,
                        p.assertNodeType)("Expression")
                    },
                    cases: {
                        validate: (0,
                        p.chain)((0,
                        p.assertValueType)("array"), (0,
                        p.assertEach)((0,
                        p.assertNodeType)("SwitchCase")))
                    }
                }
            }),
            c("ThisExpression", {
                aliases: ["Expression"]
            }),
            c("ThrowStatement", {
                visitor: ["argument"],
                aliases: ["Statement", "Terminatorless", "CompletionStatement"],
                fields: {
                    argument: {
                        validate: (0,
                        p.assertNodeType)("Expression")
                    }
                }
            }),
            c("TryStatement", {
                visitor: ["block", "handler", "finalizer"],
                aliases: ["Statement"],
                fields: {
                    block: {
                        validate: (0,
                        p.chain)((0,
                        p.assertNodeType)("BlockStatement"), Object.assign((function(r) {
                            if (t.env.BABEL_TYPES_8_BREAKING && !r.handler && !r.finalizer)
                                throw new TypeError("TryStatement expects either a handler or finalizer, or both")
                        }
                        ), {
                            oneOfNodeTypes: ["BlockStatement"]
                        }))
                    },
                    handler: {
                        optional: !0,
                        validate: (0,
                        p.assertNodeType)("CatchClause")
                    },
                    finalizer: {
                        optional: !0,
                        validate: (0,
                        p.assertNodeType)("BlockStatement")
                    }
                }
            }),
            c("UnaryExpression", {
                builder: ["operator", "argument", "prefix"],
                fields: {
                    prefix: {
                        default: !0
                    },
                    argument: {
                        validate: (0,
                        p.assertNodeType)("Expression")
                    },
                    operator: {
                        validate: (0,
                        p.assertOneOf)(...u.UNARY_OPERATORS)
                    }
                },
                visitor: ["argument"],
                aliases: ["UnaryLike", "Expression"]
            }),
            c("UpdateExpression", {
                builder: ["operator", "argument", "prefix"],
                fields: {
                    prefix: {
                        default: !1
                    },
                    argument: {
                        validate: t.env.BABEL_TYPES_8_BREAKING ? (0,
                        p.assertNodeType)("Identifier", "MemberExpression") : (0,
                        p.assertNodeType)("Expression")
                    },
                    operator: {
                        validate: (0,
                        p.assertOneOf)(...u.UPDATE_OPERATORS)
                    }
                },
                visitor: ["argument"],
                aliases: ["Expression"]
            }),
            c("VariableDeclaration", {
                builder: ["kind", "declarations"],
                visitor: ["declarations"],
                aliases: ["Statement", "Declaration"],
                fields: {
                    declare: {
                        validate: (0,
                        p.assertValueType)("boolean"),
                        optional: !0
                    },
                    kind: {
                        validate: (0,
                        p.assertOneOf)("var", "let", "const")
                    },
                    declarations: {
                        validate: (0,
                        p.chain)((0,
                        p.assertValueType)("array"), (0,
                        p.assertEach)((0,
                        p.assertNodeType)("VariableDeclarator")))
                    }
                },
                validate(r, i, o) {
                    if (t.env.BABEL_TYPES_8_BREAKING && (0,
                    a.default)("ForXStatement", r, {
                        left: o
                    }) && 1 !== o.declarations.length)
                        throw new TypeError("Exactly one VariableDeclarator is required in the VariableDeclaration of a " + r.type)
                }
            }),
            c("VariableDeclarator", {
                visitor: ["id", "init"],
                fields: {
                    id: {
                        validate: function() {
                            if (!t.env.BABEL_TYPES_8_BREAKING)
                                return (0,
                                p.assertNodeType)("LVal");
                            const r = (0,
                            p.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern")
                              , i = (0,
                            p.assertNodeType)("Identifier");
                            return function(t, a, o) {
                                (t.init ? r : i)(t, a, o)
                            }
                        }()
                    },
                    definite: {
                        optional: !0,
                        validate: (0,
                        p.assertValueType)("boolean")
                    },
                    init: {
                        optional: !0,
                        validate: (0,
                        p.assertNodeType)("Expression")
                    }
                }
            }),
            c("WhileStatement", {
                visitor: ["test", "body"],
                aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"],
                fields: {
                    test: {
                        validate: (0,
                        p.assertNodeType)("Expression")
                    },
                    body: {
                        validate: (0,
                        p.assertNodeType)("Statement")
                    }
                }
            }),
            c("WithStatement", {
                visitor: ["object", "body"],
                aliases: ["Statement"],
                fields: {
                    object: {
                        validate: (0,
                        p.assertNodeType)("Expression")
                    },
                    body: {
                        validate: (0,
                        p.assertNodeType)("Statement")
                    }
                }
            }),
            c("AssignmentPattern", {
                visitor: ["left", "right", "decorators"],
                builder: ["left", "right"],
                aliases: ["Pattern", "PatternLike", "LVal"],
                fields: Object.assign({}, m, {
                    left: {
                        validate: (0,
                        p.assertNodeType)("Identifier", "ObjectPattern", "ArrayPattern", "MemberExpression")
                    },
                    right: {
                        validate: (0,
                        p.assertNodeType)("Expression")
                    },
                    decorators: {
                        validate: (0,
                        p.chain)((0,
                        p.assertValueType)("array"), (0,
                        p.assertEach)((0,
                        p.assertNodeType)("Decorator"))),
                        optional: !0
                    }
                })
            }),
            c("ArrayPattern", {
                visitor: ["elements", "typeAnnotation"],
                builder: ["elements"],
                aliases: ["Pattern", "PatternLike", "LVal"],
                fields: Object.assign({}, m, {
                    elements: {
                        validate: (0,
                        p.chain)((0,
                        p.assertValueType)("array"), (0,
                        p.assertEach)((0,
                        p.assertNodeOrValueType)("null", "PatternLike")))
                    },
                    decorators: {
                        validate: (0,
                        p.chain)((0,
                        p.assertValueType)("array"), (0,
                        p.assertEach)((0,
                        p.assertNodeType)("Decorator"))),
                        optional: !0
                    },
                    optional: {
                        validate: (0,
                        p.assertValueType)("boolean"),
                        optional: !0
                    }
                })
            }),
            c("ArrowFunctionExpression", {
                builder: ["params", "body", "async"],
                visitor: ["params", "body", "returnType", "typeParameters"],
                aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
                fields: Object.assign({}, d, y, {
                    expression: {
                        validate: (0,
                        p.assertValueType)("boolean")
                    },
                    body: {
                        validate: (0,
                        p.assertNodeType)("BlockStatement", "Expression")
                    }
                })
            }),
            c("ClassBody", {
                visitor: ["body"],
                fields: {
                    body: {
                        validate: (0,
                        p.chain)((0,
                        p.assertValueType)("array"), (0,
                        p.assertEach)((0,
                        p.assertNodeType)("ClassMethod", "ClassPrivateMethod", "ClassProperty", "ClassPrivateProperty", "TSDeclareMethod", "TSIndexSignature")))
                    }
                }
            }),
            c("ClassExpression", {
                builder: ["id", "superClass", "body", "decorators"],
                visitor: ["id", "body", "superClass", "mixins", "typeParameters", "superTypeParameters", "implements", "decorators"],
                aliases: ["Scopable", "Class", "Expression"],
                fields: {
                    id: {
                        validate: (0,
                        p.assertNodeType)("Identifier"),
                        optional: !0
                    },
                    typeParameters: {
                        validate: (0,
                        p.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
                        optional: !0
                    },
                    body: {
                        validate: (0,
                        p.assertNodeType)("ClassBody")
                    },
                    superClass: {
                        optional: !0,
                        validate: (0,
                        p.assertNodeType)("Expression")
                    },
                    superTypeParameters: {
                        validate: (0,
                        p.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
                        optional: !0
                    },
                    implements: {
                        validate: (0,
                        p.chain)((0,
                        p.assertValueType)("array"), (0,
                        p.assertEach)((0,
                        p.assertNodeType)("TSExpressionWithTypeArguments", "ClassImplements"))),
                        optional: !0
                    },
                    decorators: {
                        validate: (0,
                        p.chain)((0,
                        p.assertValueType)("array"), (0,
                        p.assertEach)((0,
                        p.assertNodeType)("Decorator"))),
                        optional: !0
                    },
                    mixins: {
                        validate: (0,
                        p.assertNodeType)("InterfaceExtends"),
                        optional: !0
                    }
                }
            }),
            c("ClassDeclaration", {
                inherits: "ClassExpression",
                aliases: ["Scopable", "Class", "Statement", "Declaration"],
                fields: {
                    id: {
                        validate: (0,
                        p.assertNodeType)("Identifier")
                    },
                    typeParameters: {
                        validate: (0,
                        p.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
                        optional: !0
                    },
                    body: {
                        validate: (0,
                        p.assertNodeType)("ClassBody")
                    },
                    superClass: {
                        optional: !0,
                        validate: (0,
                        p.assertNodeType)("Expression")
                    },
                    superTypeParameters: {
                        validate: (0,
                        p.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
                        optional: !0
                    },
                    implements: {
                        validate: (0,
                        p.chain)((0,
                        p.assertValueType)("array"), (0,
                        p.assertEach)((0,
                        p.assertNodeType)("TSExpressionWithTypeArguments", "ClassImplements"))),
                        optional: !0
                    },
                    decorators: {
                        validate: (0,
                        p.chain)((0,
                        p.assertValueType)("array"), (0,
                        p.assertEach)((0,
                        p.assertNodeType)("Decorator"))),
                        optional: !0
                    },
                    mixins: {
                        validate: (0,
                        p.assertNodeType)("InterfaceExtends"),
                        optional: !0
                    },
                    declare: {
                        validate: (0,
                        p.assertValueType)("boolean"),
                        optional: !0
                    },
                    abstract: {
                        validate: (0,
                        p.assertValueType)("boolean"),
                        optional: !0
                    }
                },
                validate: function() {
                    const r = (0,
                    p.assertNodeType)("Identifier");
                    return function(i, o, l) {
                        t.env.BABEL_TYPES_8_BREAKING && ((0,
                        a.default)("ExportDefaultDeclaration", i) || r(l, "id", l.id))
                    }
                }()
            }),
            c("ExportAllDeclaration", {
                visitor: ["source"],
                aliases: ["Statement", "Declaration", "ModuleDeclaration", "ExportDeclaration"],
                fields: {
                    source: {
                        validate: (0,
                        p.assertNodeType)("StringLiteral")
                    },
                    exportKind: (0,
                    p.validateOptional)((0,
                    p.assertOneOf)("type", "value")),
                    assertions: {
                        optional: !0,
                        validate: (0,
                        p.chain)((0,
                        p.assertValueType)("array"), (0,
                        p.assertEach)((0,
                        p.assertNodeType)("ImportAttribute")))
                    }
                }
            }),
            c("ExportDefaultDeclaration", {
                visitor: ["declaration"],
                aliases: ["Statement", "Declaration", "ModuleDeclaration", "ExportDeclaration"],
                fields: {
                    declaration: {
                        validate: (0,
                        p.assertNodeType)("FunctionDeclaration", "TSDeclareFunction", "ClassDeclaration", "Expression")
                    },
                    exportKind: (0,
                    p.validateOptional)((0,
                    p.assertOneOf)("value"))
                }
            }),
            c("ExportNamedDeclaration", {
                visitor: ["declaration", "specifiers", "source"],
                aliases: ["Statement", "Declaration", "ModuleDeclaration", "ExportDeclaration"],
                fields: {
                    declaration: {
                        optional: !0,
                        validate: (0,
                        p.chain)((0,
                        p.assertNodeType)("Declaration"), Object.assign((function(r, i, a) {
                            if (t.env.BABEL_TYPES_8_BREAKING && a && r.specifiers.length)
                                throw new TypeError("Only declaration or specifiers is allowed on ExportNamedDeclaration")
                        }
                        ), {
                            oneOfNodeTypes: ["Declaration"]
                        }), (function(r, i, a) {
                            if (t.env.BABEL_TYPES_8_BREAKING && a && r.source)
                                throw new TypeError("Cannot export a declaration from a source")
                        }
                        ))
                    },
                    assertions: {
                        optional: !0,
                        validate: (0,
                        p.chain)((0,
                        p.assertValueType)("array"), (0,
                        p.assertEach)((0,
                        p.assertNodeType)("ImportAttribute")))
                    },
                    specifiers: {
                        default: [],
                        validate: (0,
                        p.chain)((0,
                        p.assertValueType)("array"), (0,
                        p.assertEach)(function() {
                            const r = (0,
                            p.assertNodeType)("ExportSpecifier", "ExportDefaultSpecifier", "ExportNamespaceSpecifier")
                              , i = (0,
                            p.assertNodeType)("ExportSpecifier");
                            return t.env.BABEL_TYPES_8_BREAKING ? function(t, a, o) {
                                (t.source ? r : i)(t, a, o)
                            }
                            : r
                        }()))
                    },
                    source: {
                        validate: (0,
                        p.assertNodeType)("StringLiteral"),
                        optional: !0
                    },
                    exportKind: (0,
                    p.validateOptional)((0,
                    p.assertOneOf)("type", "value"))
                }
            }),
            c("ExportSpecifier", {
                visitor: ["local", "exported"],
                aliases: ["ModuleSpecifier"],
                fields: {
                    local: {
                        validate: (0,
                        p.assertNodeType)("Identifier")
                    },
                    exported: {
                        validate: (0,
                        p.assertNodeType)("Identifier", "StringLiteral")
                    },
                    exportKind: {
                        validate: (0,
                        p.assertOneOf)("type", "value"),
                        optional: !0
                    }
                }
            }),
            c("ForOfStatement", {
                visitor: ["left", "right", "body"],
                builder: ["left", "right", "body", "await"],
                aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
                fields: {
                    left: {
                        validate: function() {
                            if (!t.env.BABEL_TYPES_8_BREAKING)
                                return (0,
                                p.assertNodeType)("VariableDeclaration", "LVal");
                            const r = (0,
                            p.assertNodeType)("VariableDeclaration")
                              , i = (0,
                            p.assertNodeType)("Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern");
                            return function(t, o, l) {
                                (0,
                                a.default)("VariableDeclaration", l) ? r(t, o, l) : i(t, o, l)
                            }
                        }()
                    },
                    right: {
                        validate: (0,
                        p.assertNodeType)("Expression")
                    },
                    body: {
                        validate: (0,
                        p.assertNodeType)("Statement")
                    },
                    await: {
                        default: !1
                    }
                }
            }),
            c("ImportDeclaration", {
                visitor: ["specifiers", "source"],
                aliases: ["Statement", "Declaration", "ModuleDeclaration"],
                fields: {
                    assertions: {
                        optional: !0,
                        validate: (0,
                        p.chain)((0,
                        p.assertValueType)("array"), (0,
                        p.assertEach)((0,
                        p.assertNodeType)("ImportAttribute")))
                    },
                    specifiers: {
                        validate: (0,
                        p.chain)((0,
                        p.assertValueType)("array"), (0,
                        p.assertEach)((0,
                        p.assertNodeType)("ImportSpecifier", "ImportDefaultSpecifier", "ImportNamespaceSpecifier")))
                    },
                    source: {
                        validate: (0,
                        p.assertNodeType)("StringLiteral")
                    },
                    importKind: {
                        validate: (0,
                        p.assertOneOf)("type", "typeof", "value"),
                        optional: !0
                    }
                }
            }),
            c("ImportDefaultSpecifier", {
                visitor: ["local"],
                aliases: ["ModuleSpecifier"],
                fields: {
                    local: {
                        validate: (0,
                        p.assertNodeType)("Identifier")
                    }
                }
            }),
            c("ImportNamespaceSpecifier", {
                visitor: ["local"],
                aliases: ["ModuleSpecifier"],
                fields: {
                    local: {
                        validate: (0,
                        p.assertNodeType)("Identifier")
                    }
                }
            }),
            c("ImportSpecifier", {
                visitor: ["local", "imported"],
                aliases: ["ModuleSpecifier"],
                fields: {
                    local: {
                        validate: (0,
                        p.assertNodeType)("Identifier")
                    },
                    imported: {
                        validate: (0,
                        p.assertNodeType)("Identifier", "StringLiteral")
                    },
                    importKind: {
                        validate: (0,
                        p.assertOneOf)("type", "typeof", "value"),
                        optional: !0
                    }
                }
            }),
            c("MetaProperty", {
                visitor: ["meta", "property"],
                aliases: ["Expression"],
                fields: {
                    meta: {
                        validate: (0,
                        p.chain)((0,
                        p.assertNodeType)("Identifier"), Object.assign((function(r, i, o) {
                            if (!t.env.BABEL_TYPES_8_BREAKING)
                                return;
                            let l;
                            switch (o.name) {
                            case "function":
                                l = "sent";
                                break;
                            case "new":
                                l = "target";
                                break;
                            case "import":
                                l = "meta"
                            }
                            if (!(0,
                            a.default)("Identifier", r.property, {
                                name: l
                            }))
                                throw new TypeError("Unrecognised MetaProperty")
                        }
                        ), {
                            oneOfNodeTypes: ["Identifier"]
                        }))
                    },
                    property: {
                        validate: (0,
                        p.assertNodeType)("Identifier")
                    }
                }
            });
            const T = {
                abstract: {
                    validate: (0,
                    p.assertValueType)("boolean"),
                    optional: !0
                },
                accessibility: {
                    validate: (0,
                    p.assertOneOf)("public", "private", "protected"),
                    optional: !0
                },
                static: {
                    default: !1
                },
                override: {
                    default: !1
                },
                computed: {
                    default: !1
                },
                optional: {
                    validate: (0,
                    p.assertValueType)("boolean"),
                    optional: !0
                },
                key: {
                    validate: (0,
                    p.chain)(function() {
                        const t = (0,
                        p.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral")
                          , r = (0,
                        p.assertNodeType)("Expression");
                        return function(i, a, o) {
                            (i.computed ? r : t)(i, a, o)
                        }
                    }(), (0,
                    p.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "Expression"))
                }
            };
            r.classMethodOrPropertyCommon = T;
            const S = Object.assign({}, d, T, {
                params: {
                    validate: (0,
                    p.chain)((0,
                    p.assertValueType)("array"), (0,
                    p.assertEach)((0,
                    p.assertNodeType)("Identifier", "Pattern", "RestElement", "TSParameterProperty")))
                },
                kind: {
                    validate: (0,
                    p.assertOneOf)("get", "set", "method", "constructor"),
                    default: "method"
                },
                access: {
                    validate: (0,
                    p.chain)((0,
                    p.assertValueType)("string"), (0,
                    p.assertOneOf)("public", "private", "protected")),
                    optional: !0
                },
                decorators: {
                    validate: (0,
                    p.chain)((0,
                    p.assertValueType)("array"), (0,
                    p.assertEach)((0,
                    p.assertNodeType)("Decorator"))),
                    optional: !0
                }
            });
            r.classMethodOrDeclareMethodCommon = S,
            c("ClassMethod", {
                aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method"],
                builder: ["kind", "key", "params", "body", "computed", "static", "generator", "async"],
                visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
                fields: Object.assign({}, S, y, {
                    body: {
                        validate: (0,
                        p.assertNodeType)("BlockStatement")
                    }
                })
            }),
            c("ObjectPattern", {
                visitor: ["properties", "typeAnnotation", "decorators"],
                builder: ["properties"],
                aliases: ["Pattern", "PatternLike", "LVal"],
                fields: Object.assign({}, m, {
                    properties: {
                        validate: (0,
                        p.chain)((0,
                        p.assertValueType)("array"), (0,
                        p.assertEach)((0,
                        p.assertNodeType)("RestElement", "ObjectProperty")))
                    }
                })
            }),
            c("SpreadElement", {
                visitor: ["argument"],
                aliases: ["UnaryLike"],
                deprecatedAlias: "SpreadProperty",
                fields: {
                    argument: {
                        validate: (0,
                        p.assertNodeType)("Expression")
                    }
                }
            }),
            c("Super", {
                aliases: ["Expression"]
            }),
            c("TaggedTemplateExpression", {
                visitor: ["tag", "quasi", "typeParameters"],
                builder: ["tag", "quasi"],
                aliases: ["Expression"],
                fields: {
                    tag: {
                        validate: (0,
                        p.assertNodeType)("Expression")
                    },
                    quasi: {
                        validate: (0,
                        p.assertNodeType)("TemplateLiteral")
                    },
                    typeParameters: {
                        validate: (0,
                        p.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
                        optional: !0
                    }
                }
            }),
            c("TemplateElement", {
                builder: ["value", "tail"],
                fields: {
                    value: {
                        validate: (0,
                        p.assertShape)({
                            raw: {
                                validate: (0,
                                p.assertValueType)("string")
                            },
                            cooked: {
                                validate: (0,
                                p.assertValueType)("string"),
                                optional: !0
                            }
                        })
                    },
                    tail: {
                        default: !1
                    }
                }
            }),
            c("TemplateLiteral", {
                visitor: ["quasis", "expressions"],
                aliases: ["Expression", "Literal"],
                fields: {
                    quasis: {
                        validate: (0,
                        p.chain)((0,
                        p.assertValueType)("array"), (0,
                        p.assertEach)((0,
                        p.assertNodeType)("TemplateElement")))
                    },
                    expressions: {
                        validate: (0,
                        p.chain)((0,
                        p.assertValueType)("array"), (0,
                        p.assertEach)((0,
                        p.assertNodeType)("Expression", "TSType")), (function(t, r, i) {
                            if (t.quasis.length !== i.length + 1)
                                throw new TypeError(`Number of ${t.type} quasis should be exactly one more than the number of expressions.\nExpected ${i.length + 1} quasis but got ${t.quasis.length}`)
                        }
                        ))
                    }
                }
            }),
            c("YieldExpression", {
                builder: ["argument", "delegate"],
                visitor: ["argument"],
                aliases: ["Expression", "Terminatorless"],
                fields: {
                    delegate: {
                        validate: (0,
                        p.chain)((0,
                        p.assertValueType)("boolean"), Object.assign((function(r, i, a) {
                            if (t.env.BABEL_TYPES_8_BREAKING && a && !r.argument)
                                throw new TypeError("Property delegate of YieldExpression cannot be true if there is no argument")
                        }
                        ), {
                            type: "boolean"
                        })),
                        default: !1
                    },
                    argument: {
                        optional: !0,
                        validate: (0,
                        p.assertNodeType)("Expression")
                    }
                }
            }),
            c("AwaitExpression", {
                builder: ["argument"],
                visitor: ["argument"],
                aliases: ["Expression", "Terminatorless"],
                fields: {
                    argument: {
                        validate: (0,
                        p.assertNodeType)("Expression")
                    }
                }
            }),
            c("Import", {
                aliases: ["Expression"]
            }),
            c("BigIntLiteral", {
                builder: ["value"],
                fields: {
                    value: {
                        validate: (0,
                        p.assertValueType)("string")
                    }
                },
                aliases: ["Expression", "Pureish", "Literal", "Immutable"]
            }),
            c("ExportNamespaceSpecifier", {
                visitor: ["exported"],
                aliases: ["ModuleSpecifier"],
                fields: {
                    exported: {
                        validate: (0,
                        p.assertNodeType)("Identifier")
                    }
                }
            }),
            c("OptionalMemberExpression", {
                builder: ["object", "property", "computed", "optional"],
                visitor: ["object", "property"],
                aliases: ["Expression"],
                fields: {
                    object: {
                        validate: (0,
                        p.assertNodeType)("Expression")
                    },
                    property: {
                        validate: function() {
                            const t = (0,
                            p.assertNodeType)("Identifier")
                              , r = (0,
                            p.assertNodeType)("Expression")
                              , validator = function(i, a, o) {
                                (i.computed ? r : t)(i, a, o)
                            };
                            return validator.oneOfNodeTypes = ["Expression", "Identifier"],
                            validator
                        }()
                    },
                    computed: {
                        default: !1
                    },
                    optional: {
                        validate: t.env.BABEL_TYPES_8_BREAKING ? (0,
                        p.chain)((0,
                        p.assertValueType)("boolean"), (0,
                        p.assertOptionalChainStart)()) : (0,
                        p.assertValueType)("boolean")
                    }
                }
            }),
            c("OptionalCallExpression", {
                visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
                builder: ["callee", "arguments", "optional"],
                aliases: ["Expression"],
                fields: {
                    callee: {
                        validate: (0,
                        p.assertNodeType)("Expression")
                    },
                    arguments: {
                        validate: (0,
                        p.chain)((0,
                        p.assertValueType)("array"), (0,
                        p.assertEach)((0,
                        p.assertNodeType)("Expression", "SpreadElement", "JSXNamespacedName", "ArgumentPlaceholder")))
                    },
                    optional: {
                        validate: t.env.BABEL_TYPES_8_BREAKING ? (0,
                        p.chain)((0,
                        p.assertValueType)("boolean"), (0,
                        p.assertOptionalChainStart)()) : (0,
                        p.assertValueType)("boolean")
                    },
                    typeArguments: {
                        validate: (0,
                        p.assertNodeType)("TypeParameterInstantiation"),
                        optional: !0
                    },
                    typeParameters: {
                        validate: (0,
                        p.assertNodeType)("TSTypeParameterInstantiation"),
                        optional: !0
                    }
                }
            }),
            c("ClassProperty", {
                visitor: ["key", "value", "typeAnnotation", "decorators"],
                builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"],
                aliases: ["Property"],
                fields: Object.assign({}, T, {
                    value: {
                        validate: (0,
                        p.assertNodeType)("Expression"),
                        optional: !0
                    },
                    definite: {
                        validate: (0,
                        p.assertValueType)("boolean"),
                        optional: !0
                    },
                    typeAnnotation: {
                        validate: (0,
                        p.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
                        optional: !0
                    },
                    decorators: {
                        validate: (0,
                        p.chain)((0,
                        p.assertValueType)("array"), (0,
                        p.assertEach)((0,
                        p.assertNodeType)("Decorator"))),
                        optional: !0
                    },
                    readonly: {
                        validate: (0,
                        p.assertValueType)("boolean"),
                        optional: !0
                    },
                    declare: {
                        validate: (0,
                        p.assertValueType)("boolean"),
                        optional: !0
                    },
                    variance: {
                        validate: (0,
                        p.assertNodeType)("Variance"),
                        optional: !0
                    }
                })
            }),
            c("ClassPrivateProperty", {
                visitor: ["key", "value", "decorators", "typeAnnotation"],
                builder: ["key", "value", "decorators", "static"],
                aliases: ["Property", "Private"],
                fields: {
                    key: {
                        validate: (0,
                        p.assertNodeType)("PrivateName")
                    },
                    value: {
                        validate: (0,
                        p.assertNodeType)("Expression"),
                        optional: !0
                    },
                    typeAnnotation: {
                        validate: (0,
                        p.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
                        optional: !0
                    },
                    decorators: {
                        validate: (0,
                        p.chain)((0,
                        p.assertValueType)("array"), (0,
                        p.assertEach)((0,
                        p.assertNodeType)("Decorator"))),
                        optional: !0
                    },
                    readonly: {
                        validate: (0,
                        p.assertValueType)("boolean"),
                        optional: !0
                    },
                    definite: {
                        validate: (0,
                        p.assertValueType)("boolean"),
                        optional: !0
                    },
                    variance: {
                        validate: (0,
                        p.assertNodeType)("Variance"),
                        optional: !0
                    }
                }
            }),
            c("ClassPrivateMethod", {
                builder: ["kind", "key", "params", "body", "static"],
                visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
                aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method", "Private"],
                fields: Object.assign({}, S, y, {
                    key: {
                        validate: (0,
                        p.assertNodeType)("PrivateName")
                    },
                    body: {
                        validate: (0,
                        p.assertNodeType)("BlockStatement")
                    }
                })
            }),
            c("PrivateName", {
                visitor: ["id"],
                aliases: ["Private"],
                fields: {
                    id: {
                        validate: (0,
                        p.assertNodeType)("Identifier")
                    }
                }
            }),
            c("StaticBlock", {
                visitor: ["body"],
                fields: {
                    body: {
                        validate: (0,
                        p.chain)((0,
                        p.assertValueType)("array"), (0,
                        p.assertEach)((0,
                        p.assertNodeType)("Statement")))
                    }
                },
                aliases: ["Scopable", "BlockParent", "FunctionParent"]
            })
        }
        ).call(this, i("8oxB"))
    },
    "8oxB": function(t, r) {
        var i, a, o = t.exports = {};
        function defaultSetTimout() {
            throw new Error("setTimeout has not been defined")
        }
        function defaultClearTimeout() {
            throw new Error("clearTimeout has not been defined")
        }
        function runTimeout(t) {
            if (i === setTimeout)
                return setTimeout(t, 0);
            if ((i === defaultSetTimout || !i) && setTimeout)
                return i = setTimeout,
                setTimeout(t, 0);
            try {
                return i(t, 0)
            } catch (r) {
                try {
                    return i.call(null, t, 0)
                } catch (r) {
                    return i.call(this, t, 0)
                }
            }
        }
        !function() {
            try {
                i = "function" == typeof setTimeout ? setTimeout : defaultSetTimout
            } catch (t) {
                i = defaultSetTimout
            }
            try {
                a = "function" == typeof clearTimeout ? clearTimeout : defaultClearTimeout
            } catch (t) {
                a = defaultClearTimeout
            }
        }();
        var l, u = [], p = !1, c = -1;
        function cleanUpNextTick() {
            p && l && (p = !1,
            l.length ? u = l.concat(u) : c = -1,
            u.length && drainQueue())
        }
        function drainQueue() {
            if (!p) {
                var t = runTimeout(cleanUpNextTick);
                p = !0;
                for (var r = u.length; r; ) {
                    for (l = u,
                    u = []; ++c < r; )
                        l && l[c].run();
                    c = -1,
                    r = u.length
                }
                l = null,
                p = !1,
                function runClearTimeout(t) {
                    if (a === clearTimeout)
                        return clearTimeout(t);
                    if ((a === defaultClearTimeout || !a) && clearTimeout)
                        return a = clearTimeout,
                        clearTimeout(t);
                    try {
                        return a(t)
                    } catch (r) {
                        try {
                            return a.call(null, t)
                        } catch (r) {
                            return a.call(this, t)
                        }
                    }
                }(t)
            }
        }
        function Item(t, r) {
            this.fun = t,
            this.array = r
        }
        function noop() {}
        o.nextTick = function(t) {
            var r = new Array(arguments.length - 1);
            if (arguments.length > 1)
                for (var i = 1; i < arguments.length; i++)
                    r[i - 1] = arguments[i];
            u.push(new Item(t,r)),
            1 !== u.length || p || runTimeout(drainQueue)
        }
        ,
        Item.prototype.run = function() {
            this.fun.apply(null, this.array)
        }
        ,
        o.title = "browser",
        o.browser = !0,
        o.env = {},
        o.argv = [],
        o.version = "",
        o.versions = {},
        o.on = noop,
        o.addListener = noop,
        o.once = noop,
        o.off = noop,
        o.removeListener = noop,
        o.removeAllListeners = noop,
        o.emit = noop,
        o.prependListener = noop,
        o.prependOnceListener = noop,
        o.listeners = function(t) {
            return []
        }
        ,
        o.binding = function(t) {
            throw new Error("process.binding is not supported")
        }
        ,
        o.cwd = function() {
            return "/"
        }
        ,
        o.chdir = function(t) {
            throw new Error("process.chdir is not supported")
        }
        ,
        o.umask = function() {
            return 0
        }
    },
    "8pGw": function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.WHILE_TYPES = r.USERWHITESPACABLE_TYPES = r.UNARYLIKE_TYPES = r.TYPESCRIPT_TYPES = r.TSTYPE_TYPES = r.TSTYPEELEMENT_TYPES = r.TSENTITYNAME_TYPES = r.TSBASETYPE_TYPES = r.TERMINATORLESS_TYPES = r.STATEMENT_TYPES = r.STANDARDIZED_TYPES = r.SCOPABLE_TYPES = r.PUREISH_TYPES = r.PROPERTY_TYPES = r.PRIVATE_TYPES = r.PATTERN_TYPES = r.PATTERNLIKE_TYPES = r.OBJECTMEMBER_TYPES = r.MODULESPECIFIER_TYPES = r.MODULEDECLARATION_TYPES = r.MISCELLANEOUS_TYPES = r.METHOD_TYPES = r.LVAL_TYPES = r.LOOP_TYPES = r.LITERAL_TYPES = r.JSX_TYPES = r.IMMUTABLE_TYPES = r.FUNCTION_TYPES = r.FUNCTIONPARENT_TYPES = r.FOR_TYPES = r.FORXSTATEMENT_TYPES = r.FLOW_TYPES = r.FLOWTYPE_TYPES = r.FLOWPREDICATE_TYPES = r.FLOWDECLARATION_TYPES = r.FLOWBASEANNOTATION_TYPES = r.EXPRESSION_TYPES = r.EXPRESSIONWRAPPER_TYPES = r.EXPORTDECLARATION_TYPES = r.ENUMMEMBER_TYPES = r.ENUMBODY_TYPES = r.DECLARATION_TYPES = r.CONDITIONAL_TYPES = r.COMPLETIONSTATEMENT_TYPES = r.CLASS_TYPES = r.BLOCK_TYPES = r.BLOCKPARENT_TYPES = r.BINARY_TYPES = void 0;
        var a = i("UHlb")
          , o = a.FLIPPED_ALIAS_KEYS.Standardized;
        r.STANDARDIZED_TYPES = o;
        var l = a.FLIPPED_ALIAS_KEYS.Expression;
        r.EXPRESSION_TYPES = l;
        var u = a.FLIPPED_ALIAS_KEYS.Binary;
        r.BINARY_TYPES = u;
        var p = a.FLIPPED_ALIAS_KEYS.Scopable;
        r.SCOPABLE_TYPES = p;
        var c = a.FLIPPED_ALIAS_KEYS.BlockParent;
        r.BLOCKPARENT_TYPES = c;
        var d = a.FLIPPED_ALIAS_KEYS.Block;
        r.BLOCK_TYPES = d;
        var y = a.FLIPPED_ALIAS_KEYS.Statement;
        r.STATEMENT_TYPES = y;
        var h = a.FLIPPED_ALIAS_KEYS.Terminatorless;
        r.TERMINATORLESS_TYPES = h;
        var m = a.FLIPPED_ALIAS_KEYS.CompletionStatement;
        r.COMPLETIONSTATEMENT_TYPES = m;
        var T = a.FLIPPED_ALIAS_KEYS.Conditional;
        r.CONDITIONAL_TYPES = T;
        var S = a.FLIPPED_ALIAS_KEYS.Loop;
        r.LOOP_TYPES = S;
        var g = a.FLIPPED_ALIAS_KEYS.While;
        r.WHILE_TYPES = g;
        var b = a.FLIPPED_ALIAS_KEYS.ExpressionWrapper;
        r.EXPRESSIONWRAPPER_TYPES = b;
        var v = a.FLIPPED_ALIAS_KEYS.For;
        r.FOR_TYPES = v;
        var E = a.FLIPPED_ALIAS_KEYS.ForXStatement;
        r.FORXSTATEMENT_TYPES = E;
        var P = a.FLIPPED_ALIAS_KEYS.Function;
        r.FUNCTION_TYPES = P;
        var x = a.FLIPPED_ALIAS_KEYS.FunctionParent;
        r.FUNCTIONPARENT_TYPES = x;
        var A = a.FLIPPED_ALIAS_KEYS.Pureish;
        r.PUREISH_TYPES = A;
        var O = a.FLIPPED_ALIAS_KEYS.Declaration;
        r.DECLARATION_TYPES = O;
        var I = a.FLIPPED_ALIAS_KEYS.PatternLike;
        r.PATTERNLIKE_TYPES = I;
        var w = a.FLIPPED_ALIAS_KEYS.LVal;
        r.LVAL_TYPES = w;
        var C = a.FLIPPED_ALIAS_KEYS.TSEntityName;
        r.TSENTITYNAME_TYPES = C;
        var N = a.FLIPPED_ALIAS_KEYS.Literal;
        r.LITERAL_TYPES = N;
        var D = a.FLIPPED_ALIAS_KEYS.Immutable;
        r.IMMUTABLE_TYPES = D;
        var _ = a.FLIPPED_ALIAS_KEYS.UserWhitespacable;
        r.USERWHITESPACABLE_TYPES = _;
        var L = a.FLIPPED_ALIAS_KEYS.Method;
        r.METHOD_TYPES = L;
        var k = a.FLIPPED_ALIAS_KEYS.ObjectMember;
        r.OBJECTMEMBER_TYPES = k;
        var M = a.FLIPPED_ALIAS_KEYS.Property;
        r.PROPERTY_TYPES = M;
        var j = a.FLIPPED_ALIAS_KEYS.UnaryLike;
        r.UNARYLIKE_TYPES = j;
        var B = a.FLIPPED_ALIAS_KEYS.Pattern;
        r.PATTERN_TYPES = B;
        var R = a.FLIPPED_ALIAS_KEYS.Class;
        r.CLASS_TYPES = R;
        var K = a.FLIPPED_ALIAS_KEYS.ModuleDeclaration;
        r.MODULEDECLARATION_TYPES = K;
        var V = a.FLIPPED_ALIAS_KEYS.ExportDeclaration;
        r.EXPORTDECLARATION_TYPES = V;
        var U = a.FLIPPED_ALIAS_KEYS.ModuleSpecifier;
        r.MODULESPECIFIER_TYPES = U;
        var Y = a.FLIPPED_ALIAS_KEYS.Private;
        r.PRIVATE_TYPES = Y;
        var X = a.FLIPPED_ALIAS_KEYS.Flow;
        r.FLOW_TYPES = X;
        var J = a.FLIPPED_ALIAS_KEYS.FlowType;
        r.FLOWTYPE_TYPES = J;
        var W = a.FLIPPED_ALIAS_KEYS.FlowBaseAnnotation;
        r.FLOWBASEANNOTATION_TYPES = W;
        var q = a.FLIPPED_ALIAS_KEYS.FlowDeclaration;
        r.FLOWDECLARATION_TYPES = q;
        var H = a.FLIPPED_ALIAS_KEYS.FlowPredicate;
        r.FLOWPREDICATE_TYPES = H;
        var G = a.FLIPPED_ALIAS_KEYS.EnumBody;
        r.ENUMBODY_TYPES = G;
        var z = a.FLIPPED_ALIAS_KEYS.EnumMember;
        r.ENUMMEMBER_TYPES = z;
        var Q = a.FLIPPED_ALIAS_KEYS.JSX;
        r.JSX_TYPES = Q;
        var $ = a.FLIPPED_ALIAS_KEYS.Miscellaneous;
        r.MISCELLANEOUS_TYPES = $;
        var Z = a.FLIPPED_ALIAS_KEYS.TypeScript;
        r.TYPESCRIPT_TYPES = Z;
        var ee = a.FLIPPED_ALIAS_KEYS.TSTypeElement;
        r.TSTYPEELEMENT_TYPES = ee;
        var te = a.FLIPPED_ALIAS_KEYS.TSType;
        r.TSTYPE_TYPES = te;
        var re = a.FLIPPED_ALIAS_KEYS.TSBaseType;
        r.TSBASETYPE_TYPES = re
    },
    "8xt1": function(t, r, i) {
        "use strict";
        (function(t) {
            Object.defineProperty(r, "__esModule", {
                value: !0
            }),
            r.codeFrameColumns = codeFrameColumns,
            r.default = function _default(r, i, a) {
                var l = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {};
                if (!o) {
                    o = !0;
                    var u = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
                    if (t.emitWarning)
                        t.emitWarning(u, "DeprecationWarning");
                    else {
                        var p = new Error(u);
                        p.name = "DeprecationWarning",
                        console.warn(new Error(u))
                    }
                }
                var c = {
                    start: {
                        column: a = Math.max(a, 0),
                        line: i
                    }
                };
                return codeFrameColumns(r, c, l)
            }
            ;
            var a = i("yKvr")
              , o = !1;
            function getDefs(t) {
                return {
                    gutter: t.grey,
                    marker: t.red.bold,
                    message: t.red.bold
                }
            }
            var l = /\r\n|[\n\r\u2028\u2029]/;
            function getMarkerLines(t, r, i) {
                var a = Object.assign({
                    column: 0,
                    line: -1
                }, t.start)
                  , o = Object.assign({}, a, t.end)
                  , l = i || {}
                  , u = l.linesAbove
                  , p = void 0 === u ? 2 : u
                  , c = l.linesBelow
                  , d = void 0 === c ? 3 : c
                  , y = a.line
                  , h = a.column
                  , m = o.line
                  , T = o.column
                  , S = Math.max(y - (p + 1), 0)
                  , g = Math.min(r.length, m + d);
                -1 === y && (S = 0),
                -1 === m && (g = r.length);
                var b = m - y
                  , v = {};
                if (b)
                    for (var E = 0; E <= b; E++) {
                        var P = E + y;
                        if (h)
                            if (0 === E) {
                                var x = r[P - 1].length;
                                v[P] = [h, x - h + 1]
                            } else if (E === b)
                                v[P] = [0, T];
                            else {
                                var A = r[P - E].length;
                                v[P] = [0, A]
                            }
                        else
                            v[P] = !0
                    }
                else
                    v[y] = h === T ? !h || [h, 0] : [h, T - h];
                return {
                    start: S,
                    end: g,
                    markerLines: v
                }
            }
            function codeFrameColumns(t, r) {
                var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}
                  , o = (i.highlightCode || i.forceColor) && (0,
                a.shouldHighlight)(i)
                  , u = (0,
                a.getChalk)(i)
                  , p = getDefs(u)
                  , c = function maybeHighlight(t, r) {
                    return o ? t(r) : r
                }
                  , d = t.split(l)
                  , y = getMarkerLines(r, d, i)
                  , h = y.start
                  , m = y.end
                  , T = y.markerLines
                  , S = r.start && "number" == typeof r.start.column
                  , g = String(m).length
                  , b = o ? (0,
                a.default)(t, i) : t
                  , v = b.split(l).slice(h, m).map((function(t, r) {
                    var a = h + 1 + r
                      , o = " ".concat(a).slice(-g)
                      , l = " ".concat(o, " |")
                      , u = T[a]
                      , d = !T[a + 1];
                    if (u) {
                        var y = "";
                        if (Array.isArray(u)) {
                            var m = t.slice(0, Math.max(u[0] - 1, 0)).replace(/[^\t]/g, " ")
                              , S = u[1] || 1;
                            y = ["\n ", c(p.gutter, l.replace(/\d/g, " ")), " ", m, c(p.marker, "^").repeat(S)].join(""),
                            d && i.message && (y += " " + c(p.message, i.message))
                        }
                        return [c(p.marker, ">"), c(p.gutter, l), t.length > 0 ? " ".concat(t) : "", y].join("")
                    }
                    return " ".concat(c(p.gutter, l)).concat(t.length > 0 ? " ".concat(t) : "")
                }
                )).join("\n");
                return i.message && !S && (v = "".concat(" ".repeat(g + 1)).concat(i.message, "\n").concat(v)),
                o ? u.reset(v) : v
            }
        }
        ).call(this, i("8oxB"))
    },
    "91HG": function(t, r, i) {
        var a = i("5kYL");
        function deriveBFS(t) {
            var r = function buildGraph() {
                for (var t = {}, r = Object.keys(a), i = r.length, o = 0; o < i; o++)
                    t[r[o]] = {
                        distance: -1,
                        parent: null
                    };
                return t
            }()
              , i = [t];
            for (r[t].distance = 0; i.length; )
                for (var o = i.pop(), l = Object.keys(a[o]), u = l.length, p = 0; p < u; p++) {
                    var c = l[p]
                      , d = r[c];
                    -1 === d.distance && (d.distance = r[o].distance + 1,
                    d.parent = o,
                    i.unshift(c))
                }
            return r
        }
        function link(t, r) {
            return function(i) {
                return r(t(i))
            }
        }
        function wrapConversion(t, r) {
            for (var i = [r[t].parent, t], o = a[r[t].parent][t], l = r[t].parent; r[l].parent; )
                i.unshift(r[l].parent),
                o = link(a[r[l].parent][l], o),
                l = r[l].parent;
            return o.conversion = i,
            o
        }
        t.exports = function(t) {
            for (var r = deriveBFS(t), i = {}, a = Object.keys(r), o = a.length, l = 0; l < o; l++) {
                var u = a[l];
                null !== r[u].parent && (i[u] = wrapConversion(u, r))
            }
            return i
        }
    },
    "9DXG": function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = void 0;
        var a = (0,
        i("qGI9").default)("React.Component");
        r.default = a
    },
    "9W4/": function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function cloneDeepWithoutLoc(t) {
            return (0,
            a.default)(t, !0, !0)
        }
        ;
        var a = i("aHlp")
    },
    "9YWw": function(t, r, i) {
        "use strict";
        function _createForOfIteratorHelper(t, r) {
            var i = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
            if (!i) {
                if (Array.isArray(t) || (i = function _unsupportedIterableToArray(t, r) {
                    if (!t)
                        return;
                    if ("string" == typeof t)
                        return _arrayLikeToArray(t, r);
                    var i = Object.prototype.toString.call(t).slice(8, -1);
                    "Object" === i && t.constructor && (i = t.constructor.name);
                    if ("Map" === i || "Set" === i)
                        return Array.from(t);
                    if ("Arguments" === i || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i))
                        return _arrayLikeToArray(t, r)
                }(t)) || r && t && "number" == typeof t.length) {
                    i && (t = i);
                    var a = 0
                      , o = function F() {};
                    return {
                        s: o,
                        n: function n() {
                            return a >= t.length ? {
                                done: !0
                            } : {
                                done: !1,
                                value: t[a++]
                            }
                        },
                        e: function e(t) {
                            throw t
                        },
                        f: o
                    }
                }
                throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
            }
            var l, u = !0, p = !1;
            return {
                s: function s() {
                    i = i.call(t)
                },
                n: function n() {
                    var t = i.next();
                    return u = t.done,
                    t
                },
                e: function e(t) {
                    p = !0,
                    l = t
                },
                f: function f() {
                    try {
                        u || null == i.return || i.return()
                    } finally {
                        if (p)
                            throw l
                    }
                }
            }
        }
        function _arrayLikeToArray(t, r) {
            (null == r || r > t.length) && (r = t.length);
            for (var i = 0, a = new Array(r); i < r; i++)
                a[i] = t[i];
            return a
        }
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.findParent = function findParent(t) {
            var r = this;
            for (; r = r.parentPath; )
                if (t(r))
                    return r;
            return null
        }
        ,
        r.find = function find(t) {
            var r = this;
            do {
                if (t(r))
                    return r
            } while (r = r.parentPath);
            return null
        }
        ,
        r.getFunctionParent = function getFunctionParent() {
            return this.findParent((function(t) {
                return t.isFunction()
            }
            ))
        }
        ,
        r.getStatementParent = function getStatementParent() {
            var t = this;
            do {
                if (!t.parentPath || Array.isArray(t.container) && t.isStatement())
                    break;
                t = t.parentPath
            } while (t);
            if (t && (t.isProgram() || t.isFile()))
                throw new Error("File/Program node, we can't possibly find a statement parent to this");
            return t
        }
        ,
        r.getEarliestCommonAncestorFrom = function getEarliestCommonAncestorFrom(t) {
            return this.getDeepestCommonAncestorFrom(t, (function(t, r, i) {
                var o, l, u = a.VISITOR_KEYS[t.type], p = _createForOfIteratorHelper(i);
                try {
                    for (p.s(); !(l = p.n()).done; ) {
                        var c = l.value[r + 1];
                        if (o)
                            if (c.listKey && o.listKey === c.listKey && c.key < o.key)
                                o = c;
                            else
                                u.indexOf(o.parentKey) > u.indexOf(c.parentKey) && (o = c);
                        else
                            o = c
                    }
                } catch (t) {
                    p.e(t)
                } finally {
                    p.f()
                }
                return o
            }
            ))
        }
        ,
        r.getDeepestCommonAncestorFrom = function getDeepestCommonAncestorFrom(t, r) {
            var i = this;
            if (!t.length)
                return this;
            if (1 === t.length)
                return t[0];
            var a, o, l = 1 / 0, u = t.map((function(t) {
                var r = [];
                do {
                    r.unshift(t)
                } while ((t = t.parentPath) && t !== i);
                return r.length < l && (l = r.length),
                r
            }
            )), p = u[0];
            e: for (var c = 0; c < l; c++) {
                var d, y = p[c], h = _createForOfIteratorHelper(u);
                try {
                    for (h.s(); !(d = h.n()).done; ) {
                        if (d.value[c] !== y)
                            break e
                    }
                } catch (t) {
                    h.e(t)
                } finally {
                    h.f()
                }
                a = c,
                o = y
            }
            if (o)
                return r ? r(o, a, u) : o;
            throw new Error("Couldn't find intersection")
        }
        ,
        r.getAncestry = function getAncestry() {
            var t = this
              , r = [];
            do {
                r.push(t)
            } while (t = t.parentPath);
            return r
        }
        ,
        r.isAncestor = function isAncestor(t) {
            return t.isDescendant(this)
        }
        ,
        r.isDescendant = function isDescendant(t) {
            return !!this.findParent((function(r) {
                return r === t
            }
            ))
        }
        ,
        r.inType = function inType() {
            for (var t = this, r = arguments.length, i = new Array(r), a = 0; a < r; a++)
                i[a] = arguments[a];
            for (; t; ) {
                var o, l = _createForOfIteratorHelper(i);
                try {
                    for (l.s(); !(o = l.n()).done; ) {
                        var u = o.value;
                        if (t.node.type === u)
                            return !0
                    }
                } catch (t) {
                    l.e(t)
                } finally {
                    l.f()
                }
                t = t.parentPath
            }
            return !1
        }
        ;
        var a = i("ZtNB");
        i("MBGo")
    },
    "9aGZ": function(t, r, i) {
        "use strict";
        var a = i("TqRt")
          , o = a(i("iWIM"))
          , l = a(i("lwsE"))
          , u = a(i("W8MJ"))
          , p = a(i("7W2i"))
          , c = a(i("a1gu"))
          , d = a(i("Nsbk"));
        function _createForOfIteratorHelper(t, r) {
            var i = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
            if (!i) {
                if (Array.isArray(t) || (i = function _unsupportedIterableToArray(t, r) {
                    if (!t)
                        return;
                    if ("string" == typeof t)
                        return _arrayLikeToArray(t, r);
                    var i = Object.prototype.toString.call(t).slice(8, -1);
                    "Object" === i && t.constructor && (i = t.constructor.name);
                    if ("Map" === i || "Set" === i)
                        return Array.from(t);
                    if ("Arguments" === i || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i))
                        return _arrayLikeToArray(t, r)
                }(t)) || r && t && "number" == typeof t.length) {
                    i && (t = i);
                    var a = 0
                      , o = function F() {};
                    return {
                        s: o,
                        n: function n() {
                            return a >= t.length ? {
                                done: !0
                            } : {
                                done: !1,
                                value: t[a++]
                            }
                        },
                        e: function e(t) {
                            throw t
                        },
                        f: o
                    }
                }
                throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
            }
            var l, u = !0, p = !1;
            return {
                s: function s() {
                    i = i.call(t)
                },
                n: function n() {
                    var t = i.next();
                    return u = t.done,
                    t
                },
                e: function e(t) {
                    p = !0,
                    l = t
                },
                f: function f() {
                    try {
                        u || null == i.return || i.return()
                    } finally {
                        if (p)
                            throw l
                    }
                }
            }
        }
        function _arrayLikeToArray(t, r) {
            (null == r || r > t.length) && (r = t.length);
            for (var i = 0, a = new Array(r); i < r; i++)
                a[i] = t[i];
            return a
        }
        function _createSuper(t) {
            var r = function _isNativeReflectConstruct() {
                if ("undefined" == typeof Reflect || !Reflect.construct)
                    return !1;
                if (Reflect.construct.sham)
                    return !1;
                if ("function" == typeof Proxy)
                    return !0;
                try {
                    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}
                    ))),
                    !0
                } catch (t) {
                    return !1
                }
            }();
            return function _createSuperInternal() {
                var i, a = (0,
                d.default)(t);
                if (r) {
                    var o = (0,
                    d.default)(this).constructor;
                    i = Reflect.construct(a, arguments, o)
                } else
                    i = a.apply(this, arguments);
                return (0,
                c.default)(this, i)
            }
        }
        var y = i("YSHT")
          , h = i("hsUc")
          , m = i("C+dp").Definition
          , T = i("lTU0")
          , S = i("V+V6")
          , g = i("Z6Aa").getKeys
          , b = i("89jI")
          , v = y.FLIPPED_ALIAS_KEYS.Flow.concat(["ArrayPattern", "ClassDeclaration", "ClassExpression", "FunctionDeclaration", "FunctionExpression", "Identifier", "ObjectPattern", "RestElement"])
          , E = Object.keys(y.VISITOR_KEYS).reduce((function(t, r) {
            var i = y.VISITOR_KEYS[r];
            return -1 === v.indexOf(i) && (t[r] = i),
            t
        }
        ), {})
          , P = {
            callProperties: {
                type: "loop",
                values: ["value"]
            },
            indexers: {
                type: "loop",
                values: ["key", "value"]
            },
            properties: {
                type: "loop",
                values: ["argument", "value"]
            },
            types: {
                type: "loop"
            },
            params: {
                type: "loop"
            },
            argument: {
                type: "single"
            },
            elementType: {
                type: "single"
            },
            qualification: {
                type: "single"
            },
            rest: {
                type: "single"
            },
            returnType: {
                type: "single"
            },
            typeAnnotation: {
                type: "typeAnnotation"
            },
            typeParameters: {
                type: "typeParameters"
            },
            id: {
                type: "id"
            }
        }
          , x = function(t) {
            (0,
            p.default)(PatternVisitor, t);
            var r = _createSuper(PatternVisitor);
            function PatternVisitor() {
                return (0,
                l.default)(this, PatternVisitor),
                r.apply(this, arguments)
            }
            return (0,
            u.default)(PatternVisitor, [{
                key: "ArrayPattern",
                value: function ArrayPattern(t) {
                    t.elements.forEach(this.visit, this)
                }
            }, {
                key: "ObjectPattern",
                value: function ObjectPattern(t) {
                    t.properties.forEach(this.visit, this)
                }
            }]),
            PatternVisitor
        }(T)
          , A = function(t) {
            (0,
            p.default)(Referencer, t);
            var r = _createSuper(Referencer);
            function Referencer() {
                return (0,
                l.default)(this, Referencer),
                r.apply(this, arguments)
            }
            return (0,
            u.default)(Referencer, [{
                key: "visitPattern",
                value: function visitPattern(t, r, i) {
                    if (t) {
                        this._checkIdentifierOrVisit(t.typeAnnotation),
                        y.isAssignmentPattern(t) && this._checkIdentifierOrVisit(t.left.typeAnnotation),
                        "function" == typeof r && (i = r,
                        r = {
                            processRightHandNodes: !1
                        });
                        var a = new x(this.options,t,i);
                        a.visit(t),
                        r.processRightHandNodes && a.rightHandNodes.forEach(this.visit, this)
                    }
                }
            }, {
                key: "visitClass",
                value: function visitClass(t) {
                    this._visitArray(t.decorators);
                    var r = this._nestTypeParamScope(t);
                    this._visitTypeAnnotation(t.implements),
                    this._visitTypeAnnotation(t.superTypeParameters && t.superTypeParameters.params),
                    (0,
                    o.default)((0,
                    d.default)(Referencer.prototype), "visitClass", this).call(this, t),
                    r && this.close(t)
                }
            }, {
                key: "visitFunction",
                value: function visitFunction(t) {
                    var r = this._nestTypeParamScope(t);
                    this._checkIdentifierOrVisit(t.returnType),
                    (0,
                    o.default)((0,
                    d.default)(Referencer.prototype), "visitFunction", this).call(this, t),
                    r && this.close(t)
                }
            }, {
                key: "visitProperty",
                value: function visitProperty(t) {
                    t.value && "TypeCastExpression" === t.value.type && this._visitTypeAnnotation(t.value),
                    this._visitArray(t.decorators),
                    (0,
                    o.default)((0,
                    d.default)(Referencer.prototype), "visitProperty", this).call(this, t)
                }
            }, {
                key: "InterfaceDeclaration",
                value: function InterfaceDeclaration(t) {
                    this._createScopeVariable(t, t.id);
                    var r = this._nestTypeParamScope(t);
                    this._visitArray(t.extends),
                    this.visit(t.body),
                    r && this.close(t)
                }
            }, {
                key: "TypeAlias",
                value: function TypeAlias(t) {
                    this._createScopeVariable(t, t.id);
                    var r = this._nestTypeParamScope(t);
                    this.visit(t.right),
                    r && this.close(t)
                }
            }, {
                key: "ClassProperty",
                value: function ClassProperty(t) {
                    this._visitClassProperty(t)
                }
            }, {
                key: "ClassPrivateProperty",
                value: function ClassPrivateProperty(t) {
                    this._visitClassProperty(t)
                }
            }, {
                key: "DeclareModule",
                value: function DeclareModule(t) {
                    this._visitDeclareX(t)
                }
            }, {
                key: "DeclareFunction",
                value: function DeclareFunction(t) {
                    this._visitDeclareX(t)
                }
            }, {
                key: "DeclareVariable",
                value: function DeclareVariable(t) {
                    this._visitDeclareX(t)
                }
            }, {
                key: "DeclareClass",
                value: function DeclareClass(t) {
                    this._visitDeclareX(t)
                }
            }, {
                key: "OptionalMemberExpression",
                value: function OptionalMemberExpression(t) {
                    (0,
                    o.default)((0,
                    d.default)(Referencer.prototype), "MemberExpression", this).call(this, t)
                }
            }, {
                key: "_visitClassProperty",
                value: function _visitClassProperty(t) {
                    this._visitTypeAnnotation(t.typeAnnotation),
                    this.visitProperty(t)
                }
            }, {
                key: "_visitDeclareX",
                value: function _visitDeclareX(t) {
                    t.id && this._createScopeVariable(t, t.id),
                    this._nestTypeParamScope(t) && this.close(t)
                }
            }, {
                key: "_createScopeVariable",
                value: function _createScopeVariable(t, r) {
                    this.currentScope().variableScope.__define(r, new m("Variable",r,t,null,null,null))
                }
            }, {
                key: "_nestTypeParamScope",
                value: function _nestTypeParamScope(t) {
                    if (!t.typeParameters)
                        return null;
                    var r = this.scopeManager.__currentScope
                      , i = new h.Scope(this.scopeManager,"type-parameters",r,t,!1);
                    this.scopeManager.__nestScope(i);
                    for (var a = 0; a < t.typeParameters.params.length; a++) {
                        var o = t.typeParameters.params[a];
                        i.__define(o, new m("TypeParameter",o,o)),
                        o.typeAnnotation && this._checkIdentifierOrVisit(o)
                    }
                    return i.__define = function() {
                        return r.__define.apply(r, arguments)
                    }
                    ,
                    i
                }
            }, {
                key: "_visitTypeAnnotation",
                value: function _visitTypeAnnotation(t) {
                    if (t)
                        if (Array.isArray(t))
                            t.forEach(this._visitTypeAnnotation, this);
                        else {
                            var r = E[t.type];
                            if (r)
                                for (var i = 0; i < r.length; i++) {
                                    var a = r[i]
                                      , o = P[a]
                                      , l = t[a];
                                    if (null != o && null != l)
                                        if ("loop" === o.type)
                                            for (var u = 0; u < l.length; u++)
                                                if (Array.isArray(o.values))
                                                    for (var p = 0; p < o.values.length; p++) {
                                                        var c = l[u][o.values[p]];
                                                        c && this._checkIdentifierOrVisit(c)
                                                    }
                                                else
                                                    this._checkIdentifierOrVisit(l[u]);
                                        else if ("single" === o.type)
                                            this._checkIdentifierOrVisit(l);
                                        else if ("typeAnnotation" === o.type)
                                            this._visitTypeAnnotation(t.typeAnnotation);
                                        else if ("typeParameters" === o.type)
                                            for (var d = 0; d < t.typeParameters.params.length; d++)
                                                this._checkIdentifierOrVisit(t.typeParameters.params[d]);
                                        else
                                            "id" === o.type && ("Identifier" === t.id.type ? this._checkIdentifierOrVisit(t.id) : this._visitTypeAnnotation(t.id))
                                }
                        }
                }
            }, {
                key: "_checkIdentifierOrVisit",
                value: function _checkIdentifierOrVisit(t) {
                    t && t.typeAnnotation ? this._visitTypeAnnotation(t.typeAnnotation) : t && "Identifier" === t.type ? this.visit(t) : this._visitTypeAnnotation(t)
                }
            }, {
                key: "_visitArray",
                value: function _visitArray(t) {
                    if (t) {
                        var r, i = _createForOfIteratorHelper(t);
                        try {
                            for (i.s(); !(r = i.n()).done; ) {
                                var a = r.value;
                                this.visit(a)
                            }
                        } catch (t) {
                            i.e(t)
                        } finally {
                            i.f()
                        }
                    }
                }
            }]),
            Referencer
        }(S);
        t.exports = function(t, r) {
            var a = {
                ignoreEval: !0,
                optimistic: !1,
                directive: !1,
                nodejsScope: "script" === t.sourceType && !0 === (r.ecmaFeatures && r.ecmaFeatures.globalReturn),
                impliedStrict: !1,
                sourceType: t.sourceType,
                ecmaVersion: r.ecmaVersion || 2018,
                fallback: g
            };
            if (S._babelEslintPatched)
                return i("IAoA")(r),
                h.analyze(t, a);
            a.childVisitorKeys = b;
            var o = new h.ScopeManager(a);
            return new A(a,o).visit(t),
            o
        }
    },
    "9gGh": function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function isLet(t) {
            return (0,
            a.isVariableDeclaration)(t) && ("var" !== t.kind || t[o.BLOCK_SCOPED_SYMBOL])
        }
        ;
        var a = i("FUES")
          , o = i("RS7Y")
    },
    "9lTW": function(t, r, i) {
        "use strict";
        (function(r) {
            var a = i("MgzW");
            function compare(t, r) {
                if (t === r)
                    return 0;
                for (var i = t.length, a = r.length, o = 0, l = Math.min(i, a); o < l; ++o)
                    if (t[o] !== r[o]) {
                        i = t[o],
                        a = r[o];
                        break
                    }
                return i < a ? -1 : a < i ? 1 : 0
            }
            function isBuffer(t) {
                return r.Buffer && "function" == typeof r.Buffer.isBuffer ? r.Buffer.isBuffer(t) : !(null == t || !t._isBuffer)
            }
            var o = i("MCLT")
              , l = Object.prototype.hasOwnProperty
              , u = Array.prototype.slice
              , p = "foo" === function foo() {}
            .name;
            function pToString(t) {
                return Object.prototype.toString.call(t)
            }
            function isView(t) {
                return !isBuffer(t) && ("function" == typeof r.ArrayBuffer && ("function" == typeof ArrayBuffer.isView ? ArrayBuffer.isView(t) : !!t && (t instanceof DataView || !!(t.buffer && t.buffer instanceof ArrayBuffer))))
            }
            var c = t.exports = ok
              , d = /\s*function\s+([^\(\s]*)\s*/;
            function getName(t) {
                if (o.isFunction(t)) {
                    if (p)
                        return t.name;
                    var r = t.toString().match(d);
                    return r && r[1]
                }
            }
            function truncate(t, r) {
                return "string" == typeof t ? t.length < r ? t : t.slice(0, r) : t
            }
            function inspect(t) {
                if (p || !o.isFunction(t))
                    return o.inspect(t);
                var r = getName(t);
                return "[Function" + (r ? ": " + r : "") + "]"
            }
            function fail(t, r, i, a, o) {
                throw new c.AssertionError({
                    message: i,
                    actual: t,
                    expected: r,
                    operator: a,
                    stackStartFunction: o
                })
            }
            function ok(t, r) {
                t || fail(t, !0, r, "==", c.ok)
            }
            function _deepEqual(t, r, i, a) {
                if (t === r)
                    return !0;
                if (isBuffer(t) && isBuffer(r))
                    return 0 === compare(t, r);
                if (o.isDate(t) && o.isDate(r))
                    return t.getTime() === r.getTime();
                if (o.isRegExp(t) && o.isRegExp(r))
                    return t.source === r.source && t.global === r.global && t.multiline === r.multiline && t.lastIndex === r.lastIndex && t.ignoreCase === r.ignoreCase;
                if (null !== t && "object" == typeof t || null !== r && "object" == typeof r) {
                    if (isView(t) && isView(r) && pToString(t) === pToString(r) && !(t instanceof Float32Array || t instanceof Float64Array))
                        return 0 === compare(new Uint8Array(t.buffer), new Uint8Array(r.buffer));
                    if (isBuffer(t) !== isBuffer(r))
                        return !1;
                    var l = (a = a || {
                        actual: [],
                        expected: []
                    }).actual.indexOf(t);
                    return -1 !== l && l === a.expected.indexOf(r) || (a.actual.push(t),
                    a.expected.push(r),
                    function objEquiv(t, r, i, a) {
                        if (null == t || null == r)
                            return !1;
                        if (o.isPrimitive(t) || o.isPrimitive(r))
                            return t === r;
                        if (i && Object.getPrototypeOf(t) !== Object.getPrototypeOf(r))
                            return !1;
                        var l = isArguments(t)
                          , p = isArguments(r);
                        if (l && !p || !l && p)
                            return !1;
                        if (l)
                            return t = u.call(t),
                            r = u.call(r),
                            _deepEqual(t, r, i);
                        var c, d, h = y(t), m = y(r);
                        if (h.length !== m.length)
                            return !1;
                        for (h.sort(),
                        m.sort(),
                        d = h.length - 1; d >= 0; d--)
                            if (h[d] !== m[d])
                                return !1;
                        for (d = h.length - 1; d >= 0; d--)
                            if (c = h[d],
                            !_deepEqual(t[c], r[c], i, a))
                                return !1;
                        return !0
                    }(t, r, i, a))
                }
                return i ? t === r : t == r
            }
            function isArguments(t) {
                return "[object Arguments]" == Object.prototype.toString.call(t)
            }
            function expectedException(t, r) {
                if (!t || !r)
                    return !1;
                if ("[object RegExp]" == Object.prototype.toString.call(r))
                    return r.test(t);
                try {
                    if (t instanceof r)
                        return !0
                } catch (t) {}
                return !Error.isPrototypeOf(r) && !0 === r.call({}, t)
            }
            function _throws(t, r, i, a) {
                var l;
                if ("function" != typeof r)
                    throw new TypeError('"block" argument must be a function');
                "string" == typeof i && (a = i,
                i = null),
                l = function _tryBlock(t) {
                    var r;
                    try {
                        t()
                    } catch (t) {
                        r = t
                    }
                    return r
                }(r),
                a = (i && i.name ? " (" + i.name + ")." : ".") + (a ? " " + a : "."),
                t && !l && fail(l, i, "Missing expected exception" + a);
                var u = "string" == typeof a
                  , p = !t && l && !i;
                if ((!t && o.isError(l) && u && expectedException(l, i) || p) && fail(l, i, "Got unwanted exception" + a),
                t && l && i && !expectedException(l, i) || !t && l)
                    throw l
            }
            c.AssertionError = function AssertionError(t) {
                this.name = "AssertionError",
                this.actual = t.actual,
                this.expected = t.expected,
                this.operator = t.operator,
                t.message ? (this.message = t.message,
                this.generatedMessage = !1) : (this.message = function getMessage(t) {
                    return truncate(inspect(t.actual), 128) + " " + t.operator + " " + truncate(inspect(t.expected), 128)
                }(this),
                this.generatedMessage = !0);
                var r = t.stackStartFunction || fail;
                if (Error.captureStackTrace)
                    Error.captureStackTrace(this, r);
                else {
                    var i = new Error;
                    if (i.stack) {
                        var a = i.stack
                          , o = getName(r)
                          , l = a.indexOf("\n" + o);
                        if (l >= 0) {
                            var u = a.indexOf("\n", l + 1);
                            a = a.substring(u + 1)
                        }
                        this.stack = a
                    }
                }
            }
            ,
            o.inherits(c.AssertionError, Error),
            c.fail = fail,
            c.ok = ok,
            c.equal = function equal(t, r, i) {
                t != r && fail(t, r, i, "==", c.equal)
            }
            ,
            c.notEqual = function notEqual(t, r, i) {
                t == r && fail(t, r, i, "!=", c.notEqual)
            }
            ,
            c.deepEqual = function deepEqual(t, r, i) {
                _deepEqual(t, r, !1) || fail(t, r, i, "deepEqual", c.deepEqual)
            }
            ,
            c.deepStrictEqual = function deepStrictEqual(t, r, i) {
                _deepEqual(t, r, !0) || fail(t, r, i, "deepStrictEqual", c.deepStrictEqual)
            }
            ,
            c.notDeepEqual = function notDeepEqual(t, r, i) {
                _deepEqual(t, r, !1) && fail(t, r, i, "notDeepEqual", c.notDeepEqual)
            }
            ,
            c.notDeepStrictEqual = function notDeepStrictEqual(t, r, i) {
                _deepEqual(t, r, !0) && fail(t, r, i, "notDeepStrictEqual", notDeepStrictEqual)
            }
            ,
            c.strictEqual = function strictEqual(t, r, i) {
                t !== r && fail(t, r, i, "===", c.strictEqual)
            }
            ,
            c.notStrictEqual = function notStrictEqual(t, r, i) {
                t === r && fail(t, r, i, "!==", c.notStrictEqual)
            }
            ,
            c.throws = function(t, r, i) {
                _throws(!0, t, r, i)
            }
            ,
            c.doesNotThrow = function(t, r, i) {
                _throws(!1, t, r, i)
            }
            ,
            c.ifError = function(t) {
                if (t)
                    throw t
            }
            ,
            c.strict = a((function strict(t, r) {
                t || fail(t, !0, r, "==", strict)
            }
            ), c, {
                equal: c.strictEqual,
                deepEqual: c.deepStrictEqual,
                notEqual: c.notStrictEqual,
                notDeepEqual: c.notDeepStrictEqual
            }),
            c.strict.strict = c.strict;
            var y = Object.keys || function(t) {
                var r = [];
                for (var i in t)
                    l.call(t, i) && r.push(i);
                return r
            }
        }
        ).call(this, i("yLpj"))
    },
    "9vpr": function(t, r) {
        !function clone(t) {
            "use strict";
            var r, i, a, o, l, u;
            function deepCopy(t) {
                var r, i, a = {};
                for (r in t)
                    t.hasOwnProperty(r) && (i = t[r],
                    a[r] = "object" == typeof i && null !== i ? deepCopy(i) : i);
                return a
            }
            function Reference(t, r) {
                this.parent = t,
                this.key = r
            }
            function Element(t, r, i, a) {
                this.node = t,
                this.path = r,
                this.wrap = i,
                this.ref = a
            }
            function Controller() {}
            function isNode(t) {
                return null != t && ("object" == typeof t && "string" == typeof t.type)
            }
            function isProperty(t, i) {
                return (t === r.ObjectExpression || t === r.ObjectPattern) && "properties" === i
            }
            function candidateExistsInLeaveList(t, r) {
                for (var i = t.length - 1; i >= 0; --i)
                    if (t[i].node === r)
                        return !0;
                return !1
            }
            function traverse(t, r) {
                return (new Controller).traverse(t, r)
            }
            function extendCommentRange(t, r) {
                var i;
                return i = function upperBound(t, r) {
                    var i, a, o, l;
                    for (a = t.length,
                    o = 0; a; )
                        r(t[l = o + (i = a >>> 1)]) ? a = i : (o = l + 1,
                        a -= i + 1);
                    return o
                }(r, (function search(r) {
                    return r.range[0] > t.range[0]
                }
                )),
                t.extendedRange = [t.range[0], t.range[1]],
                i !== r.length && (t.extendedRange[1] = r[i].range[0]),
                (i -= 1) >= 0 && (t.extendedRange[0] = r[i].range[1]),
                t
            }
            return r = {
                AssignmentExpression: "AssignmentExpression",
                AssignmentPattern: "AssignmentPattern",
                ArrayExpression: "ArrayExpression",
                ArrayPattern: "ArrayPattern",
                ArrowFunctionExpression: "ArrowFunctionExpression",
                AwaitExpression: "AwaitExpression",
                BlockStatement: "BlockStatement",
                BinaryExpression: "BinaryExpression",
                BreakStatement: "BreakStatement",
                CallExpression: "CallExpression",
                CatchClause: "CatchClause",
                ChainExpression: "ChainExpression",
                ClassBody: "ClassBody",
                ClassDeclaration: "ClassDeclaration",
                ClassExpression: "ClassExpression",
                ComprehensionBlock: "ComprehensionBlock",
                ComprehensionExpression: "ComprehensionExpression",
                ConditionalExpression: "ConditionalExpression",
                ContinueStatement: "ContinueStatement",
                DebuggerStatement: "DebuggerStatement",
                DirectiveStatement: "DirectiveStatement",
                DoWhileStatement: "DoWhileStatement",
                EmptyStatement: "EmptyStatement",
                ExportAllDeclaration: "ExportAllDeclaration",
                ExportDefaultDeclaration: "ExportDefaultDeclaration",
                ExportNamedDeclaration: "ExportNamedDeclaration",
                ExportSpecifier: "ExportSpecifier",
                ExpressionStatement: "ExpressionStatement",
                ForStatement: "ForStatement",
                ForInStatement: "ForInStatement",
                ForOfStatement: "ForOfStatement",
                FunctionDeclaration: "FunctionDeclaration",
                FunctionExpression: "FunctionExpression",
                GeneratorExpression: "GeneratorExpression",
                Identifier: "Identifier",
                IfStatement: "IfStatement",
                ImportExpression: "ImportExpression",
                ImportDeclaration: "ImportDeclaration",
                ImportDefaultSpecifier: "ImportDefaultSpecifier",
                ImportNamespaceSpecifier: "ImportNamespaceSpecifier",
                ImportSpecifier: "ImportSpecifier",
                Literal: "Literal",
                LabeledStatement: "LabeledStatement",
                LogicalExpression: "LogicalExpression",
                MemberExpression: "MemberExpression",
                MetaProperty: "MetaProperty",
                MethodDefinition: "MethodDefinition",
                ModuleSpecifier: "ModuleSpecifier",
                NewExpression: "NewExpression",
                ObjectExpression: "ObjectExpression",
                ObjectPattern: "ObjectPattern",
                Program: "Program",
                Property: "Property",
                RestElement: "RestElement",
                ReturnStatement: "ReturnStatement",
                SequenceExpression: "SequenceExpression",
                SpreadElement: "SpreadElement",
                Super: "Super",
                SwitchStatement: "SwitchStatement",
                SwitchCase: "SwitchCase",
                TaggedTemplateExpression: "TaggedTemplateExpression",
                TemplateElement: "TemplateElement",
                TemplateLiteral: "TemplateLiteral",
                ThisExpression: "ThisExpression",
                ThrowStatement: "ThrowStatement",
                TryStatement: "TryStatement",
                UnaryExpression: "UnaryExpression",
                UpdateExpression: "UpdateExpression",
                VariableDeclaration: "VariableDeclaration",
                VariableDeclarator: "VariableDeclarator",
                WhileStatement: "WhileStatement",
                WithStatement: "WithStatement",
                YieldExpression: "YieldExpression"
            },
            a = {
                AssignmentExpression: ["left", "right"],
                AssignmentPattern: ["left", "right"],
                ArrayExpression: ["elements"],
                ArrayPattern: ["elements"],
                ArrowFunctionExpression: ["params", "body"],
                AwaitExpression: ["argument"],
                BlockStatement: ["body"],
                BinaryExpression: ["left", "right"],
                BreakStatement: ["label"],
                CallExpression: ["callee", "arguments"],
                CatchClause: ["param", "body"],
                ChainExpression: ["expression"],
                ClassBody: ["body"],
                ClassDeclaration: ["id", "superClass", "body"],
                ClassExpression: ["id", "superClass", "body"],
                ComprehensionBlock: ["left", "right"],
                ComprehensionExpression: ["blocks", "filter", "body"],
                ConditionalExpression: ["test", "consequent", "alternate"],
                ContinueStatement: ["label"],
                DebuggerStatement: [],
                DirectiveStatement: [],
                DoWhileStatement: ["body", "test"],
                EmptyStatement: [],
                ExportAllDeclaration: ["source"],
                ExportDefaultDeclaration: ["declaration"],
                ExportNamedDeclaration: ["declaration", "specifiers", "source"],
                ExportSpecifier: ["exported", "local"],
                ExpressionStatement: ["expression"],
                ForStatement: ["init", "test", "update", "body"],
                ForInStatement: ["left", "right", "body"],
                ForOfStatement: ["left", "right", "body"],
                FunctionDeclaration: ["id", "params", "body"],
                FunctionExpression: ["id", "params", "body"],
                GeneratorExpression: ["blocks", "filter", "body"],
                Identifier: [],
                IfStatement: ["test", "consequent", "alternate"],
                ImportExpression: ["source"],
                ImportDeclaration: ["specifiers", "source"],
                ImportDefaultSpecifier: ["local"],
                ImportNamespaceSpecifier: ["local"],
                ImportSpecifier: ["imported", "local"],
                Literal: [],
                LabeledStatement: ["label", "body"],
                LogicalExpression: ["left", "right"],
                MemberExpression: ["object", "property"],
                MetaProperty: ["meta", "property"],
                MethodDefinition: ["key", "value"],
                ModuleSpecifier: [],
                NewExpression: ["callee", "arguments"],
                ObjectExpression: ["properties"],
                ObjectPattern: ["properties"],
                Program: ["body"],
                Property: ["key", "value"],
                RestElement: ["argument"],
                ReturnStatement: ["argument"],
                SequenceExpression: ["expressions"],
                SpreadElement: ["argument"],
                Super: [],
                SwitchStatement: ["discriminant", "cases"],
                SwitchCase: ["test", "consequent"],
                TaggedTemplateExpression: ["tag", "quasi"],
                TemplateElement: [],
                TemplateLiteral: ["quasis", "expressions"],
                ThisExpression: [],
                ThrowStatement: ["argument"],
                TryStatement: ["block", "handler", "finalizer"],
                UnaryExpression: ["argument"],
                UpdateExpression: ["argument"],
                VariableDeclaration: ["declarations"],
                VariableDeclarator: ["id", "init"],
                WhileStatement: ["test", "body"],
                WithStatement: ["object", "body"],
                YieldExpression: ["argument"]
            },
            i = {
                Break: o = {},
                Skip: l = {},
                Remove: u = {}
            },
            Reference.prototype.replace = function replace(t) {
                this.parent[this.key] = t
            }
            ,
            Reference.prototype.remove = function remove() {
                return Array.isArray(this.parent) ? (this.parent.splice(this.key, 1),
                !0) : (this.replace(null),
                !1)
            }
            ,
            Controller.prototype.path = function path() {
                var t, r, i, a, o;
                function addToPath(t, r) {
                    if (Array.isArray(r))
                        for (i = 0,
                        a = r.length; i < a; ++i)
                            t.push(r[i]);
                    else
                        t.push(r)
                }
                if (!this.__current.path)
                    return null;
                for (o = [],
                t = 2,
                r = this.__leavelist.length; t < r; ++t)
                    addToPath(o, this.__leavelist[t].path);
                return addToPath(o, this.__current.path),
                o
            }
            ,
            Controller.prototype.type = function() {
                return this.current().type || this.__current.wrap
            }
            ,
            Controller.prototype.parents = function parents() {
                var t, r, i;
                for (i = [],
                t = 1,
                r = this.__leavelist.length; t < r; ++t)
                    i.push(this.__leavelist[t].node);
                return i
            }
            ,
            Controller.prototype.current = function current() {
                return this.__current.node
            }
            ,
            Controller.prototype.__execute = function __execute(t, r) {
                var i, a;
                return a = void 0,
                i = this.__current,
                this.__current = r,
                this.__state = null,
                t && (a = t.call(this, r.node, this.__leavelist[this.__leavelist.length - 1].node)),
                this.__current = i,
                a
            }
            ,
            Controller.prototype.notify = function notify(t) {
                this.__state = t
            }
            ,
            Controller.prototype.skip = function() {
                this.notify(l)
            }
            ,
            Controller.prototype.break = function() {
                this.notify(o)
            }
            ,
            Controller.prototype.remove = function() {
                this.notify(u)
            }
            ,
            Controller.prototype.__initialize = function(t, r) {
                this.visitor = r,
                this.root = t,
                this.__worklist = [],
                this.__leavelist = [],
                this.__current = null,
                this.__state = null,
                this.__fallback = null,
                "iteration" === r.fallback ? this.__fallback = Object.keys : "function" == typeof r.fallback && (this.__fallback = r.fallback),
                this.__keys = a,
                r.keys && (this.__keys = Object.assign(Object.create(this.__keys), r.keys))
            }
            ,
            Controller.prototype.traverse = function traverse(t, r) {
                var i, a, u, p, c, d, y, h, m, T, S, g;
                for (this.__initialize(t, r),
                g = {},
                i = this.__worklist,
                a = this.__leavelist,
                i.push(new Element(t,null,null,null)),
                a.push(new Element(null,null,null,null)); i.length; )
                    if ((u = i.pop()) !== g) {
                        if (u.node) {
                            if (d = this.__execute(r.enter, u),
                            this.__state === o || d === o)
                                return;
                            if (i.push(g),
                            a.push(u),
                            this.__state === l || d === l)
                                continue;
                            if (c = (p = u.node).type || u.wrap,
                            !(T = this.__keys[c])) {
                                if (!this.__fallback)
                                    throw new Error("Unknown node type " + c + ".");
                                T = this.__fallback(p)
                            }
                            for (h = T.length; (h -= 1) >= 0; )
                                if (S = p[y = T[h]])
                                    if (Array.isArray(S)) {
                                        for (m = S.length; (m -= 1) >= 0; )
                                            if (S[m] && !candidateExistsInLeaveList(a, S[m])) {
                                                if (isProperty(c, T[h]))
                                                    u = new Element(S[m],[y, m],"Property",null);
                                                else {
                                                    if (!isNode(S[m]))
                                                        continue;
                                                    u = new Element(S[m],[y, m],null,null)
                                                }
                                                i.push(u)
                                            }
                                    } else if (isNode(S)) {
                                        if (candidateExistsInLeaveList(a, S))
                                            continue;
                                        i.push(new Element(S,y,null,null))
                                    }
                        }
                    } else if (u = a.pop(),
                    d = this.__execute(r.leave, u),
                    this.__state === o || d === o)
                        return
            }
            ,
            Controller.prototype.replace = function replace(t, r) {
                var i, a, p, c, d, y, h, m, T, S, g, b, v;
                function removeElem(t) {
                    var r, a, o, l;
                    if (t.ref.remove())
                        for (a = t.ref.key,
                        l = t.ref.parent,
                        r = i.length; r--; )
                            if ((o = i[r]).ref && o.ref.parent === l) {
                                if (o.ref.key < a)
                                    break;
                                --o.ref.key
                            }
                }
                for (this.__initialize(t, r),
                g = {},
                i = this.__worklist,
                a = this.__leavelist,
                y = new Element(t,null,null,new Reference(b = {
                    root: t
                },"root")),
                i.push(y),
                a.push(y); i.length; )
                    if ((y = i.pop()) !== g) {
                        if (void 0 !== (d = this.__execute(r.enter, y)) && d !== o && d !== l && d !== u && (y.ref.replace(d),
                        y.node = d),
                        this.__state !== u && d !== u || (removeElem(y),
                        y.node = null),
                        this.__state === o || d === o)
                            return b.root;
                        if ((p = y.node) && (i.push(g),
                        a.push(y),
                        this.__state !== l && d !== l)) {
                            if (c = p.type || y.wrap,
                            !(T = this.__keys[c])) {
                                if (!this.__fallback)
                                    throw new Error("Unknown node type " + c + ".");
                                T = this.__fallback(p)
                            }
                            for (h = T.length; (h -= 1) >= 0; )
                                if (S = p[v = T[h]])
                                    if (Array.isArray(S)) {
                                        for (m = S.length; (m -= 1) >= 0; )
                                            if (S[m]) {
                                                if (isProperty(c, T[h]))
                                                    y = new Element(S[m],[v, m],"Property",new Reference(S,m));
                                                else {
                                                    if (!isNode(S[m]))
                                                        continue;
                                                    y = new Element(S[m],[v, m],null,new Reference(S,m))
                                                }
                                                i.push(y)
                                            }
                                    } else
                                        isNode(S) && i.push(new Element(S,v,null,new Reference(p,v)))
                        }
                    } else if (y = a.pop(),
                    void 0 !== (d = this.__execute(r.leave, y)) && d !== o && d !== l && d !== u && y.ref.replace(d),
                    this.__state !== u && d !== u || removeElem(y),
                    this.__state === o || d === o)
                        return b.root;
                return b.root
            }
            ,
            t.Syntax = r,
            t.traverse = traverse,
            t.replace = function replace(t, r) {
                return (new Controller).replace(t, r)
            }
            ,
            t.attachComments = function attachComments(t, r, a) {
                var o, l, u, p, c = [];
                if (!t.range)
                    throw new Error("attachComments needs range information");
                if (!a.length) {
                    if (r.length) {
                        for (u = 0,
                        l = r.length; u < l; u += 1)
                            (o = deepCopy(r[u])).extendedRange = [0, t.range[0]],
                            c.push(o);
                        t.leadingComments = c
                    }
                    return t
                }
                for (u = 0,
                l = r.length; u < l; u += 1)
                    c.push(extendCommentRange(deepCopy(r[u]), a));
                return p = 0,
                traverse(t, {
                    enter: function(t) {
                        for (var r; p < c.length && !((r = c[p]).extendedRange[1] > t.range[0]); )
                            r.extendedRange[1] === t.range[0] ? (t.leadingComments || (t.leadingComments = []),
                            t.leadingComments.push(r),
                            c.splice(p, 1)) : p += 1;
                        return p === c.length ? i.Break : c[p].extendedRange[0] > t.range[1] ? i.Skip : void 0
                    }
                }),
                p = 0,
                traverse(t, {
                    leave: function(t) {
                        for (var r; p < c.length && (r = c[p],
                        !(t.range[1] < r.extendedRange[0])); )
                            t.range[1] === r.extendedRange[0] ? (t.trailingComments || (t.trailingComments = []),
                            t.trailingComments.push(r),
                            c.splice(p, 1)) : p += 1;
                        return p === c.length ? i.Break : c[p].extendedRange[0] > t.range[1] ? i.Skip : void 0
                    }
                }),
                t
            }
            ,
            t.VisitorKeys = a,
            t.VisitorOption = i,
            t.Controller = Controller,
            t.cloneEnvironment = function() {
                return clone({})
            }
            ,
            t
        }(r)
    },
    A27I: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        Object.defineProperty(r, "isIdentifierChar", {
            enumerable: !0,
            get: function() {
                return a.isIdentifierChar
            }
        }),
        Object.defineProperty(r, "isIdentifierName", {
            enumerable: !0,
            get: function() {
                return a.isIdentifierName
            }
        }),
        Object.defineProperty(r, "isIdentifierStart", {
            enumerable: !0,
            get: function() {
                return a.isIdentifierStart
            }
        }),
        Object.defineProperty(r, "isKeyword", {
            enumerable: !0,
            get: function() {
                return o.isKeyword
            }
        }),
        Object.defineProperty(r, "isReservedWord", {
            enumerable: !0,
            get: function() {
                return o.isReservedWord
            }
        }),
        Object.defineProperty(r, "isStrictBindOnlyReservedWord", {
            enumerable: !0,
            get: function() {
                return o.isStrictBindOnlyReservedWord
            }
        }),
        Object.defineProperty(r, "isStrictBindReservedWord", {
            enumerable: !0,
            get: function() {
                return o.isStrictBindReservedWord
            }
        }),
        Object.defineProperty(r, "isStrictReservedWord", {
            enumerable: !0,
            get: function() {
                return o.isStrictReservedWord
            }
        });
        var a = i("4tS7")
          , o = i("EX0z")
    },
    A5Ry: function(t, r, i) {
        "use strict";
        var a = i("TqRt")(i("RIqP"))
          , o = i("aaMo")
          , l = i("QmCO")
          , u = (0,
        o.defineAliasedType)("Miscellaneous");
        u("Noop", {
            visitor: []
        }),
        u("Placeholder", {
            visitor: [],
            builder: ["expectedNode", "name"],
            fields: {
                name: {
                    validate: (0,
                    o.assertNodeType)("Identifier")
                },
                expectedNode: {
                    validate: o.assertOneOf.apply(void 0, (0,
                    a.default)(l.PLACEHOLDERS))
                }
            }
        }),
        u("V8IntrinsicIdentifier", {
            builder: ["name"],
            fields: {
                name: {
                    validate: (0,
                    o.assertValueType)("string")
                }
            }
        })
    },
    "AB3+": function(t, r, i) {
        "use strict";
        function _createForOfIteratorHelper(t, r) {
            var i = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
            if (!i) {
                if (Array.isArray(t) || (i = function _unsupportedIterableToArray(t, r) {
                    if (!t)
                        return;
                    if ("string" == typeof t)
                        return _arrayLikeToArray(t, r);
                    var i = Object.prototype.toString.call(t).slice(8, -1);
                    "Object" === i && t.constructor && (i = t.constructor.name);
                    if ("Map" === i || "Set" === i)
                        return Array.from(t);
                    if ("Arguments" === i || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i))
                        return _arrayLikeToArray(t, r)
                }(t)) || r && t && "number" == typeof t.length) {
                    i && (t = i);
                    var a = 0
                      , o = function F() {};
                    return {
                        s: o,
                        n: function n() {
                            return a >= t.length ? {
                                done: !0
                            } : {
                                done: !1,
                                value: t[a++]
                            }
                        },
                        e: function e(t) {
                            throw t
                        },
                        f: o
                    }
                }
                throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
            }
            var l, u = !0, p = !1;
            return {
                s: function s() {
                    i = i.call(t)
                },
                n: function n() {
                    var t = i.next();
                    return u = t.done,
                    t
                },
                e: function e(t) {
                    p = !0,
                    l = t
                },
                f: function f() {
                    try {
                        u || null == i.return || i.return()
                    } finally {
                        if (p)
                            throw l
                    }
                }
            }
        }
        function _arrayLikeToArray(t, r) {
            (null == r || r > t.length) && (r = t.length);
            for (var i = 0, a = new Array(r); i < r; i++)
                a[i] = t[i];
            return a
        }
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function isPlaceholderType(t, r) {
            if (t === r)
                return !0;
            var i = a.PLACEHOLDERS_ALIAS[t];
            if (i) {
                var o, l = _createForOfIteratorHelper(i);
                try {
                    for (l.s(); !(o = l.n()).done; ) {
                        var u = o.value;
                        if (r === u)
                            return !0
                    }
                } catch (t) {
                    l.e(t)
                } finally {
                    l.f()
                }
            }
            return !1
        }
        ;
        var a = i("UHlb")
    },
    AMU3: function(t, r, i) {
        r.SourceMapGenerator = i("SxUr").SourceMapGenerator,
        r.SourceMapConsumer = i("tXCm").SourceMapConsumer,
        r.SourceNode = i("Q/XA").SourceNode
    },
    AVna: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function toComputedKey(t) {
            var r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : t.key || t.property;
            !t.computed && (0,
            a.isIdentifier)(r) && (r = (0,
            o.stringLiteral)(r.name));
            return r
        }
        ;
        var a = i("FUES")
          , o = i("57mi")
    },
    AaQr: function(t, r, i) {
        "use strict";
        var a = i("TqRt")(i("cDf5"));
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function isNodesEquivalent(t, r) {
            if ("object" !== (0,
            a.default)(t) || "object" !== (0,
            a.default)(r) || null == t || null == r)
                return t === r;
            if (t.type !== r.type)
                return !1;
            for (var i = Object.keys(o.NODE_FIELDS[t.type] || t.type), l = o.VISITOR_KEYS[t.type], u = 0, p = i; u < p.length; u++) {
                var c = p[u];
                if ((0,
                a.default)(t[c]) !== (0,
                a.default)(r[c]))
                    return !1;
                if (null != t[c] || null != r[c]) {
                    if (null == t[c] || null == r[c])
                        return !1;
                    if (Array.isArray(t[c])) {
                        if (!Array.isArray(r[c]))
                            return !1;
                        if (t[c].length !== r[c].length)
                            return !1;
                        for (var d = 0; d < t[c].length; d++)
                            if (!isNodesEquivalent(t[c][d], r[c][d]))
                                return !1
                    } else if ("object" !== (0,
                    a.default)(t[c]) || null != l && l.includes(c)) {
                        if (!isNodesEquivalent(t[c], r[c]))
                            return !1
                    } else
                        for (var y = 0, h = Object.keys(t[c]); y < h.length; y++) {
                            var m = h[y];
                            if (t[c][m] !== r[c][m])
                                return !1
                        }
                }
            }
            return !0
        }
        ;
        var o = i("Resm")
    },
    Aacy: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function clone(t) {
            return (0,
            a.default)(t, !1)
        }
        ;
        var a = i("aHlp")
    },
    AfzR: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function isVar(t) {
            return (0,
            a.isVariableDeclaration)(t, {
                kind: "var"
            }) && !t[o.BLOCK_SCOPED_SYMBOL]
        }
        ;
        var a = i("pbIU")
          , o = i("M7ys")
    },
    Aniq: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function isValidIdentifier(t) {
            var r = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
            if ("string" != typeof t)
                return !1;
            if (r && ((0,
            a.isKeyword)(t) || (0,
            a.isStrictReservedWord)(t, !0)))
                return !1;
            return (0,
            a.isIdentifierName)(t)
        }
        ;
        var a = i("KPS7")
    },
    Ax53: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function toBindingIdentifierName(t) {
            "eval" !== (t = (0,
            a.default)(t)) && "arguments" !== t || (t = "_" + t);
            return t
        }
        ;
        var a = i("z1ss")
    },
    AzTl: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function createTypeAnnotationBasedOnTypeof(t) {
            if ("string" === t)
                return (0,
                a.stringTypeAnnotation)();
            if ("number" === t)
                return (0,
                a.numberTypeAnnotation)();
            if ("undefined" === t)
                return (0,
                a.voidTypeAnnotation)();
            if ("boolean" === t)
                return (0,
                a.booleanTypeAnnotation)();
            if ("function" === t)
                return (0,
                a.genericTypeAnnotation)((0,
                a.identifier)("Function"));
            if ("object" === t)
                return (0,
                a.genericTypeAnnotation)((0,
                a.identifier)("Object"));
            if ("symbol" === t)
                return (0,
                a.genericTypeAnnotation)((0,
                a.identifier)("Symbol"));
            if ("bigint" === t)
                return (0,
                a.anyTypeAnnotation)();
            throw new Error("Invalid typeof value: " + t)
        }
        ;
        var a = i("57mi")
    },
    B17m: function(t, r) {},
    B3XP: function(t, r, i) {
        var a = i("5kYL")
          , o = i("91HG")
          , l = {};
        Object.keys(a).forEach((function(t) {
            l[t] = {},
            Object.defineProperty(l[t], "channels", {
                value: a[t].channels
            }),
            Object.defineProperty(l[t], "labels", {
                value: a[t].labels
            });
            var r = o(t);
            Object.keys(r).forEach((function(i) {
                var a = r[i];
                l[t][i] = function wrapRounded(t) {
                    var wrappedFn = function(r) {
                        if (null == r)
                            return r;
                        arguments.length > 1 && (r = Array.prototype.slice.call(arguments));
                        var i = t(r);
                        if ("object" == typeof i)
                            for (var a = i.length, o = 0; o < a; o++)
                                i[o] = Math.round(i[o]);
                        return i
                    };
                    return "conversion"in t && (wrappedFn.conversion = t.conversion),
                    wrappedFn
                }(a),
                l[t][i].raw = function wrapRaw(t) {
                    var wrappedFn = function(r) {
                        return null == r ? r : (arguments.length > 1 && (r = Array.prototype.slice.call(arguments)),
                        t(r))
                    };
                    return "conversion"in t && (wrappedFn.conversion = t.conversion),
                    wrappedFn
                }(a)
            }
            ))
        }
        )),
        t.exports = l
    },
    BMrg: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.assertAnyTypeAnnotation = function assertAnyTypeAnnotation(t, r) {
            assert("AnyTypeAnnotation", t, r)
        }
        ,
        r.assertArgumentPlaceholder = function assertArgumentPlaceholder(t, r) {
            assert("ArgumentPlaceholder", t, r)
        }
        ,
        r.assertArrayExpression = function assertArrayExpression(t, r) {
            assert("ArrayExpression", t, r)
        }
        ,
        r.assertArrayPattern = function assertArrayPattern(t, r) {
            assert("ArrayPattern", t, r)
        }
        ,
        r.assertArrayTypeAnnotation = function assertArrayTypeAnnotation(t, r) {
            assert("ArrayTypeAnnotation", t, r)
        }
        ,
        r.assertArrowFunctionExpression = function assertArrowFunctionExpression(t, r) {
            assert("ArrowFunctionExpression", t, r)
        }
        ,
        r.assertAssignmentExpression = function assertAssignmentExpression(t, r) {
            assert("AssignmentExpression", t, r)
        }
        ,
        r.assertAssignmentPattern = function assertAssignmentPattern(t, r) {
            assert("AssignmentPattern", t, r)
        }
        ,
        r.assertAwaitExpression = function assertAwaitExpression(t, r) {
            assert("AwaitExpression", t, r)
        }
        ,
        r.assertBigIntLiteral = function assertBigIntLiteral(t, r) {
            assert("BigIntLiteral", t, r)
        }
        ,
        r.assertBinary = function assertBinary(t, r) {
            assert("Binary", t, r)
        }
        ,
        r.assertBinaryExpression = function assertBinaryExpression(t, r) {
            assert("BinaryExpression", t, r)
        }
        ,
        r.assertBindExpression = function assertBindExpression(t, r) {
            assert("BindExpression", t, r)
        }
        ,
        r.assertBlock = function assertBlock(t, r) {
            assert("Block", t, r)
        }
        ,
        r.assertBlockParent = function assertBlockParent(t, r) {
            assert("BlockParent", t, r)
        }
        ,
        r.assertBlockStatement = function assertBlockStatement(t, r) {
            assert("BlockStatement", t, r)
        }
        ,
        r.assertBooleanLiteral = function assertBooleanLiteral(t, r) {
            assert("BooleanLiteral", t, r)
        }
        ,
        r.assertBooleanLiteralTypeAnnotation = function assertBooleanLiteralTypeAnnotation(t, r) {
            assert("BooleanLiteralTypeAnnotation", t, r)
        }
        ,
        r.assertBooleanTypeAnnotation = function assertBooleanTypeAnnotation(t, r) {
            assert("BooleanTypeAnnotation", t, r)
        }
        ,
        r.assertBreakStatement = function assertBreakStatement(t, r) {
            assert("BreakStatement", t, r)
        }
        ,
        r.assertCallExpression = function assertCallExpression(t, r) {
            assert("CallExpression", t, r)
        }
        ,
        r.assertCatchClause = function assertCatchClause(t, r) {
            assert("CatchClause", t, r)
        }
        ,
        r.assertClass = function assertClass(t, r) {
            assert("Class", t, r)
        }
        ,
        r.assertClassBody = function assertClassBody(t, r) {
            assert("ClassBody", t, r)
        }
        ,
        r.assertClassDeclaration = function assertClassDeclaration(t, r) {
            assert("ClassDeclaration", t, r)
        }
        ,
        r.assertClassExpression = function assertClassExpression(t, r) {
            assert("ClassExpression", t, r)
        }
        ,
        r.assertClassImplements = function assertClassImplements(t, r) {
            assert("ClassImplements", t, r)
        }
        ,
        r.assertClassMethod = function assertClassMethod(t, r) {
            assert("ClassMethod", t, r)
        }
        ,
        r.assertClassPrivateMethod = function assertClassPrivateMethod(t, r) {
            assert("ClassPrivateMethod", t, r)
        }
        ,
        r.assertClassPrivateProperty = function assertClassPrivateProperty(t, r) {
            assert("ClassPrivateProperty", t, r)
        }
        ,
        r.assertClassProperty = function assertClassProperty(t, r) {
            assert("ClassProperty", t, r)
        }
        ,
        r.assertCompletionStatement = function assertCompletionStatement(t, r) {
            assert("CompletionStatement", t, r)
        }
        ,
        r.assertConditional = function assertConditional(t, r) {
            assert("Conditional", t, r)
        }
        ,
        r.assertConditionalExpression = function assertConditionalExpression(t, r) {
            assert("ConditionalExpression", t, r)
        }
        ,
        r.assertContinueStatement = function assertContinueStatement(t, r) {
            assert("ContinueStatement", t, r)
        }
        ,
        r.assertDebuggerStatement = function assertDebuggerStatement(t, r) {
            assert("DebuggerStatement", t, r)
        }
        ,
        r.assertDecimalLiteral = function assertDecimalLiteral(t, r) {
            assert("DecimalLiteral", t, r)
        }
        ,
        r.assertDeclaration = function assertDeclaration(t, r) {
            assert("Declaration", t, r)
        }
        ,
        r.assertDeclareClass = function assertDeclareClass(t, r) {
            assert("DeclareClass", t, r)
        }
        ,
        r.assertDeclareExportAllDeclaration = function assertDeclareExportAllDeclaration(t, r) {
            assert("DeclareExportAllDeclaration", t, r)
        }
        ,
        r.assertDeclareExportDeclaration = function assertDeclareExportDeclaration(t, r) {
            assert("DeclareExportDeclaration", t, r)
        }
        ,
        r.assertDeclareFunction = function assertDeclareFunction(t, r) {
            assert("DeclareFunction", t, r)
        }
        ,
        r.assertDeclareInterface = function assertDeclareInterface(t, r) {
            assert("DeclareInterface", t, r)
        }
        ,
        r.assertDeclareModule = function assertDeclareModule(t, r) {
            assert("DeclareModule", t, r)
        }
        ,
        r.assertDeclareModuleExports = function assertDeclareModuleExports(t, r) {
            assert("DeclareModuleExports", t, r)
        }
        ,
        r.assertDeclareOpaqueType = function assertDeclareOpaqueType(t, r) {
            assert("DeclareOpaqueType", t, r)
        }
        ,
        r.assertDeclareTypeAlias = function assertDeclareTypeAlias(t, r) {
            assert("DeclareTypeAlias", t, r)
        }
        ,
        r.assertDeclareVariable = function assertDeclareVariable(t, r) {
            assert("DeclareVariable", t, r)
        }
        ,
        r.assertDeclaredPredicate = function assertDeclaredPredicate(t, r) {
            assert("DeclaredPredicate", t, r)
        }
        ,
        r.assertDecorator = function assertDecorator(t, r) {
            assert("Decorator", t, r)
        }
        ,
        r.assertDirective = function assertDirective(t, r) {
            assert("Directive", t, r)
        }
        ,
        r.assertDirectiveLiteral = function assertDirectiveLiteral(t, r) {
            assert("DirectiveLiteral", t, r)
        }
        ,
        r.assertDoExpression = function assertDoExpression(t, r) {
            assert("DoExpression", t, r)
        }
        ,
        r.assertDoWhileStatement = function assertDoWhileStatement(t, r) {
            assert("DoWhileStatement", t, r)
        }
        ,
        r.assertEmptyStatement = function assertEmptyStatement(t, r) {
            assert("EmptyStatement", t, r)
        }
        ,
        r.assertEmptyTypeAnnotation = function assertEmptyTypeAnnotation(t, r) {
            assert("EmptyTypeAnnotation", t, r)
        }
        ,
        r.assertEnumBody = function assertEnumBody(t, r) {
            assert("EnumBody", t, r)
        }
        ,
        r.assertEnumBooleanBody = function assertEnumBooleanBody(t, r) {
            assert("EnumBooleanBody", t, r)
        }
        ,
        r.assertEnumBooleanMember = function assertEnumBooleanMember(t, r) {
            assert("EnumBooleanMember", t, r)
        }
        ,
        r.assertEnumDeclaration = function assertEnumDeclaration(t, r) {
            assert("EnumDeclaration", t, r)
        }
        ,
        r.assertEnumDefaultedMember = function assertEnumDefaultedMember(t, r) {
            assert("EnumDefaultedMember", t, r)
        }
        ,
        r.assertEnumMember = function assertEnumMember(t, r) {
            assert("EnumMember", t, r)
        }
        ,
        r.assertEnumNumberBody = function assertEnumNumberBody(t, r) {
            assert("EnumNumberBody", t, r)
        }
        ,
        r.assertEnumNumberMember = function assertEnumNumberMember(t, r) {
            assert("EnumNumberMember", t, r)
        }
        ,
        r.assertEnumStringBody = function assertEnumStringBody(t, r) {
            assert("EnumStringBody", t, r)
        }
        ,
        r.assertEnumStringMember = function assertEnumStringMember(t, r) {
            assert("EnumStringMember", t, r)
        }
        ,
        r.assertEnumSymbolBody = function assertEnumSymbolBody(t, r) {
            assert("EnumSymbolBody", t, r)
        }
        ,
        r.assertExistsTypeAnnotation = function assertExistsTypeAnnotation(t, r) {
            assert("ExistsTypeAnnotation", t, r)
        }
        ,
        r.assertExportAllDeclaration = function assertExportAllDeclaration(t, r) {
            assert("ExportAllDeclaration", t, r)
        }
        ,
        r.assertExportDeclaration = function assertExportDeclaration(t, r) {
            assert("ExportDeclaration", t, r)
        }
        ,
        r.assertExportDefaultDeclaration = function assertExportDefaultDeclaration(t, r) {
            assert("ExportDefaultDeclaration", t, r)
        }
        ,
        r.assertExportDefaultSpecifier = function assertExportDefaultSpecifier(t, r) {
            assert("ExportDefaultSpecifier", t, r)
        }
        ,
        r.assertExportNamedDeclaration = function assertExportNamedDeclaration(t, r) {
            assert("ExportNamedDeclaration", t, r)
        }
        ,
        r.assertExportNamespaceSpecifier = function assertExportNamespaceSpecifier(t, r) {
            assert("ExportNamespaceSpecifier", t, r)
        }
        ,
        r.assertExportSpecifier = function assertExportSpecifier(t, r) {
            assert("ExportSpecifier", t, r)
        }
        ,
        r.assertExpression = function assertExpression(t, r) {
            assert("Expression", t, r)
        }
        ,
        r.assertExpressionStatement = function assertExpressionStatement(t, r) {
            assert("ExpressionStatement", t, r)
        }
        ,
        r.assertExpressionWrapper = function assertExpressionWrapper(t, r) {
            assert("ExpressionWrapper", t, r)
        }
        ,
        r.assertFile = function assertFile(t, r) {
            assert("File", t, r)
        }
        ,
        r.assertFlow = function assertFlow(t, r) {
            assert("Flow", t, r)
        }
        ,
        r.assertFlowBaseAnnotation = function assertFlowBaseAnnotation(t, r) {
            assert("FlowBaseAnnotation", t, r)
        }
        ,
        r.assertFlowDeclaration = function assertFlowDeclaration(t, r) {
            assert("FlowDeclaration", t, r)
        }
        ,
        r.assertFlowPredicate = function assertFlowPredicate(t, r) {
            assert("FlowPredicate", t, r)
        }
        ,
        r.assertFlowType = function assertFlowType(t, r) {
            assert("FlowType", t, r)
        }
        ,
        r.assertFor = function assertFor(t, r) {
            assert("For", t, r)
        }
        ,
        r.assertForInStatement = function assertForInStatement(t, r) {
            assert("ForInStatement", t, r)
        }
        ,
        r.assertForOfStatement = function assertForOfStatement(t, r) {
            assert("ForOfStatement", t, r)
        }
        ,
        r.assertForStatement = function assertForStatement(t, r) {
            assert("ForStatement", t, r)
        }
        ,
        r.assertForXStatement = function assertForXStatement(t, r) {
            assert("ForXStatement", t, r)
        }
        ,
        r.assertFunction = function assertFunction(t, r) {
            assert("Function", t, r)
        }
        ,
        r.assertFunctionDeclaration = function assertFunctionDeclaration(t, r) {
            assert("FunctionDeclaration", t, r)
        }
        ,
        r.assertFunctionExpression = function assertFunctionExpression(t, r) {
            assert("FunctionExpression", t, r)
        }
        ,
        r.assertFunctionParent = function assertFunctionParent(t, r) {
            assert("FunctionParent", t, r)
        }
        ,
        r.assertFunctionTypeAnnotation = function assertFunctionTypeAnnotation(t, r) {
            assert("FunctionTypeAnnotation", t, r)
        }
        ,
        r.assertFunctionTypeParam = function assertFunctionTypeParam(t, r) {
            assert("FunctionTypeParam", t, r)
        }
        ,
        r.assertGenericTypeAnnotation = function assertGenericTypeAnnotation(t, r) {
            assert("GenericTypeAnnotation", t, r)
        }
        ,
        r.assertIdentifier = function assertIdentifier(t, r) {
            assert("Identifier", t, r)
        }
        ,
        r.assertIfStatement = function assertIfStatement(t, r) {
            assert("IfStatement", t, r)
        }
        ,
        r.assertImmutable = function assertImmutable(t, r) {
            assert("Immutable", t, r)
        }
        ,
        r.assertImport = function assertImport(t, r) {
            assert("Import", t, r)
        }
        ,
        r.assertImportAttribute = function assertImportAttribute(t, r) {
            assert("ImportAttribute", t, r)
        }
        ,
        r.assertImportDeclaration = function assertImportDeclaration(t, r) {
            assert("ImportDeclaration", t, r)
        }
        ,
        r.assertImportDefaultSpecifier = function assertImportDefaultSpecifier(t, r) {
            assert("ImportDefaultSpecifier", t, r)
        }
        ,
        r.assertImportNamespaceSpecifier = function assertImportNamespaceSpecifier(t, r) {
            assert("ImportNamespaceSpecifier", t, r)
        }
        ,
        r.assertImportSpecifier = function assertImportSpecifier(t, r) {
            assert("ImportSpecifier", t, r)
        }
        ,
        r.assertIndexedAccessType = function assertIndexedAccessType(t, r) {
            assert("IndexedAccessType", t, r)
        }
        ,
        r.assertInferredPredicate = function assertInferredPredicate(t, r) {
            assert("InferredPredicate", t, r)
        }
        ,
        r.assertInterfaceDeclaration = function assertInterfaceDeclaration(t, r) {
            assert("InterfaceDeclaration", t, r)
        }
        ,
        r.assertInterfaceExtends = function assertInterfaceExtends(t, r) {
            assert("InterfaceExtends", t, r)
        }
        ,
        r.assertInterfaceTypeAnnotation = function assertInterfaceTypeAnnotation(t, r) {
            assert("InterfaceTypeAnnotation", t, r)
        }
        ,
        r.assertInterpreterDirective = function assertInterpreterDirective(t, r) {
            assert("InterpreterDirective", t, r)
        }
        ,
        r.assertIntersectionTypeAnnotation = function assertIntersectionTypeAnnotation(t, r) {
            assert("IntersectionTypeAnnotation", t, r)
        }
        ,
        r.assertJSX = function assertJSX(t, r) {
            assert("JSX", t, r)
        }
        ,
        r.assertJSXAttribute = function assertJSXAttribute(t, r) {
            assert("JSXAttribute", t, r)
        }
        ,
        r.assertJSXClosingElement = function assertJSXClosingElement(t, r) {
            assert("JSXClosingElement", t, r)
        }
        ,
        r.assertJSXClosingFragment = function assertJSXClosingFragment(t, r) {
            assert("JSXClosingFragment", t, r)
        }
        ,
        r.assertJSXElement = function assertJSXElement(t, r) {
            assert("JSXElement", t, r)
        }
        ,
        r.assertJSXEmptyExpression = function assertJSXEmptyExpression(t, r) {
            assert("JSXEmptyExpression", t, r)
        }
        ,
        r.assertJSXExpressionContainer = function assertJSXExpressionContainer(t, r) {
            assert("JSXExpressionContainer", t, r)
        }
        ,
        r.assertJSXFragment = function assertJSXFragment(t, r) {
            assert("JSXFragment", t, r)
        }
        ,
        r.assertJSXIdentifier = function assertJSXIdentifier(t, r) {
            assert("JSXIdentifier", t, r)
        }
        ,
        r.assertJSXMemberExpression = function assertJSXMemberExpression(t, r) {
            assert("JSXMemberExpression", t, r)
        }
        ,
        r.assertJSXNamespacedName = function assertJSXNamespacedName(t, r) {
            assert("JSXNamespacedName", t, r)
        }
        ,
        r.assertJSXOpeningElement = function assertJSXOpeningElement(t, r) {
            assert("JSXOpeningElement", t, r)
        }
        ,
        r.assertJSXOpeningFragment = function assertJSXOpeningFragment(t, r) {
            assert("JSXOpeningFragment", t, r)
        }
        ,
        r.assertJSXSpreadAttribute = function assertJSXSpreadAttribute(t, r) {
            assert("JSXSpreadAttribute", t, r)
        }
        ,
        r.assertJSXSpreadChild = function assertJSXSpreadChild(t, r) {
            assert("JSXSpreadChild", t, r)
        }
        ,
        r.assertJSXText = function assertJSXText(t, r) {
            assert("JSXText", t, r)
        }
        ,
        r.assertLVal = function assertLVal(t, r) {
            assert("LVal", t, r)
        }
        ,
        r.assertLabeledStatement = function assertLabeledStatement(t, r) {
            assert("LabeledStatement", t, r)
        }
        ,
        r.assertLiteral = function assertLiteral(t, r) {
            assert("Literal", t, r)
        }
        ,
        r.assertLogicalExpression = function assertLogicalExpression(t, r) {
            assert("LogicalExpression", t, r)
        }
        ,
        r.assertLoop = function assertLoop(t, r) {
            assert("Loop", t, r)
        }
        ,
        r.assertMemberExpression = function assertMemberExpression(t, r) {
            assert("MemberExpression", t, r)
        }
        ,
        r.assertMetaProperty = function assertMetaProperty(t, r) {
            assert("MetaProperty", t, r)
        }
        ,
        r.assertMethod = function assertMethod(t, r) {
            assert("Method", t, r)
        }
        ,
        r.assertMiscellaneous = function assertMiscellaneous(t, r) {
            assert("Miscellaneous", t, r)
        }
        ,
        r.assertMixedTypeAnnotation = function assertMixedTypeAnnotation(t, r) {
            assert("MixedTypeAnnotation", t, r)
        }
        ,
        r.assertModuleDeclaration = function assertModuleDeclaration(t, r) {
            assert("ModuleDeclaration", t, r)
        }
        ,
        r.assertModuleExpression = function assertModuleExpression(t, r) {
            assert("ModuleExpression", t, r)
        }
        ,
        r.assertModuleSpecifier = function assertModuleSpecifier(t, r) {
            assert("ModuleSpecifier", t, r)
        }
        ,
        r.assertNewExpression = function assertNewExpression(t, r) {
            assert("NewExpression", t, r)
        }
        ,
        r.assertNoop = function assertNoop(t, r) {
            assert("Noop", t, r)
        }
        ,
        r.assertNullLiteral = function assertNullLiteral(t, r) {
            assert("NullLiteral", t, r)
        }
        ,
        r.assertNullLiteralTypeAnnotation = function assertNullLiteralTypeAnnotation(t, r) {
            assert("NullLiteralTypeAnnotation", t, r)
        }
        ,
        r.assertNullableTypeAnnotation = function assertNullableTypeAnnotation(t, r) {
            assert("NullableTypeAnnotation", t, r)
        }
        ,
        r.assertNumberLiteral = function assertNumberLiteral(t, r) {
            console.trace("The node type NumberLiteral has been renamed to NumericLiteral"),
            assert("NumberLiteral", t, r)
        }
        ,
        r.assertNumberLiteralTypeAnnotation = function assertNumberLiteralTypeAnnotation(t, r) {
            assert("NumberLiteralTypeAnnotation", t, r)
        }
        ,
        r.assertNumberTypeAnnotation = function assertNumberTypeAnnotation(t, r) {
            assert("NumberTypeAnnotation", t, r)
        }
        ,
        r.assertNumericLiteral = function assertNumericLiteral(t, r) {
            assert("NumericLiteral", t, r)
        }
        ,
        r.assertObjectExpression = function assertObjectExpression(t, r) {
            assert("ObjectExpression", t, r)
        }
        ,
        r.assertObjectMember = function assertObjectMember(t, r) {
            assert("ObjectMember", t, r)
        }
        ,
        r.assertObjectMethod = function assertObjectMethod(t, r) {
            assert("ObjectMethod", t, r)
        }
        ,
        r.assertObjectPattern = function assertObjectPattern(t, r) {
            assert("ObjectPattern", t, r)
        }
        ,
        r.assertObjectProperty = function assertObjectProperty(t, r) {
            assert("ObjectProperty", t, r)
        }
        ,
        r.assertObjectTypeAnnotation = function assertObjectTypeAnnotation(t, r) {
            assert("ObjectTypeAnnotation", t, r)
        }
        ,
        r.assertObjectTypeCallProperty = function assertObjectTypeCallProperty(t, r) {
            assert("ObjectTypeCallProperty", t, r)
        }
        ,
        r.assertObjectTypeIndexer = function assertObjectTypeIndexer(t, r) {
            assert("ObjectTypeIndexer", t, r)
        }
        ,
        r.assertObjectTypeInternalSlot = function assertObjectTypeInternalSlot(t, r) {
            assert("ObjectTypeInternalSlot", t, r)
        }
        ,
        r.assertObjectTypeProperty = function assertObjectTypeProperty(t, r) {
            assert("ObjectTypeProperty", t, r)
        }
        ,
        r.assertObjectTypeSpreadProperty = function assertObjectTypeSpreadProperty(t, r) {
            assert("ObjectTypeSpreadProperty", t, r)
        }
        ,
        r.assertOpaqueType = function assertOpaqueType(t, r) {
            assert("OpaqueType", t, r)
        }
        ,
        r.assertOptionalCallExpression = function assertOptionalCallExpression(t, r) {
            assert("OptionalCallExpression", t, r)
        }
        ,
        r.assertOptionalIndexedAccessType = function assertOptionalIndexedAccessType(t, r) {
            assert("OptionalIndexedAccessType", t, r)
        }
        ,
        r.assertOptionalMemberExpression = function assertOptionalMemberExpression(t, r) {
            assert("OptionalMemberExpression", t, r)
        }
        ,
        r.assertParenthesizedExpression = function assertParenthesizedExpression(t, r) {
            assert("ParenthesizedExpression", t, r)
        }
        ,
        r.assertPattern = function assertPattern(t, r) {
            assert("Pattern", t, r)
        }
        ,
        r.assertPatternLike = function assertPatternLike(t, r) {
            assert("PatternLike", t, r)
        }
        ,
        r.assertPipelineBareFunction = function assertPipelineBareFunction(t, r) {
            assert("PipelineBareFunction", t, r)
        }
        ,
        r.assertPipelinePrimaryTopicReference = function assertPipelinePrimaryTopicReference(t, r) {
            assert("PipelinePrimaryTopicReference", t, r)
        }
        ,
        r.assertPipelineTopicExpression = function assertPipelineTopicExpression(t, r) {
            assert("PipelineTopicExpression", t, r)
        }
        ,
        r.assertPlaceholder = function assertPlaceholder(t, r) {
            assert("Placeholder", t, r)
        }
        ,
        r.assertPrivate = function assertPrivate(t, r) {
            assert("Private", t, r)
        }
        ,
        r.assertPrivateName = function assertPrivateName(t, r) {
            assert("PrivateName", t, r)
        }
        ,
        r.assertProgram = function assertProgram(t, r) {
            assert("Program", t, r)
        }
        ,
        r.assertProperty = function assertProperty(t, r) {
            assert("Property", t, r)
        }
        ,
        r.assertPureish = function assertPureish(t, r) {
            assert("Pureish", t, r)
        }
        ,
        r.assertQualifiedTypeIdentifier = function assertQualifiedTypeIdentifier(t, r) {
            assert("QualifiedTypeIdentifier", t, r)
        }
        ,
        r.assertRecordExpression = function assertRecordExpression(t, r) {
            assert("RecordExpression", t, r)
        }
        ,
        r.assertRegExpLiteral = function assertRegExpLiteral(t, r) {
            assert("RegExpLiteral", t, r)
        }
        ,
        r.assertRegexLiteral = function assertRegexLiteral(t, r) {
            console.trace("The node type RegexLiteral has been renamed to RegExpLiteral"),
            assert("RegexLiteral", t, r)
        }
        ,
        r.assertRestElement = function assertRestElement(t, r) {
            assert("RestElement", t, r)
        }
        ,
        r.assertRestProperty = function assertRestProperty(t, r) {
            console.trace("The node type RestProperty has been renamed to RestElement"),
            assert("RestProperty", t, r)
        }
        ,
        r.assertReturnStatement = function assertReturnStatement(t, r) {
            assert("ReturnStatement", t, r)
        }
        ,
        r.assertScopable = function assertScopable(t, r) {
            assert("Scopable", t, r)
        }
        ,
        r.assertSequenceExpression = function assertSequenceExpression(t, r) {
            assert("SequenceExpression", t, r)
        }
        ,
        r.assertSpreadElement = function assertSpreadElement(t, r) {
            assert("SpreadElement", t, r)
        }
        ,
        r.assertSpreadProperty = function assertSpreadProperty(t, r) {
            console.trace("The node type SpreadProperty has been renamed to SpreadElement"),
            assert("SpreadProperty", t, r)
        }
        ,
        r.assertStandardized = function assertStandardized(t, r) {
            assert("Standardized", t, r)
        }
        ,
        r.assertStatement = function assertStatement(t, r) {
            assert("Statement", t, r)
        }
        ,
        r.assertStaticBlock = function assertStaticBlock(t, r) {
            assert("StaticBlock", t, r)
        }
        ,
        r.assertStringLiteral = function assertStringLiteral(t, r) {
            assert("StringLiteral", t, r)
        }
        ,
        r.assertStringLiteralTypeAnnotation = function assertStringLiteralTypeAnnotation(t, r) {
            assert("StringLiteralTypeAnnotation", t, r)
        }
        ,
        r.assertStringTypeAnnotation = function assertStringTypeAnnotation(t, r) {
            assert("StringTypeAnnotation", t, r)
        }
        ,
        r.assertSuper = function assertSuper(t, r) {
            assert("Super", t, r)
        }
        ,
        r.assertSwitchCase = function assertSwitchCase(t, r) {
            assert("SwitchCase", t, r)
        }
        ,
        r.assertSwitchStatement = function assertSwitchStatement(t, r) {
            assert("SwitchStatement", t, r)
        }
        ,
        r.assertSymbolTypeAnnotation = function assertSymbolTypeAnnotation(t, r) {
            assert("SymbolTypeAnnotation", t, r)
        }
        ,
        r.assertTSAnyKeyword = function assertTSAnyKeyword(t, r) {
            assert("TSAnyKeyword", t, r)
        }
        ,
        r.assertTSArrayType = function assertTSArrayType(t, r) {
            assert("TSArrayType", t, r)
        }
        ,
        r.assertTSAsExpression = function assertTSAsExpression(t, r) {
            assert("TSAsExpression", t, r)
        }
        ,
        r.assertTSBaseType = function assertTSBaseType(t, r) {
            assert("TSBaseType", t, r)
        }
        ,
        r.assertTSBigIntKeyword = function assertTSBigIntKeyword(t, r) {
            assert("TSBigIntKeyword", t, r)
        }
        ,
        r.assertTSBooleanKeyword = function assertTSBooleanKeyword(t, r) {
            assert("TSBooleanKeyword", t, r)
        }
        ,
        r.assertTSCallSignatureDeclaration = function assertTSCallSignatureDeclaration(t, r) {
            assert("TSCallSignatureDeclaration", t, r)
        }
        ,
        r.assertTSConditionalType = function assertTSConditionalType(t, r) {
            assert("TSConditionalType", t, r)
        }
        ,
        r.assertTSConstructSignatureDeclaration = function assertTSConstructSignatureDeclaration(t, r) {
            assert("TSConstructSignatureDeclaration", t, r)
        }
        ,
        r.assertTSConstructorType = function assertTSConstructorType(t, r) {
            assert("TSConstructorType", t, r)
        }
        ,
        r.assertTSDeclareFunction = function assertTSDeclareFunction(t, r) {
            assert("TSDeclareFunction", t, r)
        }
        ,
        r.assertTSDeclareMethod = function assertTSDeclareMethod(t, r) {
            assert("TSDeclareMethod", t, r)
        }
        ,
        r.assertTSEntityName = function assertTSEntityName(t, r) {
            assert("TSEntityName", t, r)
        }
        ,
        r.assertTSEnumDeclaration = function assertTSEnumDeclaration(t, r) {
            assert("TSEnumDeclaration", t, r)
        }
        ,
        r.assertTSEnumMember = function assertTSEnumMember(t, r) {
            assert("TSEnumMember", t, r)
        }
        ,
        r.assertTSExportAssignment = function assertTSExportAssignment(t, r) {
            assert("TSExportAssignment", t, r)
        }
        ,
        r.assertTSExpressionWithTypeArguments = function assertTSExpressionWithTypeArguments(t, r) {
            assert("TSExpressionWithTypeArguments", t, r)
        }
        ,
        r.assertTSExternalModuleReference = function assertTSExternalModuleReference(t, r) {
            assert("TSExternalModuleReference", t, r)
        }
        ,
        r.assertTSFunctionType = function assertTSFunctionType(t, r) {
            assert("TSFunctionType", t, r)
        }
        ,
        r.assertTSImportEqualsDeclaration = function assertTSImportEqualsDeclaration(t, r) {
            assert("TSImportEqualsDeclaration", t, r)
        }
        ,
        r.assertTSImportType = function assertTSImportType(t, r) {
            assert("TSImportType", t, r)
        }
        ,
        r.assertTSIndexSignature = function assertTSIndexSignature(t, r) {
            assert("TSIndexSignature", t, r)
        }
        ,
        r.assertTSIndexedAccessType = function assertTSIndexedAccessType(t, r) {
            assert("TSIndexedAccessType", t, r)
        }
        ,
        r.assertTSInferType = function assertTSInferType(t, r) {
            assert("TSInferType", t, r)
        }
        ,
        r.assertTSInterfaceBody = function assertTSInterfaceBody(t, r) {
            assert("TSInterfaceBody", t, r)
        }
        ,
        r.assertTSInterfaceDeclaration = function assertTSInterfaceDeclaration(t, r) {
            assert("TSInterfaceDeclaration", t, r)
        }
        ,
        r.assertTSIntersectionType = function assertTSIntersectionType(t, r) {
            assert("TSIntersectionType", t, r)
        }
        ,
        r.assertTSIntrinsicKeyword = function assertTSIntrinsicKeyword(t, r) {
            assert("TSIntrinsicKeyword", t, r)
        }
        ,
        r.assertTSLiteralType = function assertTSLiteralType(t, r) {
            assert("TSLiteralType", t, r)
        }
        ,
        r.assertTSMappedType = function assertTSMappedType(t, r) {
            assert("TSMappedType", t, r)
        }
        ,
        r.assertTSMethodSignature = function assertTSMethodSignature(t, r) {
            assert("TSMethodSignature", t, r)
        }
        ,
        r.assertTSModuleBlock = function assertTSModuleBlock(t, r) {
            assert("TSModuleBlock", t, r)
        }
        ,
        r.assertTSModuleDeclaration = function assertTSModuleDeclaration(t, r) {
            assert("TSModuleDeclaration", t, r)
        }
        ,
        r.assertTSNamedTupleMember = function assertTSNamedTupleMember(t, r) {
            assert("TSNamedTupleMember", t, r)
        }
        ,
        r.assertTSNamespaceExportDeclaration = function assertTSNamespaceExportDeclaration(t, r) {
            assert("TSNamespaceExportDeclaration", t, r)
        }
        ,
        r.assertTSNeverKeyword = function assertTSNeverKeyword(t, r) {
            assert("TSNeverKeyword", t, r)
        }
        ,
        r.assertTSNonNullExpression = function assertTSNonNullExpression(t, r) {
            assert("TSNonNullExpression", t, r)
        }
        ,
        r.assertTSNullKeyword = function assertTSNullKeyword(t, r) {
            assert("TSNullKeyword", t, r)
        }
        ,
        r.assertTSNumberKeyword = function assertTSNumberKeyword(t, r) {
            assert("TSNumberKeyword", t, r)
        }
        ,
        r.assertTSObjectKeyword = function assertTSObjectKeyword(t, r) {
            assert("TSObjectKeyword", t, r)
        }
        ,
        r.assertTSOptionalType = function assertTSOptionalType(t, r) {
            assert("TSOptionalType", t, r)
        }
        ,
        r.assertTSParameterProperty = function assertTSParameterProperty(t, r) {
            assert("TSParameterProperty", t, r)
        }
        ,
        r.assertTSParenthesizedType = function assertTSParenthesizedType(t, r) {
            assert("TSParenthesizedType", t, r)
        }
        ,
        r.assertTSPropertySignature = function assertTSPropertySignature(t, r) {
            assert("TSPropertySignature", t, r)
        }
        ,
        r.assertTSQualifiedName = function assertTSQualifiedName(t, r) {
            assert("TSQualifiedName", t, r)
        }
        ,
        r.assertTSRestType = function assertTSRestType(t, r) {
            assert("TSRestType", t, r)
        }
        ,
        r.assertTSStringKeyword = function assertTSStringKeyword(t, r) {
            assert("TSStringKeyword", t, r)
        }
        ,
        r.assertTSSymbolKeyword = function assertTSSymbolKeyword(t, r) {
            assert("TSSymbolKeyword", t, r)
        }
        ,
        r.assertTSThisType = function assertTSThisType(t, r) {
            assert("TSThisType", t, r)
        }
        ,
        r.assertTSTupleType = function assertTSTupleType(t, r) {
            assert("TSTupleType", t, r)
        }
        ,
        r.assertTSType = function assertTSType(t, r) {
            assert("TSType", t, r)
        }
        ,
        r.assertTSTypeAliasDeclaration = function assertTSTypeAliasDeclaration(t, r) {
            assert("TSTypeAliasDeclaration", t, r)
        }
        ,
        r.assertTSTypeAnnotation = function assertTSTypeAnnotation(t, r) {
            assert("TSTypeAnnotation", t, r)
        }
        ,
        r.assertTSTypeAssertion = function assertTSTypeAssertion(t, r) {
            assert("TSTypeAssertion", t, r)
        }
        ,
        r.assertTSTypeElement = function assertTSTypeElement(t, r) {
            assert("TSTypeElement", t, r)
        }
        ,
        r.assertTSTypeLiteral = function assertTSTypeLiteral(t, r) {
            assert("TSTypeLiteral", t, r)
        }
        ,
        r.assertTSTypeOperator = function assertTSTypeOperator(t, r) {
            assert("TSTypeOperator", t, r)
        }
        ,
        r.assertTSTypeParameter = function assertTSTypeParameter(t, r) {
            assert("TSTypeParameter", t, r)
        }
        ,
        r.assertTSTypeParameterDeclaration = function assertTSTypeParameterDeclaration(t, r) {
            assert("TSTypeParameterDeclaration", t, r)
        }
        ,
        r.assertTSTypeParameterInstantiation = function assertTSTypeParameterInstantiation(t, r) {
            assert("TSTypeParameterInstantiation", t, r)
        }
        ,
        r.assertTSTypePredicate = function assertTSTypePredicate(t, r) {
            assert("TSTypePredicate", t, r)
        }
        ,
        r.assertTSTypeQuery = function assertTSTypeQuery(t, r) {
            assert("TSTypeQuery", t, r)
        }
        ,
        r.assertTSTypeReference = function assertTSTypeReference(t, r) {
            assert("TSTypeReference", t, r)
        }
        ,
        r.assertTSUndefinedKeyword = function assertTSUndefinedKeyword(t, r) {
            assert("TSUndefinedKeyword", t, r)
        }
        ,
        r.assertTSUnionType = function assertTSUnionType(t, r) {
            assert("TSUnionType", t, r)
        }
        ,
        r.assertTSUnknownKeyword = function assertTSUnknownKeyword(t, r) {
            assert("TSUnknownKeyword", t, r)
        }
        ,
        r.assertTSVoidKeyword = function assertTSVoidKeyword(t, r) {
            assert("TSVoidKeyword", t, r)
        }
        ,
        r.assertTaggedTemplateExpression = function assertTaggedTemplateExpression(t, r) {
            assert("TaggedTemplateExpression", t, r)
        }
        ,
        r.assertTemplateElement = function assertTemplateElement(t, r) {
            assert("TemplateElement", t, r)
        }
        ,
        r.assertTemplateLiteral = function assertTemplateLiteral(t, r) {
            assert("TemplateLiteral", t, r)
        }
        ,
        r.assertTerminatorless = function assertTerminatorless(t, r) {
            assert("Terminatorless", t, r)
        }
        ,
        r.assertThisExpression = function assertThisExpression(t, r) {
            assert("ThisExpression", t, r)
        }
        ,
        r.assertThisTypeAnnotation = function assertThisTypeAnnotation(t, r) {
            assert("ThisTypeAnnotation", t, r)
        }
        ,
        r.assertThrowStatement = function assertThrowStatement(t, r) {
            assert("ThrowStatement", t, r)
        }
        ,
        r.assertTopicReference = function assertTopicReference(t, r) {
            assert("TopicReference", t, r)
        }
        ,
        r.assertTryStatement = function assertTryStatement(t, r) {
            assert("TryStatement", t, r)
        }
        ,
        r.assertTupleExpression = function assertTupleExpression(t, r) {
            assert("TupleExpression", t, r)
        }
        ,
        r.assertTupleTypeAnnotation = function assertTupleTypeAnnotation(t, r) {
            assert("TupleTypeAnnotation", t, r)
        }
        ,
        r.assertTypeAlias = function assertTypeAlias(t, r) {
            assert("TypeAlias", t, r)
        }
        ,
        r.assertTypeAnnotation = function assertTypeAnnotation(t, r) {
            assert("TypeAnnotation", t, r)
        }
        ,
        r.assertTypeCastExpression = function assertTypeCastExpression(t, r) {
            assert("TypeCastExpression", t, r)
        }
        ,
        r.assertTypeParameter = function assertTypeParameter(t, r) {
            assert("TypeParameter", t, r)
        }
        ,
        r.assertTypeParameterDeclaration = function assertTypeParameterDeclaration(t, r) {
            assert("TypeParameterDeclaration", t, r)
        }
        ,
        r.assertTypeParameterInstantiation = function assertTypeParameterInstantiation(t, r) {
            assert("TypeParameterInstantiation", t, r)
        }
        ,
        r.assertTypeScript = function assertTypeScript(t, r) {
            assert("TypeScript", t, r)
        }
        ,
        r.assertTypeofTypeAnnotation = function assertTypeofTypeAnnotation(t, r) {
            assert("TypeofTypeAnnotation", t, r)
        }
        ,
        r.assertUnaryExpression = function assertUnaryExpression(t, r) {
            assert("UnaryExpression", t, r)
        }
        ,
        r.assertUnaryLike = function assertUnaryLike(t, r) {
            assert("UnaryLike", t, r)
        }
        ,
        r.assertUnionTypeAnnotation = function assertUnionTypeAnnotation(t, r) {
            assert("UnionTypeAnnotation", t, r)
        }
        ,
        r.assertUpdateExpression = function assertUpdateExpression(t, r) {
            assert("UpdateExpression", t, r)
        }
        ,
        r.assertUserWhitespacable = function assertUserWhitespacable(t, r) {
            assert("UserWhitespacable", t, r)
        }
        ,
        r.assertV8IntrinsicIdentifier = function assertV8IntrinsicIdentifier(t, r) {
            assert("V8IntrinsicIdentifier", t, r)
        }
        ,
        r.assertVariableDeclaration = function assertVariableDeclaration(t, r) {
            assert("VariableDeclaration", t, r)
        }
        ,
        r.assertVariableDeclarator = function assertVariableDeclarator(t, r) {
            assert("VariableDeclarator", t, r)
        }
        ,
        r.assertVariance = function assertVariance(t, r) {
            assert("Variance", t, r)
        }
        ,
        r.assertVoidTypeAnnotation = function assertVoidTypeAnnotation(t, r) {
            assert("VoidTypeAnnotation", t, r)
        }
        ,
        r.assertWhile = function assertWhile(t, r) {
            assert("While", t, r)
        }
        ,
        r.assertWhileStatement = function assertWhileStatement(t, r) {
            assert("WhileStatement", t, r)
        }
        ,
        r.assertWithStatement = function assertWithStatement(t, r) {
            assert("WithStatement", t, r)
        }
        ,
        r.assertYieldExpression = function assertYieldExpression(t, r) {
            assert("YieldExpression", t, r)
        }
        ;
        var a = i("F3vi");
        function assert(t, r, i) {
            if (!(0,
            a.default)(t, r, i))
                throw new Error(`Expected type "${t}" with option ${JSON.stringify(i)}, but instead got "${r.type}".`)
        }
    },
    BohA: function(t, r, i) {
        "use strict";
        var a = i("TqRt")
          , o = a(i("J4zp"))
          , l = a(i("lwsE"))
          , u = a(i("W8MJ"));
        function _createForOfIteratorHelper(t, r) {
            var i = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
            if (!i) {
                if (Array.isArray(t) || (i = function _unsupportedIterableToArray(t, r) {
                    if (!t)
                        return;
                    if ("string" == typeof t)
                        return _arrayLikeToArray(t, r);
                    var i = Object.prototype.toString.call(t).slice(8, -1);
                    "Object" === i && t.constructor && (i = t.constructor.name);
                    if ("Map" === i || "Set" === i)
                        return Array.from(t);
                    if ("Arguments" === i || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i))
                        return _arrayLikeToArray(t, r)
                }(t)) || r && t && "number" == typeof t.length) {
                    i && (t = i);
                    var a = 0
                      , o = function F() {};
                    return {
                        s: o,
                        n: function n() {
                            return a >= t.length ? {
                                done: !0
                            } : {
                                done: !1,
                                value: t[a++]
                            }
                        },
                        e: function e(t) {
                            throw t
                        },
                        f: o
                    }
                }
                throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
            }
            var l, u = !0, p = !1;
            return {
                s: function s() {
                    i = i.call(t)
                },
                n: function n() {
                    var t = i.next();
                    return u = t.done,
                    t
                },
                e: function e(t) {
                    p = !0,
                    l = t
                },
                f: function f() {
                    try {
                        u || null == i.return || i.return()
                    } finally {
                        if (p)
                            throw l
                    }
                }
            }
        }
        function _arrayLikeToArray(t, r) {
            (null == r || r > t.length) && (r = t.length);
            for (var i = 0, a = new Array(r); i < r; i++)
                a[i] = t[i];
            return a
        }
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = void 0;
        var p = i("ZtNB")
          , c = {
            ReferencedIdentifier: function ReferencedIdentifier(t, r) {
                if (!t.isJSXIdentifier() || !p.react.isCompatTag(t.node.name) || t.parentPath.isJSXMemberExpression()) {
                    if ("this" === t.node.name) {
                        var i = t.scope;
                        do {
                            if (i.path.isFunction() && !i.path.isArrowFunctionExpression())
                                break
                        } while (i = i.parent);
                        i && r.breakOnScopePaths.push(i.path)
                    }
                    var a = t.scope.getBinding(t.node.name);
                    if (a) {
                        var o, l = _createForOfIteratorHelper(a.constantViolations);
                        try {
                            for (l.s(); !(o = l.n()).done; ) {
                                if (o.value.scope !== a.path.scope)
                                    return r.mutableBinding = !0,
                                    void t.stop()
                            }
                        } catch (t) {
                            l.e(t)
                        } finally {
                            l.f()
                        }
                        a === r.scope.getBinding(t.node.name) && (r.bindings[t.node.name] = a)
                    }
                }
            }
        }
          , d = function() {
            function PathHoister(t, r) {
                (0,
                l.default)(this, PathHoister),
                this.breakOnScopePaths = void 0,
                this.bindings = void 0,
                this.mutableBinding = void 0,
                this.scopes = void 0,
                this.scope = void 0,
                this.path = void 0,
                this.attachAfter = void 0,
                this.breakOnScopePaths = [],
                this.bindings = {},
                this.mutableBinding = !1,
                this.scopes = [],
                this.scope = r,
                this.path = t,
                this.attachAfter = !1
            }
            return (0,
            u.default)(PathHoister, [{
                key: "isCompatibleScope",
                value: function isCompatibleScope(t) {
                    for (var r = 0, i = Object.keys(this.bindings); r < i.length; r++) {
                        var a = i[r]
                          , o = this.bindings[a];
                        if (!t.bindingIdentifierEquals(a, o.identifier))
                            return !1
                    }
                    return !0
                }
            }, {
                key: "getCompatibleScopes",
                value: function getCompatibleScopes() {
                    var t = this.path.scope;
                    do {
                        if (!this.isCompatibleScope(t))
                            break;
                        if (this.scopes.push(t),
                        this.breakOnScopePaths.indexOf(t.path) >= 0)
                            break
                    } while (t = t.parent)
                }
            }, {
                key: "getAttachmentPath",
                value: function getAttachmentPath() {
                    var t = this._getAttachmentPath();
                    if (t) {
                        var r = t.scope;
                        if (r.path === t && (r = t.scope.parent),
                        r.path.isProgram() || r.path.isFunction())
                            for (var i = 0, a = Object.keys(this.bindings); i < a.length; i++) {
                                var o = a[i];
                                if (r.hasOwnBinding(o)) {
                                    var l = this.bindings[o];
                                    if ("param" !== l.kind && "params" !== l.path.parentKey)
                                        if (this.getAttachmentParentForPath(l.path).key >= t.key) {
                                            this.attachAfter = !0,
                                            t = l.path;
                                            var u, p = _createForOfIteratorHelper(l.constantViolations);
                                            try {
                                                for (p.s(); !(u = p.n()).done; ) {
                                                    var c = u.value;
                                                    this.getAttachmentParentForPath(c).key > t.key && (t = c)
                                                }
                                            } catch (t) {
                                                p.e(t)
                                            } finally {
                                                p.f()
                                            }
                                        }
                                }
                            }
                        return t
                    }
                }
            }, {
                key: "_getAttachmentPath",
                value: function _getAttachmentPath() {
                    var t = this.scopes.pop();
                    if (t)
                        if (t.path.isFunction()) {
                            if (!this.hasOwnParamBindings(t))
                                return this.getNextScopeAttachmentParent();
                            if (this.scope === t)
                                return;
                            for (var r = t.path.get("body").get("body"), i = 0; i < r.length; i++)
                                if (!r[i].node._blockHoist)
                                    return r[i]
                        } else if (t.path.isProgram())
                            return this.getNextScopeAttachmentParent()
                }
            }, {
                key: "getNextScopeAttachmentParent",
                value: function getNextScopeAttachmentParent() {
                    var t = this.scopes.pop();
                    if (t)
                        return this.getAttachmentParentForPath(t.path)
                }
            }, {
                key: "getAttachmentParentForPath",
                value: function getAttachmentParentForPath(t) {
                    do {
                        if (!t.parentPath || Array.isArray(t.container) && t.isStatement())
                            return t
                    } while (t = t.parentPath)
                }
            }, {
                key: "hasOwnParamBindings",
                value: function hasOwnParamBindings(t) {
                    for (var r = 0, i = Object.keys(this.bindings); r < i.length; r++) {
                        var a = i[r];
                        if (t.hasOwnBinding(a)) {
                            var o = this.bindings[a];
                            if ("param" === o.kind && o.constant)
                                return !0
                        }
                    }
                    return !1
                }
            }, {
                key: "run",
                value: function run() {
                    if (this.path.traverse(c, this),
                    !this.mutableBinding) {
                        this.getCompatibleScopes();
                        var t = this.getAttachmentPath();
                        if (t && t.getFunctionParent() !== this.path.getFunctionParent()) {
                            var r = t.scope.generateUidIdentifier("ref")
                              , i = p.variableDeclarator(r, this.path.node)
                              , a = t[this.attachAfter ? "insertAfter" : "insertBefore"]([t.isVariableDeclarator() ? i : p.variableDeclaration("var", [i])])
                              , l = (0,
                            o.default)(a, 1)[0]
                              , u = this.path.parentPath;
                            return u.isJSXElement() && this.path.container === u.node.children && (r = p.jsxExpressionContainer(r)),
                            this.path.replaceWith(p.cloneNode(r)),
                            t.isVariableDeclarator() ? l.get("init") : l.get("declarations.0.init")
                        }
                    }
                }
            }]),
            PathHoister
        }();
        r.default = d
    },
    "C+dp": function(t, r, i) {
        "use strict";
        var a = i("TqRt")
          , o = a(i("7W2i"))
          , l = a(i("a1gu"))
          , u = a(i("Nsbk"))
          , p = a(i("W8MJ"))
          , c = a(i("lwsE"));
        function _createSuper(t) {
            var r = function _isNativeReflectConstruct() {
                if ("undefined" == typeof Reflect || !Reflect.construct)
                    return !1;
                if (Reflect.construct.sham)
                    return !1;
                if ("function" == typeof Proxy)
                    return !0;
                try {
                    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}
                    ))),
                    !0
                } catch (t) {
                    return !1
                }
            }();
            return function _createSuperInternal() {
                var i, a = (0,
                u.default)(t);
                if (r) {
                    var o = (0,
                    u.default)(this).constructor;
                    i = Reflect.construct(a, arguments, o)
                } else
                    i = a.apply(this, arguments);
                return (0,
                l.default)(this, i)
            }
        }
        var d = i("dYsE")
          , y = (0,
        p.default)((function Definition(t, r, i, a, o, l) {
            (0,
            c.default)(this, Definition),
            this.type = t,
            this.name = r,
            this.node = i,
            this.parent = a,
            this.index = o,
            this.kind = l
        }
        ))
          , h = function(t) {
            (0,
            o.default)(ParameterDefinition, t);
            var r = _createSuper(ParameterDefinition);
            function ParameterDefinition(t, i, a, o) {
                var l;
                return (0,
                c.default)(this, ParameterDefinition),
                (l = r.call(this, d.Parameter, t, i, null, a, null)).rest = o,
                l
            }
            return (0,
            p.default)(ParameterDefinition)
        }(y);
        t.exports = {
            ParameterDefinition: h,
            Definition: y
        }
    },
    CuUK: function(t, r, i) {
        "use strict";
        var a = i("TqRt")
          , o = a(i("cDf5"))
          , l = a(i("J4zp"))
          , u = a(i("RIqP"));
        function _createForOfIteratorHelper(t, r) {
            var i = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
            if (!i) {
                if (Array.isArray(t) || (i = function _unsupportedIterableToArray(t, r) {
                    if (!t)
                        return;
                    if ("string" == typeof t)
                        return _arrayLikeToArray(t, r);
                    var i = Object.prototype.toString.call(t).slice(8, -1);
                    "Object" === i && t.constructor && (i = t.constructor.name);
                    if ("Map" === i || "Set" === i)
                        return Array.from(t);
                    if ("Arguments" === i || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i))
                        return _arrayLikeToArray(t, r)
                }(t)) || r && t && "number" == typeof t.length) {
                    i && (t = i);
                    var a = 0
                      , o = function F() {};
                    return {
                        s: o,
                        n: function n() {
                            return a >= t.length ? {
                                done: !0
                            } : {
                                done: !1,
                                value: t[a++]
                            }
                        },
                        e: function e(t) {
                            throw t
                        },
                        f: o
                    }
                }
                throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
            }
            var l, u = !0, p = !1;
            return {
                s: function s() {
                    i = i.call(t)
                },
                n: function n() {
                    var t = i.next();
                    return u = t.done,
                    t
                },
                e: function e(t) {
                    p = !0,
                    l = t
                },
                f: function f() {
                    try {
                        u || null == i.return || i.return()
                    } finally {
                        if (p)
                            throw l
                    }
                }
            }
        }
        function _arrayLikeToArray(t, r) {
            (null == r || r > t.length) && (r = t.length);
            for (var i = 0, a = new Array(r); i < r; i++)
                a[i] = t[i];
            return a
        }
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.insertBefore = function insertBefore(t) {
            this._assertUnremoved();
            var r = this._verifyNodeList(t)
              , i = this.parentPath;
            if (i.isExpressionStatement() || i.isLabeledStatement() || i.isExportNamedDeclaration() || i.isExportDefaultDeclaration() && this.isDeclaration())
                return i.insertBefore(r);
            if (this.isNodeType("Expression") && !this.isJSXElement() || i.isForStatement() && "init" === this.key)
                return this.node && r.push(this.node),
                this.replaceExpressionWithStatements(r);
            if (Array.isArray(this.container))
                return this._containerInsertBefore(r);
            if (this.isStatementOrBlock()) {
                var a = this.node
                  , o = a && (!this.isExpressionStatement() || null != a.expression);
                return this.replaceWith(y.blockStatement(o ? [a] : [])),
                this.unshiftContainer("body", r)
            }
            throw new Error("We don't know what to do with this node type. We were previously a Statement but we can't fit in here?")
        }
        ,
        r._containerInsert = function _containerInsert(t, r) {
            var i;
            this.updateSiblingKeys(t, r.length);
            var a = [];
            (i = this.container).splice.apply(i, [t, 0].concat((0,
            u.default)(r)));
            for (var o = 0; o < r.length; o++) {
                var l = t + o
                  , p = this.getSibling(l);
                a.push(p),
                this.context && this.context.queue && p.pushContext(this.context)
            }
            for (var c = this._getQueueContexts(), d = 0, y = a; d < y.length; d++) {
                var h = y[d];
                h.setScope(),
                h.debug("Inserted.");
                var m, T = _createForOfIteratorHelper(c);
                try {
                    for (T.s(); !(m = T.n()).done; ) {
                        m.value.maybeQueue(h, !0)
                    }
                } catch (t) {
                    T.e(t)
                } finally {
                    T.f()
                }
            }
            return a
        }
        ,
        r._containerInsertBefore = function _containerInsertBefore(t) {
            return this._containerInsert(this.key, t)
        }
        ,
        r._containerInsertAfter = function _containerInsertAfter(t) {
            return this._containerInsert(this.key + 1, t)
        }
        ,
        r.insertAfter = function insertAfter(t) {
            this._assertUnremoved();
            var r = this._verifyNodeList(t)
              , i = this.parentPath;
            if (i.isExpressionStatement() || i.isLabeledStatement() || i.isExportNamedDeclaration() || i.isExportDefaultDeclaration() && this.isDeclaration())
                return i.insertAfter(r.map((function(t) {
                    return y.isExpression(t) ? y.expressionStatement(t) : t
                }
                )));
            if (this.isNodeType("Expression") && !this.isJSXElement() && !i.isJSXElement() || i.isForStatement() && "init" === this.key) {
                if (this.node) {
                    var a = this.node
                      , o = this.scope;
                    if (o.path.isPattern())
                        return y.assertExpression(a),
                        this.replaceWith(y.callExpression(y.arrowFunctionExpression([], a), [])),
                        this.get("callee.body").insertAfter(r),
                        [this];
                    i.isMethod({
                        computed: !0,
                        key: a
                    }) && (o = o.parent);
                    var l = o.generateDeclaredUidIdentifier();
                    r.unshift(y.expressionStatement(y.assignmentExpression("=", y.cloneNode(l), a))),
                    r.push(y.expressionStatement(y.cloneNode(l)))
                }
                return this.replaceExpressionWithStatements(r)
            }
            if (Array.isArray(this.container))
                return this._containerInsertAfter(r);
            if (this.isStatementOrBlock()) {
                var u = this.node
                  , p = u && (!this.isExpressionStatement() || null != u.expression);
                return this.replaceWith(y.blockStatement(p ? [u] : [])),
                this.pushContainer("body", r)
            }
            throw new Error("We don't know what to do with this node type. We were previously a Statement but we can't fit in here?")
        }
        ,
        r.updateSiblingKeys = function updateSiblingKeys(t, r) {
            if (!this.parent)
                return;
            var i, a = _createForOfIteratorHelper(p.path.get(this.parent));
            try {
                for (a.s(); !(i = a.n()).done; ) {
                    var o = (0,
                    l.default)(i.value, 2)[1];
                    o.key >= t && (o.key += r)
                }
            } catch (t) {
                a.e(t)
            } finally {
                a.f()
            }
        }
        ,
        r._verifyNodeList = function _verifyNodeList(t) {
            if (!t)
                return [];
            Array.isArray(t) || (t = [t]);
            for (var r = 0; r < t.length; r++) {
                var i = t[r]
                  , a = void 0;
                if (i ? "object" !== (0,
                o.default)(i) ? a = "contains a non-object node" : i.type ? i instanceof d.default && (a = "has a NodePath when it expected a raw object") : a = "without a type" : a = "has falsy node",
                a) {
                    var l = Array.isArray(i) ? "array" : (0,
                    o.default)(i);
                    throw new Error("Node list ".concat(a, " with the index of ").concat(r, " and type of ").concat(l))
                }
            }
            return t
        }
        ,
        r.unshiftContainer = function unshiftContainer(t, r) {
            return this._assertUnremoved(),
            r = this._verifyNodeList(r),
            d.default.get({
                parentPath: this,
                parent: this.node,
                container: this.node[t],
                listKey: t,
                key: 0
            }).setContext(this.context)._containerInsertBefore(r)
        }
        ,
        r.pushContainer = function pushContainer(t, r) {
            this._assertUnremoved();
            var i = this._verifyNodeList(r)
              , a = this.node[t];
            return d.default.get({
                parentPath: this,
                parent: this.node,
                container: a,
                listKey: t,
                key: a.length
            }).setContext(this.context).replaceWithMultiple(i)
        }
        ,
        r.hoist = function hoist() {
            var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.scope
              , r = new c.default(this,t);
            return r.run()
        }
        ;
        var p = i("qMwM")
          , c = i("BohA")
          , d = i("MBGo")
          , y = i("ZtNB")
    },
    "D+ka": function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function validate(t, r, i) {
            if (!t)
                return;
            var o = a.NODE_FIELDS[t.type];
            if (!o)
                return;
            var l = o[r];
            validateField(t, r, i, l),
            validateChild(t, r, i)
        }
        ,
        r.validateChild = validateChild,
        r.validateField = validateField;
        var a = i("UHlb");
        function validateField(t, r, i, a) {
            null != a && a.validate && (a.optional && null == i || a.validate(t, r, i))
        }
        function validateChild(t, r, i) {
            if (null != i) {
                var o = a.NODE_PARENT_VALIDATIONS[i.type];
                o && o(t, r, i)
            }
        }
    },
    D0vZ: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.ForAwaitStatement = r.NumericLiteralTypeAnnotation = r.ExistentialTypeParam = r.SpreadProperty = r.RestProperty = r.Flow = r.Pure = r.Generated = r.User = r.Var = r.BlockScoped = r.Referenced = r.Scope = r.Expression = r.Statement = r.BindingIdentifier = r.ReferencedMemberExpression = r.ReferencedIdentifier = void 0;
        var a = i("ZtNB")
          , o = {
            types: ["Identifier", "JSXIdentifier"],
            checkPath: function checkPath(t, r) {
                var i = t.node
                  , o = t.parent;
                if (!a.isIdentifier(i, r) && !a.isJSXMemberExpression(o, r)) {
                    if (!a.isJSXIdentifier(i, r))
                        return !1;
                    if (a.react.isCompatTag(i.name))
                        return !1
                }
                return a.isReferenced(i, o, t.parentPath.parent)
            }
        };
        r.ReferencedIdentifier = o;
        var l = {
            types: ["MemberExpression"],
            checkPath: function checkPath(t) {
                var r = t.node
                  , i = t.parent;
                return a.isMemberExpression(r) && a.isReferenced(r, i)
            }
        };
        r.ReferencedMemberExpression = l;
        var u = {
            types: ["Identifier"],
            checkPath: function checkPath(t) {
                var r = t.node
                  , i = t.parent
                  , o = t.parentPath.parent;
                return a.isIdentifier(r) && a.isBinding(r, i, o)
            }
        };
        r.BindingIdentifier = u;
        var p = {
            types: ["Statement"],
            checkPath: function checkPath(t) {
                var r = t.node
                  , i = t.parent;
                if (a.isStatement(r)) {
                    if (a.isVariableDeclaration(r)) {
                        if (a.isForXStatement(i, {
                            left: r
                        }))
                            return !1;
                        if (a.isForStatement(i, {
                            init: r
                        }))
                            return !1
                    }
                    return !0
                }
                return !1
            }
        };
        r.Statement = p;
        var c = {
            types: ["Expression"],
            checkPath: function checkPath(t) {
                return t.isIdentifier() ? t.isReferencedIdentifier() : a.isExpression(t.node)
            }
        };
        r.Expression = c;
        var d = {
            types: ["Scopable", "Pattern"],
            checkPath: function checkPath(t) {
                return a.isScope(t.node, t.parent)
            }
        };
        r.Scope = d;
        var y = {
            checkPath: function checkPath(t) {
                return a.isReferenced(t.node, t.parent)
            }
        };
        r.Referenced = y;
        var h = {
            checkPath: function checkPath(t) {
                return a.isBlockScoped(t.node)
            }
        };
        r.BlockScoped = h;
        var m = {
            types: ["VariableDeclaration"],
            checkPath: function checkPath(t) {
                return a.isVar(t.node)
            }
        };
        r.Var = m;
        r.User = {
            checkPath: function checkPath(t) {
                return t.node && !!t.node.loc
            }
        };
        r.Generated = {
            checkPath: function checkPath(t) {
                return !t.isUser()
            }
        };
        r.Pure = {
            checkPath: function checkPath(t, r) {
                return t.scope.isPure(t.node, r)
            }
        };
        var T = {
            types: ["Flow", "ImportDeclaration", "ExportDeclaration", "ImportSpecifier"],
            checkPath: function checkPath(t) {
                var r = t.node;
                return !!a.isFlow(r) || (a.isImportDeclaration(r) ? "type" === r.importKind || "typeof" === r.importKind : a.isExportDeclaration(r) ? "type" === r.exportKind : !!a.isImportSpecifier(r) && ("type" === r.importKind || "typeof" === r.importKind))
            }
        };
        r.Flow = T;
        r.RestProperty = {
            types: ["RestElement"],
            checkPath: function checkPath(t) {
                return t.parentPath && t.parentPath.isObjectPattern()
            }
        };
        r.SpreadProperty = {
            types: ["RestElement"],
            checkPath: function checkPath(t) {
                return t.parentPath && t.parentPath.isObjectExpression()
            }
        };
        r.ExistentialTypeParam = {
            types: ["ExistsTypeAnnotation"]
        };
        r.NumericLiteralTypeAnnotation = {
            types: ["NumberLiteralTypeAnnotation"]
        };
        r.ForAwaitStatement = {
            types: ["ForOfStatement"],
            checkPath: function checkPath(t) {
                return !0 === t.node.await
            }
        }
    },
    DW02: function(t, r, i) {
        var a = i("mObf");
        r.encode = function base64VLQ_encode(t) {
            var r, i = "", o = function toVLQSigned(t) {
                return t < 0 ? 1 + (-t << 1) : 0 + (t << 1)
            }(t);
            do {
                r = 31 & o,
                (o >>>= 5) > 0 && (r |= 32),
                i += a.encode(r)
            } while (o > 0);
            return i
        }
        ,
        r.decode = function base64VLQ_decode(t, r, i) {
            var o, l, u = t.length, p = 0, c = 0;
            do {
                if (r >= u)
                    throw new Error("Expected more digits in base 64 VLQ value.");
                if (-1 === (l = a.decode(t.charCodeAt(r++))))
                    throw new Error("Invalid base64 digit: " + t.charAt(r - 1));
                o = !!(32 & l),
                p += (l &= 31) << c,
                c += 5
            } while (o);
            i.value = function fromVLQSigned(t) {
                var r = t >> 1;
                return 1 == (1 & t) ? -r : r
            }(p),
            i.rest = r
        }
    },
    Df4y: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function inherit(t, r, i) {
            r && i && (r[t] = Array.from(new Set([].concat(r[t], i[t]).filter(Boolean))))
        }
    },
    Dku2: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.assertAnyTypeAnnotation = function assertAnyTypeAnnotation(t, r) {
            assert("AnyTypeAnnotation", t, r)
        }
        ,
        r.assertArgumentPlaceholder = function assertArgumentPlaceholder(t, r) {
            assert("ArgumentPlaceholder", t, r)
        }
        ,
        r.assertArrayExpression = function assertArrayExpression(t, r) {
            assert("ArrayExpression", t, r)
        }
        ,
        r.assertArrayPattern = function assertArrayPattern(t, r) {
            assert("ArrayPattern", t, r)
        }
        ,
        r.assertArrayTypeAnnotation = function assertArrayTypeAnnotation(t, r) {
            assert("ArrayTypeAnnotation", t, r)
        }
        ,
        r.assertArrowFunctionExpression = function assertArrowFunctionExpression(t, r) {
            assert("ArrowFunctionExpression", t, r)
        }
        ,
        r.assertAssignmentExpression = function assertAssignmentExpression(t, r) {
            assert("AssignmentExpression", t, r)
        }
        ,
        r.assertAssignmentPattern = function assertAssignmentPattern(t, r) {
            assert("AssignmentPattern", t, r)
        }
        ,
        r.assertAwaitExpression = function assertAwaitExpression(t, r) {
            assert("AwaitExpression", t, r)
        }
        ,
        r.assertBigIntLiteral = function assertBigIntLiteral(t, r) {
            assert("BigIntLiteral", t, r)
        }
        ,
        r.assertBinary = function assertBinary(t, r) {
            assert("Binary", t, r)
        }
        ,
        r.assertBinaryExpression = function assertBinaryExpression(t, r) {
            assert("BinaryExpression", t, r)
        }
        ,
        r.assertBindExpression = function assertBindExpression(t, r) {
            assert("BindExpression", t, r)
        }
        ,
        r.assertBlock = function assertBlock(t, r) {
            assert("Block", t, r)
        }
        ,
        r.assertBlockParent = function assertBlockParent(t, r) {
            assert("BlockParent", t, r)
        }
        ,
        r.assertBlockStatement = function assertBlockStatement(t, r) {
            assert("BlockStatement", t, r)
        }
        ,
        r.assertBooleanLiteral = function assertBooleanLiteral(t, r) {
            assert("BooleanLiteral", t, r)
        }
        ,
        r.assertBooleanLiteralTypeAnnotation = function assertBooleanLiteralTypeAnnotation(t, r) {
            assert("BooleanLiteralTypeAnnotation", t, r)
        }
        ,
        r.assertBooleanTypeAnnotation = function assertBooleanTypeAnnotation(t, r) {
            assert("BooleanTypeAnnotation", t, r)
        }
        ,
        r.assertBreakStatement = function assertBreakStatement(t, r) {
            assert("BreakStatement", t, r)
        }
        ,
        r.assertCallExpression = function assertCallExpression(t, r) {
            assert("CallExpression", t, r)
        }
        ,
        r.assertCatchClause = function assertCatchClause(t, r) {
            assert("CatchClause", t, r)
        }
        ,
        r.assertClass = function assertClass(t, r) {
            assert("Class", t, r)
        }
        ,
        r.assertClassBody = function assertClassBody(t, r) {
            assert("ClassBody", t, r)
        }
        ,
        r.assertClassDeclaration = function assertClassDeclaration(t, r) {
            assert("ClassDeclaration", t, r)
        }
        ,
        r.assertClassExpression = function assertClassExpression(t, r) {
            assert("ClassExpression", t, r)
        }
        ,
        r.assertClassImplements = function assertClassImplements(t, r) {
            assert("ClassImplements", t, r)
        }
        ,
        r.assertClassMethod = function assertClassMethod(t, r) {
            assert("ClassMethod", t, r)
        }
        ,
        r.assertClassPrivateMethod = function assertClassPrivateMethod(t, r) {
            assert("ClassPrivateMethod", t, r)
        }
        ,
        r.assertClassPrivateProperty = function assertClassPrivateProperty(t, r) {
            assert("ClassPrivateProperty", t, r)
        }
        ,
        r.assertClassProperty = function assertClassProperty(t, r) {
            assert("ClassProperty", t, r)
        }
        ,
        r.assertCompletionStatement = function assertCompletionStatement(t, r) {
            assert("CompletionStatement", t, r)
        }
        ,
        r.assertConditional = function assertConditional(t, r) {
            assert("Conditional", t, r)
        }
        ,
        r.assertConditionalExpression = function assertConditionalExpression(t, r) {
            assert("ConditionalExpression", t, r)
        }
        ,
        r.assertContinueStatement = function assertContinueStatement(t, r) {
            assert("ContinueStatement", t, r)
        }
        ,
        r.assertDebuggerStatement = function assertDebuggerStatement(t, r) {
            assert("DebuggerStatement", t, r)
        }
        ,
        r.assertDecimalLiteral = function assertDecimalLiteral(t, r) {
            assert("DecimalLiteral", t, r)
        }
        ,
        r.assertDeclaration = function assertDeclaration(t, r) {
            assert("Declaration", t, r)
        }
        ,
        r.assertDeclareClass = function assertDeclareClass(t, r) {
            assert("DeclareClass", t, r)
        }
        ,
        r.assertDeclareExportAllDeclaration = function assertDeclareExportAllDeclaration(t, r) {
            assert("DeclareExportAllDeclaration", t, r)
        }
        ,
        r.assertDeclareExportDeclaration = function assertDeclareExportDeclaration(t, r) {
            assert("DeclareExportDeclaration", t, r)
        }
        ,
        r.assertDeclareFunction = function assertDeclareFunction(t, r) {
            assert("DeclareFunction", t, r)
        }
        ,
        r.assertDeclareInterface = function assertDeclareInterface(t, r) {
            assert("DeclareInterface", t, r)
        }
        ,
        r.assertDeclareModule = function assertDeclareModule(t, r) {
            assert("DeclareModule", t, r)
        }
        ,
        r.assertDeclareModuleExports = function assertDeclareModuleExports(t, r) {
            assert("DeclareModuleExports", t, r)
        }
        ,
        r.assertDeclareOpaqueType = function assertDeclareOpaqueType(t, r) {
            assert("DeclareOpaqueType", t, r)
        }
        ,
        r.assertDeclareTypeAlias = function assertDeclareTypeAlias(t, r) {
            assert("DeclareTypeAlias", t, r)
        }
        ,
        r.assertDeclareVariable = function assertDeclareVariable(t, r) {
            assert("DeclareVariable", t, r)
        }
        ,
        r.assertDeclaredPredicate = function assertDeclaredPredicate(t, r) {
            assert("DeclaredPredicate", t, r)
        }
        ,
        r.assertDecorator = function assertDecorator(t, r) {
            assert("Decorator", t, r)
        }
        ,
        r.assertDirective = function assertDirective(t, r) {
            assert("Directive", t, r)
        }
        ,
        r.assertDirectiveLiteral = function assertDirectiveLiteral(t, r) {
            assert("DirectiveLiteral", t, r)
        }
        ,
        r.assertDoExpression = function assertDoExpression(t, r) {
            assert("DoExpression", t, r)
        }
        ,
        r.assertDoWhileStatement = function assertDoWhileStatement(t, r) {
            assert("DoWhileStatement", t, r)
        }
        ,
        r.assertEmptyStatement = function assertEmptyStatement(t, r) {
            assert("EmptyStatement", t, r)
        }
        ,
        r.assertEmptyTypeAnnotation = function assertEmptyTypeAnnotation(t, r) {
            assert("EmptyTypeAnnotation", t, r)
        }
        ,
        r.assertEnumBody = function assertEnumBody(t, r) {
            assert("EnumBody", t, r)
        }
        ,
        r.assertEnumBooleanBody = function assertEnumBooleanBody(t, r) {
            assert("EnumBooleanBody", t, r)
        }
        ,
        r.assertEnumBooleanMember = function assertEnumBooleanMember(t, r) {
            assert("EnumBooleanMember", t, r)
        }
        ,
        r.assertEnumDeclaration = function assertEnumDeclaration(t, r) {
            assert("EnumDeclaration", t, r)
        }
        ,
        r.assertEnumDefaultedMember = function assertEnumDefaultedMember(t, r) {
            assert("EnumDefaultedMember", t, r)
        }
        ,
        r.assertEnumMember = function assertEnumMember(t, r) {
            assert("EnumMember", t, r)
        }
        ,
        r.assertEnumNumberBody = function assertEnumNumberBody(t, r) {
            assert("EnumNumberBody", t, r)
        }
        ,
        r.assertEnumNumberMember = function assertEnumNumberMember(t, r) {
            assert("EnumNumberMember", t, r)
        }
        ,
        r.assertEnumStringBody = function assertEnumStringBody(t, r) {
            assert("EnumStringBody", t, r)
        }
        ,
        r.assertEnumStringMember = function assertEnumStringMember(t, r) {
            assert("EnumStringMember", t, r)
        }
        ,
        r.assertEnumSymbolBody = function assertEnumSymbolBody(t, r) {
            assert("EnumSymbolBody", t, r)
        }
        ,
        r.assertExistsTypeAnnotation = function assertExistsTypeAnnotation(t, r) {
            assert("ExistsTypeAnnotation", t, r)
        }
        ,
        r.assertExportAllDeclaration = function assertExportAllDeclaration(t, r) {
            assert("ExportAllDeclaration", t, r)
        }
        ,
        r.assertExportDeclaration = function assertExportDeclaration(t, r) {
            assert("ExportDeclaration", t, r)
        }
        ,
        r.assertExportDefaultDeclaration = function assertExportDefaultDeclaration(t, r) {
            assert("ExportDefaultDeclaration", t, r)
        }
        ,
        r.assertExportDefaultSpecifier = function assertExportDefaultSpecifier(t, r) {
            assert("ExportDefaultSpecifier", t, r)
        }
        ,
        r.assertExportNamedDeclaration = function assertExportNamedDeclaration(t, r) {
            assert("ExportNamedDeclaration", t, r)
        }
        ,
        r.assertExportNamespaceSpecifier = function assertExportNamespaceSpecifier(t, r) {
            assert("ExportNamespaceSpecifier", t, r)
        }
        ,
        r.assertExportSpecifier = function assertExportSpecifier(t, r) {
            assert("ExportSpecifier", t, r)
        }
        ,
        r.assertExpression = function assertExpression(t, r) {
            assert("Expression", t, r)
        }
        ,
        r.assertExpressionStatement = function assertExpressionStatement(t, r) {
            assert("ExpressionStatement", t, r)
        }
        ,
        r.assertExpressionWrapper = function assertExpressionWrapper(t, r) {
            assert("ExpressionWrapper", t, r)
        }
        ,
        r.assertFile = function assertFile(t, r) {
            assert("File", t, r)
        }
        ,
        r.assertFlow = function assertFlow(t, r) {
            assert("Flow", t, r)
        }
        ,
        r.assertFlowBaseAnnotation = function assertFlowBaseAnnotation(t, r) {
            assert("FlowBaseAnnotation", t, r)
        }
        ,
        r.assertFlowDeclaration = function assertFlowDeclaration(t, r) {
            assert("FlowDeclaration", t, r)
        }
        ,
        r.assertFlowPredicate = function assertFlowPredicate(t, r) {
            assert("FlowPredicate", t, r)
        }
        ,
        r.assertFlowType = function assertFlowType(t, r) {
            assert("FlowType", t, r)
        }
        ,
        r.assertFor = function assertFor(t, r) {
            assert("For", t, r)
        }
        ,
        r.assertForInStatement = function assertForInStatement(t, r) {
            assert("ForInStatement", t, r)
        }
        ,
        r.assertForOfStatement = function assertForOfStatement(t, r) {
            assert("ForOfStatement", t, r)
        }
        ,
        r.assertForStatement = function assertForStatement(t, r) {
            assert("ForStatement", t, r)
        }
        ,
        r.assertForXStatement = function assertForXStatement(t, r) {
            assert("ForXStatement", t, r)
        }
        ,
        r.assertFunction = function assertFunction(t, r) {
            assert("Function", t, r)
        }
        ,
        r.assertFunctionDeclaration = function assertFunctionDeclaration(t, r) {
            assert("FunctionDeclaration", t, r)
        }
        ,
        r.assertFunctionExpression = function assertFunctionExpression(t, r) {
            assert("FunctionExpression", t, r)
        }
        ,
        r.assertFunctionParent = function assertFunctionParent(t, r) {
            assert("FunctionParent", t, r)
        }
        ,
        r.assertFunctionTypeAnnotation = function assertFunctionTypeAnnotation(t, r) {
            assert("FunctionTypeAnnotation", t, r)
        }
        ,
        r.assertFunctionTypeParam = function assertFunctionTypeParam(t, r) {
            assert("FunctionTypeParam", t, r)
        }
        ,
        r.assertGenericTypeAnnotation = function assertGenericTypeAnnotation(t, r) {
            assert("GenericTypeAnnotation", t, r)
        }
        ,
        r.assertIdentifier = function assertIdentifier(t, r) {
            assert("Identifier", t, r)
        }
        ,
        r.assertIfStatement = function assertIfStatement(t, r) {
            assert("IfStatement", t, r)
        }
        ,
        r.assertImmutable = function assertImmutable(t, r) {
            assert("Immutable", t, r)
        }
        ,
        r.assertImport = function assertImport(t, r) {
            assert("Import", t, r)
        }
        ,
        r.assertImportAttribute = function assertImportAttribute(t, r) {
            assert("ImportAttribute", t, r)
        }
        ,
        r.assertImportDeclaration = function assertImportDeclaration(t, r) {
            assert("ImportDeclaration", t, r)
        }
        ,
        r.assertImportDefaultSpecifier = function assertImportDefaultSpecifier(t, r) {
            assert("ImportDefaultSpecifier", t, r)
        }
        ,
        r.assertImportNamespaceSpecifier = function assertImportNamespaceSpecifier(t, r) {
            assert("ImportNamespaceSpecifier", t, r)
        }
        ,
        r.assertImportSpecifier = function assertImportSpecifier(t, r) {
            assert("ImportSpecifier", t, r)
        }
        ,
        r.assertIndexedAccessType = function assertIndexedAccessType(t, r) {
            assert("IndexedAccessType", t, r)
        }
        ,
        r.assertInferredPredicate = function assertInferredPredicate(t, r) {
            assert("InferredPredicate", t, r)
        }
        ,
        r.assertInterfaceDeclaration = function assertInterfaceDeclaration(t, r) {
            assert("InterfaceDeclaration", t, r)
        }
        ,
        r.assertInterfaceExtends = function assertInterfaceExtends(t, r) {
            assert("InterfaceExtends", t, r)
        }
        ,
        r.assertInterfaceTypeAnnotation = function assertInterfaceTypeAnnotation(t, r) {
            assert("InterfaceTypeAnnotation", t, r)
        }
        ,
        r.assertInterpreterDirective = function assertInterpreterDirective(t, r) {
            assert("InterpreterDirective", t, r)
        }
        ,
        r.assertIntersectionTypeAnnotation = function assertIntersectionTypeAnnotation(t, r) {
            assert("IntersectionTypeAnnotation", t, r)
        }
        ,
        r.assertJSX = function assertJSX(t, r) {
            assert("JSX", t, r)
        }
        ,
        r.assertJSXAttribute = function assertJSXAttribute(t, r) {
            assert("JSXAttribute", t, r)
        }
        ,
        r.assertJSXClosingElement = function assertJSXClosingElement(t, r) {
            assert("JSXClosingElement", t, r)
        }
        ,
        r.assertJSXClosingFragment = function assertJSXClosingFragment(t, r) {
            assert("JSXClosingFragment", t, r)
        }
        ,
        r.assertJSXElement = function assertJSXElement(t, r) {
            assert("JSXElement", t, r)
        }
        ,
        r.assertJSXEmptyExpression = function assertJSXEmptyExpression(t, r) {
            assert("JSXEmptyExpression", t, r)
        }
        ,
        r.assertJSXExpressionContainer = function assertJSXExpressionContainer(t, r) {
            assert("JSXExpressionContainer", t, r)
        }
        ,
        r.assertJSXFragment = function assertJSXFragment(t, r) {
            assert("JSXFragment", t, r)
        }
        ,
        r.assertJSXIdentifier = function assertJSXIdentifier(t, r) {
            assert("JSXIdentifier", t, r)
        }
        ,
        r.assertJSXMemberExpression = function assertJSXMemberExpression(t, r) {
            assert("JSXMemberExpression", t, r)
        }
        ,
        r.assertJSXNamespacedName = function assertJSXNamespacedName(t, r) {
            assert("JSXNamespacedName", t, r)
        }
        ,
        r.assertJSXOpeningElement = function assertJSXOpeningElement(t, r) {
            assert("JSXOpeningElement", t, r)
        }
        ,
        r.assertJSXOpeningFragment = function assertJSXOpeningFragment(t, r) {
            assert("JSXOpeningFragment", t, r)
        }
        ,
        r.assertJSXSpreadAttribute = function assertJSXSpreadAttribute(t, r) {
            assert("JSXSpreadAttribute", t, r)
        }
        ,
        r.assertJSXSpreadChild = function assertJSXSpreadChild(t, r) {
            assert("JSXSpreadChild", t, r)
        }
        ,
        r.assertJSXText = function assertJSXText(t, r) {
            assert("JSXText", t, r)
        }
        ,
        r.assertLVal = function assertLVal(t, r) {
            assert("LVal", t, r)
        }
        ,
        r.assertLabeledStatement = function assertLabeledStatement(t, r) {
            assert("LabeledStatement", t, r)
        }
        ,
        r.assertLiteral = function assertLiteral(t, r) {
            assert("Literal", t, r)
        }
        ,
        r.assertLogicalExpression = function assertLogicalExpression(t, r) {
            assert("LogicalExpression", t, r)
        }
        ,
        r.assertLoop = function assertLoop(t, r) {
            assert("Loop", t, r)
        }
        ,
        r.assertMemberExpression = function assertMemberExpression(t, r) {
            assert("MemberExpression", t, r)
        }
        ,
        r.assertMetaProperty = function assertMetaProperty(t, r) {
            assert("MetaProperty", t, r)
        }
        ,
        r.assertMethod = function assertMethod(t, r) {
            assert("Method", t, r)
        }
        ,
        r.assertMiscellaneous = function assertMiscellaneous(t, r) {
            assert("Miscellaneous", t, r)
        }
        ,
        r.assertMixedTypeAnnotation = function assertMixedTypeAnnotation(t, r) {
            assert("MixedTypeAnnotation", t, r)
        }
        ,
        r.assertModuleDeclaration = function assertModuleDeclaration(t, r) {
            assert("ModuleDeclaration", t, r)
        }
        ,
        r.assertModuleExpression = function assertModuleExpression(t, r) {
            assert("ModuleExpression", t, r)
        }
        ,
        r.assertModuleSpecifier = function assertModuleSpecifier(t, r) {
            assert("ModuleSpecifier", t, r)
        }
        ,
        r.assertNewExpression = function assertNewExpression(t, r) {
            assert("NewExpression", t, r)
        }
        ,
        r.assertNoop = function assertNoop(t, r) {
            assert("Noop", t, r)
        }
        ,
        r.assertNullLiteral = function assertNullLiteral(t, r) {
            assert("NullLiteral", t, r)
        }
        ,
        r.assertNullLiteralTypeAnnotation = function assertNullLiteralTypeAnnotation(t, r) {
            assert("NullLiteralTypeAnnotation", t, r)
        }
        ,
        r.assertNullableTypeAnnotation = function assertNullableTypeAnnotation(t, r) {
            assert("NullableTypeAnnotation", t, r)
        }
        ,
        r.assertNumberLiteral = function assertNumberLiteral(t, r) {
            console.trace("The node type NumberLiteral has been renamed to NumericLiteral"),
            assert("NumberLiteral", t, r)
        }
        ,
        r.assertNumberLiteralTypeAnnotation = function assertNumberLiteralTypeAnnotation(t, r) {
            assert("NumberLiteralTypeAnnotation", t, r)
        }
        ,
        r.assertNumberTypeAnnotation = function assertNumberTypeAnnotation(t, r) {
            assert("NumberTypeAnnotation", t, r)
        }
        ,
        r.assertNumericLiteral = function assertNumericLiteral(t, r) {
            assert("NumericLiteral", t, r)
        }
        ,
        r.assertObjectExpression = function assertObjectExpression(t, r) {
            assert("ObjectExpression", t, r)
        }
        ,
        r.assertObjectMember = function assertObjectMember(t, r) {
            assert("ObjectMember", t, r)
        }
        ,
        r.assertObjectMethod = function assertObjectMethod(t, r) {
            assert("ObjectMethod", t, r)
        }
        ,
        r.assertObjectPattern = function assertObjectPattern(t, r) {
            assert("ObjectPattern", t, r)
        }
        ,
        r.assertObjectProperty = function assertObjectProperty(t, r) {
            assert("ObjectProperty", t, r)
        }
        ,
        r.assertObjectTypeAnnotation = function assertObjectTypeAnnotation(t, r) {
            assert("ObjectTypeAnnotation", t, r)
        }
        ,
        r.assertObjectTypeCallProperty = function assertObjectTypeCallProperty(t, r) {
            assert("ObjectTypeCallProperty", t, r)
        }
        ,
        r.assertObjectTypeIndexer = function assertObjectTypeIndexer(t, r) {
            assert("ObjectTypeIndexer", t, r)
        }
        ,
        r.assertObjectTypeInternalSlot = function assertObjectTypeInternalSlot(t, r) {
            assert("ObjectTypeInternalSlot", t, r)
        }
        ,
        r.assertObjectTypeProperty = function assertObjectTypeProperty(t, r) {
            assert("ObjectTypeProperty", t, r)
        }
        ,
        r.assertObjectTypeSpreadProperty = function assertObjectTypeSpreadProperty(t, r) {
            assert("ObjectTypeSpreadProperty", t, r)
        }
        ,
        r.assertOpaqueType = function assertOpaqueType(t, r) {
            assert("OpaqueType", t, r)
        }
        ,
        r.assertOptionalCallExpression = function assertOptionalCallExpression(t, r) {
            assert("OptionalCallExpression", t, r)
        }
        ,
        r.assertOptionalIndexedAccessType = function assertOptionalIndexedAccessType(t, r) {
            assert("OptionalIndexedAccessType", t, r)
        }
        ,
        r.assertOptionalMemberExpression = function assertOptionalMemberExpression(t, r) {
            assert("OptionalMemberExpression", t, r)
        }
        ,
        r.assertParenthesizedExpression = function assertParenthesizedExpression(t, r) {
            assert("ParenthesizedExpression", t, r)
        }
        ,
        r.assertPattern = function assertPattern(t, r) {
            assert("Pattern", t, r)
        }
        ,
        r.assertPatternLike = function assertPatternLike(t, r) {
            assert("PatternLike", t, r)
        }
        ,
        r.assertPipelineBareFunction = function assertPipelineBareFunction(t, r) {
            assert("PipelineBareFunction", t, r)
        }
        ,
        r.assertPipelinePrimaryTopicReference = function assertPipelinePrimaryTopicReference(t, r) {
            assert("PipelinePrimaryTopicReference", t, r)
        }
        ,
        r.assertPipelineTopicExpression = function assertPipelineTopicExpression(t, r) {
            assert("PipelineTopicExpression", t, r)
        }
        ,
        r.assertPlaceholder = function assertPlaceholder(t, r) {
            assert("Placeholder", t, r)
        }
        ,
        r.assertPrivate = function assertPrivate(t, r) {
            assert("Private", t, r)
        }
        ,
        r.assertPrivateName = function assertPrivateName(t, r) {
            assert("PrivateName", t, r)
        }
        ,
        r.assertProgram = function assertProgram(t, r) {
            assert("Program", t, r)
        }
        ,
        r.assertProperty = function assertProperty(t, r) {
            assert("Property", t, r)
        }
        ,
        r.assertPureish = function assertPureish(t, r) {
            assert("Pureish", t, r)
        }
        ,
        r.assertQualifiedTypeIdentifier = function assertQualifiedTypeIdentifier(t, r) {
            assert("QualifiedTypeIdentifier", t, r)
        }
        ,
        r.assertRecordExpression = function assertRecordExpression(t, r) {
            assert("RecordExpression", t, r)
        }
        ,
        r.assertRegExpLiteral = function assertRegExpLiteral(t, r) {
            assert("RegExpLiteral", t, r)
        }
        ,
        r.assertRegexLiteral = function assertRegexLiteral(t, r) {
            console.trace("The node type RegexLiteral has been renamed to RegExpLiteral"),
            assert("RegexLiteral", t, r)
        }
        ,
        r.assertRestElement = function assertRestElement(t, r) {
            assert("RestElement", t, r)
        }
        ,
        r.assertRestProperty = function assertRestProperty(t, r) {
            console.trace("The node type RestProperty has been renamed to RestElement"),
            assert("RestProperty", t, r)
        }
        ,
        r.assertReturnStatement = function assertReturnStatement(t, r) {
            assert("ReturnStatement", t, r)
        }
        ,
        r.assertScopable = function assertScopable(t, r) {
            assert("Scopable", t, r)
        }
        ,
        r.assertSequenceExpression = function assertSequenceExpression(t, r) {
            assert("SequenceExpression", t, r)
        }
        ,
        r.assertSpreadElement = function assertSpreadElement(t, r) {
            assert("SpreadElement", t, r)
        }
        ,
        r.assertSpreadProperty = function assertSpreadProperty(t, r) {
            console.trace("The node type SpreadProperty has been renamed to SpreadElement"),
            assert("SpreadProperty", t, r)
        }
        ,
        r.assertStandardized = function assertStandardized(t, r) {
            assert("Standardized", t, r)
        }
        ,
        r.assertStatement = function assertStatement(t, r) {
            assert("Statement", t, r)
        }
        ,
        r.assertStaticBlock = function assertStaticBlock(t, r) {
            assert("StaticBlock", t, r)
        }
        ,
        r.assertStringLiteral = function assertStringLiteral(t, r) {
            assert("StringLiteral", t, r)
        }
        ,
        r.assertStringLiteralTypeAnnotation = function assertStringLiteralTypeAnnotation(t, r) {
            assert("StringLiteralTypeAnnotation", t, r)
        }
        ,
        r.assertStringTypeAnnotation = function assertStringTypeAnnotation(t, r) {
            assert("StringTypeAnnotation", t, r)
        }
        ,
        r.assertSuper = function assertSuper(t, r) {
            assert("Super", t, r)
        }
        ,
        r.assertSwitchCase = function assertSwitchCase(t, r) {
            assert("SwitchCase", t, r)
        }
        ,
        r.assertSwitchStatement = function assertSwitchStatement(t, r) {
            assert("SwitchStatement", t, r)
        }
        ,
        r.assertSymbolTypeAnnotation = function assertSymbolTypeAnnotation(t, r) {
            assert("SymbolTypeAnnotation", t, r)
        }
        ,
        r.assertTSAnyKeyword = function assertTSAnyKeyword(t, r) {
            assert("TSAnyKeyword", t, r)
        }
        ,
        r.assertTSArrayType = function assertTSArrayType(t, r) {
            assert("TSArrayType", t, r)
        }
        ,
        r.assertTSAsExpression = function assertTSAsExpression(t, r) {
            assert("TSAsExpression", t, r)
        }
        ,
        r.assertTSBaseType = function assertTSBaseType(t, r) {
            assert("TSBaseType", t, r)
        }
        ,
        r.assertTSBigIntKeyword = function assertTSBigIntKeyword(t, r) {
            assert("TSBigIntKeyword", t, r)
        }
        ,
        r.assertTSBooleanKeyword = function assertTSBooleanKeyword(t, r) {
            assert("TSBooleanKeyword", t, r)
        }
        ,
        r.assertTSCallSignatureDeclaration = function assertTSCallSignatureDeclaration(t, r) {
            assert("TSCallSignatureDeclaration", t, r)
        }
        ,
        r.assertTSConditionalType = function assertTSConditionalType(t, r) {
            assert("TSConditionalType", t, r)
        }
        ,
        r.assertTSConstructSignatureDeclaration = function assertTSConstructSignatureDeclaration(t, r) {
            assert("TSConstructSignatureDeclaration", t, r)
        }
        ,
        r.assertTSConstructorType = function assertTSConstructorType(t, r) {
            assert("TSConstructorType", t, r)
        }
        ,
        r.assertTSDeclareFunction = function assertTSDeclareFunction(t, r) {
            assert("TSDeclareFunction", t, r)
        }
        ,
        r.assertTSDeclareMethod = function assertTSDeclareMethod(t, r) {
            assert("TSDeclareMethod", t, r)
        }
        ,
        r.assertTSEntityName = function assertTSEntityName(t, r) {
            assert("TSEntityName", t, r)
        }
        ,
        r.assertTSEnumDeclaration = function assertTSEnumDeclaration(t, r) {
            assert("TSEnumDeclaration", t, r)
        }
        ,
        r.assertTSEnumMember = function assertTSEnumMember(t, r) {
            assert("TSEnumMember", t, r)
        }
        ,
        r.assertTSExportAssignment = function assertTSExportAssignment(t, r) {
            assert("TSExportAssignment", t, r)
        }
        ,
        r.assertTSExpressionWithTypeArguments = function assertTSExpressionWithTypeArguments(t, r) {
            assert("TSExpressionWithTypeArguments", t, r)
        }
        ,
        r.assertTSExternalModuleReference = function assertTSExternalModuleReference(t, r) {
            assert("TSExternalModuleReference", t, r)
        }
        ,
        r.assertTSFunctionType = function assertTSFunctionType(t, r) {
            assert("TSFunctionType", t, r)
        }
        ,
        r.assertTSImportEqualsDeclaration = function assertTSImportEqualsDeclaration(t, r) {
            assert("TSImportEqualsDeclaration", t, r)
        }
        ,
        r.assertTSImportType = function assertTSImportType(t, r) {
            assert("TSImportType", t, r)
        }
        ,
        r.assertTSIndexSignature = function assertTSIndexSignature(t, r) {
            assert("TSIndexSignature", t, r)
        }
        ,
        r.assertTSIndexedAccessType = function assertTSIndexedAccessType(t, r) {
            assert("TSIndexedAccessType", t, r)
        }
        ,
        r.assertTSInferType = function assertTSInferType(t, r) {
            assert("TSInferType", t, r)
        }
        ,
        r.assertTSInterfaceBody = function assertTSInterfaceBody(t, r) {
            assert("TSInterfaceBody", t, r)
        }
        ,
        r.assertTSInterfaceDeclaration = function assertTSInterfaceDeclaration(t, r) {
            assert("TSInterfaceDeclaration", t, r)
        }
        ,
        r.assertTSIntersectionType = function assertTSIntersectionType(t, r) {
            assert("TSIntersectionType", t, r)
        }
        ,
        r.assertTSIntrinsicKeyword = function assertTSIntrinsicKeyword(t, r) {
            assert("TSIntrinsicKeyword", t, r)
        }
        ,
        r.assertTSLiteralType = function assertTSLiteralType(t, r) {
            assert("TSLiteralType", t, r)
        }
        ,
        r.assertTSMappedType = function assertTSMappedType(t, r) {
            assert("TSMappedType", t, r)
        }
        ,
        r.assertTSMethodSignature = function assertTSMethodSignature(t, r) {
            assert("TSMethodSignature", t, r)
        }
        ,
        r.assertTSModuleBlock = function assertTSModuleBlock(t, r) {
            assert("TSModuleBlock", t, r)
        }
        ,
        r.assertTSModuleDeclaration = function assertTSModuleDeclaration(t, r) {
            assert("TSModuleDeclaration", t, r)
        }
        ,
        r.assertTSNamedTupleMember = function assertTSNamedTupleMember(t, r) {
            assert("TSNamedTupleMember", t, r)
        }
        ,
        r.assertTSNamespaceExportDeclaration = function assertTSNamespaceExportDeclaration(t, r) {
            assert("TSNamespaceExportDeclaration", t, r)
        }
        ,
        r.assertTSNeverKeyword = function assertTSNeverKeyword(t, r) {
            assert("TSNeverKeyword", t, r)
        }
        ,
        r.assertTSNonNullExpression = function assertTSNonNullExpression(t, r) {
            assert("TSNonNullExpression", t, r)
        }
        ,
        r.assertTSNullKeyword = function assertTSNullKeyword(t, r) {
            assert("TSNullKeyword", t, r)
        }
        ,
        r.assertTSNumberKeyword = function assertTSNumberKeyword(t, r) {
            assert("TSNumberKeyword", t, r)
        }
        ,
        r.assertTSObjectKeyword = function assertTSObjectKeyword(t, r) {
            assert("TSObjectKeyword", t, r)
        }
        ,
        r.assertTSOptionalType = function assertTSOptionalType(t, r) {
            assert("TSOptionalType", t, r)
        }
        ,
        r.assertTSParameterProperty = function assertTSParameterProperty(t, r) {
            assert("TSParameterProperty", t, r)
        }
        ,
        r.assertTSParenthesizedType = function assertTSParenthesizedType(t, r) {
            assert("TSParenthesizedType", t, r)
        }
        ,
        r.assertTSPropertySignature = function assertTSPropertySignature(t, r) {
            assert("TSPropertySignature", t, r)
        }
        ,
        r.assertTSQualifiedName = function assertTSQualifiedName(t, r) {
            assert("TSQualifiedName", t, r)
        }
        ,
        r.assertTSRestType = function assertTSRestType(t, r) {
            assert("TSRestType", t, r)
        }
        ,
        r.assertTSStringKeyword = function assertTSStringKeyword(t, r) {
            assert("TSStringKeyword", t, r)
        }
        ,
        r.assertTSSymbolKeyword = function assertTSSymbolKeyword(t, r) {
            assert("TSSymbolKeyword", t, r)
        }
        ,
        r.assertTSThisType = function assertTSThisType(t, r) {
            assert("TSThisType", t, r)
        }
        ,
        r.assertTSTupleType = function assertTSTupleType(t, r) {
            assert("TSTupleType", t, r)
        }
        ,
        r.assertTSType = function assertTSType(t, r) {
            assert("TSType", t, r)
        }
        ,
        r.assertTSTypeAliasDeclaration = function assertTSTypeAliasDeclaration(t, r) {
            assert("TSTypeAliasDeclaration", t, r)
        }
        ,
        r.assertTSTypeAnnotation = function assertTSTypeAnnotation(t, r) {
            assert("TSTypeAnnotation", t, r)
        }
        ,
        r.assertTSTypeAssertion = function assertTSTypeAssertion(t, r) {
            assert("TSTypeAssertion", t, r)
        }
        ,
        r.assertTSTypeElement = function assertTSTypeElement(t, r) {
            assert("TSTypeElement", t, r)
        }
        ,
        r.assertTSTypeLiteral = function assertTSTypeLiteral(t, r) {
            assert("TSTypeLiteral", t, r)
        }
        ,
        r.assertTSTypeOperator = function assertTSTypeOperator(t, r) {
            assert("TSTypeOperator", t, r)
        }
        ,
        r.assertTSTypeParameter = function assertTSTypeParameter(t, r) {
            assert("TSTypeParameter", t, r)
        }
        ,
        r.assertTSTypeParameterDeclaration = function assertTSTypeParameterDeclaration(t, r) {
            assert("TSTypeParameterDeclaration", t, r)
        }
        ,
        r.assertTSTypeParameterInstantiation = function assertTSTypeParameterInstantiation(t, r) {
            assert("TSTypeParameterInstantiation", t, r)
        }
        ,
        r.assertTSTypePredicate = function assertTSTypePredicate(t, r) {
            assert("TSTypePredicate", t, r)
        }
        ,
        r.assertTSTypeQuery = function assertTSTypeQuery(t, r) {
            assert("TSTypeQuery", t, r)
        }
        ,
        r.assertTSTypeReference = function assertTSTypeReference(t, r) {
            assert("TSTypeReference", t, r)
        }
        ,
        r.assertTSUndefinedKeyword = function assertTSUndefinedKeyword(t, r) {
            assert("TSUndefinedKeyword", t, r)
        }
        ,
        r.assertTSUnionType = function assertTSUnionType(t, r) {
            assert("TSUnionType", t, r)
        }
        ,
        r.assertTSUnknownKeyword = function assertTSUnknownKeyword(t, r) {
            assert("TSUnknownKeyword", t, r)
        }
        ,
        r.assertTSVoidKeyword = function assertTSVoidKeyword(t, r) {
            assert("TSVoidKeyword", t, r)
        }
        ,
        r.assertTaggedTemplateExpression = function assertTaggedTemplateExpression(t, r) {
            assert("TaggedTemplateExpression", t, r)
        }
        ,
        r.assertTemplateElement = function assertTemplateElement(t, r) {
            assert("TemplateElement", t, r)
        }
        ,
        r.assertTemplateLiteral = function assertTemplateLiteral(t, r) {
            assert("TemplateLiteral", t, r)
        }
        ,
        r.assertTerminatorless = function assertTerminatorless(t, r) {
            assert("Terminatorless", t, r)
        }
        ,
        r.assertThisExpression = function assertThisExpression(t, r) {
            assert("ThisExpression", t, r)
        }
        ,
        r.assertThisTypeAnnotation = function assertThisTypeAnnotation(t, r) {
            assert("ThisTypeAnnotation", t, r)
        }
        ,
        r.assertThrowStatement = function assertThrowStatement(t, r) {
            assert("ThrowStatement", t, r)
        }
        ,
        r.assertTopicReference = function assertTopicReference(t, r) {
            assert("TopicReference", t, r)
        }
        ,
        r.assertTryStatement = function assertTryStatement(t, r) {
            assert("TryStatement", t, r)
        }
        ,
        r.assertTupleExpression = function assertTupleExpression(t, r) {
            assert("TupleExpression", t, r)
        }
        ,
        r.assertTupleTypeAnnotation = function assertTupleTypeAnnotation(t, r) {
            assert("TupleTypeAnnotation", t, r)
        }
        ,
        r.assertTypeAlias = function assertTypeAlias(t, r) {
            assert("TypeAlias", t, r)
        }
        ,
        r.assertTypeAnnotation = function assertTypeAnnotation(t, r) {
            assert("TypeAnnotation", t, r)
        }
        ,
        r.assertTypeCastExpression = function assertTypeCastExpression(t, r) {
            assert("TypeCastExpression", t, r)
        }
        ,
        r.assertTypeParameter = function assertTypeParameter(t, r) {
            assert("TypeParameter", t, r)
        }
        ,
        r.assertTypeParameterDeclaration = function assertTypeParameterDeclaration(t, r) {
            assert("TypeParameterDeclaration", t, r)
        }
        ,
        r.assertTypeParameterInstantiation = function assertTypeParameterInstantiation(t, r) {
            assert("TypeParameterInstantiation", t, r)
        }
        ,
        r.assertTypeScript = function assertTypeScript(t, r) {
            assert("TypeScript", t, r)
        }
        ,
        r.assertTypeofTypeAnnotation = function assertTypeofTypeAnnotation(t, r) {
            assert("TypeofTypeAnnotation", t, r)
        }
        ,
        r.assertUnaryExpression = function assertUnaryExpression(t, r) {
            assert("UnaryExpression", t, r)
        }
        ,
        r.assertUnaryLike = function assertUnaryLike(t, r) {
            assert("UnaryLike", t, r)
        }
        ,
        r.assertUnionTypeAnnotation = function assertUnionTypeAnnotation(t, r) {
            assert("UnionTypeAnnotation", t, r)
        }
        ,
        r.assertUpdateExpression = function assertUpdateExpression(t, r) {
            assert("UpdateExpression", t, r)
        }
        ,
        r.assertUserWhitespacable = function assertUserWhitespacable(t, r) {
            assert("UserWhitespacable", t, r)
        }
        ,
        r.assertV8IntrinsicIdentifier = function assertV8IntrinsicIdentifier(t, r) {
            assert("V8IntrinsicIdentifier", t, r)
        }
        ,
        r.assertVariableDeclaration = function assertVariableDeclaration(t, r) {
            assert("VariableDeclaration", t, r)
        }
        ,
        r.assertVariableDeclarator = function assertVariableDeclarator(t, r) {
            assert("VariableDeclarator", t, r)
        }
        ,
        r.assertVariance = function assertVariance(t, r) {
            assert("Variance", t, r)
        }
        ,
        r.assertVoidTypeAnnotation = function assertVoidTypeAnnotation(t, r) {
            assert("VoidTypeAnnotation", t, r)
        }
        ,
        r.assertWhile = function assertWhile(t, r) {
            assert("While", t, r)
        }
        ,
        r.assertWhileStatement = function assertWhileStatement(t, r) {
            assert("WhileStatement", t, r)
        }
        ,
        r.assertWithStatement = function assertWithStatement(t, r) {
            assert("WithStatement", t, r)
        }
        ,
        r.assertYieldExpression = function assertYieldExpression(t, r) {
            assert("YieldExpression", t, r)
        }
        ;
        var a = i("ET4T");
        function assert(t, r, i) {
            if (!(0,
            a.default)(t, r, i))
                throw new Error('Expected type "'.concat(t, '" with option ').concat(JSON.stringify(i), ", ") + 'but instead got "'.concat(r.type, '".'))
        }
    },
    DrtQ: function(t, r, i) {
        "use strict";
        (function(t) {
            var a = i("TqRt")
              , o = a(i("J4zp"))
              , l = a(i("RIqP"));
            Object.defineProperty(r, "__esModule", {
                value: !0
            }),
            r.classMethodOrDeclareMethodCommon = r.classMethodOrPropertyCommon = r.patternLikeCommon = r.functionDeclarationCommon = r.functionTypeAnnotationCommon = r.functionCommon = void 0;
            var u, p, c, d = i("0G7A"), y = i("yK+d"), h = i("KPS7"), m = i("RS7Y"), T = i("7ePq");
            (0,
            T.default)("ArrayExpression", {
                fields: {
                    elements: {
                        validate: (0,
                        T.chain)((0,
                        T.assertValueType)("array"), (0,
                        T.assertEach)((0,
                        T.assertNodeOrValueType)("null", "Expression", "SpreadElement"))),
                        default: t.env.BABEL_TYPES_8_BREAKING ? void 0 : []
                    }
                },
                visitor: ["elements"],
                aliases: ["Expression"]
            }),
            (0,
            T.default)("AssignmentExpression", {
                fields: {
                    operator: {
                        validate: function() {
                            if (!t.env.BABEL_TYPES_8_BREAKING)
                                return (0,
                                T.assertValueType)("string");
                            var r = T.assertOneOf.apply(void 0, (0,
                            l.default)(m.ASSIGNMENT_OPERATORS))
                              , i = (0,
                            T.assertOneOf)("=");
                            return function(t, a, o) {
                                ((0,
                                d.default)("Pattern", t.left) ? i : r)(t, a, o)
                            }
                        }()
                    },
                    left: {
                        validate: t.env.BABEL_TYPES_8_BREAKING ? (0,
                        T.assertNodeType)("Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern") : (0,
                        T.assertNodeType)("LVal")
                    },
                    right: {
                        validate: (0,
                        T.assertNodeType)("Expression")
                    }
                },
                builder: ["operator", "left", "right"],
                visitor: ["left", "right"],
                aliases: ["Expression"]
            }),
            (0,
            T.default)("BinaryExpression", {
                builder: ["operator", "left", "right"],
                fields: {
                    operator: {
                        validate: T.assertOneOf.apply(void 0, (0,
                        l.default)(m.BINARY_OPERATORS))
                    },
                    left: {
                        validate: (u = (0,
                        T.assertNodeType)("Expression"),
                        p = (0,
                        T.assertNodeType)("Expression", "PrivateName"),
                        c = function validator(t, r, i) {
                            var validator = "in" === t.operator ? p : u;
                            validator(t, r, i)
                        }
                        ,
                        c.oneOfNodeTypes = ["Expression", "PrivateName"],
                        c)
                    },
                    right: {
                        validate: (0,
                        T.assertNodeType)("Expression")
                    }
                },
                visitor: ["left", "right"],
                aliases: ["Binary", "Expression"]
            }),
            (0,
            T.default)("InterpreterDirective", {
                builder: ["value"],
                fields: {
                    value: {
                        validate: (0,
                        T.assertValueType)("string")
                    }
                }
            }),
            (0,
            T.default)("Directive", {
                visitor: ["value"],
                fields: {
                    value: {
                        validate: (0,
                        T.assertNodeType)("DirectiveLiteral")
                    }
                }
            }),
            (0,
            T.default)("DirectiveLiteral", {
                builder: ["value"],
                fields: {
                    value: {
                        validate: (0,
                        T.assertValueType)("string")
                    }
                }
            }),
            (0,
            T.default)("BlockStatement", {
                builder: ["body", "directives"],
                visitor: ["directives", "body"],
                fields: {
                    directives: {
                        validate: (0,
                        T.chain)((0,
                        T.assertValueType)("array"), (0,
                        T.assertEach)((0,
                        T.assertNodeType)("Directive"))),
                        default: []
                    },
                    body: {
                        validate: (0,
                        T.chain)((0,
                        T.assertValueType)("array"), (0,
                        T.assertEach)((0,
                        T.assertNodeType)("Statement")))
                    }
                },
                aliases: ["Scopable", "BlockParent", "Block", "Statement"]
            }),
            (0,
            T.default)("BreakStatement", {
                visitor: ["label"],
                fields: {
                    label: {
                        validate: (0,
                        T.assertNodeType)("Identifier"),
                        optional: !0
                    }
                },
                aliases: ["Statement", "Terminatorless", "CompletionStatement"]
            }),
            (0,
            T.default)("CallExpression", {
                visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
                builder: ["callee", "arguments"],
                aliases: ["Expression"],
                fields: Object.assign({
                    callee: {
                        validate: (0,
                        T.assertNodeType)("Expression", "V8IntrinsicIdentifier")
                    },
                    arguments: {
                        validate: (0,
                        T.chain)((0,
                        T.assertValueType)("array"), (0,
                        T.assertEach)((0,
                        T.assertNodeType)("Expression", "SpreadElement", "JSXNamespacedName", "ArgumentPlaceholder")))
                    }
                }, t.env.BABEL_TYPES_8_BREAKING ? {} : {
                    optional: {
                        validate: (0,
                        T.assertOneOf)(!0, !1),
                        optional: !0
                    }
                }, {
                    typeArguments: {
                        validate: (0,
                        T.assertNodeType)("TypeParameterInstantiation"),
                        optional: !0
                    },
                    typeParameters: {
                        validate: (0,
                        T.assertNodeType)("TSTypeParameterInstantiation"),
                        optional: !0
                    }
                })
            }),
            (0,
            T.default)("CatchClause", {
                visitor: ["param", "body"],
                fields: {
                    param: {
                        validate: (0,
                        T.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern"),
                        optional: !0
                    },
                    body: {
                        validate: (0,
                        T.assertNodeType)("BlockStatement")
                    }
                },
                aliases: ["Scopable", "BlockParent"]
            }),
            (0,
            T.default)("ConditionalExpression", {
                visitor: ["test", "consequent", "alternate"],
                fields: {
                    test: {
                        validate: (0,
                        T.assertNodeType)("Expression")
                    },
                    consequent: {
                        validate: (0,
                        T.assertNodeType)("Expression")
                    },
                    alternate: {
                        validate: (0,
                        T.assertNodeType)("Expression")
                    }
                },
                aliases: ["Expression", "Conditional"]
            }),
            (0,
            T.default)("ContinueStatement", {
                visitor: ["label"],
                fields: {
                    label: {
                        validate: (0,
                        T.assertNodeType)("Identifier"),
                        optional: !0
                    }
                },
                aliases: ["Statement", "Terminatorless", "CompletionStatement"]
            }),
            (0,
            T.default)("DebuggerStatement", {
                aliases: ["Statement"]
            }),
            (0,
            T.default)("DoWhileStatement", {
                visitor: ["test", "body"],
                fields: {
                    test: {
                        validate: (0,
                        T.assertNodeType)("Expression")
                    },
                    body: {
                        validate: (0,
                        T.assertNodeType)("Statement")
                    }
                },
                aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"]
            }),
            (0,
            T.default)("EmptyStatement", {
                aliases: ["Statement"]
            }),
            (0,
            T.default)("ExpressionStatement", {
                visitor: ["expression"],
                fields: {
                    expression: {
                        validate: (0,
                        T.assertNodeType)("Expression")
                    }
                },
                aliases: ["Statement", "ExpressionWrapper"]
            }),
            (0,
            T.default)("File", {
                builder: ["program", "comments", "tokens"],
                visitor: ["program"],
                fields: {
                    program: {
                        validate: (0,
                        T.assertNodeType)("Program")
                    },
                    comments: {
                        validate: t.env.BABEL_TYPES_8_BREAKING ? (0,
                        T.assertEach)((0,
                        T.assertNodeType)("CommentBlock", "CommentLine")) : Object.assign((function() {}
                        ), {
                            each: {
                                oneOfNodeTypes: ["CommentBlock", "CommentLine"]
                            }
                        }),
                        optional: !0
                    },
                    tokens: {
                        validate: (0,
                        T.assertEach)(Object.assign((function() {}
                        ), {
                            type: "any"
                        })),
                        optional: !0
                    }
                }
            }),
            (0,
            T.default)("ForInStatement", {
                visitor: ["left", "right", "body"],
                aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
                fields: {
                    left: {
                        validate: t.env.BABEL_TYPES_8_BREAKING ? (0,
                        T.assertNodeType)("VariableDeclaration", "Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern") : (0,
                        T.assertNodeType)("VariableDeclaration", "LVal")
                    },
                    right: {
                        validate: (0,
                        T.assertNodeType)("Expression")
                    },
                    body: {
                        validate: (0,
                        T.assertNodeType)("Statement")
                    }
                }
            }),
            (0,
            T.default)("ForStatement", {
                visitor: ["init", "test", "update", "body"],
                aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop"],
                fields: {
                    init: {
                        validate: (0,
                        T.assertNodeType)("VariableDeclaration", "Expression"),
                        optional: !0
                    },
                    test: {
                        validate: (0,
                        T.assertNodeType)("Expression"),
                        optional: !0
                    },
                    update: {
                        validate: (0,
                        T.assertNodeType)("Expression"),
                        optional: !0
                    },
                    body: {
                        validate: (0,
                        T.assertNodeType)("Statement")
                    }
                }
            });
            var S = {
                params: {
                    validate: (0,
                    T.chain)((0,
                    T.assertValueType)("array"), (0,
                    T.assertEach)((0,
                    T.assertNodeType)("Identifier", "Pattern", "RestElement")))
                },
                generator: {
                    default: !1
                },
                async: {
                    default: !1
                }
            };
            r.functionCommon = S;
            var g = {
                returnType: {
                    validate: (0,
                    T.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
                    optional: !0
                },
                typeParameters: {
                    validate: (0,
                    T.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
                    optional: !0
                }
            };
            r.functionTypeAnnotationCommon = g;
            var b = Object.assign({}, S, {
                declare: {
                    validate: (0,
                    T.assertValueType)("boolean"),
                    optional: !0
                },
                id: {
                    validate: (0,
                    T.assertNodeType)("Identifier"),
                    optional: !0
                }
            });
            r.functionDeclarationCommon = b,
            (0,
            T.default)("FunctionDeclaration", {
                builder: ["id", "params", "body", "generator", "async"],
                visitor: ["id", "params", "body", "returnType", "typeParameters"],
                fields: Object.assign({}, b, g, {
                    body: {
                        validate: (0,
                        T.assertNodeType)("BlockStatement")
                    }
                }),
                aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Statement", "Pureish", "Declaration"],
                validate: function() {
                    if (!t.env.BABEL_TYPES_8_BREAKING)
                        return function() {}
                        ;
                    var r = (0,
                    T.assertNodeType)("Identifier");
                    return function(t, i, a) {
                        (0,
                        d.default)("ExportDefaultDeclaration", t) || r(a, "id", a.id)
                    }
                }()
            }),
            (0,
            T.default)("FunctionExpression", {
                inherits: "FunctionDeclaration",
                aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
                fields: Object.assign({}, S, g, {
                    id: {
                        validate: (0,
                        T.assertNodeType)("Identifier"),
                        optional: !0
                    },
                    body: {
                        validate: (0,
                        T.assertNodeType)("BlockStatement")
                    }
                })
            });
            var v, E, P, x = {
                typeAnnotation: {
                    validate: (0,
                    T.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
                    optional: !0
                },
                decorators: {
                    validate: (0,
                    T.chain)((0,
                    T.assertValueType)("array"), (0,
                    T.assertEach)((0,
                    T.assertNodeType)("Decorator")))
                }
            };
            r.patternLikeCommon = x,
            (0,
            T.default)("Identifier", {
                builder: ["name"],
                visitor: ["typeAnnotation", "decorators"],
                aliases: ["Expression", "PatternLike", "LVal", "TSEntityName"],
                fields: Object.assign({}, x, {
                    name: {
                        validate: (0,
                        T.chain)((0,
                        T.assertValueType)("string"), Object.assign((function(r, i, a) {
                            if (t.env.BABEL_TYPES_8_BREAKING && !(0,
                            y.default)(a, !1))
                                throw new TypeError('"'.concat(a, '" is not a valid identifier name'))
                        }
                        ), {
                            type: "string"
                        }))
                    },
                    optional: {
                        validate: (0,
                        T.assertValueType)("boolean"),
                        optional: !0
                    }
                }),
                validate: function validate(r, i, a) {
                    if (t.env.BABEL_TYPES_8_BREAKING) {
                        var l = /\.(\w+)$/.exec(i);
                        if (l) {
                            var u = (0,
                            o.default)(l, 2)[1]
                              , p = {
                                computed: !1
                            };
                            if ("property" === u) {
                                if ((0,
                                d.default)("MemberExpression", r, p))
                                    return;
                                if ((0,
                                d.default)("OptionalMemberExpression", r, p))
                                    return
                            } else if ("key" === u) {
                                if ((0,
                                d.default)("Property", r, p))
                                    return;
                                if ((0,
                                d.default)("Method", r, p))
                                    return
                            } else if ("exported" === u) {
                                if ((0,
                                d.default)("ExportSpecifier", r))
                                    return
                            } else if ("imported" === u) {
                                if ((0,
                                d.default)("ImportSpecifier", r, {
                                    imported: a
                                }))
                                    return
                            } else if ("meta" === u && (0,
                            d.default)("MetaProperty", r, {
                                meta: a
                            }))
                                return;
                            if (((0,
                            h.isKeyword)(a.name) || (0,
                            h.isReservedWord)(a.name, !1)) && "this" !== a.name)
                                throw new TypeError('"'.concat(a.name, '" is not a valid identifier'))
                        }
                    }
                }
            }),
            (0,
            T.default)("IfStatement", {
                visitor: ["test", "consequent", "alternate"],
                aliases: ["Statement", "Conditional"],
                fields: {
                    test: {
                        validate: (0,
                        T.assertNodeType)("Expression")
                    },
                    consequent: {
                        validate: (0,
                        T.assertNodeType)("Statement")
                    },
                    alternate: {
                        optional: !0,
                        validate: (0,
                        T.assertNodeType)("Statement")
                    }
                }
            }),
            (0,
            T.default)("LabeledStatement", {
                visitor: ["label", "body"],
                aliases: ["Statement"],
                fields: {
                    label: {
                        validate: (0,
                        T.assertNodeType)("Identifier")
                    },
                    body: {
                        validate: (0,
                        T.assertNodeType)("Statement")
                    }
                }
            }),
            (0,
            T.default)("StringLiteral", {
                builder: ["value"],
                fields: {
                    value: {
                        validate: (0,
                        T.assertValueType)("string")
                    }
                },
                aliases: ["Expression", "Pureish", "Literal", "Immutable"]
            }),
            (0,
            T.default)("NumericLiteral", {
                builder: ["value"],
                deprecatedAlias: "NumberLiteral",
                fields: {
                    value: {
                        validate: (0,
                        T.assertValueType)("number")
                    }
                },
                aliases: ["Expression", "Pureish", "Literal", "Immutable"]
            }),
            (0,
            T.default)("NullLiteral", {
                aliases: ["Expression", "Pureish", "Literal", "Immutable"]
            }),
            (0,
            T.default)("BooleanLiteral", {
                builder: ["value"],
                fields: {
                    value: {
                        validate: (0,
                        T.assertValueType)("boolean")
                    }
                },
                aliases: ["Expression", "Pureish", "Literal", "Immutable"]
            }),
            (0,
            T.default)("RegExpLiteral", {
                builder: ["pattern", "flags"],
                deprecatedAlias: "RegexLiteral",
                aliases: ["Expression", "Pureish", "Literal"],
                fields: {
                    pattern: {
                        validate: (0,
                        T.assertValueType)("string")
                    },
                    flags: {
                        validate: (0,
                        T.chain)((0,
                        T.assertValueType)("string"), Object.assign((function(r, i, a) {
                            if (t.env.BABEL_TYPES_8_BREAKING) {
                                var o = /[^gimsuy]/.exec(a);
                                if (o)
                                    throw new TypeError('"'.concat(o[0], '" is not a valid RegExp flag'))
                            }
                        }
                        ), {
                            type: "string"
                        })),
                        default: ""
                    }
                }
            }),
            (0,
            T.default)("LogicalExpression", {
                builder: ["operator", "left", "right"],
                visitor: ["left", "right"],
                aliases: ["Binary", "Expression"],
                fields: {
                    operator: {
                        validate: T.assertOneOf.apply(void 0, (0,
                        l.default)(m.LOGICAL_OPERATORS))
                    },
                    left: {
                        validate: (0,
                        T.assertNodeType)("Expression")
                    },
                    right: {
                        validate: (0,
                        T.assertNodeType)("Expression")
                    }
                }
            }),
            (0,
            T.default)("MemberExpression", {
                builder: ["object", "property", "computed"].concat((0,
                l.default)(t.env.BABEL_TYPES_8_BREAKING ? [] : ["optional"])),
                visitor: ["object", "property"],
                aliases: ["Expression", "LVal"],
                fields: Object.assign({
                    object: {
                        validate: (0,
                        T.assertNodeType)("Expression")
                    },
                    property: {
                        validate: function() {
                            var t = (0,
                            T.assertNodeType)("Identifier", "PrivateName")
                              , r = (0,
                            T.assertNodeType)("Expression")
                              , i = function validator(i, a, o) {
                                var validator = i.computed ? r : t;
                                validator(i, a, o)
                            };
                            return i.oneOfNodeTypes = ["Expression", "Identifier", "PrivateName"],
                            i
                        }()
                    },
                    computed: {
                        default: !1
                    }
                }, t.env.BABEL_TYPES_8_BREAKING ? {} : {
                    optional: {
                        validate: (0,
                        T.assertOneOf)(!0, !1),
                        optional: !0
                    }
                })
            }),
            (0,
            T.default)("NewExpression", {
                inherits: "CallExpression"
            }),
            (0,
            T.default)("Program", {
                visitor: ["directives", "body"],
                builder: ["body", "directives", "sourceType", "interpreter"],
                fields: {
                    sourceFile: {
                        validate: (0,
                        T.assertValueType)("string")
                    },
                    sourceType: {
                        validate: (0,
                        T.assertOneOf)("script", "module"),
                        default: "script"
                    },
                    interpreter: {
                        validate: (0,
                        T.assertNodeType)("InterpreterDirective"),
                        default: null,
                        optional: !0
                    },
                    directives: {
                        validate: (0,
                        T.chain)((0,
                        T.assertValueType)("array"), (0,
                        T.assertEach)((0,
                        T.assertNodeType)("Directive"))),
                        default: []
                    },
                    body: {
                        validate: (0,
                        T.chain)((0,
                        T.assertValueType)("array"), (0,
                        T.assertEach)((0,
                        T.assertNodeType)("Statement")))
                    }
                },
                aliases: ["Scopable", "BlockParent", "Block"]
            }),
            (0,
            T.default)("ObjectExpression", {
                visitor: ["properties"],
                aliases: ["Expression"],
                fields: {
                    properties: {
                        validate: (0,
                        T.chain)((0,
                        T.assertValueType)("array"), (0,
                        T.assertEach)((0,
                        T.assertNodeType)("ObjectMethod", "ObjectProperty", "SpreadElement")))
                    }
                }
            }),
            (0,
            T.default)("ObjectMethod", {
                builder: ["kind", "key", "params", "body", "computed", "generator", "async"],
                fields: Object.assign({}, S, g, {
                    kind: Object.assign({
                        validate: (0,
                        T.assertOneOf)("method", "get", "set")
                    }, t.env.BABEL_TYPES_8_BREAKING ? {} : {
                        default: "method"
                    }),
                    computed: {
                        default: !1
                    },
                    key: {
                        validate: function() {
                            var t = (0,
                            T.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral")
                              , r = (0,
                            T.assertNodeType)("Expression")
                              , i = function validator(i, a, o) {
                                var validator = i.computed ? r : t;
                                validator(i, a, o)
                            };
                            return i.oneOfNodeTypes = ["Expression", "Identifier", "StringLiteral", "NumericLiteral"],
                            i
                        }()
                    },
                    decorators: {
                        validate: (0,
                        T.chain)((0,
                        T.assertValueType)("array"), (0,
                        T.assertEach)((0,
                        T.assertNodeType)("Decorator"))),
                        optional: !0
                    },
                    body: {
                        validate: (0,
                        T.assertNodeType)("BlockStatement")
                    }
                }),
                visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
                aliases: ["UserWhitespacable", "Function", "Scopable", "BlockParent", "FunctionParent", "Method", "ObjectMember"]
            }),
            (0,
            T.default)("ObjectProperty", {
                builder: ["key", "value", "computed", "shorthand"].concat((0,
                l.default)(t.env.BABEL_TYPES_8_BREAKING ? [] : ["decorators"])),
                fields: {
                    computed: {
                        default: !1
                    },
                    key: {
                        validate: function() {
                            var t = (0,
                            T.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral")
                              , r = (0,
                            T.assertNodeType)("Expression")
                              , i = function validator(i, a, o) {
                                var validator = i.computed ? r : t;
                                validator(i, a, o)
                            };
                            return i.oneOfNodeTypes = ["Expression", "Identifier", "StringLiteral", "NumericLiteral"],
                            i
                        }()
                    },
                    value: {
                        validate: (0,
                        T.assertNodeType)("Expression", "PatternLike")
                    },
                    shorthand: {
                        validate: (0,
                        T.chain)((0,
                        T.assertValueType)("boolean"), Object.assign((function(r, i, a) {
                            if (t.env.BABEL_TYPES_8_BREAKING && a && r.computed)
                                throw new TypeError("Property shorthand of ObjectProperty cannot be true if computed is true")
                        }
                        ), {
                            type: "boolean"
                        }), (function(r, i, a) {
                            if (t.env.BABEL_TYPES_8_BREAKING && a && !(0,
                            d.default)("Identifier", r.key))
                                throw new TypeError("Property shorthand of ObjectProperty cannot be true if key is not an Identifier")
                        }
                        )),
                        default: !1
                    },
                    decorators: {
                        validate: (0,
                        T.chain)((0,
                        T.assertValueType)("array"), (0,
                        T.assertEach)((0,
                        T.assertNodeType)("Decorator"))),
                        optional: !0
                    }
                },
                visitor: ["key", "value", "decorators"],
                aliases: ["UserWhitespacable", "Property", "ObjectMember"],
                validate: function() {
                    var r = (0,
                    T.assertNodeType)("Identifier", "Pattern")
                      , i = (0,
                    T.assertNodeType)("Expression");
                    return function(a, o, l) {
                        t.env.BABEL_TYPES_8_BREAKING && ((0,
                        d.default)("ObjectPattern", a) ? r : i)(l, "value", l.value)
                    }
                }()
            }),
            (0,
            T.default)("RestElement", {
                visitor: ["argument", "typeAnnotation"],
                builder: ["argument"],
                aliases: ["LVal", "PatternLike"],
                deprecatedAlias: "RestProperty",
                fields: Object.assign({}, x, {
                    argument: {
                        validate: t.env.BABEL_TYPES_8_BREAKING ? (0,
                        T.assertNodeType)("Identifier", "Pattern", "MemberExpression") : (0,
                        T.assertNodeType)("LVal")
                    },
                    optional: {
                        validate: (0,
                        T.assertValueType)("boolean"),
                        optional: !0
                    }
                }),
                validate: function validate(r, i) {
                    if (t.env.BABEL_TYPES_8_BREAKING) {
                        var a = /(\w+)\[(\d+)\]/.exec(i);
                        if (!a)
                            throw new Error("Internal Babel error: malformed key.");
                        var l = (0,
                        o.default)(a, 3)
                          , u = l[1]
                          , p = l[2];
                        if (r[u].length > p + 1)
                            throw new TypeError("RestElement must be last element of ".concat(u))
                    }
                }
            }),
            (0,
            T.default)("ReturnStatement", {
                visitor: ["argument"],
                aliases: ["Statement", "Terminatorless", "CompletionStatement"],
                fields: {
                    argument: {
                        validate: (0,
                        T.assertNodeType)("Expression"),
                        optional: !0
                    }
                }
            }),
            (0,
            T.default)("SequenceExpression", {
                visitor: ["expressions"],
                fields: {
                    expressions: {
                        validate: (0,
                        T.chain)((0,
                        T.assertValueType)("array"), (0,
                        T.assertEach)((0,
                        T.assertNodeType)("Expression")))
                    }
                },
                aliases: ["Expression"]
            }),
            (0,
            T.default)("ParenthesizedExpression", {
                visitor: ["expression"],
                aliases: ["Expression", "ExpressionWrapper"],
                fields: {
                    expression: {
                        validate: (0,
                        T.assertNodeType)("Expression")
                    }
                }
            }),
            (0,
            T.default)("SwitchCase", {
                visitor: ["test", "consequent"],
                fields: {
                    test: {
                        validate: (0,
                        T.assertNodeType)("Expression"),
                        optional: !0
                    },
                    consequent: {
                        validate: (0,
                        T.chain)((0,
                        T.assertValueType)("array"), (0,
                        T.assertEach)((0,
                        T.assertNodeType)("Statement")))
                    }
                }
            }),
            (0,
            T.default)("SwitchStatement", {
                visitor: ["discriminant", "cases"],
                aliases: ["Statement", "BlockParent", "Scopable"],
                fields: {
                    discriminant: {
                        validate: (0,
                        T.assertNodeType)("Expression")
                    },
                    cases: {
                        validate: (0,
                        T.chain)((0,
                        T.assertValueType)("array"), (0,
                        T.assertEach)((0,
                        T.assertNodeType)("SwitchCase")))
                    }
                }
            }),
            (0,
            T.default)("ThisExpression", {
                aliases: ["Expression"]
            }),
            (0,
            T.default)("ThrowStatement", {
                visitor: ["argument"],
                aliases: ["Statement", "Terminatorless", "CompletionStatement"],
                fields: {
                    argument: {
                        validate: (0,
                        T.assertNodeType)("Expression")
                    }
                }
            }),
            (0,
            T.default)("TryStatement", {
                visitor: ["block", "handler", "finalizer"],
                aliases: ["Statement"],
                fields: {
                    block: {
                        validate: (0,
                        T.chain)((0,
                        T.assertNodeType)("BlockStatement"), Object.assign((function(r) {
                            if (t.env.BABEL_TYPES_8_BREAKING && !r.handler && !r.finalizer)
                                throw new TypeError("TryStatement expects either a handler or finalizer, or both")
                        }
                        ), {
                            oneOfNodeTypes: ["BlockStatement"]
                        }))
                    },
                    handler: {
                        optional: !0,
                        validate: (0,
                        T.assertNodeType)("CatchClause")
                    },
                    finalizer: {
                        optional: !0,
                        validate: (0,
                        T.assertNodeType)("BlockStatement")
                    }
                }
            }),
            (0,
            T.default)("UnaryExpression", {
                builder: ["operator", "argument", "prefix"],
                fields: {
                    prefix: {
                        default: !0
                    },
                    argument: {
                        validate: (0,
                        T.assertNodeType)("Expression")
                    },
                    operator: {
                        validate: T.assertOneOf.apply(void 0, (0,
                        l.default)(m.UNARY_OPERATORS))
                    }
                },
                visitor: ["argument"],
                aliases: ["UnaryLike", "Expression"]
            }),
            (0,
            T.default)("UpdateExpression", {
                builder: ["operator", "argument", "prefix"],
                fields: {
                    prefix: {
                        default: !1
                    },
                    argument: {
                        validate: t.env.BABEL_TYPES_8_BREAKING ? (0,
                        T.assertNodeType)("Identifier", "MemberExpression") : (0,
                        T.assertNodeType)("Expression")
                    },
                    operator: {
                        validate: T.assertOneOf.apply(void 0, (0,
                        l.default)(m.UPDATE_OPERATORS))
                    }
                },
                visitor: ["argument"],
                aliases: ["Expression"]
            }),
            (0,
            T.default)("VariableDeclaration", {
                builder: ["kind", "declarations"],
                visitor: ["declarations"],
                aliases: ["Statement", "Declaration"],
                fields: {
                    declare: {
                        validate: (0,
                        T.assertValueType)("boolean"),
                        optional: !0
                    },
                    kind: {
                        validate: (0,
                        T.assertOneOf)("var", "let", "const")
                    },
                    declarations: {
                        validate: (0,
                        T.chain)((0,
                        T.assertValueType)("array"), (0,
                        T.assertEach)((0,
                        T.assertNodeType)("VariableDeclarator")))
                    }
                },
                validate: function validate(r, i, a) {
                    if (t.env.BABEL_TYPES_8_BREAKING && (0,
                    d.default)("ForXStatement", r, {
                        left: a
                    }) && 1 !== a.declarations.length)
                        throw new TypeError("Exactly one VariableDeclarator is required in the VariableDeclaration of a ".concat(r.type))
                }
            }),
            (0,
            T.default)("VariableDeclarator", {
                visitor: ["id", "init"],
                fields: {
                    id: {
                        validate: function() {
                            if (!t.env.BABEL_TYPES_8_BREAKING)
                                return (0,
                                T.assertNodeType)("LVal");
                            var r = (0,
                            T.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern")
                              , i = (0,
                            T.assertNodeType)("Identifier");
                            return function(t, a, o) {
                                (t.init ? r : i)(t, a, o)
                            }
                        }()
                    },
                    definite: {
                        optional: !0,
                        validate: (0,
                        T.assertValueType)("boolean")
                    },
                    init: {
                        optional: !0,
                        validate: (0,
                        T.assertNodeType)("Expression")
                    }
                }
            }),
            (0,
            T.default)("WhileStatement", {
                visitor: ["test", "body"],
                aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"],
                fields: {
                    test: {
                        validate: (0,
                        T.assertNodeType)("Expression")
                    },
                    body: {
                        validate: (0,
                        T.assertNodeType)("Statement")
                    }
                }
            }),
            (0,
            T.default)("WithStatement", {
                visitor: ["object", "body"],
                aliases: ["Statement"],
                fields: {
                    object: {
                        validate: (0,
                        T.assertNodeType)("Expression")
                    },
                    body: {
                        validate: (0,
                        T.assertNodeType)("Statement")
                    }
                }
            }),
            (0,
            T.default)("AssignmentPattern", {
                visitor: ["left", "right", "decorators"],
                builder: ["left", "right"],
                aliases: ["Pattern", "PatternLike", "LVal"],
                fields: Object.assign({}, x, {
                    left: {
                        validate: (0,
                        T.assertNodeType)("Identifier", "ObjectPattern", "ArrayPattern", "MemberExpression")
                    },
                    right: {
                        validate: (0,
                        T.assertNodeType)("Expression")
                    },
                    decorators: {
                        validate: (0,
                        T.chain)((0,
                        T.assertValueType)("array"), (0,
                        T.assertEach)((0,
                        T.assertNodeType)("Decorator"))),
                        optional: !0
                    }
                })
            }),
            (0,
            T.default)("ArrayPattern", {
                visitor: ["elements", "typeAnnotation"],
                builder: ["elements"],
                aliases: ["Pattern", "PatternLike", "LVal"],
                fields: Object.assign({}, x, {
                    elements: {
                        validate: (0,
                        T.chain)((0,
                        T.assertValueType)("array"), (0,
                        T.assertEach)((0,
                        T.assertNodeOrValueType)("null", "PatternLike")))
                    },
                    decorators: {
                        validate: (0,
                        T.chain)((0,
                        T.assertValueType)("array"), (0,
                        T.assertEach)((0,
                        T.assertNodeType)("Decorator"))),
                        optional: !0
                    },
                    optional: {
                        validate: (0,
                        T.assertValueType)("boolean"),
                        optional: !0
                    }
                })
            }),
            (0,
            T.default)("ArrowFunctionExpression", {
                builder: ["params", "body", "async"],
                visitor: ["params", "body", "returnType", "typeParameters"],
                aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
                fields: Object.assign({}, S, g, {
                    expression: {
                        validate: (0,
                        T.assertValueType)("boolean")
                    },
                    body: {
                        validate: (0,
                        T.assertNodeType)("BlockStatement", "Expression")
                    }
                })
            }),
            (0,
            T.default)("ClassBody", {
                visitor: ["body"],
                fields: {
                    body: {
                        validate: (0,
                        T.chain)((0,
                        T.assertValueType)("array"), (0,
                        T.assertEach)((0,
                        T.assertNodeType)("ClassMethod", "ClassPrivateMethod", "ClassProperty", "ClassPrivateProperty", "TSDeclareMethod", "TSIndexSignature")))
                    }
                }
            }),
            (0,
            T.default)("ClassExpression", {
                builder: ["id", "superClass", "body", "decorators"],
                visitor: ["id", "body", "superClass", "mixins", "typeParameters", "superTypeParameters", "implements", "decorators"],
                aliases: ["Scopable", "Class", "Expression"],
                fields: {
                    id: {
                        validate: (0,
                        T.assertNodeType)("Identifier"),
                        optional: !0
                    },
                    typeParameters: {
                        validate: (0,
                        T.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
                        optional: !0
                    },
                    body: {
                        validate: (0,
                        T.assertNodeType)("ClassBody")
                    },
                    superClass: {
                        optional: !0,
                        validate: (0,
                        T.assertNodeType)("Expression")
                    },
                    superTypeParameters: {
                        validate: (0,
                        T.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
                        optional: !0
                    },
                    implements: {
                        validate: (0,
                        T.chain)((0,
                        T.assertValueType)("array"), (0,
                        T.assertEach)((0,
                        T.assertNodeType)("TSExpressionWithTypeArguments", "ClassImplements"))),
                        optional: !0
                    },
                    decorators: {
                        validate: (0,
                        T.chain)((0,
                        T.assertValueType)("array"), (0,
                        T.assertEach)((0,
                        T.assertNodeType)("Decorator"))),
                        optional: !0
                    },
                    mixins: {
                        validate: (0,
                        T.assertNodeType)("InterfaceExtends"),
                        optional: !0
                    }
                }
            }),
            (0,
            T.default)("ClassDeclaration", {
                inherits: "ClassExpression",
                aliases: ["Scopable", "Class", "Statement", "Declaration"],
                fields: {
                    id: {
                        validate: (0,
                        T.assertNodeType)("Identifier")
                    },
                    typeParameters: {
                        validate: (0,
                        T.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
                        optional: !0
                    },
                    body: {
                        validate: (0,
                        T.assertNodeType)("ClassBody")
                    },
                    superClass: {
                        optional: !0,
                        validate: (0,
                        T.assertNodeType)("Expression")
                    },
                    superTypeParameters: {
                        validate: (0,
                        T.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
                        optional: !0
                    },
                    implements: {
                        validate: (0,
                        T.chain)((0,
                        T.assertValueType)("array"), (0,
                        T.assertEach)((0,
                        T.assertNodeType)("TSExpressionWithTypeArguments", "ClassImplements"))),
                        optional: !0
                    },
                    decorators: {
                        validate: (0,
                        T.chain)((0,
                        T.assertValueType)("array"), (0,
                        T.assertEach)((0,
                        T.assertNodeType)("Decorator"))),
                        optional: !0
                    },
                    mixins: {
                        validate: (0,
                        T.assertNodeType)("InterfaceExtends"),
                        optional: !0
                    },
                    declare: {
                        validate: (0,
                        T.assertValueType)("boolean"),
                        optional: !0
                    },
                    abstract: {
                        validate: (0,
                        T.assertValueType)("boolean"),
                        optional: !0
                    }
                },
                validate: (v = (0,
                T.assertNodeType)("Identifier"),
                function(r, i, a) {
                    t.env.BABEL_TYPES_8_BREAKING && ((0,
                    d.default)("ExportDefaultDeclaration", r) || v(a, "id", a.id))
                }
                )
            }),
            (0,
            T.default)("ExportAllDeclaration", {
                visitor: ["source"],
                aliases: ["Statement", "Declaration", "ModuleDeclaration", "ExportDeclaration"],
                fields: {
                    source: {
                        validate: (0,
                        T.assertNodeType)("StringLiteral")
                    },
                    exportKind: (0,
                    T.validateOptional)((0,
                    T.assertOneOf)("type", "value")),
                    assertions: {
                        optional: !0,
                        validate: (0,
                        T.chain)((0,
                        T.assertValueType)("array"), (0,
                        T.assertEach)((0,
                        T.assertNodeType)("ImportAttribute")))
                    }
                }
            }),
            (0,
            T.default)("ExportDefaultDeclaration", {
                visitor: ["declaration"],
                aliases: ["Statement", "Declaration", "ModuleDeclaration", "ExportDeclaration"],
                fields: {
                    declaration: {
                        validate: (0,
                        T.assertNodeType)("FunctionDeclaration", "TSDeclareFunction", "ClassDeclaration", "Expression")
                    },
                    exportKind: (0,
                    T.validateOptional)((0,
                    T.assertOneOf)("value"))
                }
            }),
            (0,
            T.default)("ExportNamedDeclaration", {
                visitor: ["declaration", "specifiers", "source"],
                aliases: ["Statement", "Declaration", "ModuleDeclaration", "ExportDeclaration"],
                fields: {
                    declaration: {
                        optional: !0,
                        validate: (0,
                        T.chain)((0,
                        T.assertNodeType)("Declaration"), Object.assign((function(r, i, a) {
                            if (t.env.BABEL_TYPES_8_BREAKING && a && r.specifiers.length)
                                throw new TypeError("Only declaration or specifiers is allowed on ExportNamedDeclaration")
                        }
                        ), {
                            oneOfNodeTypes: ["Declaration"]
                        }), (function(r, i, a) {
                            if (t.env.BABEL_TYPES_8_BREAKING && a && r.source)
                                throw new TypeError("Cannot export a declaration from a source")
                        }
                        ))
                    },
                    assertions: {
                        optional: !0,
                        validate: (0,
                        T.chain)((0,
                        T.assertValueType)("array"), (0,
                        T.assertEach)((0,
                        T.assertNodeType)("ImportAttribute")))
                    },
                    specifiers: {
                        default: [],
                        validate: (0,
                        T.chain)((0,
                        T.assertValueType)("array"), (0,
                        T.assertEach)((E = (0,
                        T.assertNodeType)("ExportSpecifier", "ExportDefaultSpecifier", "ExportNamespaceSpecifier"),
                        P = (0,
                        T.assertNodeType)("ExportSpecifier"),
                        t.env.BABEL_TYPES_8_BREAKING ? function(t, r, i) {
                            (t.source ? E : P)(t, r, i)
                        }
                        : E)))
                    },
                    source: {
                        validate: (0,
                        T.assertNodeType)("StringLiteral"),
                        optional: !0
                    },
                    exportKind: (0,
                    T.validateOptional)((0,
                    T.assertOneOf)("type", "value"))
                }
            }),
            (0,
            T.default)("ExportSpecifier", {
                visitor: ["local", "exported"],
                aliases: ["ModuleSpecifier"],
                fields: {
                    local: {
                        validate: (0,
                        T.assertNodeType)("Identifier")
                    },
                    exported: {
                        validate: (0,
                        T.assertNodeType)("Identifier", "StringLiteral")
                    }
                }
            }),
            (0,
            T.default)("ForOfStatement", {
                visitor: ["left", "right", "body"],
                builder: ["left", "right", "body", "await"],
                aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
                fields: {
                    left: {
                        validate: function() {
                            if (!t.env.BABEL_TYPES_8_BREAKING)
                                return (0,
                                T.assertNodeType)("VariableDeclaration", "LVal");
                            var r = (0,
                            T.assertNodeType)("VariableDeclaration")
                              , i = (0,
                            T.assertNodeType)("Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern");
                            return function(t, a, o) {
                                (0,
                                d.default)("VariableDeclaration", o) ? r(t, a, o) : i(t, a, o)
                            }
                        }()
                    },
                    right: {
                        validate: (0,
                        T.assertNodeType)("Expression")
                    },
                    body: {
                        validate: (0,
                        T.assertNodeType)("Statement")
                    },
                    await: {
                        default: !1
                    }
                }
            }),
            (0,
            T.default)("ImportDeclaration", {
                visitor: ["specifiers", "source"],
                aliases: ["Statement", "Declaration", "ModuleDeclaration"],
                fields: {
                    assertions: {
                        optional: !0,
                        validate: (0,
                        T.chain)((0,
                        T.assertValueType)("array"), (0,
                        T.assertEach)((0,
                        T.assertNodeType)("ImportAttribute")))
                    },
                    specifiers: {
                        validate: (0,
                        T.chain)((0,
                        T.assertValueType)("array"), (0,
                        T.assertEach)((0,
                        T.assertNodeType)("ImportSpecifier", "ImportDefaultSpecifier", "ImportNamespaceSpecifier")))
                    },
                    source: {
                        validate: (0,
                        T.assertNodeType)("StringLiteral")
                    },
                    importKind: {
                        validate: (0,
                        T.assertOneOf)("type", "typeof", "value"),
                        optional: !0
                    }
                }
            }),
            (0,
            T.default)("ImportDefaultSpecifier", {
                visitor: ["local"],
                aliases: ["ModuleSpecifier"],
                fields: {
                    local: {
                        validate: (0,
                        T.assertNodeType)("Identifier")
                    }
                }
            }),
            (0,
            T.default)("ImportNamespaceSpecifier", {
                visitor: ["local"],
                aliases: ["ModuleSpecifier"],
                fields: {
                    local: {
                        validate: (0,
                        T.assertNodeType)("Identifier")
                    }
                }
            }),
            (0,
            T.default)("ImportSpecifier", {
                visitor: ["local", "imported"],
                aliases: ["ModuleSpecifier"],
                fields: {
                    local: {
                        validate: (0,
                        T.assertNodeType)("Identifier")
                    },
                    imported: {
                        validate: (0,
                        T.assertNodeType)("Identifier", "StringLiteral")
                    },
                    importKind: {
                        validate: (0,
                        T.assertOneOf)("type", "typeof"),
                        optional: !0
                    }
                }
            }),
            (0,
            T.default)("MetaProperty", {
                visitor: ["meta", "property"],
                aliases: ["Expression"],
                fields: {
                    meta: {
                        validate: (0,
                        T.chain)((0,
                        T.assertNodeType)("Identifier"), Object.assign((function(r, i, a) {
                            if (t.env.BABEL_TYPES_8_BREAKING) {
                                var o;
                                switch (a.name) {
                                case "function":
                                    o = "sent";
                                    break;
                                case "new":
                                    o = "target";
                                    break;
                                case "import":
                                    o = "meta"
                                }
                                if (!(0,
                                d.default)("Identifier", r.property, {
                                    name: o
                                }))
                                    throw new TypeError("Unrecognised MetaProperty")
                            }
                        }
                        ), {
                            oneOfNodeTypes: ["Identifier"]
                        }))
                    },
                    property: {
                        validate: (0,
                        T.assertNodeType)("Identifier")
                    }
                }
            });
            var A, O, I = {
                abstract: {
                    validate: (0,
                    T.assertValueType)("boolean"),
                    optional: !0
                },
                accessibility: {
                    validate: (0,
                    T.assertOneOf)("public", "private", "protected"),
                    optional: !0
                },
                static: {
                    default: !1
                },
                override: {
                    default: !1
                },
                computed: {
                    default: !1
                },
                optional: {
                    validate: (0,
                    T.assertValueType)("boolean"),
                    optional: !0
                },
                key: {
                    validate: (0,
                    T.chain)((A = (0,
                    T.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral"),
                    O = (0,
                    T.assertNodeType)("Expression"),
                    function(t, r, i) {
                        (t.computed ? O : A)(t, r, i)
                    }
                    ), (0,
                    T.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "Expression"))
                }
            };
            r.classMethodOrPropertyCommon = I;
            var w = Object.assign({}, S, I, {
                params: {
                    validate: (0,
                    T.chain)((0,
                    T.assertValueType)("array"), (0,
                    T.assertEach)((0,
                    T.assertNodeType)("Identifier", "Pattern", "RestElement", "TSParameterProperty")))
                },
                kind: {
                    validate: (0,
                    T.assertOneOf)("get", "set", "method", "constructor"),
                    default: "method"
                },
                access: {
                    validate: (0,
                    T.chain)((0,
                    T.assertValueType)("string"), (0,
                    T.assertOneOf)("public", "private", "protected")),
                    optional: !0
                },
                decorators: {
                    validate: (0,
                    T.chain)((0,
                    T.assertValueType)("array"), (0,
                    T.assertEach)((0,
                    T.assertNodeType)("Decorator"))),
                    optional: !0
                }
            });
            r.classMethodOrDeclareMethodCommon = w,
            (0,
            T.default)("ClassMethod", {
                aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method"],
                builder: ["kind", "key", "params", "body", "computed", "static", "generator", "async"],
                visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
                fields: Object.assign({}, w, g, {
                    body: {
                        validate: (0,
                        T.assertNodeType)("BlockStatement")
                    }
                })
            }),
            (0,
            T.default)("ObjectPattern", {
                visitor: ["properties", "typeAnnotation", "decorators"],
                builder: ["properties"],
                aliases: ["Pattern", "PatternLike", "LVal"],
                fields: Object.assign({}, x, {
                    properties: {
                        validate: (0,
                        T.chain)((0,
                        T.assertValueType)("array"), (0,
                        T.assertEach)((0,
                        T.assertNodeType)("RestElement", "ObjectProperty")))
                    }
                })
            }),
            (0,
            T.default)("SpreadElement", {
                visitor: ["argument"],
                aliases: ["UnaryLike"],
                deprecatedAlias: "SpreadProperty",
                fields: {
                    argument: {
                        validate: (0,
                        T.assertNodeType)("Expression")
                    }
                }
            }),
            (0,
            T.default)("Super", {
                aliases: ["Expression"]
            }),
            (0,
            T.default)("TaggedTemplateExpression", {
                visitor: ["tag", "quasi", "typeParameters"],
                builder: ["tag", "quasi"],
                aliases: ["Expression"],
                fields: {
                    tag: {
                        validate: (0,
                        T.assertNodeType)("Expression")
                    },
                    quasi: {
                        validate: (0,
                        T.assertNodeType)("TemplateLiteral")
                    },
                    typeParameters: {
                        validate: (0,
                        T.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
                        optional: !0
                    }
                }
            }),
            (0,
            T.default)("TemplateElement", {
                builder: ["value", "tail"],
                fields: {
                    value: {
                        validate: (0,
                        T.assertShape)({
                            raw: {
                                validate: (0,
                                T.assertValueType)("string")
                            },
                            cooked: {
                                validate: (0,
                                T.assertValueType)("string"),
                                optional: !0
                            }
                        })
                    },
                    tail: {
                        default: !1
                    }
                }
            }),
            (0,
            T.default)("TemplateLiteral", {
                visitor: ["quasis", "expressions"],
                aliases: ["Expression", "Literal"],
                fields: {
                    quasis: {
                        validate: (0,
                        T.chain)((0,
                        T.assertValueType)("array"), (0,
                        T.assertEach)((0,
                        T.assertNodeType)("TemplateElement")))
                    },
                    expressions: {
                        validate: (0,
                        T.chain)((0,
                        T.assertValueType)("array"), (0,
                        T.assertEach)((0,
                        T.assertNodeType)("Expression", "TSType")), (function(t, r, i) {
                            if (t.quasis.length !== i.length + 1)
                                throw new TypeError("Number of ".concat(t.type, " quasis should be exactly one more than the number of expressions.\nExpected ").concat(i.length + 1, " quasis but got ").concat(t.quasis.length))
                        }
                        ))
                    }
                }
            }),
            (0,
            T.default)("YieldExpression", {
                builder: ["argument", "delegate"],
                visitor: ["argument"],
                aliases: ["Expression", "Terminatorless"],
                fields: {
                    delegate: {
                        validate: (0,
                        T.chain)((0,
                        T.assertValueType)("boolean"), Object.assign((function(r, i, a) {
                            if (t.env.BABEL_TYPES_8_BREAKING && a && !r.argument)
                                throw new TypeError("Property delegate of YieldExpression cannot be true if there is no argument")
                        }
                        ), {
                            type: "boolean"
                        })),
                        default: !1
                    },
                    argument: {
                        optional: !0,
                        validate: (0,
                        T.assertNodeType)("Expression")
                    }
                }
            }),
            (0,
            T.default)("AwaitExpression", {
                builder: ["argument"],
                visitor: ["argument"],
                aliases: ["Expression", "Terminatorless"],
                fields: {
                    argument: {
                        validate: (0,
                        T.assertNodeType)("Expression")
                    }
                }
            }),
            (0,
            T.default)("Import", {
                aliases: ["Expression"]
            }),
            (0,
            T.default)("BigIntLiteral", {
                builder: ["value"],
                fields: {
                    value: {
                        validate: (0,
                        T.assertValueType)("string")
                    }
                },
                aliases: ["Expression", "Pureish", "Literal", "Immutable"]
            }),
            (0,
            T.default)("ExportNamespaceSpecifier", {
                visitor: ["exported"],
                aliases: ["ModuleSpecifier"],
                fields: {
                    exported: {
                        validate: (0,
                        T.assertNodeType)("Identifier")
                    }
                }
            }),
            (0,
            T.default)("OptionalMemberExpression", {
                builder: ["object", "property", "computed", "optional"],
                visitor: ["object", "property"],
                aliases: ["Expression"],
                fields: {
                    object: {
                        validate: (0,
                        T.assertNodeType)("Expression")
                    },
                    property: {
                        validate: function() {
                            var t = (0,
                            T.assertNodeType)("Identifier")
                              , r = (0,
                            T.assertNodeType)("Expression")
                              , i = function validator(i, a, o) {
                                var validator = i.computed ? r : t;
                                validator(i, a, o)
                            };
                            return i.oneOfNodeTypes = ["Expression", "Identifier"],
                            i
                        }()
                    },
                    computed: {
                        default: !1
                    },
                    optional: {
                        validate: t.env.BABEL_TYPES_8_BREAKING ? (0,
                        T.chain)((0,
                        T.assertValueType)("boolean"), (0,
                        T.assertOptionalChainStart)()) : (0,
                        T.assertValueType)("boolean")
                    }
                }
            }),
            (0,
            T.default)("OptionalCallExpression", {
                visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
                builder: ["callee", "arguments", "optional"],
                aliases: ["Expression"],
                fields: {
                    callee: {
                        validate: (0,
                        T.assertNodeType)("Expression")
                    },
                    arguments: {
                        validate: (0,
                        T.chain)((0,
                        T.assertValueType)("array"), (0,
                        T.assertEach)((0,
                        T.assertNodeType)("Expression", "SpreadElement", "JSXNamespacedName", "ArgumentPlaceholder")))
                    },
                    optional: {
                        validate: t.env.BABEL_TYPES_8_BREAKING ? (0,
                        T.chain)((0,
                        T.assertValueType)("boolean"), (0,
                        T.assertOptionalChainStart)()) : (0,
                        T.assertValueType)("boolean")
                    },
                    typeArguments: {
                        validate: (0,
                        T.assertNodeType)("TypeParameterInstantiation"),
                        optional: !0
                    },
                    typeParameters: {
                        validate: (0,
                        T.assertNodeType)("TSTypeParameterInstantiation"),
                        optional: !0
                    }
                }
            }),
            (0,
            T.default)("ClassProperty", {
                visitor: ["key", "value", "typeAnnotation", "decorators"],
                builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"],
                aliases: ["Property"],
                fields: Object.assign({}, I, {
                    value: {
                        validate: (0,
                        T.assertNodeType)("Expression"),
                        optional: !0
                    },
                    definite: {
                        validate: (0,
                        T.assertValueType)("boolean"),
                        optional: !0
                    },
                    typeAnnotation: {
                        validate: (0,
                        T.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
                        optional: !0
                    },
                    decorators: {
                        validate: (0,
                        T.chain)((0,
                        T.assertValueType)("array"), (0,
                        T.assertEach)((0,
                        T.assertNodeType)("Decorator"))),
                        optional: !0
                    },
                    readonly: {
                        validate: (0,
                        T.assertValueType)("boolean"),
                        optional: !0
                    },
                    declare: {
                        validate: (0,
                        T.assertValueType)("boolean"),
                        optional: !0
                    },
                    variance: {
                        validate: (0,
                        T.assertNodeType)("Variance"),
                        optional: !0
                    }
                })
            }),
            (0,
            T.default)("ClassPrivateProperty", {
                visitor: ["key", "value", "decorators", "typeAnnotation"],
                builder: ["key", "value", "decorators", "static"],
                aliases: ["Property", "Private"],
                fields: {
                    key: {
                        validate: (0,
                        T.assertNodeType)("PrivateName")
                    },
                    value: {
                        validate: (0,
                        T.assertNodeType)("Expression"),
                        optional: !0
                    },
                    typeAnnotation: {
                        validate: (0,
                        T.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
                        optional: !0
                    },
                    decorators: {
                        validate: (0,
                        T.chain)((0,
                        T.assertValueType)("array"), (0,
                        T.assertEach)((0,
                        T.assertNodeType)("Decorator"))),
                        optional: !0
                    },
                    readonly: {
                        validate: (0,
                        T.assertValueType)("boolean"),
                        optional: !0
                    },
                    definite: {
                        validate: (0,
                        T.assertValueType)("boolean"),
                        optional: !0
                    },
                    variance: {
                        validate: (0,
                        T.assertNodeType)("Variance"),
                        optional: !0
                    }
                }
            }),
            (0,
            T.default)("ClassPrivateMethod", {
                builder: ["kind", "key", "params", "body", "static"],
                visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
                aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method", "Private"],
                fields: Object.assign({}, w, g, {
                    key: {
                        validate: (0,
                        T.assertNodeType)("PrivateName")
                    },
                    body: {
                        validate: (0,
                        T.assertNodeType)("BlockStatement")
                    }
                })
            }),
            (0,
            T.default)("PrivateName", {
                visitor: ["id"],
                aliases: ["Private"],
                fields: {
                    id: {
                        validate: (0,
                        T.assertNodeType)("Identifier")
                    }
                }
            })
        }
        ).call(this, i("8oxB"))
    },
    DsXD: function(t, r, i) {
        "use strict";
        var a = i("TqRt")
          , o = a(i("lwsE"))
          , l = a(i("W8MJ"));
        function _createForOfIteratorHelper(t, r) {
            var i = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
            if (!i) {
                if (Array.isArray(t) || (i = function _unsupportedIterableToArray(t, r) {
                    if (!t)
                        return;
                    if ("string" == typeof t)
                        return _arrayLikeToArray(t, r);
                    var i = Object.prototype.toString.call(t).slice(8, -1);
                    "Object" === i && t.constructor && (i = t.constructor.name);
                    if ("Map" === i || "Set" === i)
                        return Array.from(t);
                    if ("Arguments" === i || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i))
                        return _arrayLikeToArray(t, r)
                }(t)) || r && t && "number" == typeof t.length) {
                    i && (t = i);
                    var a = 0
                      , o = function F() {};
                    return {
                        s: o,
                        n: function n() {
                            return a >= t.length ? {
                                done: !0
                            } : {
                                done: !1,
                                value: t[a++]
                            }
                        },
                        e: function e(t) {
                            throw t
                        },
                        f: o
                    }
                }
                throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
            }
            var l, u = !0, p = !1;
            return {
                s: function s() {
                    i = i.call(t)
                },
                n: function n() {
                    var t = i.next();
                    return u = t.done,
                    t
                },
                e: function e(t) {
                    p = !0,
                    l = t
                },
                f: function f() {
                    try {
                        u || null == i.return || i.return()
                    } finally {
                        if (p)
                            throw l
                    }
                }
            }
        }
        function _arrayLikeToArray(t, r) {
            (null == r || r > t.length) && (r = t.length);
            for (var i = 0, a = new Array(r); i < r; i++)
                a[i] = t[i];
            return a
        }
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = void 0;
        i("O0/1");
        var u = i("jXap")
          , p = i("ZtNB")
          , c = {
            ReferencedIdentifier: function ReferencedIdentifier(t, r) {
                var i = t.node;
                i.name === r.oldName && (i.name = r.newName)
            },
            Scope: function Scope(t, r) {
                t.scope.bindingIdentifierEquals(r.oldName, r.binding.identifier) || function skipAllButComputedMethodKey(t) {
                    if (!t.isMethod() || !t.node.computed)
                        return void t.skip();
                    var r, i = _createForOfIteratorHelper(p.VISITOR_KEYS[t.type]);
                    try {
                        for (i.s(); !(r = i.n()).done; ) {
                            var a = r.value;
                            "key" !== a && t.skipKey(a)
                        }
                    } catch (t) {
                        i.e(t)
                    } finally {
                        i.f()
                    }
                }(t)
            },
            "AssignmentExpression|Declaration|VariableDeclarator": function AssignmentExpressionDeclarationVariableDeclarator(t, r) {
                if (!t.isVariableDeclaration()) {
                    var i = t.getOuterBindingIdentifiers();
                    for (var a in i)
                        a === r.oldName && (i[a].name = r.newName)
                }
            }
        }
          , d = function() {
            function Renamer(t, r, i) {
                (0,
                o.default)(this, Renamer),
                this.newName = i,
                this.oldName = r,
                this.binding = t
            }
            return (0,
            l.default)(Renamer, [{
                key: "maybeConvertFromExportDeclaration",
                value: function maybeConvertFromExportDeclaration(t) {
                    var r = t.parentPath;
                    r.isExportDeclaration() && (r.isExportDefaultDeclaration() && !r.get("declaration").node.id || (0,
                    u.default)(r))
                }
            }, {
                key: "maybeConvertFromClassFunctionDeclaration",
                value: function maybeConvertFromClassFunctionDeclaration(t) {}
            }, {
                key: "maybeConvertFromClassFunctionExpression",
                value: function maybeConvertFromClassFunctionExpression(t) {}
            }, {
                key: "rename",
                value: function rename(t) {
                    var r = this
                      , i = this.binding
                      , a = this.oldName
                      , o = this.newName
                      , l = i.scope
                      , u = i.path.find((function(t) {
                        return t.isDeclaration() || t.isFunctionExpression() || t.isClassExpression()
                    }
                    ));
                    u && (u.getOuterBindingIdentifiers()[a] === i.identifier && this.maybeConvertFromExportDeclaration(u));
                    var p = t || l.block;
                    "SwitchStatement" === (null == p ? void 0 : p.type) ? p.cases.forEach((function(t) {
                        l.traverse(t, c, r)
                    }
                    )) : l.traverse(p, c, this),
                    t || (l.removeOwnBinding(a),
                    l.bindings[o] = i,
                    this.binding.identifier.name = o),
                    u && (this.maybeConvertFromClassFunctionDeclaration(u),
                    this.maybeConvertFromClassFunctionExpression(u))
                }
            }]),
            Renamer
        }();
        r.default = d
    },
    "E+Px": function(t, r, i) {
        "use strict";
        var a = i("TqRt")(i("cDf5"));
        function _createForOfIteratorHelper(t, r) {
            var i = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
            if (!i) {
                if (Array.isArray(t) || (i = function _unsupportedIterableToArray(t, r) {
                    if (!t)
                        return;
                    if ("string" == typeof t)
                        return _arrayLikeToArray(t, r);
                    var i = Object.prototype.toString.call(t).slice(8, -1);
                    "Object" === i && t.constructor && (i = t.constructor.name);
                    if ("Map" === i || "Set" === i)
                        return Array.from(t);
                    if ("Arguments" === i || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i))
                        return _arrayLikeToArray(t, r)
                }(t)) || r && t && "number" == typeof t.length) {
                    i && (t = i);
                    var a = 0
                      , o = function F() {};
                    return {
                        s: o,
                        n: function n() {
                            return a >= t.length ? {
                                done: !0
                            } : {
                                done: !1,
                                value: t[a++]
                            }
                        },
                        e: function e(t) {
                            throw t
                        },
                        f: o
                    }
                }
                throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
            }
            var l, u = !0, p = !1;
            return {
                s: function s() {
                    i = i.call(t)
                },
                n: function n() {
                    var t = i.next();
                    return u = t.done,
                    t
                },
                e: function e(t) {
                    p = !0,
                    l = t
                },
                f: function f() {
                    try {
                        u || null == i.return || i.return()
                    } finally {
                        if (p)
                            throw l
                    }
                }
            }
        }
        function _arrayLikeToArray(t, r) {
            (null == r || r > t.length) && (r = t.length);
            for (var i = 0, a = new Array(r); i < r; i++)
                a[i] = t[i];
            return a
        }
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.explode = explode,
        r.verify = verify,
        r.merge = function merge(t) {
            for (var r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [], i = arguments.length > 2 ? arguments[2] : void 0, a = {}, o = 0; o < t.length; o++) {
                var l = t[o]
                  , u = r[o];
                explode(l);
                for (var p = 0, c = Object.keys(l); p < c.length; p++) {
                    var d = c[p]
                      , y = l[d];
                    (u || i) && (y = wrapWithStateOrWrapper(y, u, i));
                    var h = a[d] = a[d] || {};
                    mergePair(h, y)
                }
            }
            return a
        }
        ;
        var o = i("D0vZ")
          , l = i("ZtNB");
        function explode(t) {
            if (t._exploded)
                return t;
            t._exploded = !0;
            for (var r = 0, i = Object.keys(t); r < i.length; r++) {
                var a = i[r];
                if (!shouldIgnoreKey(a)) {
                    var u = a.split("|");
                    if (1 !== u.length) {
                        var p = t[a];
                        delete t[a];
                        var c, d = _createForOfIteratorHelper(u);
                        try {
                            for (d.s(); !(c = d.n()).done; ) {
                                t[c.value] = p
                            }
                        } catch (t) {
                            d.e(t)
                        } finally {
                            d.f()
                        }
                    }
                }
            }
            verify(t),
            delete t.__esModule,
            function ensureEntranceObjects(t) {
                for (var r = 0, i = Object.keys(t); r < i.length; r++) {
                    var a = i[r];
                    if (!shouldIgnoreKey(a)) {
                        var o = t[a];
                        "function" == typeof o && (t[a] = {
                            enter: o
                        })
                    }
                }
            }(t),
            ensureCallbackArrays(t);
            for (var y = 0, h = Object.keys(t); y < h.length; y++) {
                var m = h[y];
                if (!shouldIgnoreKey(m)) {
                    var T = o[m];
                    if (T) {
                        for (var S = t[m], g = 0, b = Object.keys(S); g < b.length; g++) {
                            var v = b[g];
                            S[v] = wrapCheck(T, S[v])
                        }
                        if (delete t[m],
                        T.types) {
                            var E, P = _createForOfIteratorHelper(T.types);
                            try {
                                for (P.s(); !(E = P.n()).done; ) {
                                    var x = E.value;
                                    t[x] ? mergePair(t[x], S) : t[x] = S
                                }
                            } catch (t) {
                                P.e(t)
                            } finally {
                                P.f()
                            }
                        } else
                            mergePair(t, S)
                    }
                }
            }
            for (var A = 0, O = Object.keys(t); A < O.length; A++) {
                var I = O[A];
                if (!shouldIgnoreKey(I)) {
                    var w = t[I]
                      , C = l.FLIPPED_ALIAS_KEYS[I]
                      , N = l.DEPRECATED_KEYS[I];
                    if (N && (console.trace("Visitor defined for ".concat(I, " but it has been renamed to ").concat(N)),
                    C = [N]),
                    C) {
                        delete t[I];
                        var D, _ = _createForOfIteratorHelper(C);
                        try {
                            for (_.s(); !(D = _.n()).done; ) {
                                var L = D.value
                                  , k = t[L];
                                k ? mergePair(k, w) : t[L] = Object.assign({}, w)
                            }
                        } catch (t) {
                            _.e(t)
                        } finally {
                            _.f()
                        }
                    }
                }
            }
            for (var M = 0, j = Object.keys(t); M < j.length; M++) {
                var B = j[M];
                shouldIgnoreKey(B) || ensureCallbackArrays(t[B])
            }
            return t
        }
        function verify(t) {
            if (!t._verified) {
                if ("function" == typeof t)
                    throw new Error("You passed `traverse()` a function when it expected a visitor object, are you sure you didn't mean `{ enter: Function }`?");
                for (var r = 0, i = Object.keys(t); r < i.length; r++) {
                    var o = i[r];
                    if ("enter" !== o && "exit" !== o || validateVisitorMethods(o, t[o]),
                    !shouldIgnoreKey(o)) {
                        if (l.TYPES.indexOf(o) < 0)
                            throw new Error("You gave us a visitor for the node type ".concat(o, " but it's not a valid type"));
                        var u = t[o];
                        if ("object" === (0,
                        a.default)(u))
                            for (var p = 0, c = Object.keys(u); p < c.length; p++) {
                                var d = c[p];
                                if ("enter" !== d && "exit" !== d)
                                    throw new Error("You passed `traverse()` a visitor object with the property " + "".concat(o, " that has the invalid property ").concat(d));
                                validateVisitorMethods("".concat(o, ".").concat(d), u[d])
                            }
                    }
                }
                t._verified = !0
            }
        }
        function validateVisitorMethods(t, r) {
            var i, o = _createForOfIteratorHelper([].concat(r));
            try {
                for (o.s(); !(i = o.n()).done; ) {
                    var l = i.value;
                    if ("function" != typeof l)
                        throw new TypeError("Non-function found defined in ".concat(t, " with type ").concat((0,
                        a.default)(l)))
                }
            } catch (t) {
                o.e(t)
            } finally {
                o.f()
            }
        }
        function wrapWithStateOrWrapper(t, r, i) {
            for (var a = {}, o = function _loop() {
                var o = u[l]
                  , p = t[o];
                if (!Array.isArray(p))
                    return "continue";
                p = p.map((function(t) {
                    var a = t;
                    return r && (a = function newFn(i) {
                        return t.call(r, i, r)
                    }
                    ),
                    i && (a = i(r.key, o, a)),
                    a !== t && (a.toString = function() {
                        return t.toString()
                    }
                    ),
                    a
                }
                )),
                a[o] = p
            }, l = 0, u = Object.keys(t); l < u.length; l++)
                o();
            return a
        }
        function ensureCallbackArrays(t) {
            t.enter && !Array.isArray(t.enter) && (t.enter = [t.enter]),
            t.exit && !Array.isArray(t.exit) && (t.exit = [t.exit])
        }
        function wrapCheck(t, r) {
            var i = function newFn(i) {
                if (t.checkPath(i))
                    return r.apply(this, arguments)
            };
            return i.toString = function() {
                return r.toString()
            }
            ,
            i
        }
        function shouldIgnoreKey(t) {
            return "_" === t[0] || ("enter" === t || "exit" === t || "shouldSkip" === t || ("denylist" === t || "noScope" === t || "skipKeys" === t || "blacklist" === t))
        }
        function mergePair(t, r) {
            for (var i = 0, a = Object.keys(r); i < a.length; i++) {
                var o = a[i];
                t[o] = [].concat(t[o] || [], r[o])
            }
        }
    },
    EJNx: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function isType(t, r) {
            if (t === r)
                return !0;
            if (a.ALIAS_KEYS[r])
                return !1;
            const i = a.FLIPPED_ALIAS_KEYS[r];
            if (i) {
                if (i[0] === t)
                    return !0;
                for (const r of i)
                    if (t === r)
                        return !0
            }
            return !1
        }
        ;
        var a = i("uXiX")
    },
    EOii: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function removeTypeDuplicates(t) {
            for (var r = {}, i = {}, o = [], l = [], u = 0; u < t.length; u++) {
                var p = t[u];
                if (p && !(l.indexOf(p) >= 0)) {
                    if ((0,
                    a.isAnyTypeAnnotation)(p))
                        return [p];
                    if ((0,
                    a.isFlowBaseAnnotation)(p))
                        i[p.type] = p;
                    else if ((0,
                    a.isUnionTypeAnnotation)(p))
                        o.indexOf(p.types) < 0 && (t = t.concat(p.types),
                        o.push(p.types));
                    else if ((0,
                    a.isGenericTypeAnnotation)(p)) {
                        var c = getQualifiedName(p.id);
                        if (r[c]) {
                            var d = r[c];
                            d.typeParameters ? p.typeParameters && (d.typeParameters.params = removeTypeDuplicates(d.typeParameters.params.concat(p.typeParameters.params))) : d = p.typeParameters
                        } else
                            r[c] = p
                    } else
                        l.push(p)
                }
            }
            for (var y = 0, h = Object.keys(i); y < h.length; y++) {
                var m = h[y];
                l.push(i[m])
            }
            for (var T = 0, S = Object.keys(r); T < S.length; T++) {
                var g = S[T];
                l.push(r[g])
            }
            return l
        }
        ;
        var a = i("FUES");
        function getQualifiedName(t) {
            return (0,
            a.isIdentifier)(t) ? t.name : "".concat(t.id.name, ".").concat(getQualifiedName(t.qualification))
        }
    },
    ET4T: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function is(t, r, i) {
            if (!r)
                return !1;
            if (!(0,
            o.default)(r.type, t))
                return !i && "Placeholder" === r.type && t in u.FLIPPED_ALIAS_KEYS && (0,
                l.default)(r.expectedNode, t);
            return void 0 === i || (0,
            a.default)(r, i)
        }
        ;
        var a = i("v3TT")
          , o = i("ud6b")
          , l = i("AB3+")
          , u = i("UHlb")
    },
    EX0z: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.isKeyword = function isKeyword(t) {
            return l.has(t)
        }
        ,
        r.isReservedWord = isReservedWord,
        r.isStrictBindOnlyReservedWord = isStrictBindOnlyReservedWord,
        r.isStrictBindReservedWord = function isStrictBindReservedWord(t, r) {
            return isStrictReservedWord(t, r) || isStrictBindOnlyReservedWord(t)
        }
        ,
        r.isStrictReservedWord = isStrictReservedWord;
        const a = ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"]
          , o = ["eval", "arguments"]
          , l = new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"])
          , u = new Set(a)
          , p = new Set(o);
        function isReservedWord(t, r) {
            return r && "await" === t || "enum" === t
        }
        function isStrictReservedWord(t, r) {
            return isReservedWord(t, r) || u.has(t)
        }
        function isStrictBindOnlyReservedWord(t) {
            return p.has(t)
        }
    },
    EYvB: function(t, r, i) {
        "use strict";
        var a, o = i("TqRt")(i("lSNA")), l = i("aaMo"), u = i("z6L1"), p = i("ET4T"), c = (0,
        l.defineAliasedType)("TypeScript"), d = (0,
        l.assertValueType)("boolean"), y = {
            returnType: {
                validate: (0,
                l.assertNodeType)("TSTypeAnnotation", "Noop"),
                optional: !0
            },
            typeParameters: {
                validate: (0,
                l.assertNodeType)("TSTypeParameterDeclaration", "Noop"),
                optional: !0
            }
        };
        c("TSParameterProperty", {
            aliases: ["LVal"],
            visitor: ["parameter"],
            fields: {
                accessibility: {
                    validate: (0,
                    l.assertOneOf)("public", "private", "protected"),
                    optional: !0
                },
                readonly: {
                    validate: (0,
                    l.assertValueType)("boolean"),
                    optional: !0
                },
                parameter: {
                    validate: (0,
                    l.assertNodeType)("Identifier", "AssignmentPattern")
                },
                override: {
                    validate: (0,
                    l.assertValueType)("boolean"),
                    optional: !0
                },
                decorators: {
                    validate: (0,
                    l.chain)((0,
                    l.assertValueType)("array"), (0,
                    l.assertEach)((0,
                    l.assertNodeType)("Decorator"))),
                    optional: !0
                }
            }
        }),
        c("TSDeclareFunction", {
            aliases: ["Statement", "Declaration"],
            visitor: ["id", "typeParameters", "params", "returnType"],
            fields: Object.assign({}, u.functionDeclarationCommon, y)
        }),
        c("TSDeclareMethod", {
            visitor: ["decorators", "key", "typeParameters", "params", "returnType"],
            fields: Object.assign({}, u.classMethodOrDeclareMethodCommon, y)
        }),
        c("TSQualifiedName", {
            aliases: ["TSEntityName"],
            visitor: ["left", "right"],
            fields: {
                left: (0,
                l.validateType)("TSEntityName"),
                right: (0,
                l.validateType)("Identifier")
            }
        });
        var h = (a = {
            typeParameters: (0,
            l.validateOptionalType)("TSTypeParameterDeclaration")
        },
        (0,
        o.default)(a, "parameters", (0,
        l.validateArrayOfType)(["Identifier", "RestElement"])),
        (0,
        o.default)(a, "typeAnnotation", (0,
        l.validateOptionalType)("TSTypeAnnotation")),
        a)
          , m = {
            aliases: ["TSTypeElement"],
            visitor: ["typeParameters", "parameters", "typeAnnotation"],
            fields: h
        };
        c("TSCallSignatureDeclaration", m),
        c("TSConstructSignatureDeclaration", m);
        var T = {
            key: (0,
            l.validateType)("Expression"),
            computed: (0,
            l.validate)(d),
            optional: (0,
            l.validateOptional)(d)
        };
        c("TSPropertySignature", {
            aliases: ["TSTypeElement"],
            visitor: ["key", "typeAnnotation", "initializer"],
            fields: Object.assign({}, T, {
                readonly: (0,
                l.validateOptional)(d),
                typeAnnotation: (0,
                l.validateOptionalType)("TSTypeAnnotation"),
                initializer: (0,
                l.validateOptionalType)("Expression"),
                kind: {
                    validate: (0,
                    l.assertOneOf)("get", "set")
                }
            })
        }),
        c("TSMethodSignature", {
            aliases: ["TSTypeElement"],
            visitor: ["key", "typeParameters", "parameters", "typeAnnotation"],
            fields: Object.assign({}, h, T, {
                kind: {
                    validate: (0,
                    l.assertOneOf)("method", "get", "set")
                }
            })
        }),
        c("TSIndexSignature", {
            aliases: ["TSTypeElement"],
            visitor: ["parameters", "typeAnnotation"],
            fields: {
                readonly: (0,
                l.validateOptional)(d),
                static: (0,
                l.validateOptional)(d),
                parameters: (0,
                l.validateArrayOfType)("Identifier"),
                typeAnnotation: (0,
                l.validateOptionalType)("TSTypeAnnotation")
            }
        });
        for (var S = 0, g = ["TSAnyKeyword", "TSBooleanKeyword", "TSBigIntKeyword", "TSIntrinsicKeyword", "TSNeverKeyword", "TSNullKeyword", "TSNumberKeyword", "TSObjectKeyword", "TSStringKeyword", "TSSymbolKeyword", "TSUndefinedKeyword", "TSUnknownKeyword", "TSVoidKeyword"]; S < g.length; S++) {
            c(g[S], {
                aliases: ["TSType", "TSBaseType"],
                visitor: [],
                fields: {}
            })
        }
        c("TSThisType", {
            aliases: ["TSType", "TSBaseType"],
            visitor: [],
            fields: {}
        });
        var b = {
            aliases: ["TSType"],
            visitor: ["typeParameters", "parameters", "typeAnnotation"]
        };
        c("TSFunctionType", Object.assign({}, b, {
            fields: h
        })),
        c("TSConstructorType", Object.assign({}, b, {
            fields: Object.assign({}, h, {
                abstract: (0,
                l.validateOptional)(d)
            })
        })),
        c("TSTypeReference", {
            aliases: ["TSType"],
            visitor: ["typeName", "typeParameters"],
            fields: {
                typeName: (0,
                l.validateType)("TSEntityName"),
                typeParameters: (0,
                l.validateOptionalType)("TSTypeParameterInstantiation")
            }
        }),
        c("TSTypePredicate", {
            aliases: ["TSType"],
            visitor: ["parameterName", "typeAnnotation"],
            builder: ["parameterName", "typeAnnotation", "asserts"],
            fields: {
                parameterName: (0,
                l.validateType)(["Identifier", "TSThisType"]),
                typeAnnotation: (0,
                l.validateOptionalType)("TSTypeAnnotation"),
                asserts: (0,
                l.validateOptional)(d)
            }
        }),
        c("TSTypeQuery", {
            aliases: ["TSType"],
            visitor: ["exprName"],
            fields: {
                exprName: (0,
                l.validateType)(["TSEntityName", "TSImportType"])
            }
        }),
        c("TSTypeLiteral", {
            aliases: ["TSType"],
            visitor: ["members"],
            fields: {
                members: (0,
                l.validateArrayOfType)("TSTypeElement")
            }
        }),
        c("TSArrayType", {
            aliases: ["TSType"],
            visitor: ["elementType"],
            fields: {
                elementType: (0,
                l.validateType)("TSType")
            }
        }),
        c("TSTupleType", {
            aliases: ["TSType"],
            visitor: ["elementTypes"],
            fields: {
                elementTypes: (0,
                l.validateArrayOfType)(["TSType", "TSNamedTupleMember"])
            }
        }),
        c("TSOptionalType", {
            aliases: ["TSType"],
            visitor: ["typeAnnotation"],
            fields: {
                typeAnnotation: (0,
                l.validateType)("TSType")
            }
        }),
        c("TSRestType", {
            aliases: ["TSType"],
            visitor: ["typeAnnotation"],
            fields: {
                typeAnnotation: (0,
                l.validateType)("TSType")
            }
        }),
        c("TSNamedTupleMember", {
            visitor: ["label", "elementType"],
            builder: ["label", "elementType", "optional"],
            fields: {
                label: (0,
                l.validateType)("Identifier"),
                optional: {
                    validate: d,
                    default: !1
                },
                elementType: (0,
                l.validateType)("TSType")
            }
        });
        var v = {
            aliases: ["TSType"],
            visitor: ["types"],
            fields: {
                types: (0,
                l.validateArrayOfType)("TSType")
            }
        };
        c("TSUnionType", v),
        c("TSIntersectionType", v),
        c("TSConditionalType", {
            aliases: ["TSType"],
            visitor: ["checkType", "extendsType", "trueType", "falseType"],
            fields: {
                checkType: (0,
                l.validateType)("TSType"),
                extendsType: (0,
                l.validateType)("TSType"),
                trueType: (0,
                l.validateType)("TSType"),
                falseType: (0,
                l.validateType)("TSType")
            }
        }),
        c("TSInferType", {
            aliases: ["TSType"],
            visitor: ["typeParameter"],
            fields: {
                typeParameter: (0,
                l.validateType)("TSTypeParameter")
            }
        }),
        c("TSParenthesizedType", {
            aliases: ["TSType"],
            visitor: ["typeAnnotation"],
            fields: {
                typeAnnotation: (0,
                l.validateType)("TSType")
            }
        }),
        c("TSTypeOperator", {
            aliases: ["TSType"],
            visitor: ["typeAnnotation"],
            fields: {
                operator: (0,
                l.validate)((0,
                l.assertValueType)("string")),
                typeAnnotation: (0,
                l.validateType)("TSType")
            }
        }),
        c("TSIndexedAccessType", {
            aliases: ["TSType"],
            visitor: ["objectType", "indexType"],
            fields: {
                objectType: (0,
                l.validateType)("TSType"),
                indexType: (0,
                l.validateType)("TSType")
            }
        }),
        c("TSMappedType", {
            aliases: ["TSType"],
            visitor: ["typeParameter", "typeAnnotation", "nameType"],
            fields: {
                readonly: (0,
                l.validateOptional)(d),
                typeParameter: (0,
                l.validateType)("TSTypeParameter"),
                optional: (0,
                l.validateOptional)(d),
                typeAnnotation: (0,
                l.validateOptionalType)("TSType"),
                nameType: (0,
                l.validateOptionalType)("TSType")
            }
        }),
        c("TSLiteralType", {
            aliases: ["TSType", "TSBaseType"],
            visitor: ["literal"],
            fields: {
                literal: {
                    validate: function() {
                        var t = (0,
                        l.assertNodeType)("NumericLiteral", "BigIntLiteral")
                          , r = (0,
                        l.assertOneOf)("-")
                          , i = (0,
                        l.assertNodeType)("NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral");
                        function validator(a, o, l) {
                            (0,
                            p.default)("UnaryExpression", l) ? (r(l, "operator", l.operator),
                            t(l, "argument", l.argument)) : i(a, o, l)
                        }
                        return validator.oneOfNodeTypes = ["NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral", "UnaryExpression"],
                        validator
                    }()
                }
            }
        }),
        c("TSExpressionWithTypeArguments", {
            aliases: ["TSType"],
            visitor: ["expression", "typeParameters"],
            fields: {
                expression: (0,
                l.validateType)("TSEntityName"),
                typeParameters: (0,
                l.validateOptionalType)("TSTypeParameterInstantiation")
            }
        }),
        c("TSInterfaceDeclaration", {
            aliases: ["Statement", "Declaration"],
            visitor: ["id", "typeParameters", "extends", "body"],
            fields: {
                declare: (0,
                l.validateOptional)(d),
                id: (0,
                l.validateType)("Identifier"),
                typeParameters: (0,
                l.validateOptionalType)("TSTypeParameterDeclaration"),
                extends: (0,
                l.validateOptional)((0,
                l.arrayOfType)("TSExpressionWithTypeArguments")),
                body: (0,
                l.validateType)("TSInterfaceBody")
            }
        }),
        c("TSInterfaceBody", {
            visitor: ["body"],
            fields: {
                body: (0,
                l.validateArrayOfType)("TSTypeElement")
            }
        }),
        c("TSTypeAliasDeclaration", {
            aliases: ["Statement", "Declaration"],
            visitor: ["id", "typeParameters", "typeAnnotation"],
            fields: {
                declare: (0,
                l.validateOptional)(d),
                id: (0,
                l.validateType)("Identifier"),
                typeParameters: (0,
                l.validateOptionalType)("TSTypeParameterDeclaration"),
                typeAnnotation: (0,
                l.validateType)("TSType")
            }
        }),
        c("TSAsExpression", {
            aliases: ["Expression"],
            visitor: ["expression", "typeAnnotation"],
            fields: {
                expression: (0,
                l.validateType)("Expression"),
                typeAnnotation: (0,
                l.validateType)("TSType")
            }
        }),
        c("TSTypeAssertion", {
            aliases: ["Expression"],
            visitor: ["typeAnnotation", "expression"],
            fields: {
                typeAnnotation: (0,
                l.validateType)("TSType"),
                expression: (0,
                l.validateType)("Expression")
            }
        }),
        c("TSEnumDeclaration", {
            aliases: ["Statement", "Declaration"],
            visitor: ["id", "members"],
            fields: {
                declare: (0,
                l.validateOptional)(d),
                const: (0,
                l.validateOptional)(d),
                id: (0,
                l.validateType)("Identifier"),
                members: (0,
                l.validateArrayOfType)("TSEnumMember"),
                initializer: (0,
                l.validateOptionalType)("Expression")
            }
        }),
        c("TSEnumMember", {
            visitor: ["id", "initializer"],
            fields: {
                id: (0,
                l.validateType)(["Identifier", "StringLiteral"]),
                initializer: (0,
                l.validateOptionalType)("Expression")
            }
        }),
        c("TSModuleDeclaration", {
            aliases: ["Statement", "Declaration"],
            visitor: ["id", "body"],
            fields: {
                declare: (0,
                l.validateOptional)(d),
                global: (0,
                l.validateOptional)(d),
                id: (0,
                l.validateType)(["Identifier", "StringLiteral"]),
                body: (0,
                l.validateType)(["TSModuleBlock", "TSModuleDeclaration"])
            }
        }),
        c("TSModuleBlock", {
            aliases: ["Scopable", "Block", "BlockParent"],
            visitor: ["body"],
            fields: {
                body: (0,
                l.validateArrayOfType)("Statement")
            }
        }),
        c("TSImportType", {
            aliases: ["TSType"],
            visitor: ["argument", "qualifier", "typeParameters"],
            fields: {
                argument: (0,
                l.validateType)("StringLiteral"),
                qualifier: (0,
                l.validateOptionalType)("TSEntityName"),
                typeParameters: (0,
                l.validateOptionalType)("TSTypeParameterInstantiation")
            }
        }),
        c("TSImportEqualsDeclaration", {
            aliases: ["Statement"],
            visitor: ["id", "moduleReference"],
            fields: {
                isExport: (0,
                l.validate)(d),
                id: (0,
                l.validateType)("Identifier"),
                moduleReference: (0,
                l.validateType)(["TSEntityName", "TSExternalModuleReference"]),
                importKind: {
                    validate: (0,
                    l.assertOneOf)("type", "value"),
                    optional: !0
                }
            }
        }),
        c("TSExternalModuleReference", {
            visitor: ["expression"],
            fields: {
                expression: (0,
                l.validateType)("StringLiteral")
            }
        }),
        c("TSNonNullExpression", {
            aliases: ["Expression"],
            visitor: ["expression"],
            fields: {
                expression: (0,
                l.validateType)("Expression")
            }
        }),
        c("TSExportAssignment", {
            aliases: ["Statement"],
            visitor: ["expression"],
            fields: {
                expression: (0,
                l.validateType)("Expression")
            }
        }),
        c("TSNamespaceExportDeclaration", {
            aliases: ["Statement"],
            visitor: ["id"],
            fields: {
                id: (0,
                l.validateType)("Identifier")
            }
        }),
        c("TSTypeAnnotation", {
            visitor: ["typeAnnotation"],
            fields: {
                typeAnnotation: {
                    validate: (0,
                    l.assertNodeType)("TSType")
                }
            }
        }),
        c("TSTypeParameterInstantiation", {
            visitor: ["params"],
            fields: {
                params: {
                    validate: (0,
                    l.chain)((0,
                    l.assertValueType)("array"), (0,
                    l.assertEach)((0,
                    l.assertNodeType)("TSType")))
                }
            }
        }),
        c("TSTypeParameterDeclaration", {
            visitor: ["params"],
            fields: {
                params: {
                    validate: (0,
                    l.chain)((0,
                    l.assertValueType)("array"), (0,
                    l.assertEach)((0,
                    l.assertNodeType)("TSTypeParameter")))
                }
            }
        }),
        c("TSTypeParameter", {
            builder: ["constraint", "default", "name"],
            visitor: ["constraint", "default"],
            fields: {
                name: {
                    validate: (0,
                    l.assertValueType)("string")
                },
                constraint: {
                    validate: (0,
                    l.assertNodeType)("TSType"),
                    optional: !0
                },
                default: {
                    validate: (0,
                    l.assertNodeType)("TSType"),
                    optional: !0
                }
            }
        })
    },
    Eum2: function(t, r, i) {
        "use strict";
        t.exports = function(t, r, i) {
            var a = t.type;
            if (t.range = [t.start, t.end],
            a === r.name)
                t.type = "Identifier";
            else if (a === r.semi || a === r.comma || a === r.parenL || a === r.parenR || a === r.braceL || a === r.braceR || a === r.slash || a === r.dot || a === r.bracketL || a === r.bracketR || a === r.ellipsis || a === r.arrow || a === r.pipeline || a === r.star || a === r.incDec || a === r.colon || a === r.question || a === r.questionDot || a === r.template || a === r.backQuote || a === r.dollarBraceL || a === r.at || a === r.logicalOR || a === r.logicalAND || a === r.nullishCoalescing || a === r.bitwiseOR || a === r.bitwiseXOR || a === r.bitwiseAND || a === r.equality || a === r.relational || a === r.bitShift || a === r.plusMin || a === r.modulo || a === r.exponent || a === r.bang || a === r.tilde || a === r.doubleColon || a.isAssign)
                t.type = "Punctuator",
                t.value || (t.value = a.label);
            else if (a === r.jsxTagStart)
                t.type = "Punctuator",
                t.value = "<";
            else if (a === r.jsxTagEnd)
                t.type = "Punctuator",
                t.value = ">";
            else if (a === r.jsxName)
                t.type = "JSXIdentifier";
            else if (a === r.jsxText)
                t.type = "JSXText";
            else if ("null" === a.keyword)
                t.type = "Null";
            else if ("false" === a.keyword || "true" === a.keyword)
                t.type = "Boolean";
            else if (a.keyword)
                t.type = "Keyword";
            else if (a === r.num)
                t.type = "Numeric",
                t.value = i.slice(t.start, t.end);
            else if (a === r.string)
                t.type = "String",
                t.value = i.slice(t.start, t.end);
            else if (a === r.regexp) {
                t.type = "RegularExpression";
                var o = t.value;
                t.regex = {
                    pattern: o.pattern,
                    flags: o.flags
                },
                t.value = "/".concat(o.pattern, "/").concat(o.flags)
            }
            return t
        }
    },
    EvNs: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = toKeyAlias;
        var a = i("pbIU")
          , o = i("aHlp")
          , l = i("lsUB");
        function toKeyAlias(t) {
            var r, i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : t.key;
            return "method" === t.kind ? toKeyAlias.increment() + "" : (r = (0,
            a.isIdentifier)(i) ? i.name : (0,
            a.isStringLiteral)(i) ? JSON.stringify(i.value) : JSON.stringify((0,
            l.default)((0,
            o.default)(i))),
            t.computed && (r = "[".concat(r, "]")),
            t.static && (r = "static:".concat(r)),
            r)
        }
        toKeyAlias.uid = 0,
        toKeyAlias.increment = function() {
            return toKeyAlias.uid >= Number.MAX_SAFE_INTEGER ? toKeyAlias.uid = 0 : toKeyAlias.uid++
        }
    },
    ExWc: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function inherit(t, r, i) {
            r && i && (r[t] = Array.from(new Set([].concat(r[t], i[t]).filter(Boolean))))
        }
    },
    "F/98": function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function isBlockScoped(t) {
            return (0,
            a.isFunctionDeclaration)(t) || (0,
            a.isClassDeclaration)(t) || (0,
            o.default)(t)
        }
        ;
        var a = i("pbIU")
          , o = i("K95w")
    },
    F3vi: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function is(t, r, i) {
            if (!r)
                return !1;
            if (!(0,
            o.default)(r.type, t))
                return !i && "Placeholder" === r.type && t in u.FLIPPED_ALIAS_KEYS && (0,
                l.default)(r.expectedNode, t);
            return void 0 === i || (0,
            a.default)(r, i)
        }
        ;
        var a = i("OS6d")
          , o = i("EJNx")
          , l = i("49gG")
          , u = i("uXiX")
    },
    FGiv: function(t, r) {
        var i = 1e3
          , a = 6e4
          , o = 60 * a
          , l = 24 * o;
        function plural(t, r, i, a) {
            var o = r >= 1.5 * i;
            return Math.round(t / i) + " " + a + (o ? "s" : "")
        }
        t.exports = function(t, r) {
            r = r || {};
            var u = typeof t;
            if ("string" === u && t.length > 0)
                return function parse(t) {
                    if ((t = String(t)).length > 100)
                        return;
                    var r = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(t);
                    if (!r)
                        return;
                    var u = parseFloat(r[1]);
                    switch ((r[2] || "ms").toLowerCase()) {
                    case "years":
                    case "year":
                    case "yrs":
                    case "yr":
                    case "y":
                        return 315576e5 * u;
                    case "weeks":
                    case "week":
                    case "w":
                        return 6048e5 * u;
                    case "days":
                    case "day":
                    case "d":
                        return u * l;
                    case "hours":
                    case "hour":
                    case "hrs":
                    case "hr":
                    case "h":
                        return u * o;
                    case "minutes":
                    case "minute":
                    case "mins":
                    case "min":
                    case "m":
                        return u * a;
                    case "seconds":
                    case "second":
                    case "secs":
                    case "sec":
                    case "s":
                        return u * i;
                    case "milliseconds":
                    case "millisecond":
                    case "msecs":
                    case "msec":
                    case "ms":
                        return u;
                    default:
                        return
                    }
                }(t);
            if ("number" === u && isFinite(t))
                return r.long ? function fmtLong(t) {
                    var r = Math.abs(t);
                    if (r >= l)
                        return plural(t, r, l, "day");
                    if (r >= o)
                        return plural(t, r, o, "hour");
                    if (r >= a)
                        return plural(t, r, a, "minute");
                    if (r >= i)
                        return plural(t, r, i, "second");
                    return t + " ms"
                }(t) : function fmtShort(t) {
                    var r = Math.abs(t);
                    if (r >= l)
                        return Math.round(t / l) + "d";
                    if (r >= o)
                        return Math.round(t / o) + "h";
                    if (r >= a)
                        return Math.round(t / a) + "m";
                    if (r >= i)
                        return Math.round(t / i) + "s";
                    return t + "ms"
                }(t);
            throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(t))
        }
    },
    FUES: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.isArrayExpression = function isArrayExpression(t, r) {
            if (!t)
                return !1;
            if ("ArrayExpression" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isAssignmentExpression = function isAssignmentExpression(t, r) {
            if (!t)
                return !1;
            if ("AssignmentExpression" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isBinaryExpression = function isBinaryExpression(t, r) {
            if (!t)
                return !1;
            if ("BinaryExpression" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isInterpreterDirective = function isInterpreterDirective(t, r) {
            if (!t)
                return !1;
            if ("InterpreterDirective" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isDirective = function isDirective(t, r) {
            if (!t)
                return !1;
            if ("Directive" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isDirectiveLiteral = function isDirectiveLiteral(t, r) {
            if (!t)
                return !1;
            if ("DirectiveLiteral" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isBlockStatement = function isBlockStatement(t, r) {
            if (!t)
                return !1;
            if ("BlockStatement" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isBreakStatement = function isBreakStatement(t, r) {
            if (!t)
                return !1;
            if ("BreakStatement" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isCallExpression = function isCallExpression(t, r) {
            if (!t)
                return !1;
            if ("CallExpression" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isCatchClause = function isCatchClause(t, r) {
            if (!t)
                return !1;
            if ("CatchClause" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isConditionalExpression = function isConditionalExpression(t, r) {
            if (!t)
                return !1;
            if ("ConditionalExpression" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isContinueStatement = function isContinueStatement(t, r) {
            if (!t)
                return !1;
            if ("ContinueStatement" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isDebuggerStatement = function isDebuggerStatement(t, r) {
            if (!t)
                return !1;
            if ("DebuggerStatement" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isDoWhileStatement = function isDoWhileStatement(t, r) {
            if (!t)
                return !1;
            if ("DoWhileStatement" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isEmptyStatement = function isEmptyStatement(t, r) {
            if (!t)
                return !1;
            if ("EmptyStatement" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isExpressionStatement = function isExpressionStatement(t, r) {
            if (!t)
                return !1;
            if ("ExpressionStatement" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isFile = function isFile(t, r) {
            if (!t)
                return !1;
            if ("File" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isForInStatement = function isForInStatement(t, r) {
            if (!t)
                return !1;
            if ("ForInStatement" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isForStatement = function isForStatement(t, r) {
            if (!t)
                return !1;
            if ("ForStatement" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isFunctionDeclaration = function isFunctionDeclaration(t, r) {
            if (!t)
                return !1;
            if ("FunctionDeclaration" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isFunctionExpression = function isFunctionExpression(t, r) {
            if (!t)
                return !1;
            if ("FunctionExpression" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isIdentifier = function isIdentifier(t, r) {
            if (!t)
                return !1;
            if ("Identifier" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isIfStatement = function isIfStatement(t, r) {
            if (!t)
                return !1;
            if ("IfStatement" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isLabeledStatement = function isLabeledStatement(t, r) {
            if (!t)
                return !1;
            if ("LabeledStatement" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isStringLiteral = function isStringLiteral(t, r) {
            if (!t)
                return !1;
            if ("StringLiteral" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isNumericLiteral = function isNumericLiteral(t, r) {
            if (!t)
                return !1;
            if ("NumericLiteral" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isNullLiteral = function isNullLiteral(t, r) {
            if (!t)
                return !1;
            if ("NullLiteral" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isBooleanLiteral = function isBooleanLiteral(t, r) {
            if (!t)
                return !1;
            if ("BooleanLiteral" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isRegExpLiteral = function isRegExpLiteral(t, r) {
            if (!t)
                return !1;
            if ("RegExpLiteral" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isLogicalExpression = function isLogicalExpression(t, r) {
            if (!t)
                return !1;
            if ("LogicalExpression" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isMemberExpression = function isMemberExpression(t, r) {
            if (!t)
                return !1;
            if ("MemberExpression" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isNewExpression = function isNewExpression(t, r) {
            if (!t)
                return !1;
            if ("NewExpression" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isProgram = function isProgram(t, r) {
            if (!t)
                return !1;
            if ("Program" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isObjectExpression = function isObjectExpression(t, r) {
            if (!t)
                return !1;
            if ("ObjectExpression" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isObjectMethod = function isObjectMethod(t, r) {
            if (!t)
                return !1;
            if ("ObjectMethod" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isObjectProperty = function isObjectProperty(t, r) {
            if (!t)
                return !1;
            if ("ObjectProperty" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isRestElement = function isRestElement(t, r) {
            if (!t)
                return !1;
            if ("RestElement" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isReturnStatement = function isReturnStatement(t, r) {
            if (!t)
                return !1;
            if ("ReturnStatement" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isSequenceExpression = function isSequenceExpression(t, r) {
            if (!t)
                return !1;
            if ("SequenceExpression" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isParenthesizedExpression = function isParenthesizedExpression(t, r) {
            if (!t)
                return !1;
            if ("ParenthesizedExpression" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isSwitchCase = function isSwitchCase(t, r) {
            if (!t)
                return !1;
            if ("SwitchCase" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isSwitchStatement = function isSwitchStatement(t, r) {
            if (!t)
                return !1;
            if ("SwitchStatement" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isThisExpression = function isThisExpression(t, r) {
            if (!t)
                return !1;
            if ("ThisExpression" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isThrowStatement = function isThrowStatement(t, r) {
            if (!t)
                return !1;
            if ("ThrowStatement" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTryStatement = function isTryStatement(t, r) {
            if (!t)
                return !1;
            if ("TryStatement" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isUnaryExpression = function isUnaryExpression(t, r) {
            if (!t)
                return !1;
            if ("UnaryExpression" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isUpdateExpression = function isUpdateExpression(t, r) {
            if (!t)
                return !1;
            if ("UpdateExpression" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isVariableDeclaration = function isVariableDeclaration(t, r) {
            if (!t)
                return !1;
            if ("VariableDeclaration" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isVariableDeclarator = function isVariableDeclarator(t, r) {
            if (!t)
                return !1;
            if ("VariableDeclarator" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isWhileStatement = function isWhileStatement(t, r) {
            if (!t)
                return !1;
            if ("WhileStatement" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isWithStatement = function isWithStatement(t, r) {
            if (!t)
                return !1;
            if ("WithStatement" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isAssignmentPattern = function isAssignmentPattern(t, r) {
            if (!t)
                return !1;
            if ("AssignmentPattern" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isArrayPattern = function isArrayPattern(t, r) {
            if (!t)
                return !1;
            if ("ArrayPattern" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isArrowFunctionExpression = function isArrowFunctionExpression(t, r) {
            if (!t)
                return !1;
            if ("ArrowFunctionExpression" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isClassBody = function isClassBody(t, r) {
            if (!t)
                return !1;
            if ("ClassBody" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isClassExpression = function isClassExpression(t, r) {
            if (!t)
                return !1;
            if ("ClassExpression" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isClassDeclaration = function isClassDeclaration(t, r) {
            if (!t)
                return !1;
            if ("ClassDeclaration" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isExportAllDeclaration = function isExportAllDeclaration(t, r) {
            if (!t)
                return !1;
            if ("ExportAllDeclaration" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isExportDefaultDeclaration = function isExportDefaultDeclaration(t, r) {
            if (!t)
                return !1;
            if ("ExportDefaultDeclaration" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isExportNamedDeclaration = function isExportNamedDeclaration(t, r) {
            if (!t)
                return !1;
            if ("ExportNamedDeclaration" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isExportSpecifier = function isExportSpecifier(t, r) {
            if (!t)
                return !1;
            if ("ExportSpecifier" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isForOfStatement = function isForOfStatement(t, r) {
            if (!t)
                return !1;
            if ("ForOfStatement" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isImportDeclaration = function isImportDeclaration(t, r) {
            if (!t)
                return !1;
            if ("ImportDeclaration" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isImportDefaultSpecifier = function isImportDefaultSpecifier(t, r) {
            if (!t)
                return !1;
            if ("ImportDefaultSpecifier" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isImportNamespaceSpecifier = function isImportNamespaceSpecifier(t, r) {
            if (!t)
                return !1;
            if ("ImportNamespaceSpecifier" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isImportSpecifier = function isImportSpecifier(t, r) {
            if (!t)
                return !1;
            if ("ImportSpecifier" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isMetaProperty = function isMetaProperty(t, r) {
            if (!t)
                return !1;
            if ("MetaProperty" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isClassMethod = function isClassMethod(t, r) {
            if (!t)
                return !1;
            if ("ClassMethod" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isObjectPattern = function isObjectPattern(t, r) {
            if (!t)
                return !1;
            if ("ObjectPattern" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isSpreadElement = function isSpreadElement(t, r) {
            if (!t)
                return !1;
            if ("SpreadElement" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isSuper = function isSuper(t, r) {
            if (!t)
                return !1;
            if ("Super" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTaggedTemplateExpression = function isTaggedTemplateExpression(t, r) {
            if (!t)
                return !1;
            if ("TaggedTemplateExpression" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTemplateElement = function isTemplateElement(t, r) {
            if (!t)
                return !1;
            if ("TemplateElement" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTemplateLiteral = function isTemplateLiteral(t, r) {
            if (!t)
                return !1;
            if ("TemplateLiteral" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isYieldExpression = function isYieldExpression(t, r) {
            if (!t)
                return !1;
            if ("YieldExpression" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isAwaitExpression = function isAwaitExpression(t, r) {
            if (!t)
                return !1;
            if ("AwaitExpression" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isImport = function isImport(t, r) {
            if (!t)
                return !1;
            if ("Import" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isBigIntLiteral = function isBigIntLiteral(t, r) {
            if (!t)
                return !1;
            if ("BigIntLiteral" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isExportNamespaceSpecifier = function isExportNamespaceSpecifier(t, r) {
            if (!t)
                return !1;
            if ("ExportNamespaceSpecifier" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isOptionalMemberExpression = function isOptionalMemberExpression(t, r) {
            if (!t)
                return !1;
            if ("OptionalMemberExpression" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isOptionalCallExpression = function isOptionalCallExpression(t, r) {
            if (!t)
                return !1;
            if ("OptionalCallExpression" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isClassProperty = function isClassProperty(t, r) {
            if (!t)
                return !1;
            if ("ClassProperty" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isClassPrivateProperty = function isClassPrivateProperty(t, r) {
            if (!t)
                return !1;
            if ("ClassPrivateProperty" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isClassPrivateMethod = function isClassPrivateMethod(t, r) {
            if (!t)
                return !1;
            if ("ClassPrivateMethod" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isPrivateName = function isPrivateName(t, r) {
            if (!t)
                return !1;
            if ("PrivateName" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isAnyTypeAnnotation = function isAnyTypeAnnotation(t, r) {
            if (!t)
                return !1;
            if ("AnyTypeAnnotation" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isArrayTypeAnnotation = function isArrayTypeAnnotation(t, r) {
            if (!t)
                return !1;
            if ("ArrayTypeAnnotation" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isBooleanTypeAnnotation = function isBooleanTypeAnnotation(t, r) {
            if (!t)
                return !1;
            if ("BooleanTypeAnnotation" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isBooleanLiteralTypeAnnotation = function isBooleanLiteralTypeAnnotation(t, r) {
            if (!t)
                return !1;
            if ("BooleanLiteralTypeAnnotation" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isNullLiteralTypeAnnotation = function isNullLiteralTypeAnnotation(t, r) {
            if (!t)
                return !1;
            if ("NullLiteralTypeAnnotation" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isClassImplements = function isClassImplements(t, r) {
            if (!t)
                return !1;
            if ("ClassImplements" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isDeclareClass = function isDeclareClass(t, r) {
            if (!t)
                return !1;
            if ("DeclareClass" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isDeclareFunction = function isDeclareFunction(t, r) {
            if (!t)
                return !1;
            if ("DeclareFunction" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isDeclareInterface = function isDeclareInterface(t, r) {
            if (!t)
                return !1;
            if ("DeclareInterface" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isDeclareModule = function isDeclareModule(t, r) {
            if (!t)
                return !1;
            if ("DeclareModule" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isDeclareModuleExports = function isDeclareModuleExports(t, r) {
            if (!t)
                return !1;
            if ("DeclareModuleExports" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isDeclareTypeAlias = function isDeclareTypeAlias(t, r) {
            if (!t)
                return !1;
            if ("DeclareTypeAlias" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isDeclareOpaqueType = function isDeclareOpaqueType(t, r) {
            if (!t)
                return !1;
            if ("DeclareOpaqueType" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isDeclareVariable = function isDeclareVariable(t, r) {
            if (!t)
                return !1;
            if ("DeclareVariable" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isDeclareExportDeclaration = function isDeclareExportDeclaration(t, r) {
            if (!t)
                return !1;
            if ("DeclareExportDeclaration" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isDeclareExportAllDeclaration = function isDeclareExportAllDeclaration(t, r) {
            if (!t)
                return !1;
            if ("DeclareExportAllDeclaration" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isDeclaredPredicate = function isDeclaredPredicate(t, r) {
            if (!t)
                return !1;
            if ("DeclaredPredicate" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isExistsTypeAnnotation = function isExistsTypeAnnotation(t, r) {
            if (!t)
                return !1;
            if ("ExistsTypeAnnotation" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isFunctionTypeAnnotation = function isFunctionTypeAnnotation(t, r) {
            if (!t)
                return !1;
            if ("FunctionTypeAnnotation" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isFunctionTypeParam = function isFunctionTypeParam(t, r) {
            if (!t)
                return !1;
            if ("FunctionTypeParam" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isGenericTypeAnnotation = function isGenericTypeAnnotation(t, r) {
            if (!t)
                return !1;
            if ("GenericTypeAnnotation" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isInferredPredicate = function isInferredPredicate(t, r) {
            if (!t)
                return !1;
            if ("InferredPredicate" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isInterfaceExtends = function isInterfaceExtends(t, r) {
            if (!t)
                return !1;
            if ("InterfaceExtends" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isInterfaceDeclaration = function isInterfaceDeclaration(t, r) {
            if (!t)
                return !1;
            if ("InterfaceDeclaration" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isInterfaceTypeAnnotation = function isInterfaceTypeAnnotation(t, r) {
            if (!t)
                return !1;
            if ("InterfaceTypeAnnotation" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isIntersectionTypeAnnotation = function isIntersectionTypeAnnotation(t, r) {
            if (!t)
                return !1;
            if ("IntersectionTypeAnnotation" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isMixedTypeAnnotation = function isMixedTypeAnnotation(t, r) {
            if (!t)
                return !1;
            if ("MixedTypeAnnotation" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isEmptyTypeAnnotation = function isEmptyTypeAnnotation(t, r) {
            if (!t)
                return !1;
            if ("EmptyTypeAnnotation" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isNullableTypeAnnotation = function isNullableTypeAnnotation(t, r) {
            if (!t)
                return !1;
            if ("NullableTypeAnnotation" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isNumberLiteralTypeAnnotation = function isNumberLiteralTypeAnnotation(t, r) {
            if (!t)
                return !1;
            if ("NumberLiteralTypeAnnotation" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isNumberTypeAnnotation = function isNumberTypeAnnotation(t, r) {
            if (!t)
                return !1;
            if ("NumberTypeAnnotation" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isObjectTypeAnnotation = function isObjectTypeAnnotation(t, r) {
            if (!t)
                return !1;
            if ("ObjectTypeAnnotation" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isObjectTypeInternalSlot = function isObjectTypeInternalSlot(t, r) {
            if (!t)
                return !1;
            if ("ObjectTypeInternalSlot" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isObjectTypeCallProperty = function isObjectTypeCallProperty(t, r) {
            if (!t)
                return !1;
            if ("ObjectTypeCallProperty" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isObjectTypeIndexer = function isObjectTypeIndexer(t, r) {
            if (!t)
                return !1;
            if ("ObjectTypeIndexer" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isObjectTypeProperty = function isObjectTypeProperty(t, r) {
            if (!t)
                return !1;
            if ("ObjectTypeProperty" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isObjectTypeSpreadProperty = function isObjectTypeSpreadProperty(t, r) {
            if (!t)
                return !1;
            if ("ObjectTypeSpreadProperty" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isOpaqueType = function isOpaqueType(t, r) {
            if (!t)
                return !1;
            if ("OpaqueType" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isQualifiedTypeIdentifier = function isQualifiedTypeIdentifier(t, r) {
            if (!t)
                return !1;
            if ("QualifiedTypeIdentifier" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isStringLiteralTypeAnnotation = function isStringLiteralTypeAnnotation(t, r) {
            if (!t)
                return !1;
            if ("StringLiteralTypeAnnotation" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isStringTypeAnnotation = function isStringTypeAnnotation(t, r) {
            if (!t)
                return !1;
            if ("StringTypeAnnotation" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isSymbolTypeAnnotation = function isSymbolTypeAnnotation(t, r) {
            if (!t)
                return !1;
            if ("SymbolTypeAnnotation" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isThisTypeAnnotation = function isThisTypeAnnotation(t, r) {
            if (!t)
                return !1;
            if ("ThisTypeAnnotation" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTupleTypeAnnotation = function isTupleTypeAnnotation(t, r) {
            if (!t)
                return !1;
            if ("TupleTypeAnnotation" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTypeofTypeAnnotation = function isTypeofTypeAnnotation(t, r) {
            if (!t)
                return !1;
            if ("TypeofTypeAnnotation" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTypeAlias = function isTypeAlias(t, r) {
            if (!t)
                return !1;
            if ("TypeAlias" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTypeAnnotation = function isTypeAnnotation(t, r) {
            if (!t)
                return !1;
            if ("TypeAnnotation" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTypeCastExpression = function isTypeCastExpression(t, r) {
            if (!t)
                return !1;
            if ("TypeCastExpression" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTypeParameter = function isTypeParameter(t, r) {
            if (!t)
                return !1;
            if ("TypeParameter" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTypeParameterDeclaration = function isTypeParameterDeclaration(t, r) {
            if (!t)
                return !1;
            if ("TypeParameterDeclaration" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTypeParameterInstantiation = function isTypeParameterInstantiation(t, r) {
            if (!t)
                return !1;
            if ("TypeParameterInstantiation" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isUnionTypeAnnotation = function isUnionTypeAnnotation(t, r) {
            if (!t)
                return !1;
            if ("UnionTypeAnnotation" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isVariance = function isVariance(t, r) {
            if (!t)
                return !1;
            if ("Variance" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isVoidTypeAnnotation = function isVoidTypeAnnotation(t, r) {
            if (!t)
                return !1;
            if ("VoidTypeAnnotation" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isEnumDeclaration = function isEnumDeclaration(t, r) {
            if (!t)
                return !1;
            if ("EnumDeclaration" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isEnumBooleanBody = function isEnumBooleanBody(t, r) {
            if (!t)
                return !1;
            if ("EnumBooleanBody" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isEnumNumberBody = function isEnumNumberBody(t, r) {
            if (!t)
                return !1;
            if ("EnumNumberBody" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isEnumStringBody = function isEnumStringBody(t, r) {
            if (!t)
                return !1;
            if ("EnumStringBody" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isEnumSymbolBody = function isEnumSymbolBody(t, r) {
            if (!t)
                return !1;
            if ("EnumSymbolBody" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isEnumBooleanMember = function isEnumBooleanMember(t, r) {
            if (!t)
                return !1;
            if ("EnumBooleanMember" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isEnumNumberMember = function isEnumNumberMember(t, r) {
            if (!t)
                return !1;
            if ("EnumNumberMember" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isEnumStringMember = function isEnumStringMember(t, r) {
            if (!t)
                return !1;
            if ("EnumStringMember" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isEnumDefaultedMember = function isEnumDefaultedMember(t, r) {
            if (!t)
                return !1;
            if ("EnumDefaultedMember" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isIndexedAccessType = function isIndexedAccessType(t, r) {
            if (!t)
                return !1;
            if ("IndexedAccessType" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isOptionalIndexedAccessType = function isOptionalIndexedAccessType(t, r) {
            if (!t)
                return !1;
            if ("OptionalIndexedAccessType" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isJSXAttribute = function isJSXAttribute(t, r) {
            if (!t)
                return !1;
            if ("JSXAttribute" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isJSXClosingElement = function isJSXClosingElement(t, r) {
            if (!t)
                return !1;
            if ("JSXClosingElement" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isJSXElement = function isJSXElement(t, r) {
            if (!t)
                return !1;
            if ("JSXElement" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isJSXEmptyExpression = function isJSXEmptyExpression(t, r) {
            if (!t)
                return !1;
            if ("JSXEmptyExpression" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isJSXExpressionContainer = function isJSXExpressionContainer(t, r) {
            if (!t)
                return !1;
            if ("JSXExpressionContainer" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isJSXSpreadChild = function isJSXSpreadChild(t, r) {
            if (!t)
                return !1;
            if ("JSXSpreadChild" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isJSXIdentifier = function isJSXIdentifier(t, r) {
            if (!t)
                return !1;
            if ("JSXIdentifier" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isJSXMemberExpression = function isJSXMemberExpression(t, r) {
            if (!t)
                return !1;
            if ("JSXMemberExpression" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isJSXNamespacedName = function isJSXNamespacedName(t, r) {
            if (!t)
                return !1;
            if ("JSXNamespacedName" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isJSXOpeningElement = function isJSXOpeningElement(t, r) {
            if (!t)
                return !1;
            if ("JSXOpeningElement" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isJSXSpreadAttribute = function isJSXSpreadAttribute(t, r) {
            if (!t)
                return !1;
            if ("JSXSpreadAttribute" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isJSXText = function isJSXText(t, r) {
            if (!t)
                return !1;
            if ("JSXText" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isJSXFragment = function isJSXFragment(t, r) {
            if (!t)
                return !1;
            if ("JSXFragment" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isJSXOpeningFragment = function isJSXOpeningFragment(t, r) {
            if (!t)
                return !1;
            if ("JSXOpeningFragment" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isJSXClosingFragment = function isJSXClosingFragment(t, r) {
            if (!t)
                return !1;
            if ("JSXClosingFragment" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isNoop = function isNoop(t, r) {
            if (!t)
                return !1;
            if ("Noop" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isPlaceholder = function isPlaceholder(t, r) {
            if (!t)
                return !1;
            if ("Placeholder" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isV8IntrinsicIdentifier = function isV8IntrinsicIdentifier(t, r) {
            if (!t)
                return !1;
            if ("V8IntrinsicIdentifier" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isArgumentPlaceholder = function isArgumentPlaceholder(t, r) {
            if (!t)
                return !1;
            if ("ArgumentPlaceholder" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isBindExpression = function isBindExpression(t, r) {
            if (!t)
                return !1;
            if ("BindExpression" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isImportAttribute = function isImportAttribute(t, r) {
            if (!t)
                return !1;
            if ("ImportAttribute" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isDecorator = function isDecorator(t, r) {
            if (!t)
                return !1;
            if ("Decorator" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isDoExpression = function isDoExpression(t, r) {
            if (!t)
                return !1;
            if ("DoExpression" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isExportDefaultSpecifier = function isExportDefaultSpecifier(t, r) {
            if (!t)
                return !1;
            if ("ExportDefaultSpecifier" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isRecordExpression = function isRecordExpression(t, r) {
            if (!t)
                return !1;
            if ("RecordExpression" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTupleExpression = function isTupleExpression(t, r) {
            if (!t)
                return !1;
            if ("TupleExpression" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isDecimalLiteral = function isDecimalLiteral(t, r) {
            if (!t)
                return !1;
            if ("DecimalLiteral" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isStaticBlock = function isStaticBlock(t, r) {
            if (!t)
                return !1;
            if ("StaticBlock" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isModuleExpression = function isModuleExpression(t, r) {
            if (!t)
                return !1;
            if ("ModuleExpression" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTopicReference = function isTopicReference(t, r) {
            if (!t)
                return !1;
            if ("TopicReference" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isPipelineTopicExpression = function isPipelineTopicExpression(t, r) {
            if (!t)
                return !1;
            if ("PipelineTopicExpression" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isPipelineBareFunction = function isPipelineBareFunction(t, r) {
            if (!t)
                return !1;
            if ("PipelineBareFunction" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isPipelinePrimaryTopicReference = function isPipelinePrimaryTopicReference(t, r) {
            if (!t)
                return !1;
            if ("PipelinePrimaryTopicReference" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSParameterProperty = function isTSParameterProperty(t, r) {
            if (!t)
                return !1;
            if ("TSParameterProperty" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSDeclareFunction = function isTSDeclareFunction(t, r) {
            if (!t)
                return !1;
            if ("TSDeclareFunction" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSDeclareMethod = function isTSDeclareMethod(t, r) {
            if (!t)
                return !1;
            if ("TSDeclareMethod" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSQualifiedName = function isTSQualifiedName(t, r) {
            if (!t)
                return !1;
            if ("TSQualifiedName" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSCallSignatureDeclaration = function isTSCallSignatureDeclaration(t, r) {
            if (!t)
                return !1;
            if ("TSCallSignatureDeclaration" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSConstructSignatureDeclaration = function isTSConstructSignatureDeclaration(t, r) {
            if (!t)
                return !1;
            if ("TSConstructSignatureDeclaration" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSPropertySignature = function isTSPropertySignature(t, r) {
            if (!t)
                return !1;
            if ("TSPropertySignature" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSMethodSignature = function isTSMethodSignature(t, r) {
            if (!t)
                return !1;
            if ("TSMethodSignature" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSIndexSignature = function isTSIndexSignature(t, r) {
            if (!t)
                return !1;
            if ("TSIndexSignature" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSAnyKeyword = function isTSAnyKeyword(t, r) {
            if (!t)
                return !1;
            if ("TSAnyKeyword" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSBooleanKeyword = function isTSBooleanKeyword(t, r) {
            if (!t)
                return !1;
            if ("TSBooleanKeyword" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSBigIntKeyword = function isTSBigIntKeyword(t, r) {
            if (!t)
                return !1;
            if ("TSBigIntKeyword" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSIntrinsicKeyword = function isTSIntrinsicKeyword(t, r) {
            if (!t)
                return !1;
            if ("TSIntrinsicKeyword" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSNeverKeyword = function isTSNeverKeyword(t, r) {
            if (!t)
                return !1;
            if ("TSNeverKeyword" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSNullKeyword = function isTSNullKeyword(t, r) {
            if (!t)
                return !1;
            if ("TSNullKeyword" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSNumberKeyword = function isTSNumberKeyword(t, r) {
            if (!t)
                return !1;
            if ("TSNumberKeyword" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSObjectKeyword = function isTSObjectKeyword(t, r) {
            if (!t)
                return !1;
            if ("TSObjectKeyword" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSStringKeyword = function isTSStringKeyword(t, r) {
            if (!t)
                return !1;
            if ("TSStringKeyword" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSSymbolKeyword = function isTSSymbolKeyword(t, r) {
            if (!t)
                return !1;
            if ("TSSymbolKeyword" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSUndefinedKeyword = function isTSUndefinedKeyword(t, r) {
            if (!t)
                return !1;
            if ("TSUndefinedKeyword" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSUnknownKeyword = function isTSUnknownKeyword(t, r) {
            if (!t)
                return !1;
            if ("TSUnknownKeyword" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSVoidKeyword = function isTSVoidKeyword(t, r) {
            if (!t)
                return !1;
            if ("TSVoidKeyword" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSThisType = function isTSThisType(t, r) {
            if (!t)
                return !1;
            if ("TSThisType" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSFunctionType = function isTSFunctionType(t, r) {
            if (!t)
                return !1;
            if ("TSFunctionType" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSConstructorType = function isTSConstructorType(t, r) {
            if (!t)
                return !1;
            if ("TSConstructorType" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSTypeReference = function isTSTypeReference(t, r) {
            if (!t)
                return !1;
            if ("TSTypeReference" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSTypePredicate = function isTSTypePredicate(t, r) {
            if (!t)
                return !1;
            if ("TSTypePredicate" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSTypeQuery = function isTSTypeQuery(t, r) {
            if (!t)
                return !1;
            if ("TSTypeQuery" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSTypeLiteral = function isTSTypeLiteral(t, r) {
            if (!t)
                return !1;
            if ("TSTypeLiteral" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSArrayType = function isTSArrayType(t, r) {
            if (!t)
                return !1;
            if ("TSArrayType" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSTupleType = function isTSTupleType(t, r) {
            if (!t)
                return !1;
            if ("TSTupleType" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSOptionalType = function isTSOptionalType(t, r) {
            if (!t)
                return !1;
            if ("TSOptionalType" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSRestType = function isTSRestType(t, r) {
            if (!t)
                return !1;
            if ("TSRestType" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSNamedTupleMember = function isTSNamedTupleMember(t, r) {
            if (!t)
                return !1;
            if ("TSNamedTupleMember" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSUnionType = function isTSUnionType(t, r) {
            if (!t)
                return !1;
            if ("TSUnionType" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSIntersectionType = function isTSIntersectionType(t, r) {
            if (!t)
                return !1;
            if ("TSIntersectionType" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSConditionalType = function isTSConditionalType(t, r) {
            if (!t)
                return !1;
            if ("TSConditionalType" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSInferType = function isTSInferType(t, r) {
            if (!t)
                return !1;
            if ("TSInferType" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSParenthesizedType = function isTSParenthesizedType(t, r) {
            if (!t)
                return !1;
            if ("TSParenthesizedType" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSTypeOperator = function isTSTypeOperator(t, r) {
            if (!t)
                return !1;
            if ("TSTypeOperator" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSIndexedAccessType = function isTSIndexedAccessType(t, r) {
            if (!t)
                return !1;
            if ("TSIndexedAccessType" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSMappedType = function isTSMappedType(t, r) {
            if (!t)
                return !1;
            if ("TSMappedType" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSLiteralType = function isTSLiteralType(t, r) {
            if (!t)
                return !1;
            if ("TSLiteralType" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSExpressionWithTypeArguments = function isTSExpressionWithTypeArguments(t, r) {
            if (!t)
                return !1;
            if ("TSExpressionWithTypeArguments" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSInterfaceDeclaration = function isTSInterfaceDeclaration(t, r) {
            if (!t)
                return !1;
            if ("TSInterfaceDeclaration" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSInterfaceBody = function isTSInterfaceBody(t, r) {
            if (!t)
                return !1;
            if ("TSInterfaceBody" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSTypeAliasDeclaration = function isTSTypeAliasDeclaration(t, r) {
            if (!t)
                return !1;
            if ("TSTypeAliasDeclaration" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSAsExpression = function isTSAsExpression(t, r) {
            if (!t)
                return !1;
            if ("TSAsExpression" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSTypeAssertion = function isTSTypeAssertion(t, r) {
            if (!t)
                return !1;
            if ("TSTypeAssertion" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSEnumDeclaration = function isTSEnumDeclaration(t, r) {
            if (!t)
                return !1;
            if ("TSEnumDeclaration" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSEnumMember = function isTSEnumMember(t, r) {
            if (!t)
                return !1;
            if ("TSEnumMember" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSModuleDeclaration = function isTSModuleDeclaration(t, r) {
            if (!t)
                return !1;
            if ("TSModuleDeclaration" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSModuleBlock = function isTSModuleBlock(t, r) {
            if (!t)
                return !1;
            if ("TSModuleBlock" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSImportType = function isTSImportType(t, r) {
            if (!t)
                return !1;
            if ("TSImportType" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSImportEqualsDeclaration = function isTSImportEqualsDeclaration(t, r) {
            if (!t)
                return !1;
            if ("TSImportEqualsDeclaration" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSExternalModuleReference = function isTSExternalModuleReference(t, r) {
            if (!t)
                return !1;
            if ("TSExternalModuleReference" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSNonNullExpression = function isTSNonNullExpression(t, r) {
            if (!t)
                return !1;
            if ("TSNonNullExpression" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSExportAssignment = function isTSExportAssignment(t, r) {
            if (!t)
                return !1;
            if ("TSExportAssignment" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSNamespaceExportDeclaration = function isTSNamespaceExportDeclaration(t, r) {
            if (!t)
                return !1;
            if ("TSNamespaceExportDeclaration" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSTypeAnnotation = function isTSTypeAnnotation(t, r) {
            if (!t)
                return !1;
            if ("TSTypeAnnotation" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSTypeParameterInstantiation = function isTSTypeParameterInstantiation(t, r) {
            if (!t)
                return !1;
            if ("TSTypeParameterInstantiation" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSTypeParameterDeclaration = function isTSTypeParameterDeclaration(t, r) {
            if (!t)
                return !1;
            if ("TSTypeParameterDeclaration" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSTypeParameter = function isTSTypeParameter(t, r) {
            if (!t)
                return !1;
            if ("TSTypeParameter" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isExpression = function isExpression(t, r) {
            if (!t)
                return !1;
            var i = t.type;
            if ("ArrayExpression" === i || "AssignmentExpression" === i || "BinaryExpression" === i || "CallExpression" === i || "ConditionalExpression" === i || "FunctionExpression" === i || "Identifier" === i || "StringLiteral" === i || "NumericLiteral" === i || "NullLiteral" === i || "BooleanLiteral" === i || "RegExpLiteral" === i || "LogicalExpression" === i || "MemberExpression" === i || "NewExpression" === i || "ObjectExpression" === i || "SequenceExpression" === i || "ParenthesizedExpression" === i || "ThisExpression" === i || "UnaryExpression" === i || "UpdateExpression" === i || "ArrowFunctionExpression" === i || "ClassExpression" === i || "MetaProperty" === i || "Super" === i || "TaggedTemplateExpression" === i || "TemplateLiteral" === i || "YieldExpression" === i || "AwaitExpression" === i || "Import" === i || "BigIntLiteral" === i || "OptionalMemberExpression" === i || "OptionalCallExpression" === i || "TypeCastExpression" === i || "JSXElement" === i || "JSXFragment" === i || "BindExpression" === i || "DoExpression" === i || "RecordExpression" === i || "TupleExpression" === i || "DecimalLiteral" === i || "ModuleExpression" === i || "TopicReference" === i || "PipelineTopicExpression" === i || "PipelineBareFunction" === i || "PipelinePrimaryTopicReference" === i || "TSAsExpression" === i || "TSTypeAssertion" === i || "TSNonNullExpression" === i || "Placeholder" === i && ("Expression" === t.expectedNode || "Identifier" === t.expectedNode || "StringLiteral" === t.expectedNode))
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isBinary = function isBinary(t, r) {
            if (!t)
                return !1;
            var i = t.type;
            if ("BinaryExpression" === i || "LogicalExpression" === i)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isScopable = function isScopable(t, r) {
            if (!t)
                return !1;
            var i = t.type;
            if ("BlockStatement" === i || "CatchClause" === i || "DoWhileStatement" === i || "ForInStatement" === i || "ForStatement" === i || "FunctionDeclaration" === i || "FunctionExpression" === i || "Program" === i || "ObjectMethod" === i || "SwitchStatement" === i || "WhileStatement" === i || "ArrowFunctionExpression" === i || "ClassExpression" === i || "ClassDeclaration" === i || "ForOfStatement" === i || "ClassMethod" === i || "ClassPrivateMethod" === i || "StaticBlock" === i || "TSModuleBlock" === i || "Placeholder" === i && "BlockStatement" === t.expectedNode)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isBlockParent = function isBlockParent(t, r) {
            if (!t)
                return !1;
            var i = t.type;
            if ("BlockStatement" === i || "CatchClause" === i || "DoWhileStatement" === i || "ForInStatement" === i || "ForStatement" === i || "FunctionDeclaration" === i || "FunctionExpression" === i || "Program" === i || "ObjectMethod" === i || "SwitchStatement" === i || "WhileStatement" === i || "ArrowFunctionExpression" === i || "ForOfStatement" === i || "ClassMethod" === i || "ClassPrivateMethod" === i || "StaticBlock" === i || "TSModuleBlock" === i || "Placeholder" === i && "BlockStatement" === t.expectedNode)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isBlock = function isBlock(t, r) {
            if (!t)
                return !1;
            var i = t.type;
            if ("BlockStatement" === i || "Program" === i || "TSModuleBlock" === i || "Placeholder" === i && "BlockStatement" === t.expectedNode)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isStatement = function isStatement(t, r) {
            if (!t)
                return !1;
            var i = t.type;
            if ("BlockStatement" === i || "BreakStatement" === i || "ContinueStatement" === i || "DebuggerStatement" === i || "DoWhileStatement" === i || "EmptyStatement" === i || "ExpressionStatement" === i || "ForInStatement" === i || "ForStatement" === i || "FunctionDeclaration" === i || "IfStatement" === i || "LabeledStatement" === i || "ReturnStatement" === i || "SwitchStatement" === i || "ThrowStatement" === i || "TryStatement" === i || "VariableDeclaration" === i || "WhileStatement" === i || "WithStatement" === i || "ClassDeclaration" === i || "ExportAllDeclaration" === i || "ExportDefaultDeclaration" === i || "ExportNamedDeclaration" === i || "ForOfStatement" === i || "ImportDeclaration" === i || "DeclareClass" === i || "DeclareFunction" === i || "DeclareInterface" === i || "DeclareModule" === i || "DeclareModuleExports" === i || "DeclareTypeAlias" === i || "DeclareOpaqueType" === i || "DeclareVariable" === i || "DeclareExportDeclaration" === i || "DeclareExportAllDeclaration" === i || "InterfaceDeclaration" === i || "OpaqueType" === i || "TypeAlias" === i || "EnumDeclaration" === i || "TSDeclareFunction" === i || "TSInterfaceDeclaration" === i || "TSTypeAliasDeclaration" === i || "TSEnumDeclaration" === i || "TSModuleDeclaration" === i || "TSImportEqualsDeclaration" === i || "TSExportAssignment" === i || "TSNamespaceExportDeclaration" === i || "Placeholder" === i && ("Statement" === t.expectedNode || "Declaration" === t.expectedNode || "BlockStatement" === t.expectedNode))
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTerminatorless = function isTerminatorless(t, r) {
            if (!t)
                return !1;
            var i = t.type;
            if ("BreakStatement" === i || "ContinueStatement" === i || "ReturnStatement" === i || "ThrowStatement" === i || "YieldExpression" === i || "AwaitExpression" === i)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isCompletionStatement = function isCompletionStatement(t, r) {
            if (!t)
                return !1;
            var i = t.type;
            if ("BreakStatement" === i || "ContinueStatement" === i || "ReturnStatement" === i || "ThrowStatement" === i)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isConditional = function isConditional(t, r) {
            if (!t)
                return !1;
            var i = t.type;
            if ("ConditionalExpression" === i || "IfStatement" === i)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isLoop = function isLoop(t, r) {
            if (!t)
                return !1;
            var i = t.type;
            if ("DoWhileStatement" === i || "ForInStatement" === i || "ForStatement" === i || "WhileStatement" === i || "ForOfStatement" === i)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isWhile = function isWhile(t, r) {
            if (!t)
                return !1;
            var i = t.type;
            if ("DoWhileStatement" === i || "WhileStatement" === i)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isExpressionWrapper = function isExpressionWrapper(t, r) {
            if (!t)
                return !1;
            var i = t.type;
            if ("ExpressionStatement" === i || "ParenthesizedExpression" === i || "TypeCastExpression" === i)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isFor = function isFor(t, r) {
            if (!t)
                return !1;
            var i = t.type;
            if ("ForInStatement" === i || "ForStatement" === i || "ForOfStatement" === i)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isForXStatement = function isForXStatement(t, r) {
            if (!t)
                return !1;
            var i = t.type;
            if ("ForInStatement" === i || "ForOfStatement" === i)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isFunction = function isFunction(t, r) {
            if (!t)
                return !1;
            var i = t.type;
            if ("FunctionDeclaration" === i || "FunctionExpression" === i || "ObjectMethod" === i || "ArrowFunctionExpression" === i || "ClassMethod" === i || "ClassPrivateMethod" === i)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isFunctionParent = function isFunctionParent(t, r) {
            if (!t)
                return !1;
            var i = t.type;
            if ("FunctionDeclaration" === i || "FunctionExpression" === i || "ObjectMethod" === i || "ArrowFunctionExpression" === i || "ClassMethod" === i || "ClassPrivateMethod" === i)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isPureish = function isPureish(t, r) {
            if (!t)
                return !1;
            var i = t.type;
            if ("FunctionDeclaration" === i || "FunctionExpression" === i || "StringLiteral" === i || "NumericLiteral" === i || "NullLiteral" === i || "BooleanLiteral" === i || "RegExpLiteral" === i || "ArrowFunctionExpression" === i || "BigIntLiteral" === i || "DecimalLiteral" === i || "Placeholder" === i && "StringLiteral" === t.expectedNode)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isDeclaration = function isDeclaration(t, r) {
            if (!t)
                return !1;
            var i = t.type;
            if ("FunctionDeclaration" === i || "VariableDeclaration" === i || "ClassDeclaration" === i || "ExportAllDeclaration" === i || "ExportDefaultDeclaration" === i || "ExportNamedDeclaration" === i || "ImportDeclaration" === i || "DeclareClass" === i || "DeclareFunction" === i || "DeclareInterface" === i || "DeclareModule" === i || "DeclareModuleExports" === i || "DeclareTypeAlias" === i || "DeclareOpaqueType" === i || "DeclareVariable" === i || "DeclareExportDeclaration" === i || "DeclareExportAllDeclaration" === i || "InterfaceDeclaration" === i || "OpaqueType" === i || "TypeAlias" === i || "EnumDeclaration" === i || "TSDeclareFunction" === i || "TSInterfaceDeclaration" === i || "TSTypeAliasDeclaration" === i || "TSEnumDeclaration" === i || "TSModuleDeclaration" === i || "Placeholder" === i && "Declaration" === t.expectedNode)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isPatternLike = function isPatternLike(t, r) {
            if (!t)
                return !1;
            var i = t.type;
            if ("Identifier" === i || "RestElement" === i || "AssignmentPattern" === i || "ArrayPattern" === i || "ObjectPattern" === i || "Placeholder" === i && ("Pattern" === t.expectedNode || "Identifier" === t.expectedNode))
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isLVal = function isLVal(t, r) {
            if (!t)
                return !1;
            var i = t.type;
            if ("Identifier" === i || "MemberExpression" === i || "RestElement" === i || "AssignmentPattern" === i || "ArrayPattern" === i || "ObjectPattern" === i || "TSParameterProperty" === i || "Placeholder" === i && ("Pattern" === t.expectedNode || "Identifier" === t.expectedNode))
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSEntityName = function isTSEntityName(t, r) {
            if (!t)
                return !1;
            var i = t.type;
            if ("Identifier" === i || "TSQualifiedName" === i || "Placeholder" === i && "Identifier" === t.expectedNode)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isLiteral = function isLiteral(t, r) {
            if (!t)
                return !1;
            var i = t.type;
            if ("StringLiteral" === i || "NumericLiteral" === i || "NullLiteral" === i || "BooleanLiteral" === i || "RegExpLiteral" === i || "TemplateLiteral" === i || "BigIntLiteral" === i || "DecimalLiteral" === i || "Placeholder" === i && "StringLiteral" === t.expectedNode)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isImmutable = function isImmutable(t, r) {
            if (!t)
                return !1;
            var i = t.type;
            if ("StringLiteral" === i || "NumericLiteral" === i || "NullLiteral" === i || "BooleanLiteral" === i || "BigIntLiteral" === i || "JSXAttribute" === i || "JSXClosingElement" === i || "JSXElement" === i || "JSXExpressionContainer" === i || "JSXSpreadChild" === i || "JSXOpeningElement" === i || "JSXText" === i || "JSXFragment" === i || "JSXOpeningFragment" === i || "JSXClosingFragment" === i || "DecimalLiteral" === i || "Placeholder" === i && "StringLiteral" === t.expectedNode)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isUserWhitespacable = function isUserWhitespacable(t, r) {
            if (!t)
                return !1;
            var i = t.type;
            if ("ObjectMethod" === i || "ObjectProperty" === i || "ObjectTypeInternalSlot" === i || "ObjectTypeCallProperty" === i || "ObjectTypeIndexer" === i || "ObjectTypeProperty" === i || "ObjectTypeSpreadProperty" === i)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isMethod = function isMethod(t, r) {
            if (!t)
                return !1;
            var i = t.type;
            if ("ObjectMethod" === i || "ClassMethod" === i || "ClassPrivateMethod" === i)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isObjectMember = function isObjectMember(t, r) {
            if (!t)
                return !1;
            var i = t.type;
            if ("ObjectMethod" === i || "ObjectProperty" === i)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isProperty = function isProperty(t, r) {
            if (!t)
                return !1;
            var i = t.type;
            if ("ObjectProperty" === i || "ClassProperty" === i || "ClassPrivateProperty" === i)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isUnaryLike = function isUnaryLike(t, r) {
            if (!t)
                return !1;
            var i = t.type;
            if ("UnaryExpression" === i || "SpreadElement" === i)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isPattern = function isPattern(t, r) {
            if (!t)
                return !1;
            var i = t.type;
            if ("AssignmentPattern" === i || "ArrayPattern" === i || "ObjectPattern" === i || "Placeholder" === i && "Pattern" === t.expectedNode)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isClass = function isClass(t, r) {
            if (!t)
                return !1;
            var i = t.type;
            if ("ClassExpression" === i || "ClassDeclaration" === i)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isModuleDeclaration = function isModuleDeclaration(t, r) {
            if (!t)
                return !1;
            var i = t.type;
            if ("ExportAllDeclaration" === i || "ExportDefaultDeclaration" === i || "ExportNamedDeclaration" === i || "ImportDeclaration" === i)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isExportDeclaration = function isExportDeclaration(t, r) {
            if (!t)
                return !1;
            var i = t.type;
            if ("ExportAllDeclaration" === i || "ExportDefaultDeclaration" === i || "ExportNamedDeclaration" === i)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isModuleSpecifier = function isModuleSpecifier(t, r) {
            if (!t)
                return !1;
            var i = t.type;
            if ("ExportSpecifier" === i || "ImportDefaultSpecifier" === i || "ImportNamespaceSpecifier" === i || "ImportSpecifier" === i || "ExportNamespaceSpecifier" === i || "ExportDefaultSpecifier" === i)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isPrivate = function isPrivate(t, r) {
            if (!t)
                return !1;
            var i = t.type;
            if ("ClassPrivateProperty" === i || "ClassPrivateMethod" === i || "PrivateName" === i)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isFlow = function isFlow(t, r) {
            if (!t)
                return !1;
            var i = t.type;
            if ("AnyTypeAnnotation" === i || "ArrayTypeAnnotation" === i || "BooleanTypeAnnotation" === i || "BooleanLiteralTypeAnnotation" === i || "NullLiteralTypeAnnotation" === i || "ClassImplements" === i || "DeclareClass" === i || "DeclareFunction" === i || "DeclareInterface" === i || "DeclareModule" === i || "DeclareModuleExports" === i || "DeclareTypeAlias" === i || "DeclareOpaqueType" === i || "DeclareVariable" === i || "DeclareExportDeclaration" === i || "DeclareExportAllDeclaration" === i || "DeclaredPredicate" === i || "ExistsTypeAnnotation" === i || "FunctionTypeAnnotation" === i || "FunctionTypeParam" === i || "GenericTypeAnnotation" === i || "InferredPredicate" === i || "InterfaceExtends" === i || "InterfaceDeclaration" === i || "InterfaceTypeAnnotation" === i || "IntersectionTypeAnnotation" === i || "MixedTypeAnnotation" === i || "EmptyTypeAnnotation" === i || "NullableTypeAnnotation" === i || "NumberLiteralTypeAnnotation" === i || "NumberTypeAnnotation" === i || "ObjectTypeAnnotation" === i || "ObjectTypeInternalSlot" === i || "ObjectTypeCallProperty" === i || "ObjectTypeIndexer" === i || "ObjectTypeProperty" === i || "ObjectTypeSpreadProperty" === i || "OpaqueType" === i || "QualifiedTypeIdentifier" === i || "StringLiteralTypeAnnotation" === i || "StringTypeAnnotation" === i || "SymbolTypeAnnotation" === i || "ThisTypeAnnotation" === i || "TupleTypeAnnotation" === i || "TypeofTypeAnnotation" === i || "TypeAlias" === i || "TypeAnnotation" === i || "TypeCastExpression" === i || "TypeParameter" === i || "TypeParameterDeclaration" === i || "TypeParameterInstantiation" === i || "UnionTypeAnnotation" === i || "Variance" === i || "VoidTypeAnnotation" === i || "IndexedAccessType" === i || "OptionalIndexedAccessType" === i)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isFlowType = function isFlowType(t, r) {
            if (!t)
                return !1;
            var i = t.type;
            if ("AnyTypeAnnotation" === i || "ArrayTypeAnnotation" === i || "BooleanTypeAnnotation" === i || "BooleanLiteralTypeAnnotation" === i || "NullLiteralTypeAnnotation" === i || "ExistsTypeAnnotation" === i || "FunctionTypeAnnotation" === i || "GenericTypeAnnotation" === i || "InterfaceTypeAnnotation" === i || "IntersectionTypeAnnotation" === i || "MixedTypeAnnotation" === i || "EmptyTypeAnnotation" === i || "NullableTypeAnnotation" === i || "NumberLiteralTypeAnnotation" === i || "NumberTypeAnnotation" === i || "ObjectTypeAnnotation" === i || "StringLiteralTypeAnnotation" === i || "StringTypeAnnotation" === i || "SymbolTypeAnnotation" === i || "ThisTypeAnnotation" === i || "TupleTypeAnnotation" === i || "TypeofTypeAnnotation" === i || "UnionTypeAnnotation" === i || "VoidTypeAnnotation" === i || "IndexedAccessType" === i || "OptionalIndexedAccessType" === i)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isFlowBaseAnnotation = function isFlowBaseAnnotation(t, r) {
            if (!t)
                return !1;
            var i = t.type;
            if ("AnyTypeAnnotation" === i || "BooleanTypeAnnotation" === i || "NullLiteralTypeAnnotation" === i || "MixedTypeAnnotation" === i || "EmptyTypeAnnotation" === i || "NumberTypeAnnotation" === i || "StringTypeAnnotation" === i || "SymbolTypeAnnotation" === i || "ThisTypeAnnotation" === i || "VoidTypeAnnotation" === i)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isFlowDeclaration = function isFlowDeclaration(t, r) {
            if (!t)
                return !1;
            var i = t.type;
            if ("DeclareClass" === i || "DeclareFunction" === i || "DeclareInterface" === i || "DeclareModule" === i || "DeclareModuleExports" === i || "DeclareTypeAlias" === i || "DeclareOpaqueType" === i || "DeclareVariable" === i || "DeclareExportDeclaration" === i || "DeclareExportAllDeclaration" === i || "InterfaceDeclaration" === i || "OpaqueType" === i || "TypeAlias" === i)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isFlowPredicate = function isFlowPredicate(t, r) {
            if (!t)
                return !1;
            var i = t.type;
            if ("DeclaredPredicate" === i || "InferredPredicate" === i)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isEnumBody = function isEnumBody(t, r) {
            if (!t)
                return !1;
            var i = t.type;
            if ("EnumBooleanBody" === i || "EnumNumberBody" === i || "EnumStringBody" === i || "EnumSymbolBody" === i)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isEnumMember = function isEnumMember(t, r) {
            if (!t)
                return !1;
            var i = t.type;
            if ("EnumBooleanMember" === i || "EnumNumberMember" === i || "EnumStringMember" === i || "EnumDefaultedMember" === i)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isJSX = function isJSX(t, r) {
            if (!t)
                return !1;
            var i = t.type;
            if ("JSXAttribute" === i || "JSXClosingElement" === i || "JSXElement" === i || "JSXEmptyExpression" === i || "JSXExpressionContainer" === i || "JSXSpreadChild" === i || "JSXIdentifier" === i || "JSXMemberExpression" === i || "JSXNamespacedName" === i || "JSXOpeningElement" === i || "JSXSpreadAttribute" === i || "JSXText" === i || "JSXFragment" === i || "JSXOpeningFragment" === i || "JSXClosingFragment" === i)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSTypeElement = function isTSTypeElement(t, r) {
            if (!t)
                return !1;
            var i = t.type;
            if ("TSCallSignatureDeclaration" === i || "TSConstructSignatureDeclaration" === i || "TSPropertySignature" === i || "TSMethodSignature" === i || "TSIndexSignature" === i)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSType = function isTSType(t, r) {
            if (!t)
                return !1;
            var i = t.type;
            if ("TSAnyKeyword" === i || "TSBooleanKeyword" === i || "TSBigIntKeyword" === i || "TSIntrinsicKeyword" === i || "TSNeverKeyword" === i || "TSNullKeyword" === i || "TSNumberKeyword" === i || "TSObjectKeyword" === i || "TSStringKeyword" === i || "TSSymbolKeyword" === i || "TSUndefinedKeyword" === i || "TSUnknownKeyword" === i || "TSVoidKeyword" === i || "TSThisType" === i || "TSFunctionType" === i || "TSConstructorType" === i || "TSTypeReference" === i || "TSTypePredicate" === i || "TSTypeQuery" === i || "TSTypeLiteral" === i || "TSArrayType" === i || "TSTupleType" === i || "TSOptionalType" === i || "TSRestType" === i || "TSUnionType" === i || "TSIntersectionType" === i || "TSConditionalType" === i || "TSInferType" === i || "TSParenthesizedType" === i || "TSTypeOperator" === i || "TSIndexedAccessType" === i || "TSMappedType" === i || "TSLiteralType" === i || "TSExpressionWithTypeArguments" === i || "TSImportType" === i)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSBaseType = function isTSBaseType(t, r) {
            if (!t)
                return !1;
            var i = t.type;
            if ("TSAnyKeyword" === i || "TSBooleanKeyword" === i || "TSBigIntKeyword" === i || "TSIntrinsicKeyword" === i || "TSNeverKeyword" === i || "TSNullKeyword" === i || "TSNumberKeyword" === i || "TSObjectKeyword" === i || "TSStringKeyword" === i || "TSSymbolKeyword" === i || "TSUndefinedKeyword" === i || "TSUnknownKeyword" === i || "TSVoidKeyword" === i || "TSThisType" === i || "TSLiteralType" === i)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isNumberLiteral = function isNumberLiteral(t, r) {
            if (console.trace("The node type NumberLiteral has been renamed to NumericLiteral"),
            !t)
                return !1;
            if ("NumberLiteral" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isRegexLiteral = function isRegexLiteral(t, r) {
            if (console.trace("The node type RegexLiteral has been renamed to RegExpLiteral"),
            !t)
                return !1;
            if ("RegexLiteral" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isRestProperty = function isRestProperty(t, r) {
            if (console.trace("The node type RestProperty has been renamed to RestElement"),
            !t)
                return !1;
            if ("RestProperty" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isSpreadProperty = function isSpreadProperty(t, r) {
            if (console.trace("The node type SpreadProperty has been renamed to SpreadElement"),
            !t)
                return !1;
            if ("SpreadProperty" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ;
        var a = i("0Cqy")
    },
    FjNa: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function cleanJSXElementLiteralChild(t, r) {
            const i = t.value.split(/\r\n|\n|\r/);
            let o = 0;
            for (let t = 0; t < i.length; t++)
                i[t].match(/[^ \t]/) && (o = t);
            let l = "";
            for (let t = 0; t < i.length; t++) {
                const r = i[t]
                  , a = 0 === t
                  , u = t === i.length - 1
                  , p = t === o;
                let c = r.replace(/\t/g, " ");
                a || (c = c.replace(/^[ ]+/, "")),
                u || (c = c.replace(/[ ]+$/, "")),
                c && (p || (c += " "),
                l += c)
            }
            l && r.push((0,
            a.stringLiteral)(l))
        }
        ;
        var a = i("61uC")
    },
    GGH7: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        });
        class Position {
            constructor(t, r, i) {
                this.line = void 0,
                this.column = void 0,
                this.index = void 0,
                this.line = t,
                this.column = r,
                a.set(this, i)
            }
        }
        class SourceLocation {
            constructor(t, r) {
                this.start = void 0,
                this.end = void 0,
                this.filename = void 0,
                this.identifierName = void 0,
                this.start = t,
                this.end = r
            }
        }
        const a = new WeakMap;
        function createPositionWithColumnOffset(t, r) {
            const {line: i, column: o} = t;
            return new Position(i,o + r,a.get(t) + r)
        }
        function setTrailingComments(t, r) {
            void 0 === t.trailingComments ? t.trailingComments = r : t.trailingComments.unshift(...r)
        }
        function setInnerComments(t, r) {
            void 0 === t.innerComments ? t.innerComments = r : t.innerComments.unshift(...r)
        }
        function adjustInnerComments(t, r, i) {
            let a = null
              , o = r.length;
            for (; null === a && o > 0; )
                a = r[--o];
            null === a || a.start > i.start ? setInnerComments(t, i.comments) : setTrailingComments(a, i.comments)
        }
        const o = Object.freeze({
            SyntaxError: "BABEL_PARSER_SYNTAX_ERROR",
            SourceTypeModuleError: "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED"
        })
          , l = makeErrorTemplates({
            AccessorIsGenerator: "A %0ter cannot be a generator.",
            ArgumentsInClass: "'arguments' is only allowed in functions and class methods.",
            AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block.",
            AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.",
            AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.",
            AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.",
            AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.",
            AwaitNotInAsyncFunction: "'await' is only allowed within async functions.",
            BadGetterArity: "A 'get' accesor must not have any formal parameters.",
            BadSetterArity: "A 'set' accesor must have exactly one formal parameter.",
            BadSetterRestParameter: "A 'set' accesor function argument must not be a rest parameter.",
            ConstructorClassField: "Classes may not have a field named 'constructor'.",
            ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.",
            ConstructorIsAccessor: "Class constructor may not be an accessor.",
            ConstructorIsAsync: "Constructor can't be an async function.",
            ConstructorIsGenerator: "Constructor can't be a generator.",
            DeclarationMissingInitializer: "'%0' require an initialization value.",
            DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. You can set the 'decoratorsBeforeExport' option to false to use the 'export @decorator class {}' syntax.",
            DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?",
            DecoratorExportClass: "Using the export keyword between a decorator and a class is not allowed. Please use `export @dec class` instead.",
            DecoratorSemicolon: "Decorators must not be followed by a semicolon.",
            DecoratorStaticBlock: "Decorators can't be used with a static block.",
            DeletePrivateField: "Deleting a private field is not allowed.",
            DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.",
            DuplicateConstructor: "Duplicate constructor in the same class.",
            DuplicateDefaultExport: "Only one default export allowed per module.",
            DuplicateExport: "`%0` has already been exported. Exported identifiers must be unique.",
            DuplicateProto: "Redefinition of __proto__ property.",
            DuplicateRegExpFlags: "Duplicate regular expression flag.",
            ElementAfterRest: "Rest element must be last element.",
            EscapedCharNotAnIdentifier: "Invalid Unicode escape.",
            ExportBindingIsString: "A string literal cannot be used as an exported binding without `from`.\n- Did you mean `export { '%0' as '%1' } from 'some-module'`?",
            ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.",
            ForInOfLoopInitializer: "'%0' loop variable declaration may not have an initializer.",
            ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.",
            ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.",
            GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block.",
            IllegalBreakContinue: "Unsyntactic %0.",
            IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.",
            IllegalReturn: "'return' outside of function.",
            ImportBindingIsString: 'A string literal cannot be used as an imported binding.\n- Did you mean `import { "%0" as foo }`?',
            ImportCallArgumentTrailingComma: "Trailing comma is disallowed inside import(...) arguments.",
            ImportCallArity: "`import()` requires exactly %0.",
            ImportCallNotNewExpression: "Cannot use new with import(...).",
            ImportCallSpreadArgument: "`...` is not allowed in `import()`.",
            InvalidBigIntLiteral: "Invalid BigIntLiteral.",
            InvalidCodePoint: "Code point out of bounds.",
            InvalidCoverInitializedName: "Invalid shorthand property initializer.",
            InvalidDecimal: "Invalid decimal.",
            InvalidDigit: "Expected number in radix %0.",
            InvalidEscapeSequence: "Bad character escape sequence.",
            InvalidEscapeSequenceTemplate: "Invalid escape sequence in template.",
            InvalidEscapedReservedWord: "Escape sequence in keyword %0.",
            InvalidIdentifier: "Invalid identifier %0.",
            InvalidLhs: "Invalid left-hand side in %0.",
            InvalidLhsBinding: "Binding invalid left-hand side in %0.",
            InvalidNumber: "Invalid number.",
            InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.",
            InvalidOrUnexpectedToken: "Unexpected character '%0'.",
            InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern.",
            InvalidPrivateFieldResolution: "Private name #%0 is not defined.",
            InvalidPropertyBindingPattern: "Binding member expression.",
            InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions.",
            InvalidRestAssignmentPattern: "Invalid rest operator's argument.",
            LabelRedeclaration: "Label '%0' is already declared.",
            LetInLexicalBinding: "'let' is not allowed to be used as a name in 'let' or 'const' declarations.",
            LineTerminatorBeforeArrow: "No line break is allowed before '=>'.",
            MalformedRegExpFlags: "Invalid regular expression flag.",
            MissingClassName: "A class name is required.",
            MissingEqInAssignment: "Only '=' operator can be used for specifying default value.",
            MissingSemicolon: "Missing semicolon.",
            MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX.",
            MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators.",
            ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`.",
            ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values.",
            ModuleAttributesWithDuplicateKeys: 'Duplicate key "%0" is not allowed in module attributes.',
            ModuleExportNameHasLoneSurrogate: "An export name cannot include a lone surrogate, found '\\u%0'.",
            ModuleExportUndefined: "Export '%0' is not defined.",
            MultipleDefaultsInSwitch: "Multiple default clauses.",
            NewlineAfterThrow: "Illegal newline after throw.",
            NoCatchOrFinally: "Missing catch or finally clause.",
            NumberIdentifier: "Identifier directly after number.",
            NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.",
            ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.",
            OptionalChainingNoNew: "Constructors in/after an Optional Chain are not allowed.",
            OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain.",
            OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.",
            ParamDupe: "Argument name clash.",
            PatternHasAccessor: "Object pattern can't contain getter or setter.",
            PatternHasMethod: "Object pattern can't contain methods.",
            PipeBodyIsTighter: "Unexpected %0 after pipeline body; any %0 expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.",
            PipeTopicRequiresHackPipes: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.',
            PipeTopicUnbound: "Topic reference is unbound; it must be inside a pipe body.",
            PipeTopicUnconfiguredToken: 'Invalid topic token %0. In order to use %0 as a topic reference, the pipelineOperator plugin must be configured with { "proposal": "hack", "topicToken": "%0" }.',
            PipeTopicUnused: "Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.",
            PipeUnparenthesizedBody: "Hack-style pipe body cannot be an unparenthesized %0 expression; please wrap it in parentheses.",
            PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.',
            PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression.",
            PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression.",
            PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference.",
            PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding.",
            PrimaryTopicRequiresSmartPipeline: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.',
            PrivateInExpectedIn: "Private names are only allowed in property accesses (`obj.#%0`) or in `in` expressions (`#%0 in obj`).",
            PrivateNameRedeclaration: "Duplicate private name #%0.",
            RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
            RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
            RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
            RecordNoProto: "'__proto__' is not allowed in Record expressions.",
            RestTrailingComma: "Unexpected trailing comma after rest element.",
            SloppyFunction: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.",
            StaticPrototype: "Classes may not have static property named prototype.",
            StrictDelete: "Deleting local variable in strict mode.",
            StrictEvalArguments: "Assigning to '%0' in strict mode.",
            StrictEvalArgumentsBinding: "Binding '%0' in strict mode.",
            StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block.",
            StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.",
            StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode.",
            StrictWith: "'with' in strict mode.",
            SuperNotAllowed: "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?",
            SuperPrivateField: "Private fields can't be accessed on super.",
            TrailingDecorator: "Decorators must be attached to a class element.",
            TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
            TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
            TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
            UnexpectedArgumentPlaceholder: "Unexpected argument placeholder.",
            UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.',
            UnexpectedDigitAfterHash: "Unexpected digit after hash token.",
            UnexpectedImportExport: "'import' and 'export' may only appear at the top level.",
            UnexpectedKeyword: "Unexpected keyword '%0'.",
            UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.",
            UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context.",
            UnexpectedNewTarget: "`new.target` can only be used in functions or class properties.",
            UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits.",
            UnexpectedPrivateField: "Unexpected private name.",
            UnexpectedReservedWord: "Unexpected reserved word '%0'.",
            UnexpectedSuper: "'super' is only allowed in object methods and classes.",
            UnexpectedToken: "Unexpected token '%0'.",
            UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.",
            UnsupportedBind: "Binding should be performed on object property.",
            UnsupportedDecoratorExport: "A decorated export must export a class declaration.",
            UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.",
            UnsupportedImport: "`import` can only be used in `import()` or `import.meta`.",
            UnsupportedMetaProperty: "The only valid meta property for %0 is %0.%1.",
            UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters.",
            UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties.",
            UnsupportedSuper: "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).",
            UnterminatedComment: "Unterminated comment.",
            UnterminatedRegExp: "Unterminated regular expression.",
            UnterminatedString: "Unterminated string constant.",
            UnterminatedTemplate: "Unterminated template.",
            VarRedeclaration: "Identifier '%0' has already been declared.",
            YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.",
            YieldInParameter: "Yield expression is not allowed in formal parameters.",
            ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0."
        }, o.SyntaxError)
          , u = makeErrorTemplates({
            ImportMetaOutsideModule: "import.meta may appear only with 'sourceType: \"module\"'",
            ImportOutsideModule: "'import' and 'export' may appear only with 'sourceType: \"module\"'"
        }, o.SourceTypeModuleError);
        function keepReasonCodeCompat(t, r) {
            return "flow" === r && "PatternIsOptional" === t ? "OptionalBindingPattern" : t
        }
        function makeErrorTemplates(t, r, i) {
            const a = {};
            return Object.keys(t).forEach(o=>{
                a[o] = Object.freeze({
                    code: r,
                    reasonCode: keepReasonCodeCompat(o, i),
                    template: t[o]
                })
            }
            ),
            Object.freeze(a)
        }
        class TokContext {
            constructor(t, r) {
                this.token = void 0,
                this.preserveSpace = void 0,
                this.token = t,
                this.preserveSpace = !!r
            }
        }
        const p = {
            brace: new TokContext("{"),
            j_oTag: new TokContext("<tag"),
            j_cTag: new TokContext("</tag"),
            j_expr: new TokContext("<tag>...</tag>",!0)
        };
        p.template = new TokContext("`",!0);
        class ExportedTokenType {
            constructor(t, r={}) {
                this.label = void 0,
                this.keyword = void 0,
                this.beforeExpr = void 0,
                this.startsExpr = void 0,
                this.rightAssociative = void 0,
                this.isLoop = void 0,
                this.isAssign = void 0,
                this.prefix = void 0,
                this.postfix = void 0,
                this.binop = void 0,
                this.label = t,
                this.keyword = r.keyword,
                this.beforeExpr = !!r.beforeExpr,
                this.startsExpr = !!r.startsExpr,
                this.rightAssociative = !!r.rightAssociative,
                this.isLoop = !!r.isLoop,
                this.isAssign = !!r.isAssign,
                this.prefix = !!r.prefix,
                this.postfix = !!r.postfix,
                this.binop = null != r.binop ? r.binop : null,
                this.updateContext = null
            }
        }
        const c = new Map;
        function createKeyword(t, r={}) {
            r.keyword = t;
            const i = createToken(t, r);
            return c.set(t, i),
            i
        }
        function createBinop(t, r) {
            return createToken(t, {
                beforeExpr: !0,
                binop: r
            })
        }
        let d = -1;
        const y = []
          , h = []
          , m = []
          , T = []
          , S = []
          , g = [];
        function createToken(t, r={}) {
            var i, a, o, l;
            return ++d,
            h.push(t),
            m.push(null != (i = r.binop) ? i : -1),
            T.push(null != (a = r.beforeExpr) && a),
            S.push(null != (o = r.startsExpr) && o),
            g.push(null != (l = r.prefix) && l),
            y.push(new ExportedTokenType(t,r)),
            d
        }
        function createKeywordLike(t, r={}) {
            var i, a, o, l;
            return ++d,
            c.set(t, d),
            h.push(t),
            m.push(null != (i = r.binop) ? i : -1),
            T.push(null != (a = r.beforeExpr) && a),
            S.push(null != (o = r.startsExpr) && o),
            g.push(null != (l = r.prefix) && l),
            y.push(new ExportedTokenType("name",r)),
            d
        }
        const b = {
            bracketL: createToken("[", {
                beforeExpr: !0,
                startsExpr: !0
            }),
            bracketHashL: createToken("#[", {
                beforeExpr: !0,
                startsExpr: !0
            }),
            bracketBarL: createToken("[|", {
                beforeExpr: !0,
                startsExpr: !0
            }),
            bracketR: createToken("]"),
            bracketBarR: createToken("|]"),
            braceL: createToken("{", {
                beforeExpr: !0,
                startsExpr: !0
            }),
            braceBarL: createToken("{|", {
                beforeExpr: !0,
                startsExpr: !0
            }),
            braceHashL: createToken("#{", {
                beforeExpr: !0,
                startsExpr: !0
            }),
            braceR: createToken("}", {
                beforeExpr: !0
            }),
            braceBarR: createToken("|}"),
            parenL: createToken("(", {
                beforeExpr: !0,
                startsExpr: !0
            }),
            parenR: createToken(")"),
            comma: createToken(",", {
                beforeExpr: !0
            }),
            semi: createToken(";", {
                beforeExpr: !0
            }),
            colon: createToken(":", {
                beforeExpr: !0
            }),
            doubleColon: createToken("::", {
                beforeExpr: !0
            }),
            dot: createToken("."),
            question: createToken("?", {
                beforeExpr: !0
            }),
            questionDot: createToken("?."),
            arrow: createToken("=>", {
                beforeExpr: !0
            }),
            template: createToken("template"),
            ellipsis: createToken("...", {
                beforeExpr: !0
            }),
            backQuote: createToken("`", {
                startsExpr: !0
            }),
            dollarBraceL: createToken("${", {
                beforeExpr: !0,
                startsExpr: !0
            }),
            templateTail: createToken("...`", {
                startsExpr: !0
            }),
            templateNonTail: createToken("...${", {
                beforeExpr: !0,
                startsExpr: !0
            }),
            at: createToken("@"),
            hash: createToken("#", {
                startsExpr: !0
            }),
            interpreterDirective: createToken("#!..."),
            eq: createToken("=", {
                beforeExpr: !0,
                isAssign: !0
            }),
            assign: createToken("_=", {
                beforeExpr: !0,
                isAssign: !0
            }),
            slashAssign: createToken("_=", {
                beforeExpr: !0,
                isAssign: !0
            }),
            xorAssign: createToken("_=", {
                beforeExpr: !0,
                isAssign: !0
            }),
            moduloAssign: createToken("_=", {
                beforeExpr: !0,
                isAssign: !0
            }),
            incDec: createToken("++/--", {
                prefix: !0,
                postfix: !0,
                startsExpr: !0
            }),
            bang: createToken("!", {
                beforeExpr: !0,
                prefix: !0,
                startsExpr: !0
            }),
            tilde: createToken("~", {
                beforeExpr: !0,
                prefix: !0,
                startsExpr: !0
            }),
            pipeline: createBinop("|>", 0),
            nullishCoalescing: createBinop("??", 1),
            logicalOR: createBinop("||", 1),
            logicalAND: createBinop("&&", 2),
            bitwiseOR: createBinop("|", 3),
            bitwiseXOR: createBinop("^", 4),
            bitwiseAND: createBinop("&", 5),
            equality: createBinop("==/!=/===/!==", 6),
            lt: createBinop("</>/<=/>=", 7),
            gt: createBinop("</>/<=/>=", 7),
            relational: createBinop("</>/<=/>=", 7),
            bitShift: createBinop("<</>>/>>>", 8),
            plusMin: createToken("+/-", {
                beforeExpr: !0,
                binop: 9,
                prefix: !0,
                startsExpr: !0
            }),
            modulo: createToken("%", {
                binop: 10,
                startsExpr: !0
            }),
            star: createToken("*", {
                binop: 10
            }),
            slash: createBinop("/", 10),
            exponent: createToken("**", {
                beforeExpr: !0,
                binop: 11,
                rightAssociative: !0
            }),
            _in: createKeyword("in", {
                beforeExpr: !0,
                binop: 7
            }),
            _instanceof: createKeyword("instanceof", {
                beforeExpr: !0,
                binop: 7
            }),
            _break: createKeyword("break"),
            _case: createKeyword("case", {
                beforeExpr: !0
            }),
            _catch: createKeyword("catch"),
            _continue: createKeyword("continue"),
            _debugger: createKeyword("debugger"),
            _default: createKeyword("default", {
                beforeExpr: !0
            }),
            _else: createKeyword("else", {
                beforeExpr: !0
            }),
            _finally: createKeyword("finally"),
            _function: createKeyword("function", {
                startsExpr: !0
            }),
            _if: createKeyword("if"),
            _return: createKeyword("return", {
                beforeExpr: !0
            }),
            _switch: createKeyword("switch"),
            _throw: createKeyword("throw", {
                beforeExpr: !0,
                prefix: !0,
                startsExpr: !0
            }),
            _try: createKeyword("try"),
            _var: createKeyword("var"),
            _const: createKeyword("const"),
            _with: createKeyword("with"),
            _new: createKeyword("new", {
                beforeExpr: !0,
                startsExpr: !0
            }),
            _this: createKeyword("this", {
                startsExpr: !0
            }),
            _super: createKeyword("super", {
                startsExpr: !0
            }),
            _class: createKeyword("class", {
                startsExpr: !0
            }),
            _extends: createKeyword("extends", {
                beforeExpr: !0
            }),
            _export: createKeyword("export"),
            _import: createKeyword("import", {
                startsExpr: !0
            }),
            _null: createKeyword("null", {
                startsExpr: !0
            }),
            _true: createKeyword("true", {
                startsExpr: !0
            }),
            _false: createKeyword("false", {
                startsExpr: !0
            }),
            _typeof: createKeyword("typeof", {
                beforeExpr: !0,
                prefix: !0,
                startsExpr: !0
            }),
            _void: createKeyword("void", {
                beforeExpr: !0,
                prefix: !0,
                startsExpr: !0
            }),
            _delete: createKeyword("delete", {
                beforeExpr: !0,
                prefix: !0,
                startsExpr: !0
            }),
            _do: createKeyword("do", {
                isLoop: !0,
                beforeExpr: !0
            }),
            _for: createKeyword("for", {
                isLoop: !0
            }),
            _while: createKeyword("while", {
                isLoop: !0
            }),
            _as: createKeywordLike("as", {
                startsExpr: !0
            }),
            _assert: createKeywordLike("assert", {
                startsExpr: !0
            }),
            _async: createKeywordLike("async", {
                startsExpr: !0
            }),
            _await: createKeywordLike("await", {
                startsExpr: !0
            }),
            _from: createKeywordLike("from", {
                startsExpr: !0
            }),
            _get: createKeywordLike("get", {
                startsExpr: !0
            }),
            _let: createKeywordLike("let", {
                startsExpr: !0
            }),
            _meta: createKeywordLike("meta", {
                startsExpr: !0
            }),
            _of: createKeywordLike("of", {
                startsExpr: !0
            }),
            _sent: createKeywordLike("sent", {
                startsExpr: !0
            }),
            _set: createKeywordLike("set", {
                startsExpr: !0
            }),
            _static: createKeywordLike("static", {
                startsExpr: !0
            }),
            _yield: createKeywordLike("yield", {
                startsExpr: !0
            }),
            _asserts: createKeywordLike("asserts", {
                startsExpr: !0
            }),
            _checks: createKeywordLike("checks", {
                startsExpr: !0
            }),
            _exports: createKeywordLike("exports", {
                startsExpr: !0
            }),
            _global: createKeywordLike("global", {
                startsExpr: !0
            }),
            _implements: createKeywordLike("implements", {
                startsExpr: !0
            }),
            _intrinsic: createKeywordLike("intrinsic", {
                startsExpr: !0
            }),
            _infer: createKeywordLike("infer", {
                startsExpr: !0
            }),
            _is: createKeywordLike("is", {
                startsExpr: !0
            }),
            _mixins: createKeywordLike("mixins", {
                startsExpr: !0
            }),
            _proto: createKeywordLike("proto", {
                startsExpr: !0
            }),
            _require: createKeywordLike("require", {
                startsExpr: !0
            }),
            _keyof: createKeywordLike("keyof", {
                startsExpr: !0
            }),
            _readonly: createKeywordLike("readonly", {
                startsExpr: !0
            }),
            _unique: createKeywordLike("unique", {
                startsExpr: !0
            }),
            _abstract: createKeywordLike("abstract", {
                startsExpr: !0
            }),
            _declare: createKeywordLike("declare", {
                startsExpr: !0
            }),
            _enum: createKeywordLike("enum", {
                startsExpr: !0
            }),
            _module: createKeywordLike("module", {
                startsExpr: !0
            }),
            _namespace: createKeywordLike("namespace", {
                startsExpr: !0
            }),
            _interface: createKeywordLike("interface", {
                startsExpr: !0
            }),
            _type: createKeywordLike("type", {
                startsExpr: !0
            }),
            _opaque: createKeywordLike("opaque", {
                startsExpr: !0
            }),
            name: createToken("name", {
                startsExpr: !0
            }),
            string: createToken("string", {
                startsExpr: !0
            }),
            num: createToken("num", {
                startsExpr: !0
            }),
            bigint: createToken("bigint", {
                startsExpr: !0
            }),
            decimal: createToken("decimal", {
                startsExpr: !0
            }),
            regexp: createToken("regexp", {
                startsExpr: !0
            }),
            privateName: createToken("#name", {
                startsExpr: !0
            }),
            eof: createToken("eof"),
            jsxName: createToken("jsxName"),
            jsxText: createToken("jsxText", {
                beforeExpr: !0
            }),
            jsxTagStart: createToken("jsxTagStart", {
                startsExpr: !0
            }),
            jsxTagEnd: createToken("jsxTagEnd"),
            placeholder: createToken("%%", {
                startsExpr: !0
            })
        };
        function tokenIsIdentifier(t) {
            return t >= 89 && t <= 124
        }
        function tokenIsKeywordOrIdentifier(t) {
            return t >= 54 && t <= 124
        }
        function tokenIsLiteralPropertyName(t) {
            return t >= 54 && t <= 128
        }
        function tokenCanStartExpression(t) {
            return S[t]
        }
        function tokenIsFlowInterfaceOrTypeOrOpaque(t) {
            return t >= 121 && t <= 123
        }
        function tokenIsKeyword(t) {
            return t >= 54 && t <= 88
        }
        function tokenLabelName(t) {
            return h[t]
        }
        function tokenOperatorPrecedence(t) {
            return m[t]
        }
        function tokenIsTemplate(t) {
            return t >= 24 && t <= 25
        }
        function getExportedToken(t) {
            return y[t]
        }
        y[8].updateContext = t=>{
            t.pop()
        }
        ,
        y[5].updateContext = y[7].updateContext = y[23].updateContext = t=>{
            t.push(p.brace)
        }
        ,
        y[22].updateContext = t=>{
            t[t.length - 1] === p.template ? t.pop() : t.push(p.template)
        }
        ,
        y[134].updateContext = t=>{
            t.push(p.j_expr, p.j_oTag)
        }
        ;
        let v = "ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࡰ-ࢇࢉ-ࢎࢠ-ࣉऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౝౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೝೞೠೡೱೲഄ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜑᜟ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭌᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲈᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳳᳵᳶᳺᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆿㇰ-ㇿ㐀-䶿一-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꟊꟐꟑꟓꟕ-ꟙꟲ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭩꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ"
          , E = "‌‍·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛࢘-࢟࣊-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍୕-ୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఄ఼ా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ඁ-ඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ຼ່-ໍ໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜕ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠏-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᪿ-ᫎᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭᳴᳷-᳹᷀-᷿‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧ꠬ꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱ꣿ-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿";
        const P = new RegExp("[" + v + "]")
          , x = new RegExp("[" + v + E + "]");
        v = E = null;
        const A = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 190, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1070, 4050, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 46, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 482, 44, 11, 6, 17, 0, 322, 29, 19, 43, 1269, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4152, 8, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938]
          , O = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 154, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 357, 0, 62, 13, 1495, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
        function isInAstralSet(t, r) {
            let i = 65536;
            for (let a = 0, o = r.length; a < o; a += 2) {
                if (i += r[a],
                i > t)
                    return !1;
                if (i += r[a + 1],
                i >= t)
                    return !0
            }
            return !1
        }
        function isIdentifierStart(t) {
            return t < 65 ? 36 === t : t <= 90 || (t < 97 ? 95 === t : t <= 122 || (t <= 65535 ? t >= 170 && P.test(String.fromCharCode(t)) : isInAstralSet(t, A)))
        }
        function isIdentifierChar(t) {
            return t < 48 ? 36 === t : t < 58 || !(t < 65) && (t <= 90 || (t < 97 ? 95 === t : t <= 122 || (t <= 65535 ? t >= 170 && x.test(String.fromCharCode(t)) : isInAstralSet(t, A) || isInAstralSet(t, O))))
        }
        const I = ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"]
          , w = ["eval", "arguments"]
          , C = new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"])
          , N = new Set(I)
          , D = new Set(w);
        function isReservedWord(t, r) {
            return r && "await" === t || "enum" === t
        }
        function isStrictReservedWord(t, r) {
            return isReservedWord(t, r) || N.has(t)
        }
        function isStrictBindOnlyReservedWord(t) {
            return D.has(t)
        }
        function isStrictBindReservedWord(t, r) {
            return isStrictReservedWord(t, r) || isStrictBindOnlyReservedWord(t)
        }
        const _ = new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete", "implements", "interface", "let", "package", "private", "protected", "public", "static", "yield", "eval", "arguments", "enum", "await"]);
        class Scope {
            constructor(t) {
                this.var = new Set,
                this.lexical = new Set,
                this.functions = new Set,
                this.flags = t
            }
        }
        class ScopeHandler {
            constructor(t, r) {
                this.scopeStack = [],
                this.undefinedExports = new Map,
                this.raise = t,
                this.inModule = r
            }
            get inFunction() {
                return (2 & this.currentVarScopeFlags()) > 0
            }
            get allowSuper() {
                return (16 & this.currentThisScopeFlags()) > 0
            }
            get allowDirectSuper() {
                return (32 & this.currentThisScopeFlags()) > 0
            }
            get inClass() {
                return (64 & this.currentThisScopeFlags()) > 0
            }
            get inClassAndNotInNonArrowFunction() {
                const t = this.currentThisScopeFlags();
                return (64 & t) > 0 && 0 == (2 & t)
            }
            get inStaticBlock() {
                for (let t = this.scopeStack.length - 1; ; t--) {
                    const {flags: r} = this.scopeStack[t];
                    if (128 & r)
                        return !0;
                    if (323 & r)
                        return !1
                }
            }
            get inNonArrowFunction() {
                return (2 & this.currentThisScopeFlags()) > 0
            }
            get treatFunctionsAsVar() {
                return this.treatFunctionsAsVarInScope(this.currentScope())
            }
            createScope(t) {
                return new Scope(t)
            }
            enter(t) {
                this.scopeStack.push(this.createScope(t))
            }
            exit() {
                this.scopeStack.pop()
            }
            treatFunctionsAsVarInScope(t) {
                return !!(2 & t.flags || !this.inModule && 1 & t.flags)
            }
            declareName(t, r, i) {
                let a = this.currentScope();
                if (8 & r || 16 & r)
                    this.checkRedeclarationInScope(a, t, r, i),
                    16 & r ? a.functions.add(t) : a.lexical.add(t),
                    8 & r && this.maybeExportDefined(a, t);
                else if (4 & r)
                    for (let o = this.scopeStack.length - 1; o >= 0 && (a = this.scopeStack[o],
                    this.checkRedeclarationInScope(a, t, r, i),
                    a.var.add(t),
                    this.maybeExportDefined(a, t),
                    !(259 & a.flags)); --o)
                        ;
                this.inModule && 1 & a.flags && this.undefinedExports.delete(t)
            }
            maybeExportDefined(t, r) {
                this.inModule && 1 & t.flags && this.undefinedExports.delete(r)
            }
            checkRedeclarationInScope(t, r, i, a) {
                this.isRedeclaredInScope(t, r, i) && this.raise(l.VarRedeclaration, {
                    at: a
                }, r)
            }
            isRedeclaredInScope(t, r, i) {
                return !!(1 & i) && (8 & i ? t.lexical.has(r) || t.functions.has(r) || t.var.has(r) : 16 & i ? t.lexical.has(r) || !this.treatFunctionsAsVarInScope(t) && t.var.has(r) : t.lexical.has(r) && !(8 & t.flags && t.lexical.values().next().value === r) || !this.treatFunctionsAsVarInScope(t) && t.functions.has(r))
            }
            checkLocalExport(t) {
                const {name: r} = t
                  , i = this.scopeStack[0];
                i.lexical.has(r) || i.var.has(r) || i.functions.has(r) || this.undefinedExports.set(r, t.loc.start)
            }
            currentScope() {
                return this.scopeStack[this.scopeStack.length - 1]
            }
            currentVarScopeFlags() {
                for (let t = this.scopeStack.length - 1; ; t--) {
                    const {flags: r} = this.scopeStack[t];
                    if (259 & r)
                        return r
                }
            }
            currentThisScopeFlags() {
                for (let t = this.scopeStack.length - 1; ; t--) {
                    const {flags: r} = this.scopeStack[t];
                    if (323 & r && !(4 & r))
                        return r
                }
            }
        }
        class FlowScope extends Scope {
            constructor(...t) {
                super(...t),
                this.declareFunctions = new Set
            }
        }
        class FlowScopeHandler extends ScopeHandler {
            createScope(t) {
                return new FlowScope(t)
            }
            declareName(t, r, i) {
                const a = this.currentScope();
                if (2048 & r)
                    return this.checkRedeclarationInScope(a, t, r, i),
                    this.maybeExportDefined(a, t),
                    void a.declareFunctions.add(t);
                super.declareName(...arguments)
            }
            isRedeclaredInScope(t, r, i) {
                return !!super.isRedeclaredInScope(...arguments) || !!(2048 & i) && (!t.declareFunctions.has(r) && (t.lexical.has(r) || t.functions.has(r)))
            }
            checkLocalExport(t) {
                this.scopeStack[0].declareFunctions.has(t.name) || super.checkLocalExport(t)
            }
        }
        const L = /\r\n?|[\n\u2028\u2029]/
          , k = new RegExp(L.source,"g");
        function isNewLine(t) {
            switch (t) {
            case 10:
            case 13:
            case 8232:
            case 8233:
                return !0;
            default:
                return !1
            }
        }
        const M = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g
          , j = new RegExp("(?=(" + /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/y.source + "))\\1" + /(?=[\n\r\u2028\u2029]|\/\*(?!.*?\*\/)|$)/.source,"y");
        function isWhitespace(t) {
            switch (t) {
            case 9:
            case 11:
            case 12:
            case 32:
            case 160:
            case 5760:
            case 8192:
            case 8193:
            case 8194:
            case 8195:
            case 8196:
            case 8197:
            case 8198:
            case 8199:
            case 8200:
            case 8201:
            case 8202:
            case 8239:
            case 8287:
            case 12288:
            case 65279:
                return !0;
            default:
                return !1
            }
        }
        class State {
            constructor() {
                this.strict = void 0,
                this.curLine = void 0,
                this.lineStart = void 0,
                this.startLoc = void 0,
                this.endLoc = void 0,
                this.errors = [],
                this.potentialArrowAt = -1,
                this.noArrowAt = [],
                this.noArrowParamsConversionAt = [],
                this.maybeInArrowParameters = !1,
                this.inType = !1,
                this.noAnonFunctionType = !1,
                this.hasFlowComment = !1,
                this.isAmbientContext = !1,
                this.inAbstractClass = !1,
                this.topicContext = {
                    maxNumOfResolvableTopics: 0,
                    maxTopicIndex: null
                },
                this.soloAwait = !1,
                this.inFSharpPipelineDirectBody = !1,
                this.labels = [],
                this.decoratorStack = [[]],
                this.comments = [],
                this.commentStack = [],
                this.pos = 0,
                this.type = 131,
                this.value = null,
                this.start = 0,
                this.end = 0,
                this.lastTokEndLoc = null,
                this.lastTokStartLoc = null,
                this.lastTokStart = 0,
                this.context = [p.brace],
                this.canStartJSXElement = !0,
                this.containsEsc = !1,
                this.strictErrors = new Map,
                this.tokensLength = 0
            }
            init({strictMode: t, sourceType: r, startLine: i, startColumn: a}) {
                this.strict = !1 !== t && (!0 === t || "module" === r),
                this.curLine = i,
                this.lineStart = -a,
                this.startLoc = this.endLoc = new Position(i,a,0)
            }
            curPosition() {
                return new Position(this.curLine,this.pos - this.lineStart,this.pos)
            }
            clone(t) {
                const r = new State
                  , i = Object.keys(this);
                for (let a = 0, o = i.length; a < o; a++) {
                    const o = i[a];
                    let l = this[o];
                    !t && Array.isArray(l) && (l = l.slice()),
                    r[o] = l
                }
                return r
            }
        }
        var B = function isDigit(t) {
            return t >= 48 && t <= 57
        };
        const R = new Set([103, 109, 115, 105, 121, 117, 100])
          , K = {
            decBinOct: [46, 66, 69, 79, 95, 98, 101, 111],
            hex: [46, 88, 95, 120]
        }
          , V = {
            bin: [48, 49]
        };
        V.oct = [...V.bin, 50, 51, 52, 53, 54, 55],
        V.dec = [...V.oct, 56, 57],
        V.hex = [...V.dec, 65, 66, 67, 68, 69, 70, 97, 98, 99, 100, 101, 102];
        class Token {
            constructor(t) {
                this.type = t.type,
                this.value = t.value,
                this.start = t.start,
                this.end = t.end,
                this.loc = new SourceLocation(t.startLoc,t.endLoc)
            }
        }
        class ClassScope {
            constructor() {
                this.privateNames = new Set,
                this.loneAccessors = new Map,
                this.undefinedPrivateNames = new Map
            }
        }
        class ClassScopeHandler {
            constructor(t) {
                this.stack = [],
                this.undefinedPrivateNames = new Map,
                this.raise = t
            }
            current() {
                return this.stack[this.stack.length - 1]
            }
            enter() {
                this.stack.push(new ClassScope)
            }
            exit() {
                const t = this.stack.pop()
                  , r = this.current();
                for (const [i,a] of Array.from(t.undefinedPrivateNames))
                    r ? r.undefinedPrivateNames.has(i) || r.undefinedPrivateNames.set(i, a) : this.raise(l.InvalidPrivateFieldResolution, {
                        at: a
                    }, i)
            }
            declarePrivateName(t, r, i) {
                const {privateNames: a, loneAccessors: o, undefinedPrivateNames: u} = this.current();
                let p = a.has(t);
                if (3 & r) {
                    const i = p && o.get(t);
                    if (i) {
                        const a = 4 & i
                          , l = 4 & r;
                        p = (3 & i) === (3 & r) || a !== l,
                        p || o.delete(t)
                    } else
                        p || o.set(t, r)
                }
                p && this.raise(l.PrivateNameRedeclaration, {
                    at: i
                }, t),
                a.add(t),
                u.delete(t)
            }
            usePrivateName(t, r) {
                let i;
                for (i of this.stack)
                    if (i.privateNames.has(t))
                        return;
                i ? i.undefinedPrivateNames.set(t, r) : this.raise(l.InvalidPrivateFieldResolution, {
                    at: r
                }, t)
            }
        }
        class ExpressionScope {
            constructor(t=0) {
                this.type = void 0,
                this.type = t
            }
            canBeArrowParameterDeclaration() {
                return 2 === this.type || 1 === this.type
            }
            isCertainlyParameterDeclaration() {
                return 3 === this.type
            }
        }
        class ArrowHeadParsingScope extends ExpressionScope {
            constructor(t) {
                super(t),
                this.errors = new Map
            }
            recordDeclarationError(t, r) {
                this.errors.set(a.get(r), {
                    message: t,
                    loc: r
                })
            }
            clearDeclarationError(t) {
                this.errors.delete(a.get(t))
            }
            iterateErrors(t) {
                this.errors.forEach(t)
            }
        }
        class ExpressionScopeHandler {
            constructor(t) {
                this.stack = [new ExpressionScope],
                this.raise = t
            }
            enter(t) {
                this.stack.push(t)
            }
            exit() {
                this.stack.pop()
            }
            recordParameterInitializerError(t, r) {
                const {stack: i} = this;
                let a = i.length - 1
                  , o = i[a];
                for (; !o.isCertainlyParameterDeclaration(); ) {
                    if (!o.canBeArrowParameterDeclaration())
                        return;
                    o.recordDeclarationError(r, t),
                    o = i[--a]
                }
                this.raise(r, {
                    at: t
                })
            }
            recordParenthesizedIdentifierError(t, r) {
                const {stack: i} = this
                  , a = i[i.length - 1];
                if (a.isCertainlyParameterDeclaration())
                    this.raise(t, {
                        at: r
                    });
                else {
                    if (!a.canBeArrowParameterDeclaration())
                        return;
                    a.recordDeclarationError(t, r)
                }
            }
            recordAsyncArrowParametersError(t, r) {
                const {stack: i} = this;
                let a = i.length - 1
                  , o = i[a];
                for (; o.canBeArrowParameterDeclaration(); )
                    2 === o.type && o.recordDeclarationError(t, r),
                    o = i[--a]
            }
            validateAsPattern() {
                const {stack: t} = this
                  , r = t[t.length - 1];
                r.canBeArrowParameterDeclaration() && r.iterateErrors(({message: r, loc: i})=>{
                    this.raise(r, {
                        at: i
                    });
                    let a = t.length - 2
                      , o = t[a];
                    for (; o.canBeArrowParameterDeclaration(); )
                        o.clearDeclarationError(i),
                        o = t[--a]
                }
                )
            }
        }
        function newExpressionScope() {
            return new ExpressionScope
        }
        class ProductionParameterHandler {
            constructor() {
                this.stacks = []
            }
            enter(t) {
                this.stacks.push(t)
            }
            exit() {
                this.stacks.pop()
            }
            currentFlags() {
                return this.stacks[this.stacks.length - 1]
            }
            get hasAwait() {
                return (2 & this.currentFlags()) > 0
            }
            get hasYield() {
                return (1 & this.currentFlags()) > 0
            }
            get hasReturn() {
                return (4 & this.currentFlags()) > 0
            }
            get hasIn() {
                return (8 & this.currentFlags()) > 0
            }
        }
        function functionFlags(t, r) {
            return (t ? 2 : 0) | (r ? 1 : 0)
        }
        class ExpressionErrors {
            constructor() {
                this.shorthandAssignLoc = null,
                this.doubleProtoLoc = null,
                this.optionalParametersLoc = null
            }
        }
        class Node {
            constructor(t, r, i) {
                this.type = "",
                this.start = r,
                this.end = 0,
                this.loc = new SourceLocation(i),
                null != t && t.options.ranges && (this.range = [r, 0]),
                null != t && t.filename && (this.loc.filename = t.filename)
            }
        }
        const U = Node.prototype;
        function cloneIdentifier(t) {
            const {type: r, start: i, end: a, loc: o, range: l, extra: u, name: p} = t
              , c = Object.create(U);
            return c.type = r,
            c.start = i,
            c.end = a,
            c.loc = o,
            c.range = l,
            c.extra = u,
            c.name = p,
            "Placeholder" === r && (c.expectedNode = t.expectedNode),
            c
        }
        function cloneStringLiteral(t) {
            const {type: r, start: i, end: a, loc: o, range: l, extra: u} = t;
            if ("Placeholder" === r)
                return function clonePlaceholder(t) {
                    return cloneIdentifier(t)
                }(t);
            const p = Object.create(U);
            return p.type = r,
            p.start = i,
            p.end = a,
            p.loc = o,
            p.range = l,
            void 0 !== t.raw ? p.raw = t.raw : p.extra = u,
            p.value = t.value,
            p
        }
        U.__clone = function() {
            const t = new Node
              , r = Object.keys(this);
            for (let i = 0, a = r.length; i < a; i++) {
                const a = r[i];
                "leadingComments" !== a && "trailingComments" !== a && "innerComments" !== a && (t[a] = this[a])
            }
            return t
        }
        ;
        const Y = new Set(["_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "static", "string", "true", "typeof", "void"])
          , X = makeErrorTemplates({
            AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.",
            AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.",
            AssignReservedType: "Cannot overwrite reserved type %0.",
            DeclareClassElement: "The `declare` modifier can only appear on class fields.",
            DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.",
            DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement.",
            EnumBooleanMemberNotInitialized: "Boolean enum members need to be initialized. Use either `%0 = true,` or `%0 = false,` in enum `%1`.",
            EnumDuplicateMemberName: "Enum member names need to be unique, but the name `%0` has already been used before in enum `%1`.",
            EnumInconsistentMemberValues: "Enum `%0` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.",
            EnumInvalidExplicitType: "Enum type `%1` is not valid. Use one of `boolean`, `number`, `string`, or `symbol` in enum `%0`.",
            EnumInvalidExplicitTypeUnknownSupplied: "Supplied enum type is not valid. Use one of `boolean`, `number`, `string`, or `symbol` in enum `%0`.",
            EnumInvalidMemberInitializerPrimaryType: "Enum `%0` has type `%2`, so the initializer of `%1` needs to be a %2 literal.",
            EnumInvalidMemberInitializerSymbolType: "Symbol enum members cannot be initialized. Use `%1,` in enum `%0`.",
            EnumInvalidMemberInitializerUnknownType: "The enum member initializer for `%1` needs to be a literal (either a boolean, number, or string) in enum `%0`.",
            EnumInvalidMemberName: "Enum member names cannot start with lowercase 'a' through 'z'. Instead of using `%0`, consider using `%1`, in enum `%2`.",
            EnumNumberMemberNotInitialized: "Number enum members need to be initialized, e.g. `%1 = 1` in enum `%0`.",
            EnumStringMemberInconsistentlyInitailized: "String enum members need to consistently either all use initializers, or use no initializers, in enum `%0`.",
            GetterMayNotHaveThisParam: "A getter cannot have a `this` parameter.",
            ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.",
            InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type.",
            InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions.",
            InexactVariance: "Explicit inexact syntax cannot have variance.",
            InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`.",
            MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.",
            NestedDeclareModule: "`declare module` cannot be used inside another `declare module`.",
            NestedFlowComment: "Cannot have a flow comment inside another flow comment.",
            PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.",
            SetterMayNotHaveThisParam: "A setter cannot have a `this` parameter.",
            SpreadVariance: "Spread properties cannot have variance.",
            ThisParamAnnotationRequired: "A type annotation is required for the `this` parameter.",
            ThisParamBannedInConstructor: "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.",
            ThisParamMayNotBeOptional: "The `this` parameter cannot be optional.",
            ThisParamMustBeFirst: "The `this` parameter must be the first function parameter.",
            ThisParamNoDefault: "The `this` parameter may not have a default value.",
            TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
            TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis.",
            UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object.",
            UnexpectedReservedType: "Unexpected reserved type %0.",
            UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new.",
            UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.",
            UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions.",
            UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint".',
            UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration.",
            UnexpectedTypeParameterBeforeAsyncArrowFunction: "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.",
            UnsupportedDeclareExportKind: "`declare export %0` is not supported. Use `%1` instead.",
            UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module.",
            UnterminatedFlowComment: "Unterminated flow-comment."
        }, o.SyntaxError, "flow");
        function hasTypeImportKind(t) {
            return "type" === t.importKind || "typeof" === t.importKind
        }
        function isMaybeDefaultImport(t) {
            return tokenIsKeywordOrIdentifier(t) && 93 !== t
        }
        const J = {
            const: "declare export var",
            let: "declare export var",
            type: "export type",
            interface: "export interface"
        };
        const W = /\*?\s*@((?:no)?flow)\b/;
        const q = {
            quot: '"',
            amp: "&",
            apos: "'",
            lt: "<",
            gt: ">",
            nbsp: " ",
            iexcl: "¡",
            cent: "¢",
            pound: "£",
            curren: "¤",
            yen: "¥",
            brvbar: "¦",
            sect: "§",
            uml: "¨",
            copy: "©",
            ordf: "ª",
            laquo: "«",
            not: "¬",
            shy: "­",
            reg: "®",
            macr: "¯",
            deg: "°",
            plusmn: "±",
            sup2: "²",
            sup3: "³",
            acute: "´",
            micro: "µ",
            para: "¶",
            middot: "·",
            cedil: "¸",
            sup1: "¹",
            ordm: "º",
            raquo: "»",
            frac14: "¼",
            frac12: "½",
            frac34: "¾",
            iquest: "¿",
            Agrave: "À",
            Aacute: "Á",
            Acirc: "Â",
            Atilde: "Ã",
            Auml: "Ä",
            Aring: "Å",
            AElig: "Æ",
            Ccedil: "Ç",
            Egrave: "È",
            Eacute: "É",
            Ecirc: "Ê",
            Euml: "Ë",
            Igrave: "Ì",
            Iacute: "Í",
            Icirc: "Î",
            Iuml: "Ï",
            ETH: "Ð",
            Ntilde: "Ñ",
            Ograve: "Ò",
            Oacute: "Ó",
            Ocirc: "Ô",
            Otilde: "Õ",
            Ouml: "Ö",
            times: "×",
            Oslash: "Ø",
            Ugrave: "Ù",
            Uacute: "Ú",
            Ucirc: "Û",
            Uuml: "Ü",
            Yacute: "Ý",
            THORN: "Þ",
            szlig: "ß",
            agrave: "à",
            aacute: "á",
            acirc: "â",
            atilde: "ã",
            auml: "ä",
            aring: "å",
            aelig: "æ",
            ccedil: "ç",
            egrave: "è",
            eacute: "é",
            ecirc: "ê",
            euml: "ë",
            igrave: "ì",
            iacute: "í",
            icirc: "î",
            iuml: "ï",
            eth: "ð",
            ntilde: "ñ",
            ograve: "ò",
            oacute: "ó",
            ocirc: "ô",
            otilde: "õ",
            ouml: "ö",
            divide: "÷",
            oslash: "ø",
            ugrave: "ù",
            uacute: "ú",
            ucirc: "û",
            uuml: "ü",
            yacute: "ý",
            thorn: "þ",
            yuml: "ÿ",
            OElig: "Œ",
            oelig: "œ",
            Scaron: "Š",
            scaron: "š",
            Yuml: "Ÿ",
            fnof: "ƒ",
            circ: "ˆ",
            tilde: "˜",
            Alpha: "Α",
            Beta: "Β",
            Gamma: "Γ",
            Delta: "Δ",
            Epsilon: "Ε",
            Zeta: "Ζ",
            Eta: "Η",
            Theta: "Θ",
            Iota: "Ι",
            Kappa: "Κ",
            Lambda: "Λ",
            Mu: "Μ",
            Nu: "Ν",
            Xi: "Ξ",
            Omicron: "Ο",
            Pi: "Π",
            Rho: "Ρ",
            Sigma: "Σ",
            Tau: "Τ",
            Upsilon: "Υ",
            Phi: "Φ",
            Chi: "Χ",
            Psi: "Ψ",
            Omega: "Ω",
            alpha: "α",
            beta: "β",
            gamma: "γ",
            delta: "δ",
            epsilon: "ε",
            zeta: "ζ",
            eta: "η",
            theta: "θ",
            iota: "ι",
            kappa: "κ",
            lambda: "λ",
            mu: "μ",
            nu: "ν",
            xi: "ξ",
            omicron: "ο",
            pi: "π",
            rho: "ρ",
            sigmaf: "ς",
            sigma: "σ",
            tau: "τ",
            upsilon: "υ",
            phi: "φ",
            chi: "χ",
            psi: "ψ",
            omega: "ω",
            thetasym: "ϑ",
            upsih: "ϒ",
            piv: "ϖ",
            ensp: " ",
            emsp: " ",
            thinsp: " ",
            zwnj: "‌",
            zwj: "‍",
            lrm: "‎",
            rlm: "‏",
            ndash: "–",
            mdash: "—",
            lsquo: "‘",
            rsquo: "’",
            sbquo: "‚",
            ldquo: "“",
            rdquo: "”",
            bdquo: "„",
            dagger: "†",
            Dagger: "‡",
            bull: "•",
            hellip: "…",
            permil: "‰",
            prime: "′",
            Prime: "″",
            lsaquo: "‹",
            rsaquo: "›",
            oline: "‾",
            frasl: "⁄",
            euro: "€",
            image: "ℑ",
            weierp: "℘",
            real: "ℜ",
            trade: "™",
            alefsym: "ℵ",
            larr: "←",
            uarr: "↑",
            rarr: "→",
            darr: "↓",
            harr: "↔",
            crarr: "↵",
            lArr: "⇐",
            uArr: "⇑",
            rArr: "⇒",
            dArr: "⇓",
            hArr: "⇔",
            forall: "∀",
            part: "∂",
            exist: "∃",
            empty: "∅",
            nabla: "∇",
            isin: "∈",
            notin: "∉",
            ni: "∋",
            prod: "∏",
            sum: "∑",
            minus: "−",
            lowast: "∗",
            radic: "√",
            prop: "∝",
            infin: "∞",
            ang: "∠",
            and: "∧",
            or: "∨",
            cap: "∩",
            cup: "∪",
            int: "∫",
            there4: "∴",
            sim: "∼",
            cong: "≅",
            asymp: "≈",
            ne: "≠",
            equiv: "≡",
            le: "≤",
            ge: "≥",
            sub: "⊂",
            sup: "⊃",
            nsub: "⊄",
            sube: "⊆",
            supe: "⊇",
            oplus: "⊕",
            otimes: "⊗",
            perp: "⊥",
            sdot: "⋅",
            lceil: "⌈",
            rceil: "⌉",
            lfloor: "⌊",
            rfloor: "⌋",
            lang: "〈",
            rang: "〉",
            loz: "◊",
            spades: "♠",
            clubs: "♣",
            hearts: "♥",
            diams: "♦"
        }
          , H = /^[\da-fA-F]+$/
          , G = /^\d+$/
          , z = makeErrorTemplates({
            AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression.",
            MissingClosingTagElement: "Expected corresponding JSX closing tag for <%0>.",
            MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>.",
            UnexpectedSequenceExpression: "Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?",
            UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text.",
            UnterminatedJsxContent: "Unterminated JSX contents.",
            UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?"
        }, o.SyntaxError, "jsx");
        function isFragment(t) {
            return !!t && ("JSXOpeningFragment" === t.type || "JSXClosingFragment" === t.type)
        }
        function getQualifiedJSXName(t) {
            if ("JSXIdentifier" === t.type)
                return t.name;
            if ("JSXNamespacedName" === t.type)
                return t.namespace.name + ":" + t.name.name;
            if ("JSXMemberExpression" === t.type)
                return getQualifiedJSXName(t.object) + "." + getQualifiedJSXName(t.property);
            throw new Error("Node had unexpected type: " + t.type)
        }
        class TypeScriptScope extends Scope {
            constructor(...t) {
                super(...t),
                this.types = new Set,
                this.enums = new Set,
                this.constEnums = new Set,
                this.classes = new Set,
                this.exportOnlyBindings = new Set
            }
        }
        class TypeScriptScopeHandler extends ScopeHandler {
            createScope(t) {
                return new TypeScriptScope(t)
            }
            declareName(t, r, i) {
                const a = this.currentScope();
                if (1024 & r)
                    return this.maybeExportDefined(a, t),
                    void a.exportOnlyBindings.add(t);
                super.declareName(...arguments),
                2 & r && (1 & r || (this.checkRedeclarationInScope(a, t, r, i),
                this.maybeExportDefined(a, t)),
                a.types.add(t)),
                256 & r && a.enums.add(t),
                512 & r && a.constEnums.add(t),
                128 & r && a.classes.add(t)
            }
            isRedeclaredInScope(t, r, i) {
                if (t.enums.has(r)) {
                    if (256 & i) {
                        return !!(512 & i) !== t.constEnums.has(r)
                    }
                    return !0
                }
                return 128 & i && t.classes.has(r) ? !!t.lexical.has(r) && !!(1 & i) : !!(2 & i && t.types.has(r)) || super.isRedeclaredInScope(...arguments)
            }
            checkLocalExport(t) {
                const r = this.scopeStack[0]
                  , {name: i} = t;
                r.types.has(i) || r.exportOnlyBindings.has(i) || super.checkLocalExport(t)
            }
        }
        function assert(t) {
            if (!t)
                throw new Error("Assert fail")
        }
        const Q = makeErrorTemplates({
            AbstractMethodHasImplementation: "Method '%0' cannot have an implementation because it is marked abstract.",
            AbstractPropertyHasInitializer: "Property '%0' cannot have an initializer because it is marked abstract.",
            AccesorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.",
            AccesorCannotHaveTypeParameters: "An accessor cannot have type parameters.",
            ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.",
            ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.",
            ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.",
            DeclareAccessor: "'declare' is not allowed in %0ters.",
            DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.",
            DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.",
            DuplicateAccessibilityModifier: "Accessibility modifier already seen.",
            DuplicateModifier: "Duplicate modifier: '%0'.",
            EmptyHeritageClauseType: "'%0' list cannot be empty.",
            EmptyTypeArguments: "Type argument list cannot be empty.",
            EmptyTypeParameters: "Type parameter list cannot be empty.",
            ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.",
            ImportAliasHasImportType: "An import alias can not use 'import type'.",
            IncompatibleModifiers: "'%0' modifier cannot be used with '%1' modifier.",
            IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.",
            IndexSignatureHasAccessibility: "Index signatures cannot have an accessibility modifier ('%0').",
            IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.",
            IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.",
            IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.",
            InvalidModifierOnTypeMember: "'%0' modifier cannot appear on a type member.",
            InvalidModifiersOrder: "'%0' modifier must precede '%1' modifier.",
            InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.",
            MissingInterfaceName: "'interface' declarations must be followed by an identifier.",
            MixedLabeledAndUnlabeledElements: "Tuple members must all have names or all not have names.",
            NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.",
            NonClassMethodPropertyHasAbstractModifer: "'abstract' modifier can only appear on a class, method, or property declaration.",
            OptionalTypeBeforeRequired: "A required element cannot follow an optional element.",
            OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.",
            PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.",
            PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.",
            PrivateElementHasAccessibility: "Private elements cannot have an accessibility modifier ('%0').",
            ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.",
            ReservedArrowTypeParam: "This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.",
            ReservedTypeAssertion: "This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.",
            SetAccesorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.",
            SetAccesorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.",
            SetAccesorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.",
            StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.",
            TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
            TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.",
            TypeModifierIsUsedInTypeExports: "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.",
            TypeModifierIsUsedInTypeImports: "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.",
            UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.",
            UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.",
            UnexpectedTypeAnnotation: "Did not expect a type annotation here.",
            UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.",
            UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.",
            UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.",
            UnsupportedSignatureParameterKind: "Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got %0."
        }, o.SyntaxError, "typescript");
        function tsIsAccessModifier(t) {
            return "private" === t || "public" === t || "protected" === t
        }
        const $ = makeErrorTemplates({
            ClassNameIsRequired: "A class name is required."
        }, o.SyntaxError, "placeholders");
        function hasPlugin(t, r) {
            const [i,a] = "string" == typeof r ? [r, {}] : r
              , o = Object.keys(a)
              , l = 0 === o.length;
            return t.some(t=>{
                if ("string" == typeof t)
                    return l && t === i;
                {
                    const [r,l] = t;
                    if (r !== i)
                        return !1;
                    for (const t of o)
                        if (l[t] !== a[t])
                            return !1;
                    return !0
                }
            }
            )
        }
        function getPluginOption(t, r, i) {
            const a = t.find(t=>Array.isArray(t) ? t[0] === r : t === r);
            return a && Array.isArray(a) ? a[1][i] : null
        }
        const Z = ["minimal", "fsharp", "hack", "smart"]
          , ee = ["^", "%", "#"]
          , te = ["hash", "bar"];
        const re = {
            estree: t=>class extends t {
                parseRegExpLiteral({pattern: t, flags: r}) {
                    let i = null;
                    try {
                        i = new RegExp(t,r)
                    } catch (t) {}
                    const a = this.estreeParseLiteral(i);
                    return a.regex = {
                        pattern: t,
                        flags: r
                    },
                    a
                }
                parseBigIntLiteral(t) {
                    let r;
                    try {
                        r = BigInt(t)
                    } catch (t) {
                        r = null
                    }
                    const i = this.estreeParseLiteral(r);
                    return i.bigint = String(i.value || t),
                    i
                }
                parseDecimalLiteral(t) {
                    const r = this.estreeParseLiteral(null);
                    return r.decimal = String(r.value || t),
                    r
                }
                estreeParseLiteral(t) {
                    return this.parseLiteral(t, "Literal")
                }
                parseStringLiteral(t) {
                    return this.estreeParseLiteral(t)
                }
                parseNumericLiteral(t) {
                    return this.estreeParseLiteral(t)
                }
                parseNullLiteral() {
                    return this.estreeParseLiteral(null)
                }
                parseBooleanLiteral(t) {
                    return this.estreeParseLiteral(t)
                }
                directiveToStmt(t) {
                    const r = t.value
                      , i = this.startNodeAt(t.start, t.loc.start)
                      , a = this.startNodeAt(r.start, r.loc.start);
                    return a.value = r.extra.expressionValue,
                    a.raw = r.extra.raw,
                    i.expression = this.finishNodeAt(a, "Literal", r.loc.end),
                    i.directive = r.extra.raw.slice(1, -1),
                    this.finishNodeAt(i, "ExpressionStatement", t.loc.end)
                }
                initFunction(t, r) {
                    super.initFunction(t, r),
                    t.expression = !1
                }
                checkDeclaration(t) {
                    null != t && this.isObjectProperty(t) ? this.checkDeclaration(t.value) : super.checkDeclaration(t)
                }
                getObjectOrClassMethodParams(t) {
                    return t.value.params
                }
                isValidDirective(t) {
                    var r;
                    return "ExpressionStatement" === t.type && "Literal" === t.expression.type && "string" == typeof t.expression.value && !(null != (r = t.expression.extra) && r.parenthesized)
                }
                parseBlockBody(t, ...r) {
                    super.parseBlockBody(t, ...r);
                    const i = t.directives.map(t=>this.directiveToStmt(t));
                    t.body = i.concat(t.body),
                    delete t.directives
                }
                pushClassMethod(t, r, i, a, o, l) {
                    this.parseMethod(r, i, a, o, l, "ClassMethod", !0),
                    r.typeParameters && (r.value.typeParameters = r.typeParameters,
                    delete r.typeParameters),
                    t.body.push(r)
                }
                parsePrivateName() {
                    const t = super.parsePrivateName();
                    return this.getPluginOption("estree", "classFeatures") ? this.convertPrivateNameToPrivateIdentifier(t) : t
                }
                convertPrivateNameToPrivateIdentifier(t) {
                    const r = super.getPrivateNameSV(t);
                    return delete (t = t).id,
                    t.name = r,
                    t.type = "PrivateIdentifier",
                    t
                }
                isPrivateName(t) {
                    return this.getPluginOption("estree", "classFeatures") ? "PrivateIdentifier" === t.type : super.isPrivateName(t)
                }
                getPrivateNameSV(t) {
                    return this.getPluginOption("estree", "classFeatures") ? t.name : super.getPrivateNameSV(t)
                }
                parseLiteral(t, r) {
                    const i = super.parseLiteral(t, r);
                    return i.raw = i.extra.raw,
                    delete i.extra,
                    i
                }
                parseFunctionBody(t, r, i=!1) {
                    super.parseFunctionBody(t, r, i),
                    t.expression = "BlockStatement" !== t.body.type
                }
                parseMethod(t, r, i, a, o, l, u=!1) {
                    let p = this.startNode();
                    return p.kind = t.kind,
                    p = super.parseMethod(p, r, i, a, o, l, u),
                    p.type = "FunctionExpression",
                    delete p.kind,
                    t.value = p,
                    "ClassPrivateMethod" === l && (t.computed = !1),
                    l = "MethodDefinition",
                    this.finishNode(t, l)
                }
                parseClassProperty(...t) {
                    const r = super.parseClassProperty(...t);
                    return this.getPluginOption("estree", "classFeatures") ? (r.type = "PropertyDefinition",
                    r) : r
                }
                parseClassPrivateProperty(...t) {
                    const r = super.parseClassPrivateProperty(...t);
                    return this.getPluginOption("estree", "classFeatures") ? (r.type = "PropertyDefinition",
                    r.computed = !1,
                    r) : r
                }
                parseObjectMethod(t, r, i, a, o) {
                    const l = super.parseObjectMethod(t, r, i, a, o);
                    return l && (l.type = "Property",
                    "method" === l.kind && (l.kind = "init"),
                    l.shorthand = !1),
                    l
                }
                parseObjectProperty(t, r, i, a, o) {
                    const l = super.parseObjectProperty(t, r, i, a, o);
                    return l && (l.kind = "init",
                    l.type = "Property"),
                    l
                }
                isAssignable(t, r) {
                    return null != t && this.isObjectProperty(t) ? this.isAssignable(t.value, r) : super.isAssignable(t, r)
                }
                toAssignable(t, r=!1) {
                    return null != t && this.isObjectProperty(t) ? (this.toAssignable(t.value, r),
                    t) : super.toAssignable(t, r)
                }
                toAssignableObjectExpressionProp(t, ...r) {
                    "get" === t.kind || "set" === t.kind ? this.raise(l.PatternHasAccessor, {
                        node: t.key
                    }) : t.method ? this.raise(l.PatternHasMethod, {
                        node: t.key
                    }) : super.toAssignableObjectExpressionProp(t, ...r)
                }
                finishCallExpression(t, r) {
                    if (super.finishCallExpression(t, r),
                    "Import" === t.callee.type) {
                        var i;
                        if (t.type = "ImportExpression",
                        t.source = t.arguments[0],
                        this.hasPlugin("importAssertions"))
                            t.attributes = null != (i = t.arguments[1]) ? i : null;
                        delete t.arguments,
                        delete t.callee
                    }
                    return t
                }
                toReferencedArguments(t) {
                    "ImportExpression" !== t.type && super.toReferencedArguments(t)
                }
                parseExport(t) {
                    switch (super.parseExport(t),
                    t.type) {
                    case "ExportAllDeclaration":
                        t.exported = null;
                        break;
                    case "ExportNamedDeclaration":
                        1 === t.specifiers.length && "ExportNamespaceSpecifier" === t.specifiers[0].type && (t.type = "ExportAllDeclaration",
                        t.exported = t.specifiers[0].exported,
                        delete t.specifiers)
                    }
                    return t
                }
                parseSubscript(t, r, i, a, o) {
                    const l = super.parseSubscript(t, r, i, a, o);
                    if (o.optionalChainMember) {
                        if ("OptionalMemberExpression" !== l.type && "OptionalCallExpression" !== l.type || (l.type = l.type.substring(8)),
                        o.stop) {
                            const t = this.startNodeAtNode(l);
                            return t.expression = l,
                            this.finishNode(t, "ChainExpression")
                        }
                    } else
                        "MemberExpression" !== l.type && "CallExpression" !== l.type || (l.optional = !1);
                    return l
                }
                hasPropertyAsPrivateName(t) {
                    return "ChainExpression" === t.type && (t = t.expression),
                    super.hasPropertyAsPrivateName(t)
                }
                isOptionalChain(t) {
                    return "ChainExpression" === t.type
                }
                isObjectProperty(t) {
                    return "Property" === t.type && "init" === t.kind && !t.method
                }
                isObjectMethod(t) {
                    return t.method || "get" === t.kind || "set" === t.kind
                }
            }
            ,
            jsx: t=>class extends t {
                jsxReadToken() {
                    let t = ""
                      , r = this.state.pos;
                    for (; ; ) {
                        if (this.state.pos >= this.length)
                            throw this.raise(z.UnterminatedJsxContent, {
                                at: this.state.startLoc
                            });
                        const i = this.input.charCodeAt(this.state.pos);
                        switch (i) {
                        case 60:
                        case 123:
                            return this.state.pos === this.state.start ? 60 === i && this.state.canStartJSXElement ? (++this.state.pos,
                            this.finishToken(134)) : super.getTokenFromCode(i) : (t += this.input.slice(r, this.state.pos),
                            this.finishToken(133, t));
                        case 38:
                            t += this.input.slice(r, this.state.pos),
                            t += this.jsxReadEntity(),
                            r = this.state.pos;
                            break;
                        case 62:
                        case 125:
                        default:
                            isNewLine(i) ? (t += this.input.slice(r, this.state.pos),
                            t += this.jsxReadNewLine(!0),
                            r = this.state.pos) : ++this.state.pos
                        }
                    }
                }
                jsxReadNewLine(t) {
                    const r = this.input.charCodeAt(this.state.pos);
                    let i;
                    return ++this.state.pos,
                    13 === r && 10 === this.input.charCodeAt(this.state.pos) ? (++this.state.pos,
                    i = t ? "\n" : "\r\n") : i = String.fromCharCode(r),
                    ++this.state.curLine,
                    this.state.lineStart = this.state.pos,
                    i
                }
                jsxReadString(t) {
                    let r = ""
                      , i = ++this.state.pos;
                    for (; ; ) {
                        if (this.state.pos >= this.length)
                            throw this.raise(l.UnterminatedString, {
                                at: this.state.startLoc
                            });
                        const a = this.input.charCodeAt(this.state.pos);
                        if (a === t)
                            break;
                        38 === a ? (r += this.input.slice(i, this.state.pos),
                        r += this.jsxReadEntity(),
                        i = this.state.pos) : isNewLine(a) ? (r += this.input.slice(i, this.state.pos),
                        r += this.jsxReadNewLine(!1),
                        i = this.state.pos) : ++this.state.pos
                    }
                    return r += this.input.slice(i, this.state.pos++),
                    this.finishToken(125, r)
                }
                jsxReadEntity() {
                    let t, r = "", i = 0, a = this.input[this.state.pos];
                    const o = ++this.state.pos;
                    for (; this.state.pos < this.length && i++ < 10; ) {
                        if (a = this.input[this.state.pos++],
                        ";" === a) {
                            "#" === r[0] ? "x" === r[1] ? (r = r.substr(2),
                            H.test(r) && (t = String.fromCodePoint(parseInt(r, 16)))) : (r = r.substr(1),
                            G.test(r) && (t = String.fromCodePoint(parseInt(r, 10)))) : t = q[r];
                            break
                        }
                        r += a
                    }
                    return t || (this.state.pos = o,
                    "&")
                }
                jsxReadWord() {
                    let t;
                    const r = this.state.pos;
                    do {
                        t = this.input.charCodeAt(++this.state.pos)
                    } while (isIdentifierChar(t) || 45 === t);
                    return this.finishToken(132, this.input.slice(r, this.state.pos))
                }
                jsxParseIdentifier() {
                    const t = this.startNode();
                    return this.match(132) ? t.name = this.state.value : tokenIsKeyword(this.state.type) ? t.name = tokenLabelName(this.state.type) : this.unexpected(),
                    this.next(),
                    this.finishNode(t, "JSXIdentifier")
                }
                jsxParseNamespacedName() {
                    const t = this.state.start
                      , r = this.state.startLoc
                      , i = this.jsxParseIdentifier();
                    if (!this.eat(14))
                        return i;
                    const a = this.startNodeAt(t, r);
                    return a.namespace = i,
                    a.name = this.jsxParseIdentifier(),
                    this.finishNode(a, "JSXNamespacedName")
                }
                jsxParseElementName() {
                    const t = this.state.start
                      , r = this.state.startLoc;
                    let i = this.jsxParseNamespacedName();
                    if ("JSXNamespacedName" === i.type)
                        return i;
                    for (; this.eat(16); ) {
                        const a = this.startNodeAt(t, r);
                        a.object = i,
                        a.property = this.jsxParseIdentifier(),
                        i = this.finishNode(a, "JSXMemberExpression")
                    }
                    return i
                }
                jsxParseAttributeValue() {
                    let t;
                    switch (this.state.type) {
                    case 5:
                        return t = this.startNode(),
                        this.setContext(p.brace),
                        this.next(),
                        t = this.jsxParseExpressionContainer(t, p.j_oTag),
                        "JSXEmptyExpression" === t.expression.type && this.raise(z.AttributeIsEmpty, {
                            node: t
                        }),
                        t;
                    case 134:
                    case 125:
                        return this.parseExprAtom();
                    default:
                        throw this.raise(z.UnsupportedJsxValue, {
                            at: this.state.startLoc
                        })
                    }
                }
                jsxParseEmptyExpression() {
                    const t = this.startNodeAt(a.get(this.state.lastTokEndLoc), this.state.lastTokEndLoc);
                    return this.finishNodeAt(t, "JSXEmptyExpression", this.state.startLoc)
                }
                jsxParseSpreadChild(t) {
                    return this.next(),
                    t.expression = this.parseExpression(),
                    this.setContext(p.j_oTag),
                    this.expect(8),
                    this.finishNode(t, "JSXSpreadChild")
                }
                jsxParseExpressionContainer(t, r) {
                    if (this.match(8))
                        t.expression = this.jsxParseEmptyExpression();
                    else {
                        const r = this.parseExpression();
                        t.expression = r
                    }
                    return this.setContext(r),
                    this.expect(8),
                    this.finishNode(t, "JSXExpressionContainer")
                }
                jsxParseAttribute() {
                    const t = this.startNode();
                    return this.match(5) ? (this.setContext(p.brace),
                    this.next(),
                    this.expect(21),
                    t.argument = this.parseMaybeAssignAllowIn(),
                    this.setContext(p.j_oTag),
                    this.expect(8),
                    this.finishNode(t, "JSXSpreadAttribute")) : (t.name = this.jsxParseNamespacedName(),
                    t.value = this.eat(29) ? this.jsxParseAttributeValue() : null,
                    this.finishNode(t, "JSXAttribute"))
                }
                jsxParseOpeningElementAt(t, r) {
                    const i = this.startNodeAt(t, r);
                    return this.match(135) ? (this.expect(135),
                    this.finishNode(i, "JSXOpeningFragment")) : (i.name = this.jsxParseElementName(),
                    this.jsxParseOpeningElementAfterName(i))
                }
                jsxParseOpeningElementAfterName(t) {
                    const r = [];
                    for (; !this.match(52) && !this.match(135); )
                        r.push(this.jsxParseAttribute());
                    return t.attributes = r,
                    t.selfClosing = this.eat(52),
                    this.expect(135),
                    this.finishNode(t, "JSXOpeningElement")
                }
                jsxParseClosingElementAt(t, r) {
                    const i = this.startNodeAt(t, r);
                    return this.match(135) ? (this.expect(135),
                    this.finishNode(i, "JSXClosingFragment")) : (i.name = this.jsxParseElementName(),
                    this.expect(135),
                    this.finishNode(i, "JSXClosingElement"))
                }
                jsxParseElementAt(t, r) {
                    const i = this.startNodeAt(t, r)
                      , a = []
                      , o = this.jsxParseOpeningElementAt(t, r);
                    let l = null;
                    if (!o.selfClosing) {
                        e: for (; ; )
                            switch (this.state.type) {
                            case 134:
                                if (t = this.state.start,
                                r = this.state.startLoc,
                                this.next(),
                                this.eat(52)) {
                                    l = this.jsxParseClosingElementAt(t, r);
                                    break e
                                }
                                a.push(this.jsxParseElementAt(t, r));
                                break;
                            case 133:
                                a.push(this.parseExprAtom());
                                break;
                            case 5:
                                {
                                    const t = this.startNode();
                                    this.setContext(p.brace),
                                    this.next(),
                                    this.match(21) ? a.push(this.jsxParseSpreadChild(t)) : a.push(this.jsxParseExpressionContainer(t, p.j_expr));
                                    break
                                }
                            default:
                                throw this.unexpected()
                            }
                        isFragment(o) && !isFragment(l) && null !== l ? this.raise(z.MissingClosingTagFragment, {
                            node: l
                        }) : !isFragment(o) && isFragment(l) ? this.raise(z.MissingClosingTagElement, {
                            node: l
                        }, getQualifiedJSXName(o.name)) : isFragment(o) || isFragment(l) || getQualifiedJSXName(l.name) !== getQualifiedJSXName(o.name) && this.raise(z.MissingClosingTagElement, {
                            node: l
                        }, getQualifiedJSXName(o.name))
                    }
                    if (isFragment(o) ? (i.openingFragment = o,
                    i.closingFragment = l) : (i.openingElement = o,
                    i.closingElement = l),
                    i.children = a,
                    this.match(45))
                        throw this.raise(z.UnwrappedAdjacentJSXElements, {
                            at: this.state.startLoc
                        });
                    return isFragment(o) ? this.finishNode(i, "JSXFragment") : this.finishNode(i, "JSXElement")
                }
                jsxParseElement() {
                    const t = this.state.start
                      , r = this.state.startLoc;
                    return this.next(),
                    this.jsxParseElementAt(t, r)
                }
                setContext(t) {
                    const {context: r} = this.state;
                    r[r.length - 1] = t
                }
                parseExprAtom(t) {
                    return this.match(133) ? this.parseLiteral(this.state.value, "JSXText") : this.match(134) ? this.jsxParseElement() : this.match(45) && 33 !== this.input.charCodeAt(this.state.pos) ? (this.replaceToken(134),
                    this.jsxParseElement()) : super.parseExprAtom(t)
                }
                skipSpace() {
                    this.curContext().preserveSpace || super.skipSpace()
                }
                getTokenFromCode(t) {
                    const r = this.curContext();
                    if (r === p.j_expr)
                        return this.jsxReadToken();
                    if (r === p.j_oTag || r === p.j_cTag) {
                        if (isIdentifierStart(t))
                            return this.jsxReadWord();
                        if (62 === t)
                            return ++this.state.pos,
                            this.finishToken(135);
                        if ((34 === t || 39 === t) && r === p.j_oTag)
                            return this.jsxReadString(t)
                    }
                    return 60 === t && this.state.canStartJSXElement && 33 !== this.input.charCodeAt(this.state.pos + 1) ? (++this.state.pos,
                    this.finishToken(134)) : super.getTokenFromCode(t)
                }
                updateContext(t) {
                    const {context: r, type: i} = this.state;
                    if (52 === i && 134 === t)
                        r.splice(-2, 2, p.j_cTag),
                        this.state.canStartJSXElement = !1;
                    else if (134 === i)
                        r.push(p.j_oTag);
                    else if (135 === i) {
                        const i = r[r.length - 1];
                        i === p.j_oTag && 52 === t || i === p.j_cTag ? (r.pop(),
                        this.state.canStartJSXElement = r[r.length - 1] === p.j_expr) : (this.setContext(p.j_expr),
                        this.state.canStartJSXElement = !0)
                    } else
                        this.state.canStartJSXElement = function tokenComesBeforeExpression(t) {
                            return T[t]
                        }(i)
                }
            }
            ,
            flow: t=>class extends t {
                constructor(...t) {
                    super(...t),
                    this.flowPragma = void 0
                }
                getScopeHandler() {
                    return FlowScopeHandler
                }
                shouldParseTypes() {
                    return this.getPluginOption("flow", "all") || "flow" === this.flowPragma
                }
                shouldParseEnums() {
                    return !!this.getPluginOption("flow", "enums")
                }
                finishToken(t, r) {
                    return 125 !== t && 13 !== t && 28 !== t && void 0 === this.flowPragma && (this.flowPragma = null),
                    super.finishToken(t, r)
                }
                addComment(t) {
                    if (void 0 === this.flowPragma) {
                        const r = W.exec(t.value);
                        if (r)
                            if ("flow" === r[1])
                                this.flowPragma = "flow";
                            else {
                                if ("noflow" !== r[1])
                                    throw new Error("Unexpected flow pragma");
                                this.flowPragma = "noflow"
                            }
                        else
                            ;
                    }
                    return super.addComment(t)
                }
                flowParseTypeInitialiser(t) {
                    const r = this.state.inType;
                    this.state.inType = !0,
                    this.expect(t || 14);
                    const i = this.flowParseType();
                    return this.state.inType = r,
                    i
                }
                flowParsePredicate() {
                    const t = this.startNode()
                      , r = this.state.startLoc;
                    return this.next(),
                    this.expectContextual(103),
                    this.state.lastTokStart > a.get(r) + 1 && this.raise(X.UnexpectedSpaceBetweenModuloChecks, {
                        at: r
                    }),
                    this.eat(10) ? (t.value = this.parseExpression(),
                    this.expect(11),
                    this.finishNode(t, "DeclaredPredicate")) : this.finishNode(t, "InferredPredicate")
                }
                flowParseTypeAndPredicateInitialiser() {
                    const t = this.state.inType;
                    this.state.inType = !0,
                    this.expect(14);
                    let r = null
                      , i = null;
                    return this.match(50) ? (this.state.inType = t,
                    i = this.flowParsePredicate()) : (r = this.flowParseType(),
                    this.state.inType = t,
                    this.match(50) && (i = this.flowParsePredicate())),
                    [r, i]
                }
                flowParseDeclareClass(t) {
                    return this.next(),
                    this.flowParseInterfaceish(t, !0),
                    this.finishNode(t, "DeclareClass")
                }
                flowParseDeclareFunction(t) {
                    this.next();
                    const r = t.id = this.parseIdentifier()
                      , i = this.startNode()
                      , a = this.startNode();
                    this.match(45) ? i.typeParameters = this.flowParseTypeParameterDeclaration() : i.typeParameters = null,
                    this.expect(10);
                    const o = this.flowParseFunctionTypeParams();
                    return i.params = o.params,
                    i.rest = o.rest,
                    i.this = o._this,
                    this.expect(11),
                    [i.returnType,t.predicate] = this.flowParseTypeAndPredicateInitialiser(),
                    a.typeAnnotation = this.finishNode(i, "FunctionTypeAnnotation"),
                    r.typeAnnotation = this.finishNode(a, "TypeAnnotation"),
                    this.resetEndLocation(r),
                    this.semicolon(),
                    this.scope.declareName(t.id.name, 2048, t.id.loc.start),
                    this.finishNode(t, "DeclareFunction")
                }
                flowParseDeclare(t, r) {
                    if (this.match(76))
                        return this.flowParseDeclareClass(t);
                    if (this.match(64))
                        return this.flowParseDeclareFunction(t);
                    if (this.match(70))
                        return this.flowParseDeclareVariable(t);
                    if (this.eatContextual(119))
                        return this.match(16) ? this.flowParseDeclareModuleExports(t) : (r && this.raise(X.NestedDeclareModule, {
                            at: this.state.lastTokStartLoc
                        }),
                        this.flowParseDeclareModule(t));
                    if (this.isContextual(122))
                        return this.flowParseDeclareTypeAlias(t);
                    if (this.isContextual(123))
                        return this.flowParseDeclareOpaqueType(t);
                    if (this.isContextual(121))
                        return this.flowParseDeclareInterface(t);
                    if (this.match(78))
                        return this.flowParseDeclareExportDeclaration(t, r);
                    throw this.unexpected()
                }
                flowParseDeclareVariable(t) {
                    return this.next(),
                    t.id = this.flowParseTypeAnnotatableIdentifier(!0),
                    this.scope.declareName(t.id.name, 5, t.id.loc.start),
                    this.semicolon(),
                    this.finishNode(t, "DeclareVariable")
                }
                flowParseDeclareModule(t) {
                    this.scope.enter(0),
                    this.match(125) ? t.id = this.parseExprAtom() : t.id = this.parseIdentifier();
                    const r = t.body = this.startNode()
                      , i = r.body = [];
                    for (this.expect(5); !this.match(8); ) {
                        let t = this.startNode();
                        this.match(79) ? (this.next(),
                        this.isContextual(122) || this.match(83) || this.raise(X.InvalidNonTypeImportInDeclareModule, {
                            at: this.state.lastTokStartLoc
                        }),
                        this.parseImport(t)) : (this.expectContextual(117, X.UnsupportedStatementInDeclareModule),
                        t = this.flowParseDeclare(t, !0)),
                        i.push(t)
                    }
                    this.scope.exit(),
                    this.expect(8),
                    this.finishNode(r, "BlockStatement");
                    let a = null
                      , o = !1;
                    return i.forEach(t=>{
                        !function isEsModuleType(t) {
                            return "DeclareExportAllDeclaration" === t.type || "DeclareExportDeclaration" === t.type && (!t.declaration || "TypeAlias" !== t.declaration.type && "InterfaceDeclaration" !== t.declaration.type)
                        }(t) ? "DeclareModuleExports" === t.type && (o && this.raise(X.DuplicateDeclareModuleExports, {
                            node: t
                        }),
                        "ES" === a && this.raise(X.AmbiguousDeclareModuleKind, {
                            node: t
                        }),
                        a = "CommonJS",
                        o = !0) : ("CommonJS" === a && this.raise(X.AmbiguousDeclareModuleKind, {
                            node: t
                        }),
                        a = "ES")
                    }
                    ),
                    t.kind = a || "CommonJS",
                    this.finishNode(t, "DeclareModule")
                }
                flowParseDeclareExportDeclaration(t, r) {
                    if (this.expect(78),
                    this.eat(61))
                        return this.match(64) || this.match(76) ? t.declaration = this.flowParseDeclare(this.startNode()) : (t.declaration = this.flowParseType(),
                        this.semicolon()),
                        t.default = !0,
                        this.finishNode(t, "DeclareExportDeclaration");
                    if (this.match(71) || this.isLet() || (this.isContextual(122) || this.isContextual(121)) && !r) {
                        const t = this.state.value
                          , r = J[t];
                        throw this.raise(X.UnsupportedDeclareExportKind, {
                            at: this.state.startLoc
                        }, t, r)
                    }
                    if (this.match(70) || this.match(64) || this.match(76) || this.isContextual(123))
                        return t.declaration = this.flowParseDeclare(this.startNode()),
                        t.default = !1,
                        this.finishNode(t, "DeclareExportDeclaration");
                    if (this.match(51) || this.match(5) || this.isContextual(121) || this.isContextual(122) || this.isContextual(123))
                        return "ExportNamedDeclaration" === (t = this.parseExport(t)).type && (t.type = "ExportDeclaration",
                        t.default = !1,
                        delete t.exportKind),
                        t.type = "Declare" + t.type,
                        t;
                    throw this.unexpected()
                }
                flowParseDeclareModuleExports(t) {
                    return this.next(),
                    this.expectContextual(104),
                    t.typeAnnotation = this.flowParseTypeAnnotation(),
                    this.semicolon(),
                    this.finishNode(t, "DeclareModuleExports")
                }
                flowParseDeclareTypeAlias(t) {
                    return this.next(),
                    this.flowParseTypeAlias(t),
                    t.type = "DeclareTypeAlias",
                    t
                }
                flowParseDeclareOpaqueType(t) {
                    return this.next(),
                    this.flowParseOpaqueType(t, !0),
                    t.type = "DeclareOpaqueType",
                    t
                }
                flowParseDeclareInterface(t) {
                    return this.next(),
                    this.flowParseInterfaceish(t),
                    this.finishNode(t, "DeclareInterface")
                }
                flowParseInterfaceish(t, r=!1) {
                    if (t.id = this.flowParseRestrictedIdentifier(!r, !0),
                    this.scope.declareName(t.id.name, r ? 17 : 9, t.id.loc.start),
                    this.match(45) ? t.typeParameters = this.flowParseTypeParameterDeclaration() : t.typeParameters = null,
                    t.extends = [],
                    t.implements = [],
                    t.mixins = [],
                    this.eat(77))
                        do {
                            t.extends.push(this.flowParseInterfaceExtends())
                        } while (!r && this.eat(12));
                    if (this.isContextual(110)) {
                        this.next();
                        do {
                            t.mixins.push(this.flowParseInterfaceExtends())
                        } while (this.eat(12))
                    }
                    if (this.isContextual(106)) {
                        this.next();
                        do {
                            t.implements.push(this.flowParseInterfaceExtends())
                        } while (this.eat(12))
                    }
                    t.body = this.flowParseObjectType({
                        allowStatic: r,
                        allowExact: !1,
                        allowSpread: !1,
                        allowProto: r,
                        allowInexact: !1
                    })
                }
                flowParseInterfaceExtends() {
                    const t = this.startNode();
                    return t.id = this.flowParseQualifiedTypeIdentifier(),
                    this.match(45) ? t.typeParameters = this.flowParseTypeParameterInstantiation() : t.typeParameters = null,
                    this.finishNode(t, "InterfaceExtends")
                }
                flowParseInterface(t) {
                    return this.flowParseInterfaceish(t),
                    this.finishNode(t, "InterfaceDeclaration")
                }
                checkNotUnderscore(t) {
                    "_" === t && this.raise(X.UnexpectedReservedUnderscore, {
                        at: this.state.startLoc
                    })
                }
                checkReservedType(t, r, i) {
                    Y.has(t) && this.raise(i ? X.AssignReservedType : X.UnexpectedReservedType, {
                        at: r
                    }, t)
                }
                flowParseRestrictedIdentifier(t, r) {
                    return this.checkReservedType(this.state.value, this.state.startLoc, r),
                    this.parseIdentifier(t)
                }
                flowParseTypeAlias(t) {
                    return t.id = this.flowParseRestrictedIdentifier(!1, !0),
                    this.scope.declareName(t.id.name, 9, t.id.loc.start),
                    this.match(45) ? t.typeParameters = this.flowParseTypeParameterDeclaration() : t.typeParameters = null,
                    t.right = this.flowParseTypeInitialiser(29),
                    this.semicolon(),
                    this.finishNode(t, "TypeAlias")
                }
                flowParseOpaqueType(t, r) {
                    return this.expectContextual(122),
                    t.id = this.flowParseRestrictedIdentifier(!0, !0),
                    this.scope.declareName(t.id.name, 9, t.id.loc.start),
                    this.match(45) ? t.typeParameters = this.flowParseTypeParameterDeclaration() : t.typeParameters = null,
                    t.supertype = null,
                    this.match(14) && (t.supertype = this.flowParseTypeInitialiser(14)),
                    t.impltype = null,
                    r || (t.impltype = this.flowParseTypeInitialiser(29)),
                    this.semicolon(),
                    this.finishNode(t, "OpaqueType")
                }
                flowParseTypeParameter(t=!1) {
                    const r = this.state.startLoc
                      , i = this.startNode()
                      , a = this.flowParseVariance()
                      , o = this.flowParseTypeAnnotatableIdentifier();
                    return i.name = o.name,
                    i.variance = a,
                    i.bound = o.typeAnnotation,
                    this.match(29) ? (this.eat(29),
                    i.default = this.flowParseType()) : t && this.raise(X.MissingTypeParamDefault, {
                        at: r
                    }),
                    this.finishNode(i, "TypeParameter")
                }
                flowParseTypeParameterDeclaration() {
                    const t = this.state.inType
                      , r = this.startNode();
                    r.params = [],
                    this.state.inType = !0,
                    this.match(45) || this.match(134) ? this.next() : this.unexpected();
                    let i = !1;
                    do {
                        const t = this.flowParseTypeParameter(i);
                        r.params.push(t),
                        t.default && (i = !0),
                        this.match(46) || this.expect(12)
                    } while (!this.match(46));
                    return this.expect(46),
                    this.state.inType = t,
                    this.finishNode(r, "TypeParameterDeclaration")
                }
                flowParseTypeParameterInstantiation() {
                    const t = this.startNode()
                      , r = this.state.inType;
                    t.params = [],
                    this.state.inType = !0,
                    this.expect(45);
                    const i = this.state.noAnonFunctionType;
                    for (this.state.noAnonFunctionType = !1; !this.match(46); )
                        t.params.push(this.flowParseType()),
                        this.match(46) || this.expect(12);
                    return this.state.noAnonFunctionType = i,
                    this.expect(46),
                    this.state.inType = r,
                    this.finishNode(t, "TypeParameterInstantiation")
                }
                flowParseTypeParameterInstantiationCallOrNew() {
                    const t = this.startNode()
                      , r = this.state.inType;
                    for (t.params = [],
                    this.state.inType = !0,
                    this.expect(45); !this.match(46); )
                        t.params.push(this.flowParseTypeOrImplicitInstantiation()),
                        this.match(46) || this.expect(12);
                    return this.expect(46),
                    this.state.inType = r,
                    this.finishNode(t, "TypeParameterInstantiation")
                }
                flowParseInterfaceType() {
                    const t = this.startNode();
                    if (this.expectContextual(121),
                    t.extends = [],
                    this.eat(77))
                        do {
                            t.extends.push(this.flowParseInterfaceExtends())
                        } while (this.eat(12));
                    return t.body = this.flowParseObjectType({
                        allowStatic: !1,
                        allowExact: !1,
                        allowSpread: !1,
                        allowProto: !1,
                        allowInexact: !1
                    }),
                    this.finishNode(t, "InterfaceTypeAnnotation")
                }
                flowParseObjectPropertyKey() {
                    return this.match(126) || this.match(125) ? this.parseExprAtom() : this.parseIdentifier(!0)
                }
                flowParseObjectTypeIndexer(t, r, i) {
                    return t.static = r,
                    14 === this.lookahead().type ? (t.id = this.flowParseObjectPropertyKey(),
                    t.key = this.flowParseTypeInitialiser()) : (t.id = null,
                    t.key = this.flowParseType()),
                    this.expect(3),
                    t.value = this.flowParseTypeInitialiser(),
                    t.variance = i,
                    this.finishNode(t, "ObjectTypeIndexer")
                }
                flowParseObjectTypeInternalSlot(t, r) {
                    return t.static = r,
                    t.id = this.flowParseObjectPropertyKey(),
                    this.expect(3),
                    this.expect(3),
                    this.match(45) || this.match(10) ? (t.method = !0,
                    t.optional = !1,
                    t.value = this.flowParseObjectTypeMethodish(this.startNodeAt(t.start, t.loc.start))) : (t.method = !1,
                    this.eat(17) && (t.optional = !0),
                    t.value = this.flowParseTypeInitialiser()),
                    this.finishNode(t, "ObjectTypeInternalSlot")
                }
                flowParseObjectTypeMethodish(t) {
                    for (t.params = [],
                    t.rest = null,
                    t.typeParameters = null,
                    t.this = null,
                    this.match(45) && (t.typeParameters = this.flowParseTypeParameterDeclaration()),
                    this.expect(10),
                    this.match(74) && (t.this = this.flowParseFunctionTypeParam(!0),
                    t.this.name = null,
                    this.match(11) || this.expect(12)); !this.match(11) && !this.match(21); )
                        t.params.push(this.flowParseFunctionTypeParam(!1)),
                        this.match(11) || this.expect(12);
                    return this.eat(21) && (t.rest = this.flowParseFunctionTypeParam(!1)),
                    this.expect(11),
                    t.returnType = this.flowParseTypeInitialiser(),
                    this.finishNode(t, "FunctionTypeAnnotation")
                }
                flowParseObjectTypeCallProperty(t, r) {
                    const i = this.startNode();
                    return t.static = r,
                    t.value = this.flowParseObjectTypeMethodish(i),
                    this.finishNode(t, "ObjectTypeCallProperty")
                }
                flowParseObjectType({allowStatic: t, allowExact: r, allowSpread: i, allowProto: a, allowInexact: o}) {
                    const l = this.state.inType;
                    this.state.inType = !0;
                    const u = this.startNode();
                    let p, c;
                    u.callProperties = [],
                    u.properties = [],
                    u.indexers = [],
                    u.internalSlots = [];
                    let d = !1;
                    for (r && this.match(6) ? (this.expect(6),
                    p = 9,
                    c = !0) : (this.expect(5),
                    p = 8,
                    c = !1),
                    u.exact = c; !this.match(p); ) {
                        let r = !1
                          , l = null
                          , p = null;
                        const y = this.startNode();
                        if (a && this.isContextual(111)) {
                            const r = this.lookahead();
                            14 !== r.type && 17 !== r.type && (this.next(),
                            l = this.state.startLoc,
                            t = !1)
                        }
                        if (t && this.isContextual(100)) {
                            const t = this.lookahead();
                            14 !== t.type && 17 !== t.type && (this.next(),
                            r = !0)
                        }
                        const h = this.flowParseVariance();
                        if (this.eat(0))
                            null != l && this.unexpected(l),
                            this.eat(0) ? (h && this.unexpected(h.loc.start),
                            u.internalSlots.push(this.flowParseObjectTypeInternalSlot(y, r))) : u.indexers.push(this.flowParseObjectTypeIndexer(y, r, h));
                        else if (this.match(10) || this.match(45))
                            null != l && this.unexpected(l),
                            h && this.unexpected(h.loc.start),
                            u.callProperties.push(this.flowParseObjectTypeCallProperty(y, r));
                        else {
                            let t = "init";
                            if (this.isContextual(94) || this.isContextual(99)) {
                                tokenIsLiteralPropertyName(this.lookahead().type) && (t = this.state.value,
                                this.next())
                            }
                            const a = this.flowParseObjectTypeProperty(y, r, l, h, t, i, null != o ? o : !c);
                            null === a ? (d = !0,
                            p = this.state.lastTokStartLoc) : u.properties.push(a)
                        }
                        this.flowObjectTypeSemicolon(),
                        !p || this.match(8) || this.match(9) || this.raise(X.UnexpectedExplicitInexactInObject, {
                            at: p
                        })
                    }
                    this.expect(p),
                    i && (u.inexact = d);
                    const y = this.finishNode(u, "ObjectTypeAnnotation");
                    return this.state.inType = l,
                    y
                }
                flowParseObjectTypeProperty(t, r, i, a, o, l, u) {
                    if (this.eat(21)) {
                        return this.match(12) || this.match(13) || this.match(8) || this.match(9) ? (l ? u || this.raise(X.InexactInsideExact, {
                            at: this.state.lastTokStartLoc
                        }) : this.raise(X.InexactInsideNonObject, {
                            at: this.state.lastTokStartLoc
                        }),
                        a && this.raise(X.InexactVariance, {
                            node: a
                        }),
                        null) : (l || this.raise(X.UnexpectedSpreadType, {
                            at: this.state.lastTokStartLoc
                        }),
                        null != i && this.unexpected(i),
                        a && this.raise(X.SpreadVariance, {
                            node: a
                        }),
                        t.argument = this.flowParseType(),
                        this.finishNode(t, "ObjectTypeSpreadProperty"))
                    }
                    {
                        t.key = this.flowParseObjectPropertyKey(),
                        t.static = r,
                        t.proto = null != i,
                        t.kind = o;
                        let u = !1;
                        return this.match(45) || this.match(10) ? (t.method = !0,
                        null != i && this.unexpected(i),
                        a && this.unexpected(a.loc.start),
                        t.value = this.flowParseObjectTypeMethodish(this.startNodeAt(t.start, t.loc.start)),
                        "get" !== o && "set" !== o || this.flowCheckGetterSetterParams(t),
                        !l && "constructor" === t.key.name && t.value.this && this.raise(X.ThisParamBannedInConstructor, {
                            node: t.value.this
                        })) : ("init" !== o && this.unexpected(),
                        t.method = !1,
                        this.eat(17) && (u = !0),
                        t.value = this.flowParseTypeInitialiser(),
                        t.variance = a),
                        t.optional = u,
                        this.finishNode(t, "ObjectTypeProperty")
                    }
                }
                flowCheckGetterSetterParams(t) {
                    const r = "get" === t.kind ? 0 : 1
                      , i = t.value.params.length + (t.value.rest ? 1 : 0);
                    t.value.this && this.raise("get" === t.kind ? X.GetterMayNotHaveThisParam : X.SetterMayNotHaveThisParam, {
                        node: t.value.this
                    }),
                    i !== r && this.raise("get" === t.kind ? l.BadGetterArity : l.BadSetterArity, {
                        node: t
                    }),
                    "set" === t.kind && t.value.rest && this.raise(l.BadSetterRestParameter, {
                        node: t
                    })
                }
                flowObjectTypeSemicolon() {
                    this.eat(13) || this.eat(12) || this.match(8) || this.match(9) || this.unexpected()
                }
                flowParseQualifiedTypeIdentifier(t, r, i) {
                    t = t || this.state.start,
                    r = r || this.state.startLoc;
                    let a = i || this.flowParseRestrictedIdentifier(!0);
                    for (; this.eat(16); ) {
                        const i = this.startNodeAt(t, r);
                        i.qualification = a,
                        i.id = this.flowParseRestrictedIdentifier(!0),
                        a = this.finishNode(i, "QualifiedTypeIdentifier")
                    }
                    return a
                }
                flowParseGenericType(t, r, i) {
                    const a = this.startNodeAt(t, r);
                    return a.typeParameters = null,
                    a.id = this.flowParseQualifiedTypeIdentifier(t, r, i),
                    this.match(45) && (a.typeParameters = this.flowParseTypeParameterInstantiation()),
                    this.finishNode(a, "GenericTypeAnnotation")
                }
                flowParseTypeofType() {
                    const t = this.startNode();
                    return this.expect(83),
                    t.argument = this.flowParsePrimaryType(),
                    this.finishNode(t, "TypeofTypeAnnotation")
                }
                flowParseTupleType() {
                    const t = this.startNode();
                    for (t.types = [],
                    this.expect(0); this.state.pos < this.length && !this.match(3) && (t.types.push(this.flowParseType()),
                    !this.match(3)); )
                        this.expect(12);
                    return this.expect(3),
                    this.finishNode(t, "TupleTypeAnnotation")
                }
                flowParseFunctionTypeParam(t) {
                    let r = null
                      , i = !1
                      , a = null;
                    const o = this.startNode()
                      , l = this.lookahead()
                      , u = 74 === this.state.type;
                    return 14 === l.type || 17 === l.type ? (u && !t && this.raise(X.ThisParamMustBeFirst, {
                        node: o
                    }),
                    r = this.parseIdentifier(u),
                    this.eat(17) && (i = !0,
                    u && this.raise(X.ThisParamMayNotBeOptional, {
                        node: o
                    })),
                    a = this.flowParseTypeInitialiser()) : a = this.flowParseType(),
                    o.name = r,
                    o.optional = i,
                    o.typeAnnotation = a,
                    this.finishNode(o, "FunctionTypeParam")
                }
                reinterpretTypeAsFunctionTypeParam(t) {
                    const r = this.startNodeAt(t.start, t.loc.start);
                    return r.name = null,
                    r.optional = !1,
                    r.typeAnnotation = t,
                    this.finishNode(r, "FunctionTypeParam")
                }
                flowParseFunctionTypeParams(t=[]) {
                    let r = null
                      , i = null;
                    for (this.match(74) && (i = this.flowParseFunctionTypeParam(!0),
                    i.name = null,
                    this.match(11) || this.expect(12)); !this.match(11) && !this.match(21); )
                        t.push(this.flowParseFunctionTypeParam(!1)),
                        this.match(11) || this.expect(12);
                    return this.eat(21) && (r = this.flowParseFunctionTypeParam(!1)),
                    {
                        params: t,
                        rest: r,
                        _this: i
                    }
                }
                flowIdentToTypeAnnotation(t, r, i, a) {
                    switch (a.name) {
                    case "any":
                        return this.finishNode(i, "AnyTypeAnnotation");
                    case "bool":
                    case "boolean":
                        return this.finishNode(i, "BooleanTypeAnnotation");
                    case "mixed":
                        return this.finishNode(i, "MixedTypeAnnotation");
                    case "empty":
                        return this.finishNode(i, "EmptyTypeAnnotation");
                    case "number":
                        return this.finishNode(i, "NumberTypeAnnotation");
                    case "string":
                        return this.finishNode(i, "StringTypeAnnotation");
                    case "symbol":
                        return this.finishNode(i, "SymbolTypeAnnotation");
                    default:
                        return this.checkNotUnderscore(a.name),
                        this.flowParseGenericType(t, r, a)
                    }
                }
                flowParsePrimaryType() {
                    const t = this.state.start
                      , r = this.state.startLoc
                      , i = this.startNode();
                    let a, o, l = !1;
                    const u = this.state.noAnonFunctionType;
                    switch (this.state.type) {
                    case 5:
                        return this.flowParseObjectType({
                            allowStatic: !1,
                            allowExact: !1,
                            allowSpread: !0,
                            allowProto: !1,
                            allowInexact: !0
                        });
                    case 6:
                        return this.flowParseObjectType({
                            allowStatic: !1,
                            allowExact: !0,
                            allowSpread: !0,
                            allowProto: !1,
                            allowInexact: !1
                        });
                    case 0:
                        return this.state.noAnonFunctionType = !1,
                        o = this.flowParseTupleType(),
                        this.state.noAnonFunctionType = u,
                        o;
                    case 45:
                        return i.typeParameters = this.flowParseTypeParameterDeclaration(),
                        this.expect(10),
                        a = this.flowParseFunctionTypeParams(),
                        i.params = a.params,
                        i.rest = a.rest,
                        i.this = a._this,
                        this.expect(11),
                        this.expect(19),
                        i.returnType = this.flowParseType(),
                        this.finishNode(i, "FunctionTypeAnnotation");
                    case 10:
                        if (this.next(),
                        !this.match(11) && !this.match(21))
                            if (tokenIsIdentifier(this.state.type) || this.match(74)) {
                                const t = this.lookahead().type;
                                l = 17 !== t && 14 !== t
                            } else
                                l = !0;
                        if (l) {
                            if (this.state.noAnonFunctionType = !1,
                            o = this.flowParseType(),
                            this.state.noAnonFunctionType = u,
                            this.state.noAnonFunctionType || !(this.match(12) || this.match(11) && 19 === this.lookahead().type))
                                return this.expect(11),
                                o;
                            this.eat(12)
                        }
                        return a = o ? this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(o)]) : this.flowParseFunctionTypeParams(),
                        i.params = a.params,
                        i.rest = a.rest,
                        i.this = a._this,
                        this.expect(11),
                        this.expect(19),
                        i.returnType = this.flowParseType(),
                        i.typeParameters = null,
                        this.finishNode(i, "FunctionTypeAnnotation");
                    case 125:
                        return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");
                    case 81:
                    case 82:
                        return i.value = this.match(81),
                        this.next(),
                        this.finishNode(i, "BooleanLiteralTypeAnnotation");
                    case 49:
                        if ("-" === this.state.value) {
                            if (this.next(),
                            this.match(126))
                                return this.parseLiteralAtNode(-this.state.value, "NumberLiteralTypeAnnotation", i);
                            if (this.match(127))
                                return this.parseLiteralAtNode(-this.state.value, "BigIntLiteralTypeAnnotation", i);
                            throw this.raise(X.UnexpectedSubtractionOperand, {
                                at: this.state.startLoc
                            })
                        }
                        throw this.unexpected();
                    case 126:
                        return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");
                    case 127:
                        return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");
                    case 84:
                        return this.next(),
                        this.finishNode(i, "VoidTypeAnnotation");
                    case 80:
                        return this.next(),
                        this.finishNode(i, "NullLiteralTypeAnnotation");
                    case 74:
                        return this.next(),
                        this.finishNode(i, "ThisTypeAnnotation");
                    case 51:
                        return this.next(),
                        this.finishNode(i, "ExistsTypeAnnotation");
                    case 83:
                        return this.flowParseTypeofType();
                    default:
                        if (tokenIsKeyword(this.state.type)) {
                            const t = tokenLabelName(this.state.type);
                            return this.next(),
                            super.createIdentifier(i, t)
                        }
                        if (tokenIsIdentifier(this.state.type))
                            return this.isContextual(121) ? this.flowParseInterfaceType() : this.flowIdentToTypeAnnotation(t, r, i, this.parseIdentifier())
                    }
                    throw this.unexpected()
                }
                flowParsePostfixType() {
                    const t = this.state.start
                      , r = this.state.startLoc;
                    let i = this.flowParsePrimaryType()
                      , a = !1;
                    for (; (this.match(0) || this.match(18)) && !this.canInsertSemicolon(); ) {
                        const o = this.startNodeAt(t, r)
                          , l = this.eat(18);
                        a = a || l,
                        this.expect(0),
                        !l && this.match(3) ? (o.elementType = i,
                        this.next(),
                        i = this.finishNode(o, "ArrayTypeAnnotation")) : (o.objectType = i,
                        o.indexType = this.flowParseType(),
                        this.expect(3),
                        a ? (o.optional = l,
                        i = this.finishNode(o, "OptionalIndexedAccessType")) : i = this.finishNode(o, "IndexedAccessType"))
                    }
                    return i
                }
                flowParsePrefixType() {
                    const t = this.startNode();
                    return this.eat(17) ? (t.typeAnnotation = this.flowParsePrefixType(),
                    this.finishNode(t, "NullableTypeAnnotation")) : this.flowParsePostfixType()
                }
                flowParseAnonFunctionWithoutParens() {
                    const t = this.flowParsePrefixType();
                    if (!this.state.noAnonFunctionType && this.eat(19)) {
                        const r = this.startNodeAt(t.start, t.loc.start);
                        return r.params = [this.reinterpretTypeAsFunctionTypeParam(t)],
                        r.rest = null,
                        r.this = null,
                        r.returnType = this.flowParseType(),
                        r.typeParameters = null,
                        this.finishNode(r, "FunctionTypeAnnotation")
                    }
                    return t
                }
                flowParseIntersectionType() {
                    const t = this.startNode();
                    this.eat(43);
                    const r = this.flowParseAnonFunctionWithoutParens();
                    for (t.types = [r]; this.eat(43); )
                        t.types.push(this.flowParseAnonFunctionWithoutParens());
                    return 1 === t.types.length ? r : this.finishNode(t, "IntersectionTypeAnnotation")
                }
                flowParseUnionType() {
                    const t = this.startNode();
                    this.eat(41);
                    const r = this.flowParseIntersectionType();
                    for (t.types = [r]; this.eat(41); )
                        t.types.push(this.flowParseIntersectionType());
                    return 1 === t.types.length ? r : this.finishNode(t, "UnionTypeAnnotation")
                }
                flowParseType() {
                    const t = this.state.inType;
                    this.state.inType = !0;
                    const r = this.flowParseUnionType();
                    return this.state.inType = t,
                    r
                }
                flowParseTypeOrImplicitInstantiation() {
                    if (124 === this.state.type && "_" === this.state.value) {
                        const t = this.state.start
                          , r = this.state.startLoc
                          , i = this.parseIdentifier();
                        return this.flowParseGenericType(t, r, i)
                    }
                    return this.flowParseType()
                }
                flowParseTypeAnnotation() {
                    const t = this.startNode();
                    return t.typeAnnotation = this.flowParseTypeInitialiser(),
                    this.finishNode(t, "TypeAnnotation")
                }
                flowParseTypeAnnotatableIdentifier(t) {
                    const r = t ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
                    return this.match(14) && (r.typeAnnotation = this.flowParseTypeAnnotation(),
                    this.resetEndLocation(r)),
                    r
                }
                typeCastToParameter(t) {
                    return t.expression.typeAnnotation = t.typeAnnotation,
                    this.resetEndLocation(t.expression, t.typeAnnotation.loc.end),
                    t.expression
                }
                flowParseVariance() {
                    let t = null;
                    return this.match(49) && (t = this.startNode(),
                    "+" === this.state.value ? t.kind = "plus" : t.kind = "minus",
                    this.next(),
                    this.finishNode(t, "Variance")),
                    t
                }
                parseFunctionBody(t, r, i=!1) {
                    return r ? this.forwardNoArrowParamsConversionAt(t, ()=>super.parseFunctionBody(t, !0, i)) : super.parseFunctionBody(t, !1, i)
                }
                parseFunctionBodyAndFinish(t, r, i=!1) {
                    if (this.match(14)) {
                        const r = this.startNode();
                        [r.typeAnnotation,t.predicate] = this.flowParseTypeAndPredicateInitialiser(),
                        t.returnType = r.typeAnnotation ? this.finishNode(r, "TypeAnnotation") : null
                    }
                    super.parseFunctionBodyAndFinish(t, r, i)
                }
                parseStatement(t, r) {
                    if (this.state.strict && this.isContextual(121)) {
                        if (tokenIsKeywordOrIdentifier(this.lookahead().type)) {
                            const t = this.startNode();
                            return this.next(),
                            this.flowParseInterface(t)
                        }
                    } else if (this.shouldParseEnums() && this.isContextual(118)) {
                        const t = this.startNode();
                        return this.next(),
                        this.flowParseEnumDeclaration(t)
                    }
                    const i = super.parseStatement(t, r);
                    return void 0 !== this.flowPragma || this.isValidDirective(i) || (this.flowPragma = null),
                    i
                }
                parseExpressionStatement(t, r) {
                    if ("Identifier" === r.type)
                        if ("declare" === r.name) {
                            if (this.match(76) || tokenIsIdentifier(this.state.type) || this.match(64) || this.match(70) || this.match(78))
                                return this.flowParseDeclare(t)
                        } else if (tokenIsIdentifier(this.state.type)) {
                            if ("interface" === r.name)
                                return this.flowParseInterface(t);
                            if ("type" === r.name)
                                return this.flowParseTypeAlias(t);
                            if ("opaque" === r.name)
                                return this.flowParseOpaqueType(t, !1)
                        }
                    return super.parseExpressionStatement(t, r)
                }
                shouldParseExportDeclaration() {
                    const {type: t} = this.state;
                    return tokenIsFlowInterfaceOrTypeOrOpaque(t) || this.shouldParseEnums() && 118 === t ? !this.state.containsEsc : super.shouldParseExportDeclaration()
                }
                isExportDefaultSpecifier() {
                    const {type: t} = this.state;
                    return tokenIsFlowInterfaceOrTypeOrOpaque(t) || this.shouldParseEnums() && 118 === t ? this.state.containsEsc : super.isExportDefaultSpecifier()
                }
                parseExportDefaultExpression() {
                    if (this.shouldParseEnums() && this.isContextual(118)) {
                        const t = this.startNode();
                        return this.next(),
                        this.flowParseEnumDeclaration(t)
                    }
                    return super.parseExportDefaultExpression()
                }
                parseConditional(t, r, i, a) {
                    if (!this.match(17))
                        return t;
                    if (this.state.maybeInArrowParameters) {
                        const r = this.lookaheadCharCode();
                        if (44 === r || 61 === r || 58 === r || 41 === r)
                            return this.setOptionalParametersError(a),
                            t
                    }
                    this.expect(17);
                    const o = this.state.clone()
                      , l = this.state.noArrowAt
                      , u = this.startNodeAt(r, i);
                    let {consequent: p, failed: c} = this.tryParseConditionalConsequent()
                      , [d,y] = this.getArrowLikeExpressions(p);
                    if (c || y.length > 0) {
                        const t = [...l];
                        if (y.length > 0) {
                            this.state = o,
                            this.state.noArrowAt = t;
                            for (let r = 0; r < y.length; r++)
                                t.push(y[r].start);
                            ({consequent: p, failed: c} = this.tryParseConditionalConsequent()),
                            [d,y] = this.getArrowLikeExpressions(p)
                        }
                        c && d.length > 1 && this.raise(X.AmbiguousConditionalArrow, {
                            at: o.startLoc
                        }),
                        c && 1 === d.length && (this.state = o,
                        t.push(d[0].start),
                        this.state.noArrowAt = t,
                        ({consequent: p, failed: c} = this.tryParseConditionalConsequent()))
                    }
                    return this.getArrowLikeExpressions(p, !0),
                    this.state.noArrowAt = l,
                    this.expect(14),
                    u.test = t,
                    u.consequent = p,
                    u.alternate = this.forwardNoArrowParamsConversionAt(u, ()=>this.parseMaybeAssign(void 0, void 0)),
                    this.finishNode(u, "ConditionalExpression")
                }
                tryParseConditionalConsequent() {
                    this.state.noArrowParamsConversionAt.push(this.state.start);
                    const t = this.parseMaybeAssignAllowIn()
                      , r = !this.match(14);
                    return this.state.noArrowParamsConversionAt.pop(),
                    {
                        consequent: t,
                        failed: r
                    }
                }
                getArrowLikeExpressions(t, r) {
                    const i = [t]
                      , a = [];
                    for (; 0 !== i.length; ) {
                        const t = i.pop();
                        "ArrowFunctionExpression" === t.type ? (t.typeParameters || !t.returnType ? this.finishArrowValidation(t) : a.push(t),
                        i.push(t.body)) : "ConditionalExpression" === t.type && (i.push(t.consequent),
                        i.push(t.alternate))
                    }
                    return r ? (a.forEach(t=>this.finishArrowValidation(t)),
                    [a, []]) : function partition(t, r) {
                        const i = []
                          , a = [];
                        for (let o = 0; o < t.length; o++)
                            (r(t[o], o, t) ? i : a).push(t[o]);
                        return [i, a]
                    }(a, t=>t.params.every(t=>this.isAssignable(t, !0)))
                }
                finishArrowValidation(t) {
                    var r;
                    this.toAssignableList(t.params, null == (r = t.extra) ? void 0 : r.trailingCommaLoc, !1),
                    this.scope.enter(6),
                    super.checkParams(t, !1, !0),
                    this.scope.exit()
                }
                forwardNoArrowParamsConversionAt(t, r) {
                    let i;
                    return -1 !== this.state.noArrowParamsConversionAt.indexOf(t.start) ? (this.state.noArrowParamsConversionAt.push(this.state.start),
                    i = r(),
                    this.state.noArrowParamsConversionAt.pop()) : i = r(),
                    i
                }
                parseParenItem(t, r, i) {
                    if (t = super.parseParenItem(t, r, i),
                    this.eat(17) && (t.optional = !0,
                    this.resetEndLocation(t)),
                    this.match(14)) {
                        const a = this.startNodeAt(r, i);
                        return a.expression = t,
                        a.typeAnnotation = this.flowParseTypeAnnotation(),
                        this.finishNode(a, "TypeCastExpression")
                    }
                    return t
                }
                assertModuleNodeAllowed(t) {
                    "ImportDeclaration" === t.type && ("type" === t.importKind || "typeof" === t.importKind) || "ExportNamedDeclaration" === t.type && "type" === t.exportKind || "ExportAllDeclaration" === t.type && "type" === t.exportKind || super.assertModuleNodeAllowed(t)
                }
                parseExport(t) {
                    const r = super.parseExport(t);
                    return "ExportNamedDeclaration" !== r.type && "ExportAllDeclaration" !== r.type || (r.exportKind = r.exportKind || "value"),
                    r
                }
                parseExportDeclaration(t) {
                    if (this.isContextual(122)) {
                        t.exportKind = "type";
                        const r = this.startNode();
                        return this.next(),
                        this.match(5) ? (t.specifiers = this.parseExportSpecifiers(!0),
                        this.parseExportFrom(t),
                        null) : this.flowParseTypeAlias(r)
                    }
                    if (this.isContextual(123)) {
                        t.exportKind = "type";
                        const r = this.startNode();
                        return this.next(),
                        this.flowParseOpaqueType(r, !1)
                    }
                    if (this.isContextual(121)) {
                        t.exportKind = "type";
                        const r = this.startNode();
                        return this.next(),
                        this.flowParseInterface(r)
                    }
                    if (this.shouldParseEnums() && this.isContextual(118)) {
                        t.exportKind = "value";
                        const r = this.startNode();
                        return this.next(),
                        this.flowParseEnumDeclaration(r)
                    }
                    return super.parseExportDeclaration(t)
                }
                eatExportStar(t) {
                    return !!super.eatExportStar(...arguments) || !(!this.isContextual(122) || 51 !== this.lookahead().type) && (t.exportKind = "type",
                    this.next(),
                    this.next(),
                    !0)
                }
                maybeParseExportNamespaceSpecifier(t) {
                    const {startLoc: r} = this.state
                      , i = super.maybeParseExportNamespaceSpecifier(t);
                    return i && "type" === t.exportKind && this.unexpected(r),
                    i
                }
                parseClassId(t, r, i) {
                    super.parseClassId(t, r, i),
                    this.match(45) && (t.typeParameters = this.flowParseTypeParameterDeclaration())
                }
                parseClassMember(t, r, i) {
                    const {startLoc: a} = this.state;
                    if (this.isContextual(117)) {
                        if (this.parseClassMemberFromModifier(t, r))
                            return;
                        r.declare = !0
                    }
                    super.parseClassMember(t, r, i),
                    r.declare && ("ClassProperty" !== r.type && "ClassPrivateProperty" !== r.type && "PropertyDefinition" !== r.type ? this.raise(X.DeclareClassElement, {
                        at: a
                    }) : r.value && this.raise(X.DeclareClassFieldInitializer, {
                        node: r.value
                    }))
                }
                isIterator(t) {
                    return "iterator" === t || "asyncIterator" === t
                }
                readIterator() {
                    const t = super.readWord1()
                      , r = "@@" + t;
                    this.isIterator(t) && this.state.inType || this.raise(l.InvalidIdentifier, {
                        at: this.state.curPosition()
                    }, r),
                    this.finishToken(124, r)
                }
                getTokenFromCode(t) {
                    const r = this.input.charCodeAt(this.state.pos + 1);
                    return 123 === t && 124 === r ? this.finishOp(6, 2) : !this.state.inType || 62 !== t && 60 !== t ? this.state.inType && 63 === t ? 46 === r ? this.finishOp(18, 2) : this.finishOp(17, 1) : function isIteratorStart(t, r) {
                        return 64 === t && 64 === r
                    }(t, r) ? (this.state.pos += 2,
                    this.readIterator()) : super.getTokenFromCode(t) : this.finishOp(62 === t ? 46 : 45, 1)
                }
                isAssignable(t, r) {
                    return "TypeCastExpression" === t.type ? this.isAssignable(t.expression, r) : super.isAssignable(t, r)
                }
                toAssignable(t, r=!1) {
                    return "TypeCastExpression" === t.type ? super.toAssignable(this.typeCastToParameter(t), r) : super.toAssignable(t, r)
                }
                toAssignableList(t, r, i) {
                    for (let r = 0; r < t.length; r++) {
                        const i = t[r];
                        "TypeCastExpression" === (null == i ? void 0 : i.type) && (t[r] = this.typeCastToParameter(i))
                    }
                    return super.toAssignableList(t, r, i)
                }
                toReferencedList(t, r) {
                    for (let a = 0; a < t.length; a++) {
                        var i;
                        const o = t[a];
                        !o || "TypeCastExpression" !== o.type || null != (i = o.extra) && i.parenthesized || !(t.length > 1) && r || this.raise(X.TypeCastInPattern, {
                            node: o.typeAnnotation
                        })
                    }
                    return t
                }
                parseArrayLike(t, r, i, a) {
                    const o = super.parseArrayLike(t, r, i, a);
                    return r && !this.state.maybeInArrowParameters && this.toReferencedList(o.elements),
                    o
                }
                checkLVal(t, ...r) {
                    if ("TypeCastExpression" !== t.type)
                        return super.checkLVal(t, ...r)
                }
                parseClassProperty(t) {
                    return this.match(14) && (t.typeAnnotation = this.flowParseTypeAnnotation()),
                    super.parseClassProperty(t)
                }
                parseClassPrivateProperty(t) {
                    return this.match(14) && (t.typeAnnotation = this.flowParseTypeAnnotation()),
                    super.parseClassPrivateProperty(t)
                }
                isClassMethod() {
                    return this.match(45) || super.isClassMethod()
                }
                isClassProperty() {
                    return this.match(14) || super.isClassProperty()
                }
                isNonstaticConstructor(t) {
                    return !this.match(14) && super.isNonstaticConstructor(t)
                }
                pushClassMethod(t, r, i, a, o, l) {
                    if (r.variance && this.unexpected(r.variance.loc.start),
                    delete r.variance,
                    this.match(45) && (r.typeParameters = this.flowParseTypeParameterDeclaration()),
                    super.pushClassMethod(t, r, i, a, o, l),
                    r.params && o) {
                        const t = r.params;
                        t.length > 0 && this.isThisParam(t[0]) && this.raise(X.ThisParamBannedInConstructor, {
                            node: r
                        })
                    } else if ("MethodDefinition" === r.type && o && r.value.params) {
                        const t = r.value.params;
                        t.length > 0 && this.isThisParam(t[0]) && this.raise(X.ThisParamBannedInConstructor, {
                            node: r
                        })
                    }
                }
                pushClassPrivateMethod(t, r, i, a) {
                    r.variance && this.unexpected(r.variance.loc.start),
                    delete r.variance,
                    this.match(45) && (r.typeParameters = this.flowParseTypeParameterDeclaration()),
                    super.pushClassPrivateMethod(t, r, i, a)
                }
                parseClassSuper(t) {
                    if (super.parseClassSuper(t),
                    t.superClass && this.match(45) && (t.superTypeParameters = this.flowParseTypeParameterInstantiation()),
                    this.isContextual(106)) {
                        this.next();
                        const r = t.implements = [];
                        do {
                            const t = this.startNode();
                            t.id = this.flowParseRestrictedIdentifier(!0),
                            this.match(45) ? t.typeParameters = this.flowParseTypeParameterInstantiation() : t.typeParameters = null,
                            r.push(this.finishNode(t, "ClassImplements"))
                        } while (this.eat(12))
                    }
                }
                checkGetterSetterParams(t) {
                    super.checkGetterSetterParams(t);
                    const r = this.getObjectOrClassMethodParams(t);
                    if (r.length > 0) {
                        const i = r[0];
                        this.isThisParam(i) && "get" === t.kind ? this.raise(X.GetterMayNotHaveThisParam, {
                            node: i
                        }) : this.isThisParam(i) && this.raise(X.SetterMayNotHaveThisParam, {
                            node: i
                        })
                    }
                }
                parsePropertyNamePrefixOperator(t) {
                    t.variance = this.flowParseVariance()
                }
                parseObjPropValue(t, r, i, a, o, l, u, p) {
                    let c;
                    t.variance && this.unexpected(t.variance.loc.start),
                    delete t.variance,
                    this.match(45) && !u && (c = this.flowParseTypeParameterDeclaration(),
                    this.match(10) || this.unexpected()),
                    super.parseObjPropValue(t, r, i, a, o, l, u, p),
                    c && ((t.value || t).typeParameters = c)
                }
                parseAssignableListItemTypes(t) {
                    return this.eat(17) && ("Identifier" !== t.type && this.raise(X.PatternIsOptional, {
                        node: t
                    }),
                    this.isThisParam(t) && this.raise(X.ThisParamMayNotBeOptional, {
                        node: t
                    }),
                    t.optional = !0),
                    this.match(14) ? t.typeAnnotation = this.flowParseTypeAnnotation() : this.isThisParam(t) && this.raise(X.ThisParamAnnotationRequired, {
                        node: t
                    }),
                    this.match(29) && this.isThisParam(t) && this.raise(X.ThisParamNoDefault, {
                        node: t
                    }),
                    this.resetEndLocation(t),
                    t
                }
                parseMaybeDefault(t, r, i) {
                    const a = super.parseMaybeDefault(t, r, i);
                    return "AssignmentPattern" === a.type && a.typeAnnotation && a.right.start < a.typeAnnotation.start && this.raise(X.TypeBeforeInitializer, {
                        node: a.typeAnnotation
                    }),
                    a
                }
                shouldParseDefaultImport(t) {
                    return hasTypeImportKind(t) ? isMaybeDefaultImport(this.state.type) : super.shouldParseDefaultImport(t)
                }
                parseImportSpecifierLocal(t, r, i, a) {
                    r.local = hasTypeImportKind(t) ? this.flowParseRestrictedIdentifier(!0, !0) : this.parseIdentifier(),
                    this.checkLVal(r.local, a, 9),
                    t.specifiers.push(this.finishNode(r, i))
                }
                maybeParseDefaultImportSpecifier(t) {
                    t.importKind = "value";
                    let r = null;
                    if (this.match(83) ? r = "typeof" : this.isContextual(122) && (r = "type"),
                    r) {
                        const i = this.lookahead()
                          , {type: a} = i;
                        "type" === r && 51 === a && this.unexpected(null, i.type),
                        (isMaybeDefaultImport(a) || 5 === a || 51 === a) && (this.next(),
                        t.importKind = r)
                    }
                    return super.maybeParseDefaultImportSpecifier(t)
                }
                parseImportSpecifier(t, r, i, a) {
                    const o = t.imported;
                    let u = null;
                    "Identifier" === o.type && ("type" === o.name ? u = "type" : "typeof" === o.name && (u = "typeof"));
                    let p = !1;
                    if (this.isContextual(89) && !this.isLookaheadContextual("as")) {
                        const r = this.parseIdentifier(!0);
                        null === u || tokenIsKeywordOrIdentifier(this.state.type) ? (t.imported = o,
                        t.importKind = null,
                        t.local = this.parseIdentifier()) : (t.imported = r,
                        t.importKind = u,
                        t.local = cloneIdentifier(r))
                    } else {
                        if (null !== u && tokenIsKeywordOrIdentifier(this.state.type))
                            t.imported = this.parseIdentifier(!0),
                            t.importKind = u;
                        else {
                            if (r)
                                throw this.raise(l.ImportBindingIsString, {
                                    node: t
                                }, o.value);
                            t.imported = o,
                            t.importKind = null
                        }
                        this.eatContextual(89) ? t.local = this.parseIdentifier() : (p = !0,
                        t.local = cloneIdentifier(t.imported))
                    }
                    const c = hasTypeImportKind(t);
                    return i && c && this.raise(X.ImportTypeShorthandOnlyInPureImport, {
                        node: t
                    }),
                    (i || c) && this.checkReservedType(t.local.name, t.local.loc.start, !0),
                    !p || i || c || this.checkReservedWord(t.local.name, t.loc.start, !0, !0),
                    this.checkLVal(t.local, "import specifier", 9),
                    this.finishNode(t, "ImportSpecifier")
                }
                parseBindingAtom() {
                    switch (this.state.type) {
                    case 74:
                        return this.parseIdentifier(!0);
                    default:
                        return super.parseBindingAtom()
                    }
                }
                parseFunctionParams(t, r) {
                    const i = t.kind;
                    "get" !== i && "set" !== i && this.match(45) && (t.typeParameters = this.flowParseTypeParameterDeclaration()),
                    super.parseFunctionParams(t, r)
                }
                parseVarId(t, r) {
                    super.parseVarId(t, r),
                    this.match(14) && (t.id.typeAnnotation = this.flowParseTypeAnnotation(),
                    this.resetEndLocation(t.id))
                }
                parseAsyncArrowFromCallExpression(t, r) {
                    if (this.match(14)) {
                        const r = this.state.noAnonFunctionType;
                        this.state.noAnonFunctionType = !0,
                        t.returnType = this.flowParseTypeAnnotation(),
                        this.state.noAnonFunctionType = r
                    }
                    return super.parseAsyncArrowFromCallExpression(t, r)
                }
                shouldParseAsyncArrow() {
                    return this.match(14) || super.shouldParseAsyncArrow()
                }
                parseMaybeAssign(t, r) {
                    var i;
                    let a, o = null;
                    if (this.hasPlugin("jsx") && (this.match(134) || this.match(45))) {
                        if (o = this.state.clone(),
                        a = this.tryParse(()=>super.parseMaybeAssign(t, r), o),
                        !a.error)
                            return a.node;
                        const {context: i} = this.state
                          , l = i[i.length - 1];
                        l !== p.j_oTag && l !== p.j_expr || i.pop()
                    }
                    if (null != (i = a) && i.error || this.match(45)) {
                        var l, u;
                        let i;
                        o = o || this.state.clone();
                        const p = this.tryParse(a=>{
                            var o;
                            i = this.flowParseTypeParameterDeclaration();
                            const l = this.forwardNoArrowParamsConversionAt(i, ()=>{
                                const a = super.parseMaybeAssign(t, r);
                                return this.resetStartLocationFromNode(a, i),
                                a
                            }
                            );
                            null != (o = l.extra) && o.parenthesized && a();
                            const u = this.maybeUnwrapTypeCastExpression(l);
                            return "ArrowFunctionExpression" !== u.type && a(),
                            u.typeParameters = i,
                            this.resetStartLocationFromNode(u, i),
                            l
                        }
                        , o);
                        let c = null;
                        if (p.node && "ArrowFunctionExpression" === this.maybeUnwrapTypeCastExpression(p.node).type) {
                            if (!p.error && !p.aborted)
                                return p.node.async && this.raise(X.UnexpectedTypeParameterBeforeAsyncArrowFunction, {
                                    node: i
                                }),
                                p.node;
                            c = p.node
                        }
                        if (null != (l = a) && l.node)
                            return this.state = a.failState,
                            a.node;
                        if (c)
                            return this.state = p.failState,
                            c;
                        if (null != (u = a) && u.thrown)
                            throw a.error;
                        if (p.thrown)
                            throw p.error;
                        throw this.raise(X.UnexpectedTokenAfterTypeParameter, {
                            node: i
                        })
                    }
                    return super.parseMaybeAssign(t, r)
                }
                parseArrow(t) {
                    if (this.match(14)) {
                        const r = this.tryParse(()=>{
                            const r = this.state.noAnonFunctionType;
                            this.state.noAnonFunctionType = !0;
                            const i = this.startNode();
                            return [i.typeAnnotation,t.predicate] = this.flowParseTypeAndPredicateInitialiser(),
                            this.state.noAnonFunctionType = r,
                            this.canInsertSemicolon() && this.unexpected(),
                            this.match(19) || this.unexpected(),
                            i
                        }
                        );
                        if (r.thrown)
                            return null;
                        r.error && (this.state = r.failState),
                        t.returnType = r.node.typeAnnotation ? this.finishNode(r.node, "TypeAnnotation") : null
                    }
                    return super.parseArrow(t)
                }
                shouldParseArrow(t) {
                    return this.match(14) || super.shouldParseArrow(t)
                }
                setArrowFunctionParameters(t, r) {
                    -1 !== this.state.noArrowParamsConversionAt.indexOf(t.start) ? t.params = r : super.setArrowFunctionParameters(t, r)
                }
                checkParams(t, r, i) {
                    if (!i || -1 === this.state.noArrowParamsConversionAt.indexOf(t.start)) {
                        for (let r = 0; r < t.params.length; r++)
                            this.isThisParam(t.params[r]) && r > 0 && this.raise(X.ThisParamMustBeFirst, {
                                node: t.params[r]
                            });
                        return super.checkParams(...arguments)
                    }
                }
                parseParenAndDistinguishExpression(t) {
                    return super.parseParenAndDistinguishExpression(t && -1 === this.state.noArrowAt.indexOf(this.state.start))
                }
                parseSubscripts(t, r, i, a) {
                    if ("Identifier" === t.type && "async" === t.name && -1 !== this.state.noArrowAt.indexOf(r)) {
                        this.next();
                        const a = this.startNodeAt(r, i);
                        a.callee = t,
                        a.arguments = this.parseCallExpressionArguments(11, !1),
                        t = this.finishNode(a, "CallExpression")
                    } else if ("Identifier" === t.type && "async" === t.name && this.match(45)) {
                        const o = this.state.clone()
                          , l = this.tryParse(t=>this.parseAsyncArrowWithTypeParameters(r, i) || t(), o);
                        if (!l.error && !l.aborted)
                            return l.node;
                        const u = this.tryParse(()=>super.parseSubscripts(t, r, i, a), o);
                        if (u.node && !u.error)
                            return u.node;
                        if (l.node)
                            return this.state = l.failState,
                            l.node;
                        if (u.node)
                            return this.state = u.failState,
                            u.node;
                        throw l.error || u.error
                    }
                    return super.parseSubscripts(t, r, i, a)
                }
                parseSubscript(t, r, i, a, o) {
                    if (this.match(18) && this.isLookaheadToken_lt()) {
                        if (o.optionalChainMember = !0,
                        a)
                            return o.stop = !0,
                            t;
                        this.next();
                        const l = this.startNodeAt(r, i);
                        return l.callee = t,
                        l.typeArguments = this.flowParseTypeParameterInstantiation(),
                        this.expect(10),
                        l.arguments = this.parseCallExpressionArguments(11, !1),
                        l.optional = !0,
                        this.finishCallExpression(l, !0)
                    }
                    if (!a && this.shouldParseTypes() && this.match(45)) {
                        const a = this.startNodeAt(r, i);
                        a.callee = t;
                        const l = this.tryParse(()=>(a.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew(),
                        this.expect(10),
                        a.arguments = this.parseCallExpressionArguments(11, !1),
                        o.optionalChainMember && (a.optional = !1),
                        this.finishCallExpression(a, o.optionalChainMember)));
                        if (l.node)
                            return l.error && (this.state = l.failState),
                            l.node
                    }
                    return super.parseSubscript(t, r, i, a, o)
                }
                parseNewArguments(t) {
                    let r = null;
                    this.shouldParseTypes() && this.match(45) && (r = this.tryParse(()=>this.flowParseTypeParameterInstantiationCallOrNew()).node),
                    t.typeArguments = r,
                    super.parseNewArguments(t)
                }
                parseAsyncArrowWithTypeParameters(t, r) {
                    const i = this.startNodeAt(t, r);
                    if (this.parseFunctionParams(i),
                    this.parseArrow(i))
                        return this.parseArrowExpression(i, void 0, !0)
                }
                readToken_mult_modulo(t) {
                    const r = this.input.charCodeAt(this.state.pos + 1);
                    if (42 === t && 47 === r && this.state.hasFlowComment)
                        return this.state.hasFlowComment = !1,
                        this.state.pos += 2,
                        void this.nextToken();
                    super.readToken_mult_modulo(t)
                }
                readToken_pipe_amp(t) {
                    const r = this.input.charCodeAt(this.state.pos + 1);
                    124 !== t || 125 !== r ? super.readToken_pipe_amp(t) : this.finishOp(9, 2)
                }
                parseTopLevel(t, r) {
                    const i = super.parseTopLevel(t, r);
                    return this.state.hasFlowComment && this.raise(X.UnterminatedFlowComment, {
                        at: this.state.curPosition()
                    }),
                    i
                }
                skipBlockComment() {
                    if (this.hasPlugin("flowComments") && this.skipFlowComment()) {
                        if (this.state.hasFlowComment)
                            throw this.raise(X.NestedFlowComment, {
                                at: this.state.startLoc
                            });
                        return this.hasFlowCommentCompletion(),
                        this.state.pos += this.skipFlowComment(),
                        void (this.state.hasFlowComment = !0)
                    }
                    if (!this.state.hasFlowComment)
                        return super.skipBlockComment();
                    {
                        const t = this.input.indexOf("*-/", this.state.pos + 2);
                        if (-1 === t)
                            throw this.raise(l.UnterminatedComment, {
                                at: this.state.curPosition()
                            });
                        this.state.pos = t + 2 + 3
                    }
                }
                skipFlowComment() {
                    const {pos: t} = this.state;
                    let r = 2;
                    for (; [32, 9].includes(this.input.charCodeAt(t + r)); )
                        r++;
                    const i = this.input.charCodeAt(r + t)
                      , a = this.input.charCodeAt(r + t + 1);
                    return 58 === i && 58 === a ? r + 2 : "flow-include" === this.input.slice(r + t, r + t + 12) ? r + 12 : 58 === i && 58 !== a && r
                }
                hasFlowCommentCompletion() {
                    if (-1 === this.input.indexOf("*/", this.state.pos))
                        throw this.raise(l.UnterminatedComment, {
                            at: this.state.curPosition()
                        })
                }
                flowEnumErrorBooleanMemberNotInitialized(t, {enumName: r, memberName: i}) {
                    this.raise(X.EnumBooleanMemberNotInitialized, {
                        at: t
                    }, i, r)
                }
                flowEnumErrorInvalidExplicitType(t, {enumName: r, suppliedType: i}) {
                    return this.raise(null === i ? X.EnumInvalidExplicitTypeUnknownSupplied : X.EnumInvalidExplicitType, {
                        at: t
                    }, r, i)
                }
                flowEnumErrorInvalidMemberInitializer(t, {enumName: r, explicitType: i, memberName: a}) {
                    return this.raise("boolean" === i || "number" === i || "string" === i ? X.EnumInvalidMemberInitializerPrimaryType : "symbol" === i ? X.EnumInvalidMemberInitializerSymbolType : X.EnumInvalidMemberInitializerUnknownType, {
                        at: t
                    }, r, a, i)
                }
                flowEnumErrorNumberMemberNotInitialized(t, {enumName: r, memberName: i}) {
                    this.raise(X.EnumNumberMemberNotInitialized, {
                        at: t
                    }, r, i)
                }
                flowEnumErrorStringMemberInconsistentlyInitailized(t, {enumName: r}) {
                    this.raise(X.EnumStringMemberInconsistentlyInitailized, {
                        node: t
                    }, r)
                }
                flowEnumMemberInit() {
                    const t = this.state.startLoc
                      , endOfInit = ()=>this.match(12) || this.match(8);
                    switch (this.state.type) {
                    case 126:
                        {
                            const r = this.parseNumericLiteral(this.state.value);
                            return endOfInit() ? {
                                type: "number",
                                loc: r.loc.start,
                                value: r
                            } : {
                                type: "invalid",
                                loc: t
                            }
                        }
                    case 125:
                        {
                            const r = this.parseStringLiteral(this.state.value);
                            return endOfInit() ? {
                                type: "string",
                                loc: r.loc.start,
                                value: r
                            } : {
                                type: "invalid",
                                loc: t
                            }
                        }
                    case 81:
                    case 82:
                        {
                            const r = this.parseBooleanLiteral(this.match(81));
                            return endOfInit() ? {
                                type: "boolean",
                                loc: r.loc.start,
                                value: r
                            } : {
                                type: "invalid",
                                loc: t
                            }
                        }
                    default:
                        return {
                            type: "invalid",
                            loc: t
                        }
                    }
                }
                flowEnumMemberRaw() {
                    const t = this.state.startLoc;
                    return {
                        id: this.parseIdentifier(!0),
                        init: this.eat(29) ? this.flowEnumMemberInit() : {
                            type: "none",
                            loc: t
                        }
                    }
                }
                flowEnumCheckExplicitTypeMismatch(t, r, i) {
                    const {explicitType: a} = r;
                    null !== a && a !== i && this.flowEnumErrorInvalidMemberInitializer(t, r)
                }
                flowEnumMembers({enumName: t, explicitType: r}) {
                    const i = new Set
                      , a = {
                        booleanMembers: [],
                        numberMembers: [],
                        stringMembers: [],
                        defaultedMembers: []
                    };
                    let o = !1;
                    for (; !this.match(8); ) {
                        if (this.eat(21)) {
                            o = !0;
                            break
                        }
                        const l = this.startNode()
                          , {id: u, init: p} = this.flowEnumMemberRaw()
                          , c = u.name;
                        if ("" === c)
                            continue;
                        /^[a-z]/.test(c) && this.raise(X.EnumInvalidMemberName, {
                            node: u
                        }, c, c[0].toUpperCase() + c.slice(1), t),
                        i.has(c) && this.raise(X.EnumDuplicateMemberName, {
                            node: u
                        }, c, t),
                        i.add(c);
                        const d = {
                            enumName: t,
                            explicitType: r,
                            memberName: c
                        };
                        switch (l.id = u,
                        p.type) {
                        case "boolean":
                            this.flowEnumCheckExplicitTypeMismatch(p.loc, d, "boolean"),
                            l.init = p.value,
                            a.booleanMembers.push(this.finishNode(l, "EnumBooleanMember"));
                            break;
                        case "number":
                            this.flowEnumCheckExplicitTypeMismatch(p.loc, d, "number"),
                            l.init = p.value,
                            a.numberMembers.push(this.finishNode(l, "EnumNumberMember"));
                            break;
                        case "string":
                            this.flowEnumCheckExplicitTypeMismatch(p.loc, d, "string"),
                            l.init = p.value,
                            a.stringMembers.push(this.finishNode(l, "EnumStringMember"));
                            break;
                        case "invalid":
                            throw this.flowEnumErrorInvalidMemberInitializer(p.loc, d);
                        case "none":
                            switch (r) {
                            case "boolean":
                                this.flowEnumErrorBooleanMemberNotInitialized(p.loc, d);
                                break;
                            case "number":
                                this.flowEnumErrorNumberMemberNotInitialized(p.loc, d);
                                break;
                            default:
                                a.defaultedMembers.push(this.finishNode(l, "EnumDefaultedMember"))
                            }
                        }
                        this.match(8) || this.expect(12)
                    }
                    return {
                        members: a,
                        hasUnknownMembers: o
                    }
                }
                flowEnumStringMembers(t, r, {enumName: i}) {
                    if (0 === t.length)
                        return r;
                    if (0 === r.length)
                        return t;
                    if (r.length > t.length) {
                        for (const r of t)
                            this.flowEnumErrorStringMemberInconsistentlyInitailized(r, {
                                enumName: i
                            });
                        return r
                    }
                    for (const t of r)
                        this.flowEnumErrorStringMemberInconsistentlyInitailized(t, {
                            enumName: i
                        });
                    return t
                }
                flowEnumParseExplicitType({enumName: t}) {
                    if (this.eatContextual(97)) {
                        if (!tokenIsIdentifier(this.state.type))
                            throw this.flowEnumErrorInvalidExplicitType(this.state.startLoc, {
                                enumName: t,
                                suppliedType: null
                            });
                        const {value: r} = this.state;
                        return this.next(),
                        "boolean" !== r && "number" !== r && "string" !== r && "symbol" !== r && this.flowEnumErrorInvalidExplicitType(this.state.startLoc, {
                            enumName: t,
                            suppliedType: r
                        }),
                        r
                    }
                    return null
                }
                flowEnumBody(t, r) {
                    const i = r.name
                      , a = r.loc.start
                      , o = this.flowEnumParseExplicitType({
                        enumName: i
                    });
                    this.expect(5);
                    const {members: l, hasUnknownMembers: u} = this.flowEnumMembers({
                        enumName: i,
                        explicitType: o
                    });
                    switch (t.hasUnknownMembers = u,
                    o) {
                    case "boolean":
                        return t.explicitType = !0,
                        t.members = l.booleanMembers,
                        this.expect(8),
                        this.finishNode(t, "EnumBooleanBody");
                    case "number":
                        return t.explicitType = !0,
                        t.members = l.numberMembers,
                        this.expect(8),
                        this.finishNode(t, "EnumNumberBody");
                    case "string":
                        return t.explicitType = !0,
                        t.members = this.flowEnumStringMembers(l.stringMembers, l.defaultedMembers, {
                            enumName: i
                        }),
                        this.expect(8),
                        this.finishNode(t, "EnumStringBody");
                    case "symbol":
                        return t.members = l.defaultedMembers,
                        this.expect(8),
                        this.finishNode(t, "EnumSymbolBody");
                    default:
                        {
                            const empty = ()=>(t.members = [],
                            this.expect(8),
                            this.finishNode(t, "EnumStringBody"));
                            t.explicitType = !1;
                            const r = l.booleanMembers.length
                              , o = l.numberMembers.length
                              , u = l.stringMembers.length
                              , p = l.defaultedMembers.length;
                            if (r || o || u || p) {
                                if (r || o) {
                                    if (!o && !u && r >= p) {
                                        for (const t of l.defaultedMembers)
                                            this.flowEnumErrorBooleanMemberNotInitialized(t.loc.start, {
                                                enumName: i,
                                                memberName: t.id.name
                                            });
                                        return t.members = l.booleanMembers,
                                        this.expect(8),
                                        this.finishNode(t, "EnumBooleanBody")
                                    }
                                    if (!r && !u && o >= p) {
                                        for (const t of l.defaultedMembers)
                                            this.flowEnumErrorNumberMemberNotInitialized(t.loc.start, {
                                                enumName: i,
                                                memberName: t.id.name
                                            });
                                        return t.members = l.numberMembers,
                                        this.expect(8),
                                        this.finishNode(t, "EnumNumberBody")
                                    }
                                    return this.raise(X.EnumInconsistentMemberValues, {
                                        at: a
                                    }, i),
                                    empty()
                                }
                                return t.members = this.flowEnumStringMembers(l.stringMembers, l.defaultedMembers, {
                                    enumName: i
                                }),
                                this.expect(8),
                                this.finishNode(t, "EnumStringBody")
                            }
                            return empty()
                        }
                    }
                }
                flowParseEnumDeclaration(t) {
                    const r = this.parseIdentifier();
                    return t.id = r,
                    t.body = this.flowEnumBody(this.startNode(), r),
                    this.finishNode(t, "EnumDeclaration")
                }
                isLookaheadToken_lt() {
                    const t = this.nextTokenStart();
                    if (60 === this.input.charCodeAt(t)) {
                        const r = this.input.charCodeAt(t + 1);
                        return 60 !== r && 61 !== r
                    }
                    return !1
                }
                maybeUnwrapTypeCastExpression(t) {
                    return "TypeCastExpression" === t.type ? t.expression : t
                }
            }
            ,
            typescript: t=>class extends t {
                getScopeHandler() {
                    return TypeScriptScopeHandler
                }
                tsIsIdentifier() {
                    return tokenIsIdentifier(this.state.type)
                }
                tsTokenCanFollowModifier() {
                    return (this.match(0) || this.match(5) || this.match(51) || this.match(21) || this.match(130) || this.isLiteralPropertyName()) && !this.hasPrecedingLineBreak()
                }
                tsNextTokenCanFollowModifier() {
                    return this.next(),
                    this.tsTokenCanFollowModifier()
                }
                tsParseModifier(t, r) {
                    if (!tokenIsIdentifier(this.state.type))
                        return;
                    const i = this.state.value;
                    if (-1 !== t.indexOf(i)) {
                        if (r && this.tsIsStartOfStaticBlocks())
                            return;
                        if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this)))
                            return i
                    }
                }
                tsParseModifiers(t, r, i, a, o) {
                    const enforceOrder = (r,i,a,o)=>{
                        i === a && t[o] && this.raise(Q.InvalidModifiersOrder, {
                            at: r
                        }, a, o)
                    }
                      , incompatible = (r,i,a,o)=>{
                        (t[a] && i === o || t[o] && i === a) && this.raise(Q.IncompatibleModifiers, {
                            at: r
                        }, a, o)
                    }
                    ;
                    for (; ; ) {
                        const {startLoc: l} = this.state
                          , u = this.tsParseModifier(r.concat(null != i ? i : []), o);
                        if (!u)
                            break;
                        tsIsAccessModifier(u) ? t.accessibility ? this.raise(Q.DuplicateAccessibilityModifier, {
                            at: l
                        }) : (enforceOrder(l, u, u, "override"),
                        enforceOrder(l, u, u, "static"),
                        enforceOrder(l, u, u, "readonly"),
                        t.accessibility = u) : (Object.hasOwnProperty.call(t, u) ? this.raise(Q.DuplicateModifier, {
                            at: l
                        }, u) : (enforceOrder(l, u, "static", "readonly"),
                        enforceOrder(l, u, "static", "override"),
                        enforceOrder(l, u, "override", "readonly"),
                        enforceOrder(l, u, "abstract", "override"),
                        incompatible(l, u, "declare", "override"),
                        incompatible(l, u, "static", "abstract")),
                        t[u] = !0),
                        null != i && i.includes(u) && this.raise(a, {
                            at: l
                        }, u)
                    }
                }
                tsIsListTerminator(t) {
                    switch (t) {
                    case "EnumMembers":
                    case "TypeMembers":
                        return this.match(8);
                    case "HeritageClauseElement":
                        return this.match(5);
                    case "TupleElementTypes":
                        return this.match(3);
                    case "TypeParametersOrArguments":
                        return this.match(46)
                    }
                    throw new Error("Unreachable")
                }
                tsParseList(t, r) {
                    const i = [];
                    for (; !this.tsIsListTerminator(t); )
                        i.push(r());
                    return i
                }
                tsParseDelimitedList(t, r, i) {
                    return function nonNull(t) {
                        if (null == t)
                            throw new Error(`Unexpected ${t} value.`);
                        return t
                    }(this.tsParseDelimitedListWorker(t, r, !0, i))
                }
                tsParseDelimitedListWorker(t, r, i, a) {
                    const o = [];
                    let l = -1;
                    for (; !this.tsIsListTerminator(t); ) {
                        l = -1;
                        const a = r();
                        if (null == a)
                            return;
                        if (o.push(a),
                        !this.eat(12)) {
                            if (this.tsIsListTerminator(t))
                                break;
                            return void (i && this.expect(12))
                        }
                        l = this.state.lastTokStart
                    }
                    return a && (a.value = l),
                    o
                }
                tsParseBracketedList(t, r, i, a, o) {
                    a || (i ? this.expect(0) : this.expect(45));
                    const l = this.tsParseDelimitedList(t, r, o);
                    return i ? this.expect(3) : this.expect(46),
                    l
                }
                tsParseImportType() {
                    const t = this.startNode();
                    return this.expect(79),
                    this.expect(10),
                    this.match(125) || this.raise(Q.UnsupportedImportTypeArgument, {
                        at: this.state.startLoc
                    }),
                    t.argument = this.parseExprAtom(),
                    this.expect(11),
                    this.eat(16) && (t.qualifier = this.tsParseEntityName(!0)),
                    this.match(45) && (t.typeParameters = this.tsParseTypeArguments()),
                    this.finishNode(t, "TSImportType")
                }
                tsParseEntityName(t) {
                    let r = this.parseIdentifier();
                    for (; this.eat(16); ) {
                        const i = this.startNodeAtNode(r);
                        i.left = r,
                        i.right = this.parseIdentifier(t),
                        r = this.finishNode(i, "TSQualifiedName")
                    }
                    return r
                }
                tsParseTypeReference() {
                    const t = this.startNode();
                    return t.typeName = this.tsParseEntityName(!1),
                    !this.hasPrecedingLineBreak() && this.match(45) && (t.typeParameters = this.tsParseTypeArguments()),
                    this.finishNode(t, "TSTypeReference")
                }
                tsParseThisTypePredicate(t) {
                    this.next();
                    const r = this.startNodeAtNode(t);
                    return r.parameterName = t,
                    r.typeAnnotation = this.tsParseTypeAnnotation(!1),
                    r.asserts = !1,
                    this.finishNode(r, "TSTypePredicate")
                }
                tsParseThisTypeNode() {
                    const t = this.startNode();
                    return this.next(),
                    this.finishNode(t, "TSThisType")
                }
                tsParseTypeQuery() {
                    const t = this.startNode();
                    return this.expect(83),
                    this.match(79) ? t.exprName = this.tsParseImportType() : t.exprName = this.tsParseEntityName(!0),
                    this.finishNode(t, "TSTypeQuery")
                }
                tsParseTypeParameter() {
                    const t = this.startNode();
                    return t.name = this.tsParseTypeParameterName(),
                    t.constraint = this.tsEatThenParseType(77),
                    t.default = this.tsEatThenParseType(29),
                    this.finishNode(t, "TSTypeParameter")
                }
                tsTryParseTypeParameters() {
                    if (this.match(45))
                        return this.tsParseTypeParameters()
                }
                tsParseTypeParameters() {
                    const t = this.startNode();
                    this.match(45) || this.match(134) ? this.next() : this.unexpected();
                    const r = {
                        value: -1
                    };
                    return t.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this), !1, !0, r),
                    0 === t.params.length && this.raise(Q.EmptyTypeParameters, {
                        node: t
                    }),
                    -1 !== r.value && this.addExtra(t, "trailingComma", r.value),
                    this.finishNode(t, "TSTypeParameterDeclaration")
                }
                tsTryNextParseConstantContext() {
                    return 71 === this.lookahead().type ? (this.next(),
                    this.tsParseTypeReference()) : null
                }
                tsFillSignature(t, r) {
                    const i = 19 === t;
                    r.typeParameters = this.tsTryParseTypeParameters(),
                    this.expect(10),
                    r.parameters = this.tsParseBindingListForSignature(),
                    (i || this.match(t)) && (r.typeAnnotation = this.tsParseTypeOrTypePredicateAnnotation(t))
                }
                tsParseBindingListForSignature() {
                    return this.parseBindingList(11, 41).map(t=>("Identifier" !== t.type && "RestElement" !== t.type && "ObjectPattern" !== t.type && "ArrayPattern" !== t.type && this.raise(Q.UnsupportedSignatureParameterKind, {
                        node: t
                    }, t.type),
                    t))
                }
                tsParseTypeMemberSemicolon() {
                    this.eat(12) || this.isLineTerminator() || this.expect(13)
                }
                tsParseSignatureMember(t, r) {
                    return this.tsFillSignature(14, r),
                    this.tsParseTypeMemberSemicolon(),
                    this.finishNode(r, t)
                }
                tsIsUnambiguouslyIndexSignature() {
                    return this.next(),
                    !!tokenIsIdentifier(this.state.type) && (this.next(),
                    this.match(14))
                }
                tsTryParseIndexSignature(t) {
                    if (!this.match(0) || !this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this)))
                        return;
                    this.expect(0);
                    const r = this.parseIdentifier();
                    r.typeAnnotation = this.tsParseTypeAnnotation(),
                    this.resetEndLocation(r),
                    this.expect(3),
                    t.parameters = [r];
                    const i = this.tsTryParseTypeAnnotation();
                    return i && (t.typeAnnotation = i),
                    this.tsParseTypeMemberSemicolon(),
                    this.finishNode(t, "TSIndexSignature")
                }
                tsParsePropertyOrMethodSignature(t, r) {
                    this.eat(17) && (t.optional = !0);
                    const i = t;
                    if (this.match(10) || this.match(45)) {
                        r && this.raise(Q.ReadonlyForMethodSignature, {
                            node: t
                        });
                        const a = i;
                        a.kind && this.match(45) && this.raise(Q.AccesorCannotHaveTypeParameters, {
                            at: this.state.curPosition()
                        }),
                        this.tsFillSignature(14, a),
                        this.tsParseTypeMemberSemicolon();
                        const o = "parameters"
                          , u = "typeAnnotation";
                        if ("get" === a.kind)
                            a[o].length > 0 && (this.raise(l.BadGetterArity, {
                                at: this.state.curPosition()
                            }),
                            this.isThisParam(a[o][0]) && this.raise(Q.AccesorCannotDeclareThisParameter, {
                                at: this.state.curPosition()
                            }));
                        else if ("set" === a.kind) {
                            if (1 !== a[o].length)
                                this.raise(l.BadSetterArity, {
                                    at: this.state.curPosition()
                                });
                            else {
                                const t = a[o][0];
                                this.isThisParam(t) && this.raise(Q.AccesorCannotDeclareThisParameter, {
                                    at: this.state.curPosition()
                                }),
                                "Identifier" === t.type && t.optional && this.raise(Q.SetAccesorCannotHaveOptionalParameter, {
                                    at: this.state.curPosition()
                                }),
                                "RestElement" === t.type && this.raise(Q.SetAccesorCannotHaveRestParameter, {
                                    at: this.state.curPosition()
                                })
                            }
                            a[u] && this.raise(Q.SetAccesorCannotHaveReturnType, {
                                node: a[u]
                            })
                        } else
                            a.kind = "method";
                        return this.finishNode(a, "TSMethodSignature")
                    }
                    {
                        const t = i;
                        r && (t.readonly = !0);
                        const a = this.tsTryParseTypeAnnotation();
                        return a && (t.typeAnnotation = a),
                        this.tsParseTypeMemberSemicolon(),
                        this.finishNode(t, "TSPropertySignature")
                    }
                }
                tsParseTypeMember() {
                    const t = this.startNode();
                    if (this.match(10) || this.match(45))
                        return this.tsParseSignatureMember("TSCallSignatureDeclaration", t);
                    if (this.match(73)) {
                        const r = this.startNode();
                        return this.next(),
                        this.match(10) || this.match(45) ? this.tsParseSignatureMember("TSConstructSignatureDeclaration", t) : (t.key = this.createIdentifier(r, "new"),
                        this.tsParsePropertyOrMethodSignature(t, !1))
                    }
                    this.tsParseModifiers(t, ["readonly"], ["declare", "abstract", "private", "protected", "public", "static", "override"], Q.InvalidModifierOnTypeMember);
                    const r = this.tsTryParseIndexSignature(t);
                    return r || (this.parsePropertyName(t),
                    t.computed || "Identifier" !== t.key.type || "get" !== t.key.name && "set" !== t.key.name || !this.tsTokenCanFollowModifier() || (t.kind = t.key.name,
                    this.parsePropertyName(t)),
                    this.tsParsePropertyOrMethodSignature(t, !!t.readonly))
                }
                tsParseTypeLiteral() {
                    const t = this.startNode();
                    return t.members = this.tsParseObjectTypeMembers(),
                    this.finishNode(t, "TSTypeLiteral")
                }
                tsParseObjectTypeMembers() {
                    this.expect(5);
                    const t = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
                    return this.expect(8),
                    t
                }
                tsIsStartOfMappedType() {
                    return this.next(),
                    this.eat(49) ? this.isContextual(114) : (this.isContextual(114) && this.next(),
                    !!this.match(0) && (this.next(),
                    !!this.tsIsIdentifier() && (this.next(),
                    this.match(54))))
                }
                tsParseMappedTypeParameter() {
                    const t = this.startNode();
                    return t.name = this.tsParseTypeParameterName(),
                    t.constraint = this.tsExpectThenParseType(54),
                    this.finishNode(t, "TSTypeParameter")
                }
                tsParseMappedType() {
                    const t = this.startNode();
                    return this.expect(5),
                    this.match(49) ? (t.readonly = this.state.value,
                    this.next(),
                    this.expectContextual(114)) : this.eatContextual(114) && (t.readonly = !0),
                    this.expect(0),
                    t.typeParameter = this.tsParseMappedTypeParameter(),
                    t.nameType = this.eatContextual(89) ? this.tsParseType() : null,
                    this.expect(3),
                    this.match(49) ? (t.optional = this.state.value,
                    this.next(),
                    this.expect(17)) : this.eat(17) && (t.optional = !0),
                    t.typeAnnotation = this.tsTryParseType(),
                    this.semicolon(),
                    this.expect(8),
                    this.finishNode(t, "TSMappedType")
                }
                tsParseTupleType() {
                    const t = this.startNode();
                    t.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), !0, !1);
                    let r = !1
                      , i = null;
                    return t.elementTypes.forEach(t=>{
                        var a;
                        let {type: o} = t;
                        !r || "TSRestType" === o || "TSOptionalType" === o || "TSNamedTupleMember" === o && t.optional || this.raise(Q.OptionalTypeBeforeRequired, {
                            node: t
                        }),
                        r = r || "TSNamedTupleMember" === o && t.optional || "TSOptionalType" === o,
                        "TSRestType" === o && (o = (t = t.typeAnnotation).type);
                        const l = "TSNamedTupleMember" === o;
                        i = null != (a = i) ? a : l,
                        i !== l && this.raise(Q.MixedLabeledAndUnlabeledElements, {
                            node: t
                        })
                    }
                    ),
                    this.finishNode(t, "TSTupleType")
                }
                tsParseTupleElementType() {
                    const {start: t, startLoc: r} = this.state
                      , i = this.eat(21);
                    let a = this.tsParseType();
                    const o = this.eat(17);
                    if (this.eat(14)) {
                        const t = this.startNodeAtNode(a);
                        t.optional = o,
                        "TSTypeReference" !== a.type || a.typeParameters || "Identifier" !== a.typeName.type ? (this.raise(Q.InvalidTupleMemberLabel, {
                            node: a
                        }),
                        t.label = a) : t.label = a.typeName,
                        t.elementType = this.tsParseType(),
                        a = this.finishNode(t, "TSNamedTupleMember")
                    } else if (o) {
                        const t = this.startNodeAtNode(a);
                        t.typeAnnotation = a,
                        a = this.finishNode(t, "TSOptionalType")
                    }
                    if (i) {
                        const i = this.startNodeAt(t, r);
                        i.typeAnnotation = a,
                        a = this.finishNode(i, "TSRestType")
                    }
                    return a
                }
                tsParseParenthesizedType() {
                    const t = this.startNode();
                    return this.expect(10),
                    t.typeAnnotation = this.tsParseType(),
                    this.expect(11),
                    this.finishNode(t, "TSParenthesizedType")
                }
                tsParseFunctionOrConstructorType(t, r) {
                    const i = this.startNode();
                    return "TSConstructorType" === t && (i.abstract = !!r,
                    r && this.next(),
                    this.next()),
                    this.tsFillSignature(19, i),
                    this.finishNode(i, t)
                }
                tsParseLiteralTypeNode() {
                    const t = this.startNode();
                    return t.literal = (()=>{
                        switch (this.state.type) {
                        case 126:
                        case 127:
                        case 125:
                        case 81:
                        case 82:
                            return this.parseExprAtom();
                        default:
                            throw this.unexpected()
                        }
                    }
                    )(),
                    this.finishNode(t, "TSLiteralType")
                }
                tsParseTemplateLiteralType() {
                    const t = this.startNode();
                    return t.literal = this.parseTemplate(!1),
                    this.finishNode(t, "TSLiteralType")
                }
                parseTemplateSubstitution() {
                    return this.state.inType ? this.tsParseType() : super.parseTemplateSubstitution()
                }
                tsParseThisTypeOrThisTypePredicate() {
                    const t = this.tsParseThisTypeNode();
                    return this.isContextual(109) && !this.hasPrecedingLineBreak() ? this.tsParseThisTypePredicate(t) : t
                }
                tsParseNonArrayType() {
                    switch (this.state.type) {
                    case 125:
                    case 126:
                    case 127:
                    case 81:
                    case 82:
                        return this.tsParseLiteralTypeNode();
                    case 49:
                        if ("-" === this.state.value) {
                            const t = this.startNode()
                              , r = this.lookahead();
                            if (126 !== r.type && 127 !== r.type)
                                throw this.unexpected();
                            return t.literal = this.parseMaybeUnary(),
                            this.finishNode(t, "TSLiteralType")
                        }
                        break;
                    case 74:
                        return this.tsParseThisTypeOrThisTypePredicate();
                    case 83:
                        return this.tsParseTypeQuery();
                    case 79:
                        return this.tsParseImportType();
                    case 5:
                        return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
                    case 0:
                        return this.tsParseTupleType();
                    case 10:
                        return this.tsParseParenthesizedType();
                    case 25:
                    case 24:
                        return this.tsParseTemplateLiteralType();
                    default:
                        {
                            const {type: t} = this.state;
                            if (tokenIsIdentifier(t) || 84 === t || 80 === t) {
                                const r = 84 === t ? "TSVoidKeyword" : 80 === t ? "TSNullKeyword" : function keywordTypeFromName(t) {
                                    switch (t) {
                                    case "any":
                                        return "TSAnyKeyword";
                                    case "boolean":
                                        return "TSBooleanKeyword";
                                    case "bigint":
                                        return "TSBigIntKeyword";
                                    case "never":
                                        return "TSNeverKeyword";
                                    case "number":
                                        return "TSNumberKeyword";
                                    case "object":
                                        return "TSObjectKeyword";
                                    case "string":
                                        return "TSStringKeyword";
                                    case "symbol":
                                        return "TSSymbolKeyword";
                                    case "undefined":
                                        return "TSUndefinedKeyword";
                                    case "unknown":
                                        return "TSUnknownKeyword";
                                    default:
                                        return
                                    }
                                }(this.state.value);
                                if (void 0 !== r && 46 !== this.lookaheadCharCode()) {
                                    const t = this.startNode();
                                    return this.next(),
                                    this.finishNode(t, r)
                                }
                                return this.tsParseTypeReference()
                            }
                        }
                    }
                    throw this.unexpected()
                }
                tsParseArrayTypeOrHigher() {
                    let t = this.tsParseNonArrayType();
                    for (; !this.hasPrecedingLineBreak() && this.eat(0); )
                        if (this.match(3)) {
                            const r = this.startNodeAtNode(t);
                            r.elementType = t,
                            this.expect(3),
                            t = this.finishNode(r, "TSArrayType")
                        } else {
                            const r = this.startNodeAtNode(t);
                            r.objectType = t,
                            r.indexType = this.tsParseType(),
                            this.expect(3),
                            t = this.finishNode(r, "TSIndexedAccessType")
                        }
                    return t
                }
                tsParseTypeOperator() {
                    const t = this.startNode()
                      , r = this.state.value;
                    return this.next(),
                    t.operator = r,
                    t.typeAnnotation = this.tsParseTypeOperatorOrHigher(),
                    "readonly" === r && this.tsCheckTypeAnnotationForReadOnly(t),
                    this.finishNode(t, "TSTypeOperator")
                }
                tsCheckTypeAnnotationForReadOnly(t) {
                    switch (t.typeAnnotation.type) {
                    case "TSTupleType":
                    case "TSArrayType":
                        return;
                    default:
                        this.raise(Q.UnexpectedReadonly, {
                            node: t
                        })
                    }
                }
                tsParseInferType() {
                    const t = this.startNode();
                    this.expectContextual(108);
                    const r = this.startNode();
                    return r.name = this.tsParseTypeParameterName(),
                    t.typeParameter = this.finishNode(r, "TSTypeParameter"),
                    this.finishNode(t, "TSInferType")
                }
                tsParseTypeOperatorOrHigher() {
                    return function tokenIsTSTypeOperator(t) {
                        return t >= 113 && t <= 115
                    }(this.state.type) && !this.state.containsEsc ? this.tsParseTypeOperator() : this.isContextual(108) ? this.tsParseInferType() : this.tsParseArrayTypeOrHigher()
                }
                tsParseUnionOrIntersectionType(t, r, i) {
                    const a = this.startNode()
                      , o = this.eat(i)
                      , l = [];
                    do {
                        l.push(r())
                    } while (this.eat(i));
                    return 1 !== l.length || o ? (a.types = l,
                    this.finishNode(a, t)) : l[0]
                }
                tsParseIntersectionTypeOrHigher() {
                    return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), 43)
                }
                tsParseUnionTypeOrHigher() {
                    return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), 41)
                }
                tsIsStartOfFunctionType() {
                    return !!this.match(45) || this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this))
                }
                tsSkipParameterStart() {
                    if (tokenIsIdentifier(this.state.type) || this.match(74))
                        return this.next(),
                        !0;
                    if (this.match(5)) {
                        let t = 1;
                        for (this.next(); t > 0; )
                            this.match(5) ? ++t : this.match(8) && --t,
                            this.next();
                        return !0
                    }
                    if (this.match(0)) {
                        let t = 1;
                        for (this.next(); t > 0; )
                            this.match(0) ? ++t : this.match(3) && --t,
                            this.next();
                        return !0
                    }
                    return !1
                }
                tsIsUnambiguouslyStartOfFunctionType() {
                    if (this.next(),
                    this.match(11) || this.match(21))
                        return !0;
                    if (this.tsSkipParameterStart()) {
                        if (this.match(14) || this.match(12) || this.match(17) || this.match(29))
                            return !0;
                        if (this.match(11) && (this.next(),
                        this.match(19)))
                            return !0
                    }
                    return !1
                }
                tsParseTypeOrTypePredicateAnnotation(t) {
                    return this.tsInType(()=>{
                        const r = this.startNode();
                        this.expect(t);
                        const i = this.startNode()
                          , a = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
                        if (a && this.match(74)) {
                            let t = this.tsParseThisTypeOrThisTypePredicate();
                            return "TSThisType" === t.type ? (i.parameterName = t,
                            i.asserts = !0,
                            i.typeAnnotation = null,
                            t = this.finishNode(i, "TSTypePredicate")) : (this.resetStartLocationFromNode(t, i),
                            t.asserts = !0),
                            r.typeAnnotation = t,
                            this.finishNode(r, "TSTypeAnnotation")
                        }
                        const o = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
                        if (!o)
                            return a ? (i.parameterName = this.parseIdentifier(),
                            i.asserts = a,
                            i.typeAnnotation = null,
                            r.typeAnnotation = this.finishNode(i, "TSTypePredicate"),
                            this.finishNode(r, "TSTypeAnnotation")) : this.tsParseTypeAnnotation(!1, r);
                        const l = this.tsParseTypeAnnotation(!1);
                        return i.parameterName = o,
                        i.typeAnnotation = l,
                        i.asserts = a,
                        r.typeAnnotation = this.finishNode(i, "TSTypePredicate"),
                        this.finishNode(r, "TSTypeAnnotation")
                    }
                    )
                }
                tsTryParseTypeOrTypePredicateAnnotation() {
                    return this.match(14) ? this.tsParseTypeOrTypePredicateAnnotation(14) : void 0
                }
                tsTryParseTypeAnnotation() {
                    return this.match(14) ? this.tsParseTypeAnnotation() : void 0
                }
                tsTryParseType() {
                    return this.tsEatThenParseType(14)
                }
                tsParseTypePredicatePrefix() {
                    const t = this.parseIdentifier();
                    if (this.isContextual(109) && !this.hasPrecedingLineBreak())
                        return this.next(),
                        t
                }
                tsParseTypePredicateAsserts() {
                    if (102 !== this.state.type)
                        return !1;
                    const t = this.state.containsEsc;
                    return this.next(),
                    !(!tokenIsIdentifier(this.state.type) && !this.match(74)) && (t && this.raise(l.InvalidEscapedReservedWord, {
                        at: this.state.lastTokStartLoc
                    }, "asserts"),
                    !0)
                }
                tsParseTypeAnnotation(t=!0, r=this.startNode()) {
                    return this.tsInType(()=>{
                        t && this.expect(14),
                        r.typeAnnotation = this.tsParseType()
                    }
                    ),
                    this.finishNode(r, "TSTypeAnnotation")
                }
                tsParseType() {
                    assert(this.state.inType);
                    const t = this.tsParseNonConditionalType();
                    if (this.hasPrecedingLineBreak() || !this.eat(77))
                        return t;
                    const r = this.startNodeAtNode(t);
                    return r.checkType = t,
                    r.extendsType = this.tsParseNonConditionalType(),
                    this.expect(17),
                    r.trueType = this.tsParseType(),
                    this.expect(14),
                    r.falseType = this.tsParseType(),
                    this.finishNode(r, "TSConditionalType")
                }
                isAbstractConstructorSignature() {
                    return this.isContextual(116) && 73 === this.lookahead().type
                }
                tsParseNonConditionalType() {
                    return this.tsIsStartOfFunctionType() ? this.tsParseFunctionOrConstructorType("TSFunctionType") : this.match(73) ? this.tsParseFunctionOrConstructorType("TSConstructorType") : this.isAbstractConstructorSignature() ? this.tsParseFunctionOrConstructorType("TSConstructorType", !0) : this.tsParseUnionTypeOrHigher()
                }
                tsParseTypeAssertion() {
                    this.getPluginOption("typescript", "disallowAmbiguousJSXLike") && this.raise(Q.ReservedTypeAssertion, {
                        at: this.state.startLoc
                    });
                    const t = this.startNode()
                      , r = this.tsTryNextParseConstantContext();
                    return t.typeAnnotation = r || this.tsNextThenParseType(),
                    this.expect(46),
                    t.expression = this.parseMaybeUnary(),
                    this.finishNode(t, "TSTypeAssertion")
                }
                tsParseHeritageClause(t) {
                    const r = this.state.startLoc
                      , i = this.tsParseDelimitedList("HeritageClauseElement", this.tsParseExpressionWithTypeArguments.bind(this));
                    return i.length || this.raise(Q.EmptyHeritageClauseType, {
                        at: r
                    }, t),
                    i
                }
                tsParseExpressionWithTypeArguments() {
                    const t = this.startNode();
                    return t.expression = this.tsParseEntityName(!1),
                    this.match(45) && (t.typeParameters = this.tsParseTypeArguments()),
                    this.finishNode(t, "TSExpressionWithTypeArguments")
                }
                tsParseInterfaceDeclaration(t) {
                    tokenIsIdentifier(this.state.type) ? (t.id = this.parseIdentifier(),
                    this.checkLVal(t.id, "typescript interface declaration", 130)) : (t.id = null,
                    this.raise(Q.MissingInterfaceName, {
                        at: this.state.startLoc
                    })),
                    t.typeParameters = this.tsTryParseTypeParameters(),
                    this.eat(77) && (t.extends = this.tsParseHeritageClause("extends"));
                    const r = this.startNode();
                    return r.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this)),
                    t.body = this.finishNode(r, "TSInterfaceBody"),
                    this.finishNode(t, "TSInterfaceDeclaration")
                }
                tsParseTypeAliasDeclaration(t) {
                    return t.id = this.parseIdentifier(),
                    this.checkLVal(t.id, "typescript type alias", 2),
                    t.typeParameters = this.tsTryParseTypeParameters(),
                    t.typeAnnotation = this.tsInType(()=>{
                        if (this.expect(29),
                        this.isContextual(107) && 16 !== this.lookahead().type) {
                            const t = this.startNode();
                            return this.next(),
                            this.finishNode(t, "TSIntrinsicKeyword")
                        }
                        return this.tsParseType()
                    }
                    ),
                    this.semicolon(),
                    this.finishNode(t, "TSTypeAliasDeclaration")
                }
                tsInNoContext(t) {
                    const r = this.state.context;
                    this.state.context = [r[0]];
                    try {
                        return t()
                    } finally {
                        this.state.context = r
                    }
                }
                tsInType(t) {
                    const r = this.state.inType;
                    this.state.inType = !0;
                    try {
                        return t()
                    } finally {
                        this.state.inType = r
                    }
                }
                tsEatThenParseType(t) {
                    return this.match(t) ? this.tsNextThenParseType() : void 0
                }
                tsExpectThenParseType(t) {
                    return this.tsDoThenParseType(()=>this.expect(t))
                }
                tsNextThenParseType() {
                    return this.tsDoThenParseType(()=>this.next())
                }
                tsDoThenParseType(t) {
                    return this.tsInType(()=>(t(),
                    this.tsParseType()))
                }
                tsParseEnumMember() {
                    const t = this.startNode();
                    return t.id = this.match(125) ? this.parseExprAtom() : this.parseIdentifier(!0),
                    this.eat(29) && (t.initializer = this.parseMaybeAssignAllowIn()),
                    this.finishNode(t, "TSEnumMember")
                }
                tsParseEnumDeclaration(t, r) {
                    return r && (t.const = !0),
                    t.id = this.parseIdentifier(),
                    this.checkLVal(t.id, "typescript enum declaration", r ? 779 : 267),
                    this.expect(5),
                    t.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this)),
                    this.expect(8),
                    this.finishNode(t, "TSEnumDeclaration")
                }
                tsParseModuleBlock() {
                    const t = this.startNode();
                    return this.scope.enter(0),
                    this.expect(5),
                    this.parseBlockOrModuleBlockBody(t.body = [], void 0, !0, 8),
                    this.scope.exit(),
                    this.finishNode(t, "TSModuleBlock")
                }
                tsParseModuleOrNamespaceDeclaration(t, r=!1) {
                    if (t.id = this.parseIdentifier(),
                    r || this.checkLVal(t.id, "module or namespace declaration", 1024),
                    this.eat(16)) {
                        const r = this.startNode();
                        this.tsParseModuleOrNamespaceDeclaration(r, !0),
                        t.body = r
                    } else
                        this.scope.enter(256),
                        this.prodParam.enter(0),
                        t.body = this.tsParseModuleBlock(),
                        this.prodParam.exit(),
                        this.scope.exit();
                    return this.finishNode(t, "TSModuleDeclaration")
                }
                tsParseAmbientExternalModuleDeclaration(t) {
                    return this.isContextual(105) ? (t.global = !0,
                    t.id = this.parseIdentifier()) : this.match(125) ? t.id = this.parseExprAtom() : this.unexpected(),
                    this.match(5) ? (this.scope.enter(256),
                    this.prodParam.enter(0),
                    t.body = this.tsParseModuleBlock(),
                    this.prodParam.exit(),
                    this.scope.exit()) : this.semicolon(),
                    this.finishNode(t, "TSModuleDeclaration")
                }
                tsParseImportEqualsDeclaration(t, r) {
                    t.isExport = r || !1,
                    t.id = this.parseIdentifier(),
                    this.checkLVal(t.id, "import equals declaration", 9),
                    this.expect(29);
                    const i = this.tsParseModuleReference();
                    return "type" === t.importKind && "TSExternalModuleReference" !== i.type && this.raise(Q.ImportAliasHasImportType, {
                        node: i
                    }),
                    t.moduleReference = i,
                    this.semicolon(),
                    this.finishNode(t, "TSImportEqualsDeclaration")
                }
                tsIsExternalModuleReference() {
                    return this.isContextual(112) && 40 === this.lookaheadCharCode()
                }
                tsParseModuleReference() {
                    return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(!1)
                }
                tsParseExternalModuleReference() {
                    const t = this.startNode();
                    if (this.expectContextual(112),
                    this.expect(10),
                    !this.match(125))
                        throw this.unexpected();
                    return t.expression = this.parseExprAtom(),
                    this.expect(11),
                    this.finishNode(t, "TSExternalModuleReference")
                }
                tsLookAhead(t) {
                    const r = this.state.clone()
                      , i = t();
                    return this.state = r,
                    i
                }
                tsTryParseAndCatch(t) {
                    const r = this.tryParse(r=>t() || r());
                    if (!r.aborted && r.node)
                        return r.error && (this.state = r.failState),
                        r.node
                }
                tsTryParse(t) {
                    const r = this.state.clone()
                      , i = t();
                    return void 0 !== i && !1 !== i ? i : void (this.state = r)
                }
                tsTryParseDeclare(t) {
                    if (this.isLineTerminator())
                        return;
                    let r, i = this.state.type;
                    return this.isContextual(95) && (i = 70,
                    r = "let"),
                    this.tsInAmbientContext(()=>{
                        switch (i) {
                        case 64:
                            return t.declare = !0,
                            this.parseFunctionStatement(t, !1, !0);
                        case 76:
                            return t.declare = !0,
                            this.parseClass(t, !0, !1);
                        case 71:
                            if (this.match(71) && this.isLookaheadContextual("enum"))
                                return this.expect(71),
                                this.expectContextual(118),
                                this.tsParseEnumDeclaration(t, !0);
                        case 70:
                            return r = r || this.state.value,
                            this.parseVarStatement(t, r);
                        case 105:
                            return this.tsParseAmbientExternalModuleDeclaration(t);
                        default:
                            if (tokenIsIdentifier(i))
                                return this.tsParseDeclaration(t, this.state.value, !0)
                        }
                    }
                    )
                }
                tsTryParseExportDeclaration() {
                    return this.tsParseDeclaration(this.startNode(), this.state.value, !0)
                }
                tsParseExpressionStatement(t, r) {
                    switch (r.name) {
                    case "declare":
                        {
                            const r = this.tsTryParseDeclare(t);
                            if (r)
                                return r.declare = !0,
                                r;
                            break
                        }
                    case "global":
                        if (this.match(5)) {
                            this.scope.enter(256),
                            this.prodParam.enter(0);
                            const i = t;
                            return i.global = !0,
                            i.id = r,
                            i.body = this.tsParseModuleBlock(),
                            this.scope.exit(),
                            this.prodParam.exit(),
                            this.finishNode(i, "TSModuleDeclaration")
                        }
                        break;
                    default:
                        return this.tsParseDeclaration(t, r.name, !1)
                    }
                }
                tsParseDeclaration(t, r, i) {
                    switch (r) {
                    case "abstract":
                        if (this.tsCheckLineTerminator(i) && (this.match(76) || tokenIsIdentifier(this.state.type)))
                            return this.tsParseAbstractDeclaration(t);
                        break;
                    case "enum":
                        if (i || tokenIsIdentifier(this.state.type))
                            return i && this.next(),
                            this.tsParseEnumDeclaration(t, !1);
                        break;
                    case "interface":
                        if (this.tsCheckLineTerminator(i) && tokenIsIdentifier(this.state.type))
                            return this.tsParseInterfaceDeclaration(t);
                        break;
                    case "module":
                        if (this.tsCheckLineTerminator(i)) {
                            if (this.match(125))
                                return this.tsParseAmbientExternalModuleDeclaration(t);
                            if (tokenIsIdentifier(this.state.type))
                                return this.tsParseModuleOrNamespaceDeclaration(t)
                        }
                        break;
                    case "namespace":
                        if (this.tsCheckLineTerminator(i) && tokenIsIdentifier(this.state.type))
                            return this.tsParseModuleOrNamespaceDeclaration(t);
                        break;
                    case "type":
                        if (this.tsCheckLineTerminator(i) && tokenIsIdentifier(this.state.type))
                            return this.tsParseTypeAliasDeclaration(t)
                    }
                }
                tsCheckLineTerminator(t) {
                    return t ? !this.hasFollowingLineBreak() && (this.next(),
                    !0) : !this.isLineTerminator()
                }
                tsTryParseGenericAsyncArrowFunction(t, r) {
                    if (!this.match(45))
                        return;
                    const i = this.state.maybeInArrowParameters;
                    this.state.maybeInArrowParameters = !0;
                    const a = this.tsTryParseAndCatch(()=>{
                        const i = this.startNodeAt(t, r);
                        return i.typeParameters = this.tsParseTypeParameters(),
                        super.parseFunctionParams(i),
                        i.returnType = this.tsTryParseTypeOrTypePredicateAnnotation(),
                        this.expect(19),
                        i
                    }
                    );
                    return this.state.maybeInArrowParameters = i,
                    a ? this.parseArrowExpression(a, null, !0) : void 0
                }
                tsParseTypeArguments() {
                    const t = this.startNode();
                    return t.params = this.tsInType(()=>this.tsInNoContext(()=>(this.expect(45),
                    this.tsParseDelimitedList("TypeParametersOrArguments", this.tsParseType.bind(this))))),
                    0 === t.params.length && this.raise(Q.EmptyTypeArguments, {
                        node: t
                    }),
                    this.expect(46),
                    this.finishNode(t, "TSTypeParameterInstantiation")
                }
                tsIsDeclarationStart() {
                    return function tokenIsTSDeclarationStart(t) {
                        return t >= 116 && t <= 122
                    }(this.state.type)
                }
                isExportDefaultSpecifier() {
                    return !this.tsIsDeclarationStart() && super.isExportDefaultSpecifier()
                }
                parseAssignableListItem(t, r) {
                    const i = this.state.start
                      , a = this.state.startLoc;
                    let o, l = !1, u = !1;
                    if (void 0 !== t) {
                        const r = {};
                        this.tsParseModifiers(r, ["public", "private", "protected", "override", "readonly"]),
                        o = r.accessibility,
                        u = r.override,
                        l = r.readonly,
                        !1 === t && (o || l || u) && this.raise(Q.UnexpectedParameterModifier, {
                            at: a
                        })
                    }
                    const p = this.parseMaybeDefault();
                    this.parseAssignableListItemTypes(p);
                    const c = this.parseMaybeDefault(p.start, p.loc.start, p);
                    if (o || l || u) {
                        const t = this.startNodeAt(i, a);
                        return r.length && (t.decorators = r),
                        o && (t.accessibility = o),
                        l && (t.readonly = l),
                        u && (t.override = u),
                        "Identifier" !== c.type && "AssignmentPattern" !== c.type && this.raise(Q.UnsupportedParameterPropertyKind, {
                            node: t
                        }),
                        t.parameter = c,
                        this.finishNode(t, "TSParameterProperty")
                    }
                    return r.length && (p.decorators = r),
                    c
                }
                parseFunctionBodyAndFinish(t, r, i=!1) {
                    this.match(14) && (t.returnType = this.tsParseTypeOrTypePredicateAnnotation(14));
                    const a = "FunctionDeclaration" === r ? "TSDeclareFunction" : "ClassMethod" === r || "ClassPrivateMethod" === r ? "TSDeclareMethod" : void 0;
                    a && !this.match(5) && this.isLineTerminator() ? this.finishNode(t, a) : "TSDeclareFunction" === a && this.state.isAmbientContext && (this.raise(Q.DeclareFunctionHasImplementation, {
                        node: t
                    }),
                    t.declare) ? super.parseFunctionBodyAndFinish(t, a, i) : super.parseFunctionBodyAndFinish(t, r, i)
                }
                registerFunctionStatementId(t) {
                    !t.body && t.id ? this.checkLVal(t.id, "function name", 1024) : super.registerFunctionStatementId(...arguments)
                }
                tsCheckForInvalidTypeCasts(t) {
                    t.forEach(t=>{
                        "TSTypeCastExpression" === (null == t ? void 0 : t.type) && this.raise(Q.UnexpectedTypeAnnotation, {
                            node: t.typeAnnotation
                        })
                    }
                    )
                }
                toReferencedList(t, r) {
                    return this.tsCheckForInvalidTypeCasts(t),
                    t
                }
                parseArrayLike(...t) {
                    const r = super.parseArrayLike(...t);
                    return "ArrayExpression" === r.type && this.tsCheckForInvalidTypeCasts(r.elements),
                    r
                }
                parseSubscript(t, r, i, a, o) {
                    if (!this.hasPrecedingLineBreak() && this.match(35)) {
                        this.state.canStartJSXElement = !1,
                        this.next();
                        const a = this.startNodeAt(r, i);
                        return a.expression = t,
                        this.finishNode(a, "TSNonNullExpression")
                    }
                    let l = !1;
                    if (this.match(18) && 60 === this.lookaheadCharCode()) {
                        if (a)
                            return o.stop = !0,
                            t;
                        o.optionalChainMember = l = !0,
                        this.next()
                    }
                    if (this.match(45)) {
                        let u;
                        const p = this.tsTryParseAndCatch(()=>{
                            if (!a && this.atPossibleAsyncArrow(t)) {
                                const t = this.tsTryParseGenericAsyncArrowFunction(r, i);
                                if (t)
                                    return t
                            }
                            const p = this.startNodeAt(r, i);
                            p.callee = t;
                            const c = this.tsParseTypeArguments();
                            if (c) {
                                if (l && !this.match(10) && (u = this.state.curPosition(),
                                this.unexpected()),
                                !a && this.eat(10))
                                    return p.arguments = this.parseCallExpressionArguments(11, !1),
                                    this.tsCheckForInvalidTypeCasts(p.arguments),
                                    p.typeParameters = c,
                                    o.optionalChainMember && (p.optional = l),
                                    this.finishCallExpression(p, o.optionalChainMember);
                                if (tokenIsTemplate(this.state.type)) {
                                    const a = this.parseTaggedTemplateExpression(t, r, i, o);
                                    return a.typeParameters = c,
                                    a
                                }
                            }
                            this.unexpected()
                        }
                        );
                        if (u && this.unexpected(u, 10),
                        p)
                            return p
                    }
                    return super.parseSubscript(t, r, i, a, o)
                }
                parseNewArguments(t) {
                    if (this.match(45)) {
                        const r = this.tsTryParseAndCatch(()=>{
                            const t = this.tsParseTypeArguments();
                            return this.match(10) || this.unexpected(),
                            t
                        }
                        );
                        r && (t.typeParameters = r)
                    }
                    super.parseNewArguments(t)
                }
                parseExprOp(t, r, i, a) {
                    if (tokenOperatorPrecedence(54) > a && !this.hasPrecedingLineBreak() && this.isContextual(89)) {
                        const o = this.startNodeAt(r, i);
                        o.expression = t;
                        const l = this.tsTryNextParseConstantContext();
                        return o.typeAnnotation = l || this.tsNextThenParseType(),
                        this.finishNode(o, "TSAsExpression"),
                        this.reScan_lt_gt(),
                        this.parseExprOp(o, r, i, a)
                    }
                    return super.parseExprOp(t, r, i, a)
                }
                checkReservedWord(t, r, i, a) {}
                checkDuplicateExports() {}
                parseImport(t) {
                    if (t.importKind = "value",
                    tokenIsIdentifier(this.state.type) || this.match(51) || this.match(5)) {
                        let r = this.lookahead();
                        if (this.isContextual(122) && 12 !== r.type && 93 !== r.type && 29 !== r.type && (t.importKind = "type",
                        this.next(),
                        r = this.lookahead()),
                        tokenIsIdentifier(this.state.type) && 29 === r.type)
                            return this.tsParseImportEqualsDeclaration(t)
                    }
                    const r = super.parseImport(t);
                    return "type" === r.importKind && r.specifiers.length > 1 && "ImportDefaultSpecifier" === r.specifiers[0].type && this.raise(Q.TypeImportCannotSpecifyDefaultAndNamed, {
                        node: r
                    }),
                    r
                }
                parseExport(t) {
                    if (this.match(79))
                        return this.next(),
                        this.isContextual(122) && 61 !== this.lookaheadCharCode() ? (t.importKind = "type",
                        this.next()) : t.importKind = "value",
                        this.tsParseImportEqualsDeclaration(t, !0);
                    if (this.eat(29)) {
                        const r = t;
                        return r.expression = this.parseExpression(),
                        this.semicolon(),
                        this.finishNode(r, "TSExportAssignment")
                    }
                    if (this.eatContextual(89)) {
                        const r = t;
                        return this.expectContextual(120),
                        r.id = this.parseIdentifier(),
                        this.semicolon(),
                        this.finishNode(r, "TSNamespaceExportDeclaration")
                    }
                    return this.isContextual(122) && 5 === this.lookahead().type ? (this.next(),
                    t.exportKind = "type") : t.exportKind = "value",
                    super.parseExport(t)
                }
                isAbstractClass() {
                    return this.isContextual(116) && 76 === this.lookahead().type
                }
                parseExportDefaultExpression() {
                    if (this.isAbstractClass()) {
                        const t = this.startNode();
                        return this.next(),
                        t.abstract = !0,
                        this.parseClass(t, !0, !0),
                        t
                    }
                    if (this.match(121)) {
                        const t = this.startNode();
                        this.next();
                        const r = this.tsParseInterfaceDeclaration(t);
                        if (r)
                            return r
                    }
                    return super.parseExportDefaultExpression()
                }
                parseStatementContent(t, r) {
                    if (71 === this.state.type) {
                        if (118 === this.lookahead().type) {
                            const t = this.startNode();
                            return this.next(),
                            this.expectContextual(118),
                            this.tsParseEnumDeclaration(t, !0)
                        }
                    }
                    return super.parseStatementContent(t, r)
                }
                parseAccessModifier() {
                    return this.tsParseModifier(["public", "protected", "private"])
                }
                tsHasSomeModifiers(t, r) {
                    return r.some(r=>tsIsAccessModifier(r) ? t.accessibility === r : !!t[r])
                }
                tsIsStartOfStaticBlocks() {
                    return this.isContextual(100) && 123 === this.lookaheadCharCode()
                }
                parseClassMember(t, r, i) {
                    const a = ["declare", "private", "public", "protected", "override", "abstract", "readonly", "static"];
                    this.tsParseModifiers(r, a, void 0, void 0, !0);
                    const callParseClassMemberWithIsStatic = ()=>{
                        this.tsIsStartOfStaticBlocks() ? (this.next(),
                        this.next(),
                        this.tsHasSomeModifiers(r, a) && this.raise(Q.StaticBlockCannotHaveModifier, {
                            at: this.state.curPosition()
                        }),
                        this.parseClassStaticBlock(t, r)) : this.parseClassMemberWithIsStatic(t, r, i, !!r.static)
                    }
                    ;
                    r.declare ? this.tsInAmbientContext(callParseClassMemberWithIsStatic) : callParseClassMemberWithIsStatic()
                }
                parseClassMemberWithIsStatic(t, r, i, a) {
                    const o = this.tsTryParseIndexSignature(r);
                    if (o)
                        return t.body.push(o),
                        r.abstract && this.raise(Q.IndexSignatureHasAbstract, {
                            node: r
                        }),
                        r.accessibility && this.raise(Q.IndexSignatureHasAccessibility, {
                            node: r
                        }, r.accessibility),
                        r.declare && this.raise(Q.IndexSignatureHasDeclare, {
                            node: r
                        }),
                        void (r.override && this.raise(Q.IndexSignatureHasOverride, {
                            node: r
                        }));
                    !this.state.inAbstractClass && r.abstract && this.raise(Q.NonAbstractClassHasAbstractMethod, {
                        node: r
                    }),
                    r.override && (i.hadSuperClass || this.raise(Q.OverrideNotInSubClass, {
                        node: r
                    })),
                    super.parseClassMemberWithIsStatic(t, r, i, a)
                }
                parsePostMemberNameModifiers(t) {
                    this.eat(17) && (t.optional = !0),
                    t.readonly && this.match(10) && this.raise(Q.ClassMethodHasReadonly, {
                        node: t
                    }),
                    t.declare && this.match(10) && this.raise(Q.ClassMethodHasDeclare, {
                        node: t
                    })
                }
                parseExpressionStatement(t, r) {
                    return ("Identifier" === r.type ? this.tsParseExpressionStatement(t, r) : void 0) || super.parseExpressionStatement(t, r)
                }
                shouldParseExportDeclaration() {
                    return !!this.tsIsDeclarationStart() || super.shouldParseExportDeclaration()
                }
                parseConditional(t, r, i, a) {
                    if (!this.state.maybeInArrowParameters || !this.match(17))
                        return super.parseConditional(t, r, i, a);
                    const o = this.tryParse(()=>super.parseConditional(t, r, i));
                    return o.node ? (o.error && (this.state = o.failState),
                    o.node) : (o.error && super.setOptionalParametersError(a, o.error),
                    t)
                }
                parseParenItem(t, r, i) {
                    if (t = super.parseParenItem(t, r, i),
                    this.eat(17) && (t.optional = !0,
                    this.resetEndLocation(t)),
                    this.match(14)) {
                        const a = this.startNodeAt(r, i);
                        return a.expression = t,
                        a.typeAnnotation = this.tsParseTypeAnnotation(),
                        this.finishNode(a, "TSTypeCastExpression")
                    }
                    return t
                }
                parseExportDeclaration(t) {
                    const r = this.state.start
                      , i = this.state.startLoc
                      , a = this.eatContextual(117);
                    if (a && (this.isContextual(117) || !this.shouldParseExportDeclaration()))
                        throw this.raise(Q.ExpectedAmbientAfterExportDeclare, {
                            at: this.state.startLoc
                        });
                    let o;
                    return tokenIsIdentifier(this.state.type) && (o = this.tsTryParseExportDeclaration()),
                    o || (o = super.parseExportDeclaration(t)),
                    o && ("TSInterfaceDeclaration" === o.type || "TSTypeAliasDeclaration" === o.type || a) && (t.exportKind = "type"),
                    o && a && (this.resetStartLocation(o, r, i),
                    o.declare = !0),
                    o
                }
                parseClassId(t, r, i) {
                    if ((!r || i) && this.isContextual(106))
                        return;
                    super.parseClassId(t, r, i, t.declare ? 1024 : 139);
                    const a = this.tsTryParseTypeParameters();
                    a && (t.typeParameters = a)
                }
                parseClassPropertyAnnotation(t) {
                    !t.optional && this.eat(35) && (t.definite = !0);
                    const r = this.tsTryParseTypeAnnotation();
                    r && (t.typeAnnotation = r)
                }
                parseClassProperty(t) {
                    if (this.parseClassPropertyAnnotation(t),
                    this.state.isAmbientContext && this.match(29) && this.raise(Q.DeclareClassFieldHasInitializer, {
                        at: this.state.startLoc
                    }),
                    t.abstract && this.match(29)) {
                        const {key: r} = t;
                        this.raise(Q.AbstractPropertyHasInitializer, {
                            at: this.state.startLoc
                        }, "Identifier" !== r.type || t.computed ? `[${this.input.slice(r.start, r.end)}]` : r.name)
                    }
                    return super.parseClassProperty(t)
                }
                parseClassPrivateProperty(t) {
                    return t.abstract && this.raise(Q.PrivateElementHasAbstract, {
                        node: t
                    }),
                    t.accessibility && this.raise(Q.PrivateElementHasAccessibility, {
                        node: t
                    }, t.accessibility),
                    this.parseClassPropertyAnnotation(t),
                    super.parseClassPrivateProperty(t)
                }
                pushClassMethod(t, r, i, a, o, l) {
                    const u = this.tsTryParseTypeParameters();
                    u && o && this.raise(Q.ConstructorHasTypeParameters, {
                        node: u
                    }),
                    !r.declare || "get" !== r.kind && "set" !== r.kind || this.raise(Q.DeclareAccessor, {
                        node: r
                    }, r.kind),
                    u && (r.typeParameters = u),
                    super.pushClassMethod(t, r, i, a, o, l)
                }
                pushClassPrivateMethod(t, r, i, a) {
                    const o = this.tsTryParseTypeParameters();
                    o && (r.typeParameters = o),
                    super.pushClassPrivateMethod(t, r, i, a)
                }
                declareClassPrivateMethodInScope(t, r) {
                    "TSDeclareMethod" !== t.type && ("MethodDefinition" !== t.type || t.value.body) && super.declareClassPrivateMethodInScope(t, r)
                }
                parseClassSuper(t) {
                    super.parseClassSuper(t),
                    t.superClass && this.match(45) && (t.superTypeParameters = this.tsParseTypeArguments()),
                    this.eatContextual(106) && (t.implements = this.tsParseHeritageClause("implements"))
                }
                parseObjPropValue(t, ...r) {
                    const i = this.tsTryParseTypeParameters();
                    i && (t.typeParameters = i),
                    super.parseObjPropValue(t, ...r)
                }
                parseFunctionParams(t, r) {
                    const i = this.tsTryParseTypeParameters();
                    i && (t.typeParameters = i),
                    super.parseFunctionParams(t, r)
                }
                parseVarId(t, r) {
                    super.parseVarId(t, r),
                    "Identifier" === t.id.type && !this.hasPrecedingLineBreak() && this.eat(35) && (t.definite = !0);
                    const i = this.tsTryParseTypeAnnotation();
                    i && (t.id.typeAnnotation = i,
                    this.resetEndLocation(t.id))
                }
                parseAsyncArrowFromCallExpression(t, r) {
                    return this.match(14) && (t.returnType = this.tsParseTypeAnnotation()),
                    super.parseAsyncArrowFromCallExpression(t, r)
                }
                parseMaybeAssign(...t) {
                    var r, i, a, o, l, u, c;
                    let d, y, h, m;
                    if (this.hasPlugin("jsx") && (this.match(134) || this.match(45))) {
                        if (d = this.state.clone(),
                        y = this.tryParse(()=>super.parseMaybeAssign(...t), d),
                        !y.error)
                            return y.node;
                        const {context: r} = this.state
                          , i = r[r.length - 1];
                        i !== p.j_oTag && i !== p.j_expr || r.pop()
                    }
                    if (!(null != (r = y) && r.error || this.match(45)))
                        return super.parseMaybeAssign(...t);
                    d = d || this.state.clone();
                    const T = this.tryParse(r=>{
                        var i, a;
                        m = this.tsParseTypeParameters();
                        const o = super.parseMaybeAssign(...t);
                        return ("ArrowFunctionExpression" !== o.type || null != (i = o.extra) && i.parenthesized) && r(),
                        0 !== (null == (a = m) ? void 0 : a.params.length) && this.resetStartLocationFromNode(o, m),
                        o.typeParameters = m,
                        o
                    }
                    , d);
                    if (!T.error && !T.aborted)
                        return m && this.reportReservedArrowTypeParam(m),
                        T.node;
                    if (!y && (assert(!this.hasPlugin("jsx")),
                    h = this.tryParse(()=>super.parseMaybeAssign(...t), d),
                    !h.error))
                        return h.node;
                    if (null != (i = y) && i.node)
                        return this.state = y.failState,
                        y.node;
                    if (T.node)
                        return this.state = T.failState,
                        m && this.reportReservedArrowTypeParam(m),
                        T.node;
                    if (null != (a = h) && a.node)
                        return this.state = h.failState,
                        h.node;
                    if (null != (o = y) && o.thrown)
                        throw y.error;
                    if (T.thrown)
                        throw T.error;
                    if (null != (l = h) && l.thrown)
                        throw h.error;
                    throw (null == (u = y) ? void 0 : u.error) || T.error || (null == (c = h) ? void 0 : c.error)
                }
                reportReservedArrowTypeParam(t) {
                    var r;
                    1 !== t.params.length || null != (r = t.extra) && r.trailingComma || !this.getPluginOption("typescript", "disallowAmbiguousJSXLike") || this.raise(Q.ReservedArrowTypeParam, {
                        node: t
                    })
                }
                parseMaybeUnary(t) {
                    return !this.hasPlugin("jsx") && this.match(45) ? this.tsParseTypeAssertion() : super.parseMaybeUnary(t)
                }
                parseArrow(t) {
                    if (this.match(14)) {
                        const r = this.tryParse(t=>{
                            const r = this.tsParseTypeOrTypePredicateAnnotation(14);
                            return !this.canInsertSemicolon() && this.match(19) || t(),
                            r
                        }
                        );
                        if (r.aborted)
                            return;
                        r.thrown || (r.error && (this.state = r.failState),
                        t.returnType = r.node)
                    }
                    return super.parseArrow(t)
                }
                parseAssignableListItemTypes(t) {
                    this.eat(17) && ("Identifier" === t.type || this.state.isAmbientContext || this.state.inType || this.raise(Q.PatternIsOptional, {
                        node: t
                    }),
                    t.optional = !0);
                    const r = this.tsTryParseTypeAnnotation();
                    return r && (t.typeAnnotation = r),
                    this.resetEndLocation(t),
                    t
                }
                isAssignable(t, r) {
                    switch (t.type) {
                    case "TSTypeCastExpression":
                        return this.isAssignable(t.expression, r);
                    case "TSParameterProperty":
                        return !0;
                    default:
                        return super.isAssignable(t, r)
                    }
                }
                toAssignable(t, r=!1) {
                    switch (t.type) {
                    case "TSTypeCastExpression":
                        return super.toAssignable(this.typeCastToParameter(t), r);
                    case "TSParameterProperty":
                        return super.toAssignable(t, r);
                    case "ParenthesizedExpression":
                        return this.toAssignableParenthesizedExpression(t, r);
                    case "TSAsExpression":
                    case "TSNonNullExpression":
                    case "TSTypeAssertion":
                        return t.expression = this.toAssignable(t.expression, r),
                        t;
                    default:
                        return super.toAssignable(t, r)
                    }
                }
                toAssignableParenthesizedExpression(t, r) {
                    switch (t.expression.type) {
                    case "TSAsExpression":
                    case "TSNonNullExpression":
                    case "TSTypeAssertion":
                    case "ParenthesizedExpression":
                        return t.expression = this.toAssignable(t.expression, r),
                        t;
                    default:
                        return super.toAssignable(t, r)
                    }
                }
                checkLVal(t, r, ...i) {
                    var a;
                    switch (t.type) {
                    case "TSTypeCastExpression":
                        return;
                    case "TSParameterProperty":
                        return void this.checkLVal(t.parameter, "parameter property", ...i);
                    case "TSAsExpression":
                    case "TSTypeAssertion":
                        if (!(i[0] || "parenthesized expression" === r || null != (a = t.extra) && a.parenthesized)) {
                            this.raise(l.InvalidLhs, {
                                node: t
                            }, r);
                            break
                        }
                        return void this.checkLVal(t.expression, "parenthesized expression", ...i);
                    case "TSNonNullExpression":
                        return void this.checkLVal(t.expression, r, ...i);
                    default:
                        return void super.checkLVal(t, r, ...i)
                    }
                }
                parseBindingAtom() {
                    switch (this.state.type) {
                    case 74:
                        return this.parseIdentifier(!0);
                    default:
                        return super.parseBindingAtom()
                    }
                }
                parseMaybeDecoratorArguments(t) {
                    if (this.match(45)) {
                        const r = this.tsParseTypeArguments();
                        if (this.match(10)) {
                            const i = super.parseMaybeDecoratorArguments(t);
                            return i.typeParameters = r,
                            i
                        }
                        this.unexpected(null, 10)
                    }
                    return super.parseMaybeDecoratorArguments(t)
                }
                checkCommaAfterRest(t) {
                    return this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === t ? (this.next(),
                    !1) : super.checkCommaAfterRest(t)
                }
                isClassMethod() {
                    return this.match(45) || super.isClassMethod()
                }
                isClassProperty() {
                    return this.match(35) || this.match(14) || super.isClassProperty()
                }
                parseMaybeDefault(...t) {
                    const r = super.parseMaybeDefault(...t);
                    return "AssignmentPattern" === r.type && r.typeAnnotation && r.right.start < r.typeAnnotation.start && this.raise(Q.TypeAnnotationAfterAssign, {
                        node: r.typeAnnotation
                    }),
                    r
                }
                getTokenFromCode(t) {
                    if (this.state.inType) {
                        if (62 === t)
                            return this.finishOp(46, 1);
                        if (60 === t)
                            return this.finishOp(45, 1)
                    }
                    return super.getTokenFromCode(t)
                }
                reScan_lt_gt() {
                    const {type: t} = this.state;
                    45 === t ? (this.state.pos -= 1,
                    this.readToken_lt()) : 46 === t && (this.state.pos -= 1,
                    this.readToken_gt())
                }
                toAssignableList(t) {
                    for (let r = 0; r < t.length; r++) {
                        const i = t[r];
                        if (i)
                            switch (i.type) {
                            case "TSTypeCastExpression":
                                t[r] = this.typeCastToParameter(i);
                                break;
                            case "TSAsExpression":
                            case "TSTypeAssertion":
                                this.state.maybeInArrowParameters ? this.raise(Q.UnexpectedTypeCastInParameter, {
                                    node: i
                                }) : t[r] = this.typeCastToParameter(i)
                            }
                    }
                    return super.toAssignableList(...arguments)
                }
                typeCastToParameter(t) {
                    return t.expression.typeAnnotation = t.typeAnnotation,
                    this.resetEndLocation(t.expression, t.typeAnnotation.loc.end),
                    t.expression
                }
                shouldParseArrow(t) {
                    return this.match(14) ? t.every(t=>this.isAssignable(t, !0)) : super.shouldParseArrow(t)
                }
                shouldParseAsyncArrow() {
                    return this.match(14) || super.shouldParseAsyncArrow()
                }
                canHaveLeadingDecorator() {
                    return super.canHaveLeadingDecorator() || this.isAbstractClass()
                }
                jsxParseOpeningElementAfterName(t) {
                    if (this.match(45)) {
                        const r = this.tsTryParseAndCatch(()=>this.tsParseTypeArguments());
                        r && (t.typeParameters = r)
                    }
                    return super.jsxParseOpeningElementAfterName(t)
                }
                getGetterSetterExpectedParamCount(t) {
                    const r = super.getGetterSetterExpectedParamCount(t)
                      , i = this.getObjectOrClassMethodParams(t)[0];
                    return i && this.isThisParam(i) ? r + 1 : r
                }
                parseCatchClauseParam() {
                    const t = super.parseCatchClauseParam()
                      , r = this.tsTryParseTypeAnnotation();
                    return r && (t.typeAnnotation = r,
                    this.resetEndLocation(t)),
                    t
                }
                tsInAmbientContext(t) {
                    const r = this.state.isAmbientContext;
                    this.state.isAmbientContext = !0;
                    try {
                        return t()
                    } finally {
                        this.state.isAmbientContext = r
                    }
                }
                parseClass(t, ...r) {
                    const i = this.state.inAbstractClass;
                    this.state.inAbstractClass = !!t.abstract;
                    try {
                        return super.parseClass(t, ...r)
                    } finally {
                        this.state.inAbstractClass = i
                    }
                }
                tsParseAbstractDeclaration(t) {
                    if (this.match(76))
                        return t.abstract = !0,
                        this.parseClass(t, !0, !1);
                    if (this.isContextual(121)) {
                        if (!this.hasFollowingLineBreak())
                            return t.abstract = !0,
                            this.raise(Q.NonClassMethodPropertyHasAbstractModifer, {
                                node: t
                            }),
                            this.next(),
                            this.tsParseInterfaceDeclaration(t)
                    } else
                        this.unexpected(null, 76)
                }
                parseMethod(...t) {
                    const r = super.parseMethod(...t);
                    if (r.abstract) {
                        if (this.hasPlugin("estree") ? !!r.value.body : !!r.body) {
                            const {key: t} = r;
                            this.raise(Q.AbstractMethodHasImplementation, {
                                node: r
                            }, "Identifier" !== t.type || r.computed ? `[${this.input.slice(t.start, t.end)}]` : t.name)
                        }
                    }
                    return r
                }
                tsParseTypeParameterName() {
                    return this.parseIdentifier().name
                }
                shouldParseAsAmbientContext() {
                    return !!this.getPluginOption("typescript", "dts")
                }
                parse() {
                    return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = !0),
                    super.parse()
                }
                getExpression() {
                    return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = !0),
                    super.getExpression()
                }
                parseExportSpecifier(t, r, i, a) {
                    return !r && a ? (this.parseTypeOnlyImportExportSpecifier(t, !1, i),
                    this.finishNode(t, "ExportSpecifier")) : (t.exportKind = "value",
                    super.parseExportSpecifier(t, r, i, a))
                }
                parseImportSpecifier(t, r, i, a) {
                    return !r && a ? (this.parseTypeOnlyImportExportSpecifier(t, !0, i),
                    this.finishNode(t, "ImportSpecifier")) : (t.importKind = "value",
                    super.parseImportSpecifier(t, r, i, a))
                }
                parseTypeOnlyImportExportSpecifier(t, r, i) {
                    const a = r ? "imported" : "local"
                      , o = r ? "local" : "exported";
                    let l, u = t[a], p = !1, c = !0;
                    const d = u.loc.start;
                    if (this.isContextual(89)) {
                        const t = this.parseIdentifier();
                        if (this.isContextual(89)) {
                            const r = this.parseIdentifier();
                            tokenIsKeywordOrIdentifier(this.state.type) ? (p = !0,
                            u = t,
                            l = this.parseIdentifier(),
                            c = !1) : (l = r,
                            c = !1)
                        } else
                            tokenIsKeywordOrIdentifier(this.state.type) ? (c = !1,
                            l = this.parseIdentifier()) : (p = !0,
                            u = t)
                    } else
                        tokenIsKeywordOrIdentifier(this.state.type) && (p = !0,
                        u = this.parseIdentifier());
                    p && i && this.raise(r ? Q.TypeModifierIsUsedInTypeImports : Q.TypeModifierIsUsedInTypeExports, {
                        at: d
                    }),
                    t[a] = u,
                    t[o] = l,
                    t[r ? "importKind" : "exportKind"] = p ? "type" : "value",
                    c && this.eatContextual(89) && (t[o] = r ? this.parseIdentifier() : this.parseModuleExportName()),
                    t[o] || (t[o] = cloneIdentifier(t[a])),
                    r && this.checkLVal(t[o], "import specifier", 9)
                }
            }
            ,
            v8intrinsic: t=>class extends t {
                parseV8Intrinsic() {
                    if (this.match(50)) {
                        const t = this.state.startLoc
                          , r = this.startNode();
                        if (this.next(),
                        tokenIsIdentifier(this.state.type)) {
                            const t = this.parseIdentifierName(this.state.start)
                              , i = this.createIdentifier(r, t);
                            if (i.type = "V8IntrinsicIdentifier",
                            this.match(10))
                                return i
                        }
                        this.unexpected(t)
                    }
                }
                parseExprAtom() {
                    return this.parseV8Intrinsic() || super.parseExprAtom(...arguments)
                }
            }
            ,
            placeholders: t=>class extends t {
                parsePlaceholder(t) {
                    if (this.match(136)) {
                        const r = this.startNode();
                        return this.next(),
                        this.assertNoSpace("Unexpected space in placeholder."),
                        r.name = super.parseIdentifier(!0),
                        this.assertNoSpace("Unexpected space in placeholder."),
                        this.expect(136),
                        this.finishPlaceholder(r, t)
                    }
                }
                finishPlaceholder(t, r) {
                    const i = !(!t.expectedNode || "Placeholder" !== t.type);
                    return t.expectedNode = r,
                    i ? t : this.finishNode(t, "Placeholder")
                }
                getTokenFromCode(t) {
                    return 37 === t && 37 === this.input.charCodeAt(this.state.pos + 1) ? this.finishOp(136, 2) : super.getTokenFromCode(...arguments)
                }
                parseExprAtom() {
                    return this.parsePlaceholder("Expression") || super.parseExprAtom(...arguments)
                }
                parseIdentifier() {
                    return this.parsePlaceholder("Identifier") || super.parseIdentifier(...arguments)
                }
                checkReservedWord(t) {
                    void 0 !== t && super.checkReservedWord(...arguments)
                }
                parseBindingAtom() {
                    return this.parsePlaceholder("Pattern") || super.parseBindingAtom(...arguments)
                }
                checkLVal(t) {
                    "Placeholder" !== t.type && super.checkLVal(...arguments)
                }
                toAssignable(t) {
                    return t && "Placeholder" === t.type && "Expression" === t.expectedNode ? (t.expectedNode = "Pattern",
                    t) : super.toAssignable(...arguments)
                }
                isLet(t) {
                    if (super.isLet(t))
                        return !0;
                    if (!this.isContextual(95))
                        return !1;
                    if (t)
                        return !1;
                    return 136 === this.lookahead().type
                }
                verifyBreakContinue(t) {
                    t.label && "Placeholder" === t.label.type || super.verifyBreakContinue(...arguments)
                }
                parseExpressionStatement(t, r) {
                    if ("Placeholder" !== r.type || r.extra && r.extra.parenthesized)
                        return super.parseExpressionStatement(...arguments);
                    if (this.match(14)) {
                        const i = t;
                        return i.label = this.finishPlaceholder(r, "Identifier"),
                        this.next(),
                        i.body = this.parseStatement("label"),
                        this.finishNode(i, "LabeledStatement")
                    }
                    return this.semicolon(),
                    t.name = r.name,
                    this.finishPlaceholder(t, "Statement")
                }
                parseBlock() {
                    return this.parsePlaceholder("BlockStatement") || super.parseBlock(...arguments)
                }
                parseFunctionId() {
                    return this.parsePlaceholder("Identifier") || super.parseFunctionId(...arguments)
                }
                parseClass(t, r, i) {
                    const a = r ? "ClassDeclaration" : "ClassExpression";
                    this.next(),
                    this.takeDecorators(t);
                    const o = this.state.strict
                      , l = this.parsePlaceholder("Identifier");
                    if (l) {
                        if (!(this.match(77) || this.match(136) || this.match(5))) {
                            if (i || !r)
                                return t.id = null,
                                t.body = this.finishPlaceholder(l, "ClassBody"),
                                this.finishNode(t, a);
                            throw this.raise($.ClassNameIsRequired, {
                                at: this.state.startLoc
                            })
                        }
                        t.id = l
                    } else
                        this.parseClassId(t, r, i);
                    return this.parseClassSuper(t),
                    t.body = this.parsePlaceholder("ClassBody") || this.parseClassBody(!!t.superClass, o),
                    this.finishNode(t, a)
                }
                parseExport(t) {
                    const r = this.parsePlaceholder("Identifier");
                    if (!r)
                        return super.parseExport(...arguments);
                    if (!this.isContextual(93) && !this.match(12))
                        return t.specifiers = [],
                        t.source = null,
                        t.declaration = this.finishPlaceholder(r, "Declaration"),
                        this.finishNode(t, "ExportNamedDeclaration");
                    this.expectPlugin("exportDefaultFrom");
                    const i = this.startNode();
                    return i.exported = r,
                    t.specifiers = [this.finishNode(i, "ExportDefaultSpecifier")],
                    super.parseExport(t)
                }
                isExportDefaultSpecifier() {
                    if (this.match(61)) {
                        const t = this.nextTokenStart();
                        if (this.isUnparsedContextual(t, "from") && this.input.startsWith(tokenLabelName(136), this.nextTokenStartSince(t + 4)))
                            return !0
                    }
                    return super.isExportDefaultSpecifier()
                }
                maybeParseExportDefaultSpecifier(t) {
                    return !!(t.specifiers && t.specifiers.length > 0) || super.maybeParseExportDefaultSpecifier(...arguments)
                }
                checkExport(t) {
                    const {specifiers: r} = t;
                    null != r && r.length && (t.specifiers = r.filter(t=>"Placeholder" === t.exported.type)),
                    super.checkExport(t),
                    t.specifiers = r
                }
                parseImport(t) {
                    const r = this.parsePlaceholder("Identifier");
                    if (!r)
                        return super.parseImport(...arguments);
                    if (t.specifiers = [],
                    !this.isContextual(93) && !this.match(12))
                        return t.source = this.finishPlaceholder(r, "StringLiteral"),
                        this.semicolon(),
                        this.finishNode(t, "ImportDeclaration");
                    const i = this.startNodeAtNode(r);
                    if (i.local = r,
                    this.finishNode(i, "ImportDefaultSpecifier"),
                    t.specifiers.push(i),
                    this.eat(12)) {
                        this.maybeParseStarImportSpecifier(t) || this.parseNamedImportSpecifiers(t)
                    }
                    return this.expectContextual(93),
                    t.source = this.parseImportSource(),
                    this.semicolon(),
                    this.finishNode(t, "ImportDeclaration")
                }
                parseImportSource() {
                    return this.parsePlaceholder("StringLiteral") || super.parseImportSource(...arguments)
                }
            }
        }
          , ne = Object.keys(re)
          , ie = {
            sourceType: "script",
            sourceFilename: void 0,
            startColumn: 0,
            startLine: 1,
            allowAwaitOutsideFunction: !1,
            allowReturnOutsideFunction: !1,
            allowImportExportEverywhere: !1,
            allowSuperOutsideMethod: !1,
            allowUndeclaredExports: !1,
            plugins: [],
            strictMode: null,
            ranges: !1,
            tokens: !1,
            createParenthesizedExpressions: !1,
            errorRecovery: !1,
            attachComment: !0
        };
        const unwrapParenthesizedExpression = t=>"ParenthesizedExpression" === t.type ? unwrapParenthesizedExpression(t.expression) : t;
        const ae = new Map([["ArrowFunctionExpression", "arrow function"], ["AssignmentExpression", "assignment"], ["ConditionalExpression", "conditional"], ["YieldExpression", "yield"]]);
        const se = {
            kind: "loop"
        }
          , oe = {
            kind: "switch"
        }
          , le = /[\uD800-\uDFFF]/u
          , ue = /in(?:stanceof)?/y;
        class Parser extends class StatementParser extends class ExpressionParser extends class LValParser extends class NodeUtils extends class UtilParser extends class Tokenizer extends class ParserError extends class CommentsParser extends class BaseParser {
            constructor() {
                this.sawUnambiguousESM = !1,
                this.ambiguousScriptDifferentAst = !1
            }
            hasPlugin(t) {
                if ("string" == typeof t)
                    return this.plugins.has(t);
                {
                    const [r,i] = t;
                    if (!this.hasPlugin(r))
                        return !1;
                    const a = this.plugins.get(r);
                    for (const t of Object.keys(i))
                        if ((null == a ? void 0 : a[t]) !== i[t])
                            return !1;
                    return !0
                }
            }
            getPluginOption(t, r) {
                var i;
                return null == (i = this.plugins.get(t)) ? void 0 : i[r]
            }
        }
        {
            addComment(t) {
                this.filename && (t.loc.filename = this.filename),
                this.state.comments.push(t)
            }
            processComment(t) {
                const {commentStack: r} = this.state
                  , i = r.length;
                if (0 === i)
                    return;
                let a = i - 1;
                const o = r[a];
                o.start === t.end && (o.leadingNode = t,
                a--);
                const {start: l} = t;
                for (; a >= 0; a--) {
                    const i = r[a]
                      , o = i.end;
                    if (!(o > l)) {
                        o === l && (i.trailingNode = t);
                        break
                    }
                    i.containingNode = t,
                    this.finalizeComment(i),
                    r.splice(a, 1)
                }
            }
            finalizeComment(t) {
                const {comments: r} = t;
                if (null !== t.leadingNode || null !== t.trailingNode)
                    null !== t.leadingNode && setTrailingComments(t.leadingNode, r),
                    null !== t.trailingNode && function setLeadingComments(t, r) {
                        void 0 === t.leadingComments ? t.leadingComments = r : t.leadingComments.unshift(...r)
                    }(t.trailingNode, r);
                else {
                    const {containingNode: i, start: a} = t;
                    if (44 === this.input.charCodeAt(a - 1))
                        switch (i.type) {
                        case "ObjectExpression":
                        case "ObjectPattern":
                        case "RecordExpression":
                            adjustInnerComments(i, i.properties, t);
                            break;
                        case "CallExpression":
                        case "OptionalCallExpression":
                            adjustInnerComments(i, i.arguments, t);
                            break;
                        case "FunctionDeclaration":
                        case "FunctionExpression":
                        case "ArrowFunctionExpression":
                        case "ObjectMethod":
                        case "ClassMethod":
                        case "ClassPrivateMethod":
                            adjustInnerComments(i, i.params, t);
                            break;
                        case "ArrayExpression":
                        case "ArrayPattern":
                        case "TupleExpression":
                            adjustInnerComments(i, i.elements, t);
                            break;
                        case "ExportNamedDeclaration":
                        case "ImportDeclaration":
                            adjustInnerComments(i, i.specifiers, t);
                            break;
                        default:
                            setInnerComments(i, r)
                        }
                    else
                        setInnerComments(i, r)
                }
            }
            finalizeRemainingComments() {
                const {commentStack: t} = this.state;
                for (let r = t.length - 1; r >= 0; r--)
                    this.finalizeComment(t[r]);
                this.state.commentStack = []
            }
            resetPreviousNodeTrailingComments(t) {
                const {commentStack: r} = this.state
                  , {length: i} = r;
                if (0 === i)
                    return;
                const a = r[i - 1];
                a.leadingNode === t && (a.leadingNode = null)
            }
            takeSurroundingComments(t, r, i) {
                const {commentStack: a} = this.state
                  , o = a.length;
                if (0 === o)
                    return;
                let l = o - 1;
                for (; l >= 0; l--) {
                    const o = a[l]
                      , u = o.end;
                    if (o.start === i)
                        o.leadingNode = t;
                    else if (u === r)
                        o.trailingNode = t;
                    else if (u < r)
                        break
                }
            }
        }
        {
            raise({code: t, reasonCode: r, template: i}, a, ...o) {
                return this.raiseWithData(a.node ? a.node.loc.start : a.at, {
                    code: t,
                    reasonCode: r
                }, i, ...o)
            }
            raiseOverwrite(t, {code: r, template: i}, ...o) {
                const l = a.get(t)
                  , u = i.replace(/%(\d+)/g, (t,r)=>o[r]) + ` (${t.line}:${t.column})`;
                if (this.options.errorRecovery) {
                    const t = this.state.errors;
                    for (let r = t.length - 1; r >= 0; r--) {
                        const i = t[r];
                        if (i.pos === l)
                            return Object.assign(i, {
                                message: u
                            });
                        if (i.pos < l)
                            break
                    }
                }
                return this._raise({
                    code: r,
                    loc: t,
                    pos: l
                }, u)
            }
            raiseWithData(t, r, i, ...o) {
                const l = a.get(t)
                  , u = i.replace(/%(\d+)/g, (t,r)=>o[r]) + ` (${t.line}:${t.column})`;
                return this._raise(Object.assign({
                    loc: t,
                    pos: l
                }, r), u)
            }
            _raise(t, r) {
                const i = new SyntaxError(r);
                if (Object.assign(i, t),
                this.options.errorRecovery)
                    return this.isLookahead || this.state.errors.push(i),
                    i;
                throw i
            }
        }
        {
            constructor(t, r) {
                super(),
                this.isLookahead = void 0,
                this.tokens = [],
                this.state = new State,
                this.state.init(t),
                this.input = r,
                this.length = r.length,
                this.isLookahead = !1
            }
            pushToken(t) {
                this.tokens.length = this.state.tokensLength,
                this.tokens.push(t),
                ++this.state.tokensLength
            }
            next() {
                this.checkKeywordEscapes(),
                this.options.tokens && this.pushToken(new Token(this.state)),
                this.state.lastTokStart = this.state.start,
                this.state.lastTokEndLoc = this.state.endLoc,
                this.state.lastTokStartLoc = this.state.startLoc,
                this.nextToken()
            }
            eat(t) {
                return !!this.match(t) && (this.next(),
                !0)
            }
            match(t) {
                return this.state.type === t
            }
            createLookaheadState(t) {
                return {
                    pos: t.pos,
                    value: null,
                    type: t.type,
                    start: t.start,
                    end: t.end,
                    context: [this.curContext()],
                    inType: t.inType,
                    startLoc: t.startLoc,
                    lastTokEndLoc: t.lastTokEndLoc,
                    curLine: t.curLine,
                    lineStart: t.lineStart,
                    curPosition: t.curPosition
                }
            }
            lookahead() {
                const t = this.state;
                this.state = this.createLookaheadState(t),
                this.isLookahead = !0,
                this.nextToken(),
                this.isLookahead = !1;
                const r = this.state;
                return this.state = t,
                r
            }
            nextTokenStart() {
                return this.nextTokenStartSince(this.state.pos)
            }
            nextTokenStartSince(t) {
                return M.lastIndex = t,
                M.test(this.input) ? M.lastIndex : t
            }
            lookaheadCharCode() {
                return this.input.charCodeAt(this.nextTokenStart())
            }
            codePointAtPos(t) {
                let r = this.input.charCodeAt(t);
                if (55296 == (64512 & r) && ++t < this.input.length) {
                    const i = this.input.charCodeAt(t);
                    56320 == (64512 & i) && (r = 65536 + ((1023 & r) << 10) + (1023 & i))
                }
                return r
            }
            setStrict(t) {
                this.state.strict = t,
                t && (this.state.strictErrors.forEach(({message: t, loc: r})=>this.raise(t, {
                    at: r
                })),
                this.state.strictErrors.clear())
            }
            curContext() {
                return this.state.context[this.state.context.length - 1]
            }
            nextToken() {
                this.skipSpace(),
                this.state.start = this.state.pos,
                this.isLookahead || (this.state.startLoc = this.state.curPosition()),
                this.state.pos >= this.length ? this.finishToken(131) : this.getTokenFromCode(this.codePointAtPos(this.state.pos))
            }
            skipBlockComment() {
                let t;
                this.isLookahead || (t = this.state.curPosition());
                const r = this.state.pos
                  , i = this.input.indexOf("*/", r + 2);
                if (-1 === i)
                    throw this.raise(l.UnterminatedComment, {
                        at: this.state.curPosition()
                    });
                for (this.state.pos = i + 2,
                k.lastIndex = r + 2; k.test(this.input) && k.lastIndex <= i; )
                    ++this.state.curLine,
                    this.state.lineStart = k.lastIndex;
                if (this.isLookahead)
                    return;
                const a = {
                    type: "CommentBlock",
                    value: this.input.slice(r + 2, i),
                    start: r,
                    end: i + 2,
                    loc: new SourceLocation(t,this.state.curPosition())
                };
                return this.options.tokens && this.pushToken(a),
                a
            }
            skipLineComment(t) {
                const r = this.state.pos;
                let i;
                this.isLookahead || (i = this.state.curPosition());
                let a = this.input.charCodeAt(this.state.pos += t);
                if (this.state.pos < this.length)
                    for (; !isNewLine(a) && ++this.state.pos < this.length; )
                        a = this.input.charCodeAt(this.state.pos);
                if (this.isLookahead)
                    return;
                const o = this.state.pos
                  , l = {
                    type: "CommentLine",
                    value: this.input.slice(r + t, o),
                    start: r,
                    end: o,
                    loc: new SourceLocation(i,this.state.curPosition())
                };
                return this.options.tokens && this.pushToken(l),
                l
            }
            skipSpace() {
                const t = this.state.pos
                  , r = [];
                e: for (; this.state.pos < this.length; ) {
                    const i = this.input.charCodeAt(this.state.pos);
                    switch (i) {
                    case 32:
                    case 160:
                    case 9:
                        ++this.state.pos;
                        break;
                    case 13:
                        10 === this.input.charCodeAt(this.state.pos + 1) && ++this.state.pos;
                    case 10:
                    case 8232:
                    case 8233:
                        ++this.state.pos,
                        ++this.state.curLine,
                        this.state.lineStart = this.state.pos;
                        break;
                    case 47:
                        switch (this.input.charCodeAt(this.state.pos + 1)) {
                        case 42:
                            {
                                const t = this.skipBlockComment();
                                void 0 !== t && (this.addComment(t),
                                this.options.attachComment && r.push(t));
                                break
                            }
                        case 47:
                            {
                                const t = this.skipLineComment(2);
                                void 0 !== t && (this.addComment(t),
                                this.options.attachComment && r.push(t));
                                break
                            }
                        default:
                            break e
                        }
                        break;
                    default:
                        if (isWhitespace(i))
                            ++this.state.pos;
                        else if (45 !== i || this.inModule) {
                            if (60 !== i || this.inModule)
                                break e;
                            {
                                const t = this.state.pos;
                                if (33 !== this.input.charCodeAt(t + 1) || 45 !== this.input.charCodeAt(t + 2) || 45 !== this.input.charCodeAt(t + 3))
                                    break e;
                                {
                                    const t = this.skipLineComment(4);
                                    void 0 !== t && (this.addComment(t),
                                    this.options.attachComment && r.push(t))
                                }
                            }
                        } else {
                            const i = this.state.pos;
                            if (45 !== this.input.charCodeAt(i + 1) || 62 !== this.input.charCodeAt(i + 2) || !(0 === t || this.state.lineStart > t))
                                break e;
                            {
                                const t = this.skipLineComment(3);
                                void 0 !== t && (this.addComment(t),
                                this.options.attachComment && r.push(t))
                            }
                        }
                    }
                }
                if (r.length > 0) {
                    const i = {
                        start: t,
                        end: this.state.pos,
                        comments: r,
                        leadingNode: null,
                        trailingNode: null,
                        containingNode: null
                    };
                    this.state.commentStack.push(i)
                }
            }
            finishToken(t, r) {
                this.state.end = this.state.pos,
                this.state.endLoc = this.state.curPosition();
                const i = this.state.type;
                this.state.type = t,
                this.state.value = r,
                this.isLookahead || this.updateContext(i)
            }
            replaceToken(t) {
                this.state.type = t,
                this.updateContext()
            }
            readToken_numberSign() {
                if (0 === this.state.pos && this.readToken_interpreter())
                    return;
                const t = this.state.pos + 1
                  , r = this.codePointAtPos(t);
                if (r >= 48 && r <= 57)
                    throw this.raise(l.UnexpectedDigitAfterHash, {
                        at: this.state.curPosition()
                    });
                if (123 === r || 91 === r && this.hasPlugin("recordAndTuple")) {
                    if (this.expectPlugin("recordAndTuple"),
                    "hash" !== this.getPluginOption("recordAndTuple", "syntaxType"))
                        throw this.raise(123 === r ? l.RecordExpressionHashIncorrectStartSyntaxType : l.TupleExpressionHashIncorrectStartSyntaxType, {
                            at: this.state.curPosition()
                        });
                    this.state.pos += 2,
                    123 === r ? this.finishToken(7) : this.finishToken(1)
                } else
                    isIdentifierStart(r) ? (++this.state.pos,
                    this.finishToken(130, this.readWord1(r))) : 92 === r ? (++this.state.pos,
                    this.finishToken(130, this.readWord1())) : this.finishOp(27, 1)
            }
            readToken_dot() {
                const t = this.input.charCodeAt(this.state.pos + 1);
                t >= 48 && t <= 57 ? this.readNumber(!0) : 46 === t && 46 === this.input.charCodeAt(this.state.pos + 2) ? (this.state.pos += 3,
                this.finishToken(21)) : (++this.state.pos,
                this.finishToken(16))
            }
            readToken_slash() {
                61 === this.input.charCodeAt(this.state.pos + 1) ? this.finishOp(31, 2) : this.finishOp(52, 1)
            }
            readToken_interpreter() {
                if (0 !== this.state.pos || this.length < 2)
                    return !1;
                let t = this.input.charCodeAt(this.state.pos + 1);
                if (33 !== t)
                    return !1;
                const r = this.state.pos;
                for (this.state.pos += 1; !isNewLine(t) && ++this.state.pos < this.length; )
                    t = this.input.charCodeAt(this.state.pos);
                const i = this.input.slice(r + 2, this.state.pos);
                return this.finishToken(28, i),
                !0
            }
            readToken_mult_modulo(t) {
                let r = 42 === t ? 51 : 50
                  , i = 1
                  , a = this.input.charCodeAt(this.state.pos + 1);
                42 === t && 42 === a && (i++,
                a = this.input.charCodeAt(this.state.pos + 2),
                r = 53),
                61 !== a || this.state.inType || (i++,
                r = 37 === t ? 33 : 30),
                this.finishOp(r, i)
            }
            readToken_pipe_amp(t) {
                const r = this.input.charCodeAt(this.state.pos + 1);
                if (r !== t) {
                    if (124 === t) {
                        if (62 === r)
                            return void this.finishOp(37, 2);
                        if (this.hasPlugin("recordAndTuple") && 125 === r) {
                            if ("bar" !== this.getPluginOption("recordAndTuple", "syntaxType"))
                                throw this.raise(l.RecordExpressionBarIncorrectEndSyntaxType, {
                                    at: this.state.curPosition()
                                });
                            return this.state.pos += 2,
                            void this.finishToken(9)
                        }
                        if (this.hasPlugin("recordAndTuple") && 93 === r) {
                            if ("bar" !== this.getPluginOption("recordAndTuple", "syntaxType"))
                                throw this.raise(l.TupleExpressionBarIncorrectEndSyntaxType, {
                                    at: this.state.curPosition()
                                });
                            return this.state.pos += 2,
                            void this.finishToken(4)
                        }
                    }
                    61 !== r ? this.finishOp(124 === t ? 41 : 43, 1) : this.finishOp(30, 2)
                } else
                    61 === this.input.charCodeAt(this.state.pos + 2) ? this.finishOp(30, 3) : this.finishOp(124 === t ? 39 : 40, 2)
            }
            readToken_caret() {
                61 !== this.input.charCodeAt(this.state.pos + 1) || this.state.inType ? this.finishOp(42, 1) : this.finishOp(32, 2)
            }
            readToken_plus_min(t) {
                const r = this.input.charCodeAt(this.state.pos + 1);
                r !== t ? 61 === r ? this.finishOp(30, 2) : this.finishOp(49, 1) : this.finishOp(34, 2)
            }
            readToken_lt() {
                const {pos: t} = this.state
                  , r = this.input.charCodeAt(t + 1);
                if (60 === r)
                    return 61 === this.input.charCodeAt(t + 2) ? void this.finishOp(30, 3) : void this.finishOp(48, 2);
                61 !== r ? this.finishOp(45, 1) : this.finishOp(47, 2)
            }
            readToken_gt() {
                const {pos: t} = this.state
                  , r = this.input.charCodeAt(t + 1);
                if (62 === r) {
                    const r = 62 === this.input.charCodeAt(t + 2) ? 3 : 2;
                    return 61 === this.input.charCodeAt(t + r) ? void this.finishOp(30, r + 1) : void this.finishOp(48, r)
                }
                61 !== r ? this.finishOp(46, 1) : this.finishOp(47, 2)
            }
            readToken_eq_excl(t) {
                const r = this.input.charCodeAt(this.state.pos + 1);
                if (61 !== r)
                    return 61 === t && 62 === r ? (this.state.pos += 2,
                    void this.finishToken(19)) : void this.finishOp(61 === t ? 29 : 35, 1);
                this.finishOp(44, 61 === this.input.charCodeAt(this.state.pos + 2) ? 3 : 2)
            }
            readToken_question() {
                const t = this.input.charCodeAt(this.state.pos + 1)
                  , r = this.input.charCodeAt(this.state.pos + 2);
                63 === t ? 61 === r ? this.finishOp(30, 3) : this.finishOp(38, 2) : 46 !== t || r >= 48 && r <= 57 ? (++this.state.pos,
                this.finishToken(17)) : (this.state.pos += 2,
                this.finishToken(18))
            }
            getTokenFromCode(t) {
                switch (t) {
                case 46:
                    return void this.readToken_dot();
                case 40:
                    return ++this.state.pos,
                    void this.finishToken(10);
                case 41:
                    return ++this.state.pos,
                    void this.finishToken(11);
                case 59:
                    return ++this.state.pos,
                    void this.finishToken(13);
                case 44:
                    return ++this.state.pos,
                    void this.finishToken(12);
                case 91:
                    if (this.hasPlugin("recordAndTuple") && 124 === this.input.charCodeAt(this.state.pos + 1)) {
                        if ("bar" !== this.getPluginOption("recordAndTuple", "syntaxType"))
                            throw this.raise(l.TupleExpressionBarIncorrectStartSyntaxType, {
                                at: this.state.curPosition()
                            });
                        this.state.pos += 2,
                        this.finishToken(2)
                    } else
                        ++this.state.pos,
                        this.finishToken(0);
                    return;
                case 93:
                    return ++this.state.pos,
                    void this.finishToken(3);
                case 123:
                    if (this.hasPlugin("recordAndTuple") && 124 === this.input.charCodeAt(this.state.pos + 1)) {
                        if ("bar" !== this.getPluginOption("recordAndTuple", "syntaxType"))
                            throw this.raise(l.RecordExpressionBarIncorrectStartSyntaxType, {
                                at: this.state.curPosition()
                            });
                        this.state.pos += 2,
                        this.finishToken(6)
                    } else
                        ++this.state.pos,
                        this.finishToken(5);
                    return;
                case 125:
                    return ++this.state.pos,
                    void this.finishToken(8);
                case 58:
                    return void (this.hasPlugin("functionBind") && 58 === this.input.charCodeAt(this.state.pos + 1) ? this.finishOp(15, 2) : (++this.state.pos,
                    this.finishToken(14)));
                case 63:
                    return void this.readToken_question();
                case 96:
                    return void this.readTemplateToken();
                case 48:
                    {
                        const t = this.input.charCodeAt(this.state.pos + 1);
                        if (120 === t || 88 === t)
                            return void this.readRadixNumber(16);
                        if (111 === t || 79 === t)
                            return void this.readRadixNumber(8);
                        if (98 === t || 66 === t)
                            return void this.readRadixNumber(2)
                    }
                case 49:
                case 50:
                case 51:
                case 52:
                case 53:
                case 54:
                case 55:
                case 56:
                case 57:
                    return void this.readNumber(!1);
                case 34:
                case 39:
                    return void this.readString(t);
                case 47:
                    return void this.readToken_slash();
                case 37:
                case 42:
                    return void this.readToken_mult_modulo(t);
                case 124:
                case 38:
                    return void this.readToken_pipe_amp(t);
                case 94:
                    return void this.readToken_caret();
                case 43:
                case 45:
                    return void this.readToken_plus_min(t);
                case 60:
                    return void this.readToken_lt();
                case 62:
                    return void this.readToken_gt();
                case 61:
                case 33:
                    return void this.readToken_eq_excl(t);
                case 126:
                    return void this.finishOp(36, 1);
                case 64:
                    return ++this.state.pos,
                    void this.finishToken(26);
                case 35:
                    return void this.readToken_numberSign();
                case 92:
                    return void this.readWord();
                default:
                    if (isIdentifierStart(t))
                        return void this.readWord(t)
                }
                throw this.raise(l.InvalidOrUnexpectedToken, {
                    at: this.state.curPosition()
                }, String.fromCodePoint(t))
            }
            finishOp(t, r) {
                const i = this.input.slice(this.state.pos, this.state.pos + r);
                this.state.pos += r,
                this.finishToken(t, i)
            }
            readRegexp() {
                const t = this.state.startLoc
                  , r = this.state.start + 1;
                let i, a, {pos: o} = this.state;
                for (; ; ++o) {
                    if (o >= this.length)
                        throw this.raise(l.UnterminatedRegExp, {
                            at: createPositionWithColumnOffset(t, 1)
                        });
                    const r = this.input.charCodeAt(o);
                    if (isNewLine(r))
                        throw this.raise(l.UnterminatedRegExp, {
                            at: createPositionWithColumnOffset(t, 1)
                        });
                    if (i)
                        i = !1;
                    else {
                        if (91 === r)
                            a = !0;
                        else if (93 === r && a)
                            a = !1;
                        else if (47 === r && !a)
                            break;
                        i = 92 === r
                    }
                }
                const u = this.input.slice(r, o);
                ++o;
                let p = "";
                for (; o < this.length; ) {
                    const i = this.codePointAtPos(o)
                      , a = String.fromCharCode(i);
                    if (R.has(i))
                        p.includes(a) && this.raise(l.DuplicateRegExpFlags, {
                            at: createPositionWithColumnOffset(t, o + 2 - r)
                        });
                    else {
                        if (!isIdentifierChar(i) && 92 !== i)
                            break;
                        this.raise(l.MalformedRegExpFlags, {
                            at: createPositionWithColumnOffset(t, o + 2 - r)
                        })
                    }
                    ++o,
                    p += a
                }
                this.state.pos = o,
                this.finishToken(129, {
                    pattern: u,
                    flags: p
                })
            }
            readInt(t, r, i, a=!0) {
                const o = this.state.pos
                  , u = 16 === t ? K.hex : K.decBinOct
                  , p = 16 === t ? V.hex : 10 === t ? V.dec : 8 === t ? V.oct : V.bin;
                let c = !1
                  , d = 0;
                for (let o = 0, y = null == r ? 1 / 0 : r; o < y; ++o) {
                    const r = this.input.charCodeAt(this.state.pos);
                    let o;
                    if (95 !== r) {
                        if (o = r >= 97 ? r - 97 + 10 : r >= 65 ? r - 65 + 10 : B(r) ? r - 48 : 1 / 0,
                        o >= t)
                            if (this.options.errorRecovery && o <= 9)
                                o = 0,
                                this.raise(l.InvalidDigit, {
                                    at: this.state.curPosition()
                                }, t);
                            else {
                                if (!i)
                                    break;
                                o = 0,
                                c = !0
                            }
                        ++this.state.pos,
                        d = d * t + o
                    } else {
                        const t = this.input.charCodeAt(this.state.pos - 1)
                          , r = this.input.charCodeAt(this.state.pos + 1);
                        (-1 === p.indexOf(r) || u.indexOf(t) > -1 || u.indexOf(r) > -1 || Number.isNaN(r)) && this.raise(l.UnexpectedNumericSeparator, {
                            at: this.state.curPosition()
                        }),
                        a || this.raise(l.NumericSeparatorInEscapeSequence, {
                            at: this.state.curPosition()
                        }),
                        ++this.state.pos
                    }
                }
                return this.state.pos === o || null != r && this.state.pos - o !== r || c ? null : d
            }
            readRadixNumber(t) {
                const r = this.state.curPosition();
                let i = !1;
                this.state.pos += 2;
                const o = this.readInt(t);
                null == o && this.raise(l.InvalidDigit, {
                    at: createPositionWithColumnOffset(r, 2)
                }, t);
                const u = this.input.charCodeAt(this.state.pos);
                if (110 === u)
                    ++this.state.pos,
                    i = !0;
                else if (109 === u)
                    throw this.raise(l.InvalidDecimal, {
                        at: r
                    });
                if (isIdentifierStart(this.codePointAtPos(this.state.pos)))
                    throw this.raise(l.NumberIdentifier, {
                        at: this.state.curPosition()
                    });
                if (i) {
                    const t = this.input.slice(a.get(r), this.state.pos).replace(/[_n]/g, "");
                    this.finishToken(127, t)
                } else
                    this.finishToken(126, o)
            }
            readNumber(t) {
                const r = this.state.pos
                  , i = this.state.curPosition();
                let a = !1
                  , o = !1
                  , u = !1
                  , p = !1
                  , c = !1;
                t || null !== this.readInt(10) || this.raise(l.InvalidNumber, {
                    at: this.state.curPosition()
                });
                const d = this.state.pos - r >= 2 && 48 === this.input.charCodeAt(r);
                if (d) {
                    const t = this.input.slice(r, this.state.pos);
                    if (this.recordStrictModeErrors(l.StrictOctalLiteral, i),
                    !this.state.strict) {
                        const r = t.indexOf("_");
                        r > 0 && this.raise(l.ZeroDigitNumericSeparator, {
                            at: createPositionWithColumnOffset(i, r)
                        })
                    }
                    c = d && !/[89]/.test(t)
                }
                let y = this.input.charCodeAt(this.state.pos);
                if (46 !== y || c || (++this.state.pos,
                this.readInt(10),
                a = !0,
                y = this.input.charCodeAt(this.state.pos)),
                69 !== y && 101 !== y || c || (y = this.input.charCodeAt(++this.state.pos),
                43 !== y && 45 !== y || ++this.state.pos,
                null === this.readInt(10) && this.raise(l.InvalidOrMissingExponent, {
                    at: i
                }),
                a = !0,
                p = !0,
                y = this.input.charCodeAt(this.state.pos)),
                110 === y && ((a || d) && this.raise(l.InvalidBigIntLiteral, {
                    at: i
                }),
                ++this.state.pos,
                o = !0),
                109 === y && (this.expectPlugin("decimal", this.state.curPosition()),
                (p || d) && this.raise(l.InvalidDecimal, {
                    at: i
                }),
                ++this.state.pos,
                u = !0),
                isIdentifierStart(this.codePointAtPos(this.state.pos)))
                    throw this.raise(l.NumberIdentifier, {
                        at: this.state.curPosition()
                    });
                const h = this.input.slice(r, this.state.pos).replace(/[_mn]/g, "");
                if (o)
                    return void this.finishToken(127, h);
                if (u)
                    return void this.finishToken(128, h);
                const m = c ? parseInt(h, 8) : parseFloat(h);
                this.finishToken(126, m)
            }
            readCodePoint(t) {
                let r;
                if (123 === this.input.charCodeAt(this.state.pos)) {
                    if (++this.state.pos,
                    r = this.readHexChar(this.input.indexOf("}", this.state.pos) - this.state.pos, !0, t),
                    ++this.state.pos,
                    null !== r && r > 1114111) {
                        if (!t)
                            return null;
                        this.raise(l.InvalidCodePoint, {
                            at: this.state.curPosition()
                        })
                    }
                } else
                    r = this.readHexChar(4, !1, t);
                return r
            }
            readString(t) {
                let r = ""
                  , i = ++this.state.pos;
                for (; ; ) {
                    if (this.state.pos >= this.length)
                        throw this.raise(l.UnterminatedString, {
                            at: this.state.startLoc
                        });
                    const a = this.input.charCodeAt(this.state.pos);
                    if (a === t)
                        break;
                    if (92 === a)
                        r += this.input.slice(i, this.state.pos),
                        r += this.readEscapedChar(!1),
                        i = this.state.pos;
                    else if (8232 === a || 8233 === a)
                        ++this.state.pos,
                        ++this.state.curLine,
                        this.state.lineStart = this.state.pos;
                    else {
                        if (isNewLine(a))
                            throw this.raise(l.UnterminatedString, {
                                at: this.state.startLoc
                            });
                        ++this.state.pos
                    }
                }
                r += this.input.slice(i, this.state.pos++),
                this.finishToken(125, r)
            }
            readTemplateContinuation() {
                this.match(8) || this.unexpected(null, 8),
                this.state.pos--,
                this.readTemplateToken()
            }
            readTemplateToken() {
                let t = ""
                  , r = this.state.pos
                  , i = !1;
                for (++this.state.pos; ; ) {
                    if (this.state.pos >= this.length)
                        throw this.raise(l.UnterminatedTemplate, {
                            at: createPositionWithColumnOffset(this.state.startLoc, 1)
                        });
                    const a = this.input.charCodeAt(this.state.pos);
                    if (96 === a)
                        return ++this.state.pos,
                        t += this.input.slice(r, this.state.pos),
                        void this.finishToken(24, i ? null : t);
                    if (36 === a && 123 === this.input.charCodeAt(this.state.pos + 1))
                        return this.state.pos += 2,
                        t += this.input.slice(r, this.state.pos),
                        void this.finishToken(25, i ? null : t);
                    if (92 === a) {
                        t += this.input.slice(r, this.state.pos);
                        const a = this.readEscapedChar(!0);
                        null === a ? i = !0 : t += a,
                        r = this.state.pos
                    } else if (isNewLine(a)) {
                        switch (t += this.input.slice(r, this.state.pos),
                        ++this.state.pos,
                        a) {
                        case 13:
                            10 === this.input.charCodeAt(this.state.pos) && ++this.state.pos;
                        case 10:
                            t += "\n";
                            break;
                        default:
                            t += String.fromCharCode(a)
                        }
                        ++this.state.curLine,
                        this.state.lineStart = this.state.pos,
                        r = this.state.pos
                    } else
                        ++this.state.pos
                }
            }
            recordStrictModeErrors(t, r) {
                const i = a.get(r);
                this.state.strict && !this.state.strictErrors.has(i) ? this.raise(t, {
                    at: r
                }) : this.state.strictErrors.set(i, {
                    loc: r,
                    message: t
                })
            }
            readEscapedChar(t) {
                const r = !t
                  , i = this.input.charCodeAt(++this.state.pos);
                switch (++this.state.pos,
                i) {
                case 110:
                    return "\n";
                case 114:
                    return "\r";
                case 120:
                    {
                        const t = this.readHexChar(2, !1, r);
                        return null === t ? null : String.fromCharCode(t)
                    }
                case 117:
                    {
                        const t = this.readCodePoint(r);
                        return null === t ? null : String.fromCodePoint(t)
                    }
                case 116:
                    return "\t";
                case 98:
                    return "\b";
                case 118:
                    return "\v";
                case 102:
                    return "\f";
                case 13:
                    10 === this.input.charCodeAt(this.state.pos) && ++this.state.pos;
                case 10:
                    this.state.lineStart = this.state.pos,
                    ++this.state.curLine;
                case 8232:
                case 8233:
                    return "";
                case 56:
                case 57:
                    if (t)
                        return null;
                    this.recordStrictModeErrors(l.StrictNumericEscape, createPositionWithColumnOffset(this.state.curPosition(), -1));
                default:
                    if (i >= 48 && i <= 55) {
                        const r = createPositionWithColumnOffset(this.state.curPosition(), -1);
                        let i = this.input.substr(this.state.pos - 1, 3).match(/^[0-7]+/)[0]
                          , a = parseInt(i, 8);
                        a > 255 && (i = i.slice(0, -1),
                        a = parseInt(i, 8)),
                        this.state.pos += i.length - 1;
                        const o = this.input.charCodeAt(this.state.pos);
                        if ("0" !== i || 56 === o || 57 === o) {
                            if (t)
                                return null;
                            this.recordStrictModeErrors(l.StrictNumericEscape, r)
                        }
                        return String.fromCharCode(a)
                    }
                    return String.fromCharCode(i)
                }
            }
            readHexChar(t, r, i) {
                const o = this.state.curPosition()
                  , u = this.readInt(16, t, r, !1);
                return null === u && (i ? this.raise(l.InvalidEscapeSequence, {
                    at: o
                }) : this.state.pos = a.get(o) - 1),
                u
            }
            readWord1(t) {
                this.state.containsEsc = !1;
                let r = "";
                const i = this.state.pos;
                let a = this.state.pos;
                for (void 0 !== t && (this.state.pos += t <= 65535 ? 1 : 2); this.state.pos < this.length; ) {
                    const t = this.codePointAtPos(this.state.pos);
                    if (isIdentifierChar(t))
                        this.state.pos += t <= 65535 ? 1 : 2;
                    else {
                        if (92 !== t)
                            break;
                        {
                            this.state.containsEsc = !0,
                            r += this.input.slice(a, this.state.pos);
                            const t = this.state.curPosition()
                              , o = this.state.pos === i ? isIdentifierStart : isIdentifierChar;
                            if (117 !== this.input.charCodeAt(++this.state.pos)) {
                                this.raise(l.MissingUnicodeEscape, {
                                    at: this.state.curPosition()
                                }),
                                a = this.state.pos - 1;
                                continue
                            }
                            ++this.state.pos;
                            const u = this.readCodePoint(!0);
                            null !== u && (o(u) || this.raise(l.EscapedCharNotAnIdentifier, {
                                at: t
                            }),
                            r += String.fromCodePoint(u)),
                            a = this.state.pos
                        }
                    }
                }
                return r + this.input.slice(a, this.state.pos)
            }
            readWord(t) {
                const r = this.readWord1(t)
                  , i = c.get(r);
                void 0 !== i ? this.finishToken(i, tokenLabelName(i)) : this.finishToken(124, r)
            }
            checkKeywordEscapes() {
                const {type: t} = this.state;
                tokenIsKeyword(t) && this.state.containsEsc && this.raise(l.InvalidEscapedReservedWord, {
                    at: this.state.startLoc
                }, tokenLabelName(t))
            }
            updateContext(t) {}
        }
        {
            addExtra(t, r, i, a=!0) {
                if (!t)
                    return;
                const o = t.extra = t.extra || {};
                a ? o[r] = i : Object.defineProperty(o, r, {
                    enumerable: a,
                    value: i
                })
            }
            isContextual(t) {
                return this.state.type === t && !this.state.containsEsc
            }
            isUnparsedContextual(t, r) {
                const i = t + r.length;
                if (this.input.slice(t, i) === r) {
                    const t = this.input.charCodeAt(i);
                    return !(isIdentifierChar(t) || 55296 == (64512 & t))
                }
                return !1
            }
            isLookaheadContextual(t) {
                const r = this.nextTokenStart();
                return this.isUnparsedContextual(r, t)
            }
            eatContextual(t) {
                return !!this.isContextual(t) && (this.next(),
                !0)
            }
            expectContextual(t, r) {
                if (!this.eatContextual(t)) {
                    if (null != r)
                        throw this.raise(r, {
                            at: this.state.startLoc
                        });
                    throw this.unexpected(null, t)
                }
            }
            canInsertSemicolon() {
                return this.match(131) || this.match(8) || this.hasPrecedingLineBreak()
            }
            hasPrecedingLineBreak() {
                return L.test(this.input.slice(a.get(this.state.lastTokEndLoc), this.state.start))
            }
            hasFollowingLineBreak() {
                return j.lastIndex = this.state.end,
                j.test(this.input)
            }
            isLineTerminator() {
                return this.eat(13) || this.canInsertSemicolon()
            }
            semicolon(t=!0) {
                (t ? this.isLineTerminator() : this.eat(13)) || this.raise(l.MissingSemicolon, {
                    at: this.state.lastTokEndLoc
                })
            }
            expect(t, r) {
                this.eat(t) || this.unexpected(r, t)
            }
            assertNoSpace(t="Unexpected space.") {
                this.state.start > a.get(this.state.lastTokEndLoc) && this.raise({
                    code: o.SyntaxError,
                    reasonCode: "UnexpectedSpace",
                    template: t
                }, {
                    at: this.state.lastTokEndLoc
                })
            }
            unexpected(t, r) {
                throw this.raise({
                    code: o.SyntaxError,
                    reasonCode: "UnexpectedToken",
                    template: null != r ? `Unexpected token, expected "${tokenLabelName(r)}"` : "Unexpected token"
                }, {
                    at: null != t ? t : this.state.startLoc
                })
            }
            getPluginNamesFromConfigs(t) {
                return t.map(t=>"string" == typeof t ? t : t[0])
            }
            expectPlugin(t, r) {
                if (!this.hasPlugin(t))
                    throw this.raiseWithData(null != r ? r : this.state.startLoc, {
                        missingPlugin: this.getPluginNamesFromConfigs([t])
                    }, `This experimental syntax requires enabling the parser plugin: ${JSON.stringify(t)}.`);
                return !0
            }
            expectOnePlugin(t) {
                if (!t.some(t=>this.hasPlugin(t)))
                    throw this.raiseWithData(this.state.startLoc, {
                        missingPlugin: this.getPluginNamesFromConfigs(t)
                    }, `This experimental syntax requires enabling one of the following parser plugin(s): ${t.map(t=>JSON.stringify(t)).join(", ")}.`)
            }
            tryParse(t, r=this.state.clone()) {
                const i = {
                    node: null
                };
                try {
                    const a = t((t=null)=>{
                        throw i.node = t,
                        i
                    }
                    );
                    if (this.state.errors.length > r.errors.length) {
                        const t = this.state;
                        return this.state = r,
                        this.state.tokensLength = t.tokensLength,
                        {
                            node: a,
                            error: t.errors[r.errors.length],
                            thrown: !1,
                            aborted: !1,
                            failState: t
                        }
                    }
                    return {
                        node: a,
                        error: null,
                        thrown: !1,
                        aborted: !1,
                        failState: null
                    }
                } catch (t) {
                    const a = this.state;
                    if (this.state = r,
                    t instanceof SyntaxError)
                        return {
                            node: null,
                            error: t,
                            thrown: !0,
                            aborted: !1,
                            failState: a
                        };
                    if (t === i)
                        return {
                            node: i.node,
                            error: null,
                            thrown: !1,
                            aborted: !0,
                            failState: a
                        };
                    throw t
                }
            }
            checkExpressionErrors(t, r) {
                if (!t)
                    return !1;
                const {shorthandAssignLoc: i, doubleProtoLoc: a, optionalParametersLoc: o} = t;
                if (!r)
                    return !!i || !!a || !!o;
                null != i && this.raise(l.InvalidCoverInitializedName, {
                    at: i
                }),
                null != a && this.raise(l.DuplicateProto, {
                    at: a
                }),
                null != o && this.unexpected(o)
            }
            isLiteralPropertyName() {
                return tokenIsLiteralPropertyName(this.state.type)
            }
            isPrivateName(t) {
                return "PrivateName" === t.type
            }
            getPrivateNameSV(t) {
                return t.id.name
            }
            hasPropertyAsPrivateName(t) {
                return ("MemberExpression" === t.type || "OptionalMemberExpression" === t.type) && this.isPrivateName(t.property)
            }
            isOptionalChain(t) {
                return "OptionalMemberExpression" === t.type || "OptionalCallExpression" === t.type
            }
            isObjectProperty(t) {
                return "ObjectProperty" === t.type
            }
            isObjectMethod(t) {
                return "ObjectMethod" === t.type
            }
            initializeScopes(t="module" === this.options.sourceType) {
                const r = this.state.labels;
                this.state.labels = [];
                const i = this.exportedIdentifiers;
                this.exportedIdentifiers = new Set;
                const a = this.inModule;
                this.inModule = t;
                const o = this.scope
                  , l = this.getScopeHandler();
                this.scope = new l(this.raise.bind(this),this.inModule);
                const u = this.prodParam;
                this.prodParam = new ProductionParameterHandler;
                const p = this.classScope;
                this.classScope = new ClassScopeHandler(this.raise.bind(this));
                const c = this.expressionScope;
                return this.expressionScope = new ExpressionScopeHandler(this.raise.bind(this)),
                ()=>{
                    this.state.labels = r,
                    this.exportedIdentifiers = i,
                    this.inModule = a,
                    this.scope = o,
                    this.prodParam = u,
                    this.classScope = p,
                    this.expressionScope = c
                }
            }
            enterInitialScopes() {
                let t = 0;
                this.inModule && (t |= 2),
                this.scope.enter(1),
                this.prodParam.enter(t)
            }
        }
        {
            startNode() {
                return new Node(this,this.state.start,this.state.startLoc)
            }
            startNodeAt(t, r) {
                return new Node(this,t,r)
            }
            startNodeAtNode(t) {
                return this.startNodeAt(t.start, t.loc.start)
            }
            finishNode(t, r) {
                return this.finishNodeAt(t, r, this.state.lastTokEndLoc)
            }
            finishNodeAt(t, r, i) {
                return t.type = r,
                t.end = a.get(i),
                t.loc.end = i,
                this.options.ranges && (t.range[1] = t.end),
                this.options.attachComment && this.processComment(t),
                t
            }
            resetStartLocation(t, r, i) {
                t.start = r,
                t.loc.start = i,
                this.options.ranges && (t.range[0] = r)
            }
            resetEndLocation(t, r=this.state.lastTokEndLoc) {
                t.end = a.get(r),
                t.loc.end = r,
                this.options.ranges && (t.range[1] = t.end)
            }
            resetStartLocationFromNode(t, r) {
                this.resetStartLocation(t, r.start, r.loc.start)
            }
        }
        {
            toAssignable(t, r=!1) {
                var i, a;
                let o = void 0;
                switch (("ParenthesizedExpression" === t.type || null != (i = t.extra) && i.parenthesized) && (o = unwrapParenthesizedExpression(t),
                r ? "Identifier" === o.type ? this.expressionScope.recordParenthesizedIdentifierError(l.InvalidParenthesizedAssignment, t.loc.start) : "MemberExpression" !== o.type && this.raise(l.InvalidParenthesizedAssignment, {
                    node: t
                }) : this.raise(l.InvalidParenthesizedAssignment, {
                    node: t
                })),
                t.type) {
                case "Identifier":
                case "ObjectPattern":
                case "ArrayPattern":
                case "AssignmentPattern":
                case "RestElement":
                    break;
                case "ObjectExpression":
                    t.type = "ObjectPattern";
                    for (let i = 0, a = t.properties.length, o = a - 1; i < a; i++) {
                        var u;
                        const a = t.properties[i]
                          , p = i === o;
                        this.toAssignableObjectExpressionProp(a, p, r),
                        p && "RestElement" === a.type && null != (u = t.extra) && u.trailingCommaLoc && this.raise(l.RestTrailingComma, {
                            at: t.extra.trailingCommaLoc
                        })
                    }
                    break;
                case "ObjectProperty":
                    this.toAssignable(t.value, r);
                    break;
                case "SpreadElement":
                    {
                        this.checkToRestConversion(t),
                        t.type = "RestElement";
                        const i = t.argument;
                        this.toAssignable(i, r);
                        break
                    }
                case "ArrayExpression":
                    t.type = "ArrayPattern",
                    this.toAssignableList(t.elements, null == (a = t.extra) ? void 0 : a.trailingCommaLoc, r);
                    break;
                case "AssignmentExpression":
                    "=" !== t.operator && this.raise(l.MissingEqInAssignment, {
                        at: t.left.loc.end
                    }),
                    t.type = "AssignmentPattern",
                    delete t.operator,
                    this.toAssignable(t.left, r);
                    break;
                case "ParenthesizedExpression":
                    this.toAssignable(o, r)
                }
                return t
            }
            toAssignableObjectExpressionProp(t, r, i) {
                "ObjectMethod" === t.type ? this.raise("get" === t.kind || "set" === t.kind ? l.PatternHasAccessor : l.PatternHasMethod, {
                    node: t.key
                }) : "SpreadElement" !== t.type || r ? this.toAssignable(t, i) : this.raise(l.RestTrailingComma, {
                    node: t
                })
            }
            toAssignableList(t, r, i) {
                let a = t.length;
                if (a) {
                    const o = t[a - 1];
                    if ("RestElement" === (null == o ? void 0 : o.type))
                        --a;
                    else if ("SpreadElement" === (null == o ? void 0 : o.type)) {
                        o.type = "RestElement";
                        let t = o.argument;
                        this.toAssignable(t, i),
                        t = unwrapParenthesizedExpression(t),
                        "Identifier" !== t.type && "MemberExpression" !== t.type && "ArrayPattern" !== t.type && "ObjectPattern" !== t.type && this.unexpected(t.start),
                        r && this.raise(l.RestTrailingComma, {
                            at: r
                        }),
                        --a
                    }
                }
                for (let r = 0; r < a; r++) {
                    const a = t[r];
                    a && (this.toAssignable(a, i),
                    "RestElement" === a.type && this.raise(l.RestTrailingComma, {
                        node: a
                    }))
                }
                return t
            }
            isAssignable(t, r) {
                switch (t.type) {
                case "Identifier":
                case "ObjectPattern":
                case "ArrayPattern":
                case "AssignmentPattern":
                case "RestElement":
                    return !0;
                case "ObjectExpression":
                    {
                        const r = t.properties.length - 1;
                        return t.properties.every((t,i)=>"ObjectMethod" !== t.type && (i === r || "SpreadElement" !== t.type) && this.isAssignable(t))
                    }
                case "ObjectProperty":
                    return this.isAssignable(t.value);
                case "SpreadElement":
                    return this.isAssignable(t.argument);
                case "ArrayExpression":
                    return t.elements.every(t=>null === t || this.isAssignable(t));
                case "AssignmentExpression":
                    return "=" === t.operator;
                case "ParenthesizedExpression":
                    return this.isAssignable(t.expression);
                case "MemberExpression":
                case "OptionalMemberExpression":
                    return !r;
                default:
                    return !1
                }
            }
            toReferencedList(t, r) {
                return t
            }
            toReferencedListDeep(t, r) {
                this.toReferencedList(t, r);
                for (const r of t)
                    "ArrayExpression" === (null == r ? void 0 : r.type) && this.toReferencedListDeep(r.elements)
            }
            parseSpread(t, r) {
                const i = this.startNode();
                return this.next(),
                i.argument = this.parseMaybeAssignAllowIn(t, void 0, r),
                this.finishNode(i, "SpreadElement")
            }
            parseRestBinding() {
                const t = this.startNode();
                return this.next(),
                t.argument = this.parseBindingAtom(),
                this.finishNode(t, "RestElement")
            }
            parseBindingAtom() {
                switch (this.state.type) {
                case 0:
                    {
                        const t = this.startNode();
                        return this.next(),
                        t.elements = this.parseBindingList(3, 93, !0),
                        this.finishNode(t, "ArrayPattern")
                    }
                case 5:
                    return this.parseObjectLike(8, !0)
                }
                return this.parseIdentifier()
            }
            parseBindingList(t, r, i, a) {
                const o = [];
                let u = !0;
                for (; !this.eat(t); )
                    if (u ? u = !1 : this.expect(12),
                    i && this.match(12))
                        o.push(null);
                    else {
                        if (this.eat(t))
                            break;
                        if (this.match(21)) {
                            if (o.push(this.parseAssignableListItemTypes(this.parseRestBinding())),
                            !this.checkCommaAfterRest(r)) {
                                this.expect(t);
                                break
                            }
                        } else {
                            const t = [];
                            for (this.match(26) && this.hasPlugin("decorators") && this.raise(l.UnsupportedParameterDecorator, {
                                at: this.state.startLoc
                            }); this.match(26); )
                                t.push(this.parseDecorator());
                            o.push(this.parseAssignableListItem(a, t))
                        }
                    }
                return o
            }
            parseBindingRestProperty(t) {
                return this.next(),
                t.argument = this.parseIdentifier(),
                this.checkCommaAfterRest(125),
                this.finishNode(t, "RestElement")
            }
            parseBindingProperty() {
                const t = this.startNode()
                  , {type: r, start: i, startLoc: a} = this.state;
                return 21 === r ? this.parseBindingRestProperty(t) : (this.parsePropertyName(t),
                t.method = !1,
                this.parseObjPropValue(t, i, a, !1, !1, !0, !1),
                t)
            }
            parseAssignableListItem(t, r) {
                const i = this.parseMaybeDefault();
                this.parseAssignableListItemTypes(i);
                const a = this.parseMaybeDefault(i.start, i.loc.start, i);
                return r.length && (i.decorators = r),
                a
            }
            parseAssignableListItemTypes(t) {
                return t
            }
            parseMaybeDefault(t, r, i) {
                var a, o, l;
                if (r = null != (a = r) ? a : this.state.startLoc,
                t = null != (o = t) ? o : this.state.start,
                i = null != (l = i) ? l : this.parseBindingAtom(),
                !this.eat(29))
                    return i;
                const u = this.startNodeAt(t, r);
                return u.left = i,
                u.right = this.parseMaybeAssignAllowIn(),
                this.finishNode(u, "AssignmentPattern")
            }
            checkLVal(t, r, i=64, a, o, u=!1) {
                switch (t.type) {
                case "Identifier":
                    {
                        const {name: r} = t;
                        this.state.strict && (u ? isStrictBindReservedWord(r, this.inModule) : isStrictBindOnlyReservedWord(r)) && this.raise(64 === i ? l.StrictEvalArguments : l.StrictEvalArgumentsBinding, {
                            node: t
                        }, r),
                        a && (a.has(r) ? this.raise(l.ParamDupe, {
                            node: t
                        }) : a.add(r)),
                        o && "let" === r && this.raise(l.LetInLexicalBinding, {
                            node: t
                        }),
                        64 & i || this.scope.declareName(r, i, t.loc.start);
                        break
                    }
                case "MemberExpression":
                    64 !== i && this.raise(l.InvalidPropertyBindingPattern, {
                        node: t
                    });
                    break;
                case "ObjectPattern":
                    for (let r of t.properties) {
                        if (this.isObjectProperty(r))
                            r = r.value;
                        else if (this.isObjectMethod(r))
                            continue;
                        this.checkLVal(r, "object destructuring pattern", i, a, o)
                    }
                    break;
                case "ArrayPattern":
                    for (const r of t.elements)
                        r && this.checkLVal(r, "array destructuring pattern", i, a, o);
                    break;
                case "AssignmentPattern":
                    this.checkLVal(t.left, "assignment pattern", i, a);
                    break;
                case "RestElement":
                    this.checkLVal(t.argument, "rest element", i, a);
                    break;
                case "ParenthesizedExpression":
                    this.checkLVal(t.expression, "parenthesized expression", i, a);
                    break;
                default:
                    this.raise(64 === i ? l.InvalidLhs : l.InvalidLhsBinding, {
                        node: t
                    }, r)
                }
            }
            checkToRestConversion(t) {
                "Identifier" !== t.argument.type && "MemberExpression" !== t.argument.type && this.raise(l.InvalidRestAssignmentPattern, {
                    node: t.argument
                })
            }
            checkCommaAfterRest(t) {
                return !!this.match(12) && (this.raise(this.lookaheadCharCode() === t ? l.RestTrailingComma : l.ElementAfterRest, {
                    at: this.state.startLoc
                }),
                !0)
            }
        }
        {
            checkProto(t, r, i, a) {
                if ("SpreadElement" === t.type || this.isObjectMethod(t) || t.computed || t.shorthand)
                    return;
                const o = t.key;
                if ("__proto__" === ("Identifier" === o.type ? o.name : o.value)) {
                    if (r)
                        return void this.raise(l.RecordNoProto, {
                            node: o
                        });
                    i.used && (a ? null === a.doubleProtoLoc && (a.doubleProtoLoc = o.loc.start) : this.raise(l.DuplicateProto, {
                        node: o
                    })),
                    i.used = !0
                }
            }
            shouldExitDescending(t, r) {
                return "ArrowFunctionExpression" === t.type && t.start === r
            }
            getExpression() {
                this.enterInitialScopes(),
                this.nextToken();
                const t = this.parseExpression();
                return this.match(131) || this.unexpected(),
                this.finalizeRemainingComments(),
                t.comments = this.state.comments,
                t.errors = this.state.errors,
                this.options.tokens && (t.tokens = this.tokens),
                t
            }
            parseExpression(t, r) {
                return t ? this.disallowInAnd(()=>this.parseExpressionBase(r)) : this.allowInAnd(()=>this.parseExpressionBase(r))
            }
            parseExpressionBase(t) {
                const r = this.state.start
                  , i = this.state.startLoc
                  , a = this.parseMaybeAssign(t);
                if (this.match(12)) {
                    const o = this.startNodeAt(r, i);
                    for (o.expressions = [a]; this.eat(12); )
                        o.expressions.push(this.parseMaybeAssign(t));
                    return this.toReferencedList(o.expressions),
                    this.finishNode(o, "SequenceExpression")
                }
                return a
            }
            parseMaybeAssignDisallowIn(t, r) {
                return this.disallowInAnd(()=>this.parseMaybeAssign(t, r))
            }
            parseMaybeAssignAllowIn(t, r) {
                return this.allowInAnd(()=>this.parseMaybeAssign(t, r))
            }
            setOptionalParametersError(t, r) {
                var i;
                t.optionalParametersLoc = null != (i = null == r ? void 0 : r.loc) ? i : this.state.startLoc
            }
            parseMaybeAssign(t, r) {
                const i = this.state.start
                  , o = this.state.startLoc;
                if (this.isContextual(101) && this.prodParam.hasYield) {
                    let t = this.parseYield();
                    return r && (t = r.call(this, t, i, o)),
                    t
                }
                let l;
                t ? l = !1 : (t = new ExpressionErrors,
                l = !0);
                const {type: u} = this.state;
                (10 === u || tokenIsIdentifier(u)) && (this.state.potentialArrowAt = this.state.start);
                let p = this.parseMaybeConditional(t);
                if (r && (p = r.call(this, p, i, o)),
                function tokenIsAssignment(t) {
                    return t >= 29 && t <= 33
                }(this.state.type)) {
                    const r = this.startNodeAt(i, o)
                      , l = this.state.value;
                    return r.operator = l,
                    this.match(29) ? (r.left = this.toAssignable(p, !0),
                    null != t.doubleProtoLoc && a.get(t.doubleProtoLoc) >= i && (t.doubleProtoLoc = null),
                    null != t.shorthandAssignLoc && a.get(t.shorthandAssignLoc) >= i && (t.shorthandAssignLoc = null)) : r.left = p,
                    this.checkLVal(p, "assignment expression"),
                    this.next(),
                    r.right = this.parseMaybeAssign(),
                    this.finishNode(r, "AssignmentExpression")
                }
                return l && this.checkExpressionErrors(t, !0),
                p
            }
            parseMaybeConditional(t) {
                const r = this.state.start
                  , i = this.state.startLoc
                  , a = this.state.potentialArrowAt
                  , o = this.parseExprOps(t);
                return this.shouldExitDescending(o, a) ? o : this.parseConditional(o, r, i, t)
            }
            parseConditional(t, r, i, a) {
                if (this.eat(17)) {
                    const a = this.startNodeAt(r, i);
                    return a.test = t,
                    a.consequent = this.parseMaybeAssignAllowIn(),
                    this.expect(14),
                    a.alternate = this.parseMaybeAssign(),
                    this.finishNode(a, "ConditionalExpression")
                }
                return t
            }
            parseMaybeUnaryOrPrivate(t) {
                return this.match(130) ? this.parsePrivateName() : this.parseMaybeUnary(t)
            }
            parseExprOps(t) {
                const r = this.state.start
                  , i = this.state.startLoc
                  , a = this.state.potentialArrowAt
                  , o = this.parseMaybeUnaryOrPrivate(t);
                return this.shouldExitDescending(o, a) ? o : this.parseExprOp(o, r, i, -1)
            }
            parseExprOp(t, r, i, a) {
                if (this.isPrivateName(t)) {
                    const r = this.getPrivateNameSV(t);
                    (a >= tokenOperatorPrecedence(54) || !this.prodParam.hasIn || !this.match(54)) && this.raise(l.PrivateInExpectedIn, {
                        node: t
                    }, r),
                    this.classScope.usePrivateName(r, t.loc.start)
                }
                const o = this.state.type;
                if (function tokenIsOperator(t) {
                    return t >= 37 && t <= 55
                }(o) && (this.prodParam.hasIn || !this.match(54))) {
                    let u = tokenOperatorPrecedence(o);
                    if (u > a) {
                        if (37 === o) {
                            if (this.expectPlugin("pipelineOperator"),
                            this.state.inFSharpPipelineDirectBody)
                                return t;
                            this.checkPipelineAtInfixOperator(t, i)
                        }
                        const p = this.startNodeAt(r, i);
                        p.left = t,
                        p.operator = this.state.value;
                        const c = 39 === o || 40 === o
                          , d = 38 === o;
                        if (d && (u = tokenOperatorPrecedence(40)),
                        this.next(),
                        37 === o && this.hasPlugin(["pipelineOperator", {
                            proposal: "minimal"
                        }]) && 92 === this.state.type && this.prodParam.hasAwait)
                            throw this.raise(l.UnexpectedAwaitAfterPipelineBody, {
                                at: this.state.startLoc
                            });
                        p.right = this.parseExprOpRightExpr(o, u),
                        this.finishNode(p, c || d ? "LogicalExpression" : "BinaryExpression");
                        const y = this.state.type;
                        if (d && (39 === y || 40 === y) || c && 38 === y)
                            throw this.raise(l.MixingCoalesceWithLogical, {
                                at: this.state.startLoc
                            });
                        return this.parseExprOp(p, r, i, a)
                    }
                }
                return t
            }
            parseExprOpRightExpr(t, r) {
                const i = this.state.start
                  , a = this.state.startLoc;
                switch (t) {
                case 37:
                    switch (this.getPluginOption("pipelineOperator", "proposal")) {
                    case "hack":
                        return this.withTopicBindingContext(()=>this.parseHackPipeBody());
                    case "smart":
                        return this.withTopicBindingContext(()=>{
                            if (this.prodParam.hasYield && this.isContextual(101))
                                throw this.raise(l.PipeBodyIsTighter, {
                                    at: this.state.startLoc
                                }, this.state.value);
                            return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(t, r), i, a)
                        }
                        );
                    case "fsharp":
                        return this.withSoloAwaitPermittingContext(()=>this.parseFSharpPipelineBody(r))
                    }
                default:
                    return this.parseExprOpBaseRightExpr(t, r)
                }
            }
            parseExprOpBaseRightExpr(t, r) {
                const i = this.state.start
                  , a = this.state.startLoc;
                return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), i, a, function tokenIsRightAssociative(t) {
                    return 53 === t
                }(t) ? r - 1 : r)
            }
            parseHackPipeBody() {
                var t;
                const {startLoc: r} = this.state
                  , i = this.parseMaybeAssign();
                return !ae.has(i.type) || null != (t = i.extra) && t.parenthesized || this.raise(l.PipeUnparenthesizedBody, {
                    at: r
                }, ae.get(i.type)),
                this.topicReferenceWasUsedInCurrentContext() || this.raise(l.PipeTopicUnused, {
                    at: r
                }),
                i
            }
            checkExponentialAfterUnary(t) {
                this.match(53) && this.raise(l.UnexpectedTokenUnaryExponentiation, {
                    node: t.argument
                })
            }
            parseMaybeUnary(t, r) {
                const i = this.state.start
                  , a = this.state.startLoc
                  , o = this.isContextual(92);
                if (o && this.isAwaitAllowed()) {
                    this.next();
                    const t = this.parseAwait(i, a);
                    return r || this.checkExponentialAfterUnary(t),
                    t
                }
                const u = this.match(34)
                  , p = this.startNode();
                if (function tokenIsPrefix(t) {
                    return g[t]
                }(this.state.type)) {
                    p.operator = this.state.value,
                    p.prefix = !0,
                    this.match(68) && this.expectPlugin("throwExpressions");
                    const i = this.match(85);
                    if (this.next(),
                    p.argument = this.parseMaybeUnary(null, !0),
                    this.checkExpressionErrors(t, !0),
                    this.state.strict && i) {
                        const t = p.argument;
                        "Identifier" === t.type ? this.raise(l.StrictDelete, {
                            node: p
                        }) : this.hasPropertyAsPrivateName(t) && this.raise(l.DeletePrivateField, {
                            node: p
                        })
                    }
                    if (!u)
                        return r || this.checkExponentialAfterUnary(p),
                        this.finishNode(p, "UnaryExpression")
                }
                const c = this.parseUpdate(p, u, t);
                if (o) {
                    const {type: t} = this.state;
                    if ((this.hasPlugin("v8intrinsic") ? tokenCanStartExpression(t) : tokenCanStartExpression(t) && !this.match(50)) && !this.isAmbiguousAwait())
                        return this.raiseOverwrite(a, l.AwaitNotInAsyncContext),
                        this.parseAwait(i, a)
                }
                return c
            }
            parseUpdate(t, r, i) {
                if (r)
                    return this.checkLVal(t.argument, "prefix operation"),
                    this.finishNode(t, "UpdateExpression");
                const a = this.state.start
                  , o = this.state.startLoc;
                let l = this.parseExprSubscripts(i);
                if (this.checkExpressionErrors(i, !1))
                    return l;
                for (; 34 === this.state.type && !this.canInsertSemicolon(); ) {
                    const t = this.startNodeAt(a, o);
                    t.operator = this.state.value,
                    t.prefix = !1,
                    t.argument = l,
                    this.checkLVal(l, "postfix operation"),
                    this.next(),
                    l = this.finishNode(t, "UpdateExpression")
                }
                return l
            }
            parseExprSubscripts(t) {
                const r = this.state.start
                  , i = this.state.startLoc
                  , a = this.state.potentialArrowAt
                  , o = this.parseExprAtom(t);
                return this.shouldExitDescending(o, a) ? o : this.parseSubscripts(o, r, i)
            }
            parseSubscripts(t, r, i, a) {
                const o = {
                    optionalChainMember: !1,
                    maybeAsyncArrow: this.atPossibleAsyncArrow(t),
                    stop: !1
                };
                do {
                    t = this.parseSubscript(t, r, i, a, o),
                    o.maybeAsyncArrow = !1
                } while (!o.stop);
                return t
            }
            parseSubscript(t, r, i, a, o) {
                const {type: l} = this.state;
                if (!a && 15 === l)
                    return this.parseBind(t, r, i, a, o);
                if (tokenIsTemplate(l))
                    return this.parseTaggedTemplateExpression(t, r, i, o);
                let u = !1;
                if (18 === l) {
                    if (a && 40 === this.lookaheadCharCode())
                        return o.stop = !0,
                        t;
                    o.optionalChainMember = u = !0,
                    this.next()
                }
                if (!a && this.match(10))
                    return this.parseCoverCallAndAsyncArrowHead(t, r, i, o, u);
                {
                    const a = this.eat(0);
                    return a || u || this.eat(16) ? this.parseMember(t, r, i, o, a, u) : (o.stop = !0,
                    t)
                }
            }
            parseMember(t, r, i, a, o, u) {
                const p = this.startNodeAt(r, i);
                return p.object = t,
                p.computed = o,
                o ? (p.property = this.parseExpression(),
                this.expect(3)) : this.match(130) ? ("Super" === t.type && this.raise(l.SuperPrivateField, {
                    at: i
                }),
                this.classScope.usePrivateName(this.state.value, this.state.startLoc),
                p.property = this.parsePrivateName()) : p.property = this.parseIdentifier(!0),
                a.optionalChainMember ? (p.optional = u,
                this.finishNode(p, "OptionalMemberExpression")) : this.finishNode(p, "MemberExpression")
            }
            parseBind(t, r, i, a, o) {
                const l = this.startNodeAt(r, i);
                return l.object = t,
                this.next(),
                l.callee = this.parseNoCallExpr(),
                o.stop = !0,
                this.parseSubscripts(this.finishNode(l, "BindExpression"), r, i, a)
            }
            parseCoverCallAndAsyncArrowHead(t, r, i, a, o) {
                const l = this.state.maybeInArrowParameters;
                let u = null;
                this.state.maybeInArrowParameters = !0,
                this.next();
                let p = this.startNodeAt(r, i);
                return p.callee = t,
                a.maybeAsyncArrow && (this.expressionScope.enter(function newAsyncArrowScope() {
                    return new ArrowHeadParsingScope(2)
                }()),
                u = new ExpressionErrors),
                a.optionalChainMember && (p.optional = o),
                p.arguments = o ? this.parseCallExpressionArguments(11) : this.parseCallExpressionArguments(11, "Import" === t.type, "Super" !== t.type, p, u),
                this.finishCallExpression(p, a.optionalChainMember),
                a.maybeAsyncArrow && this.shouldParseAsyncArrow() && !o ? (a.stop = !0,
                this.expressionScope.validateAsPattern(),
                this.expressionScope.exit(),
                p = this.parseAsyncArrowFromCallExpression(this.startNodeAt(r, i), p)) : (a.maybeAsyncArrow && (this.checkExpressionErrors(u, !0),
                this.expressionScope.exit()),
                this.toReferencedArguments(p)),
                this.state.maybeInArrowParameters = l,
                p
            }
            toReferencedArguments(t, r) {
                this.toReferencedListDeep(t.arguments, r)
            }
            parseTaggedTemplateExpression(t, r, i, a) {
                const o = this.startNodeAt(r, i);
                return o.tag = t,
                o.quasi = this.parseTemplate(!0),
                a.optionalChainMember && this.raise(l.OptionalChainingNoTemplate, {
                    at: i
                }),
                this.finishNode(o, "TaggedTemplateExpression")
            }
            atPossibleAsyncArrow(t) {
                return "Identifier" === t.type && "async" === t.name && a.get(this.state.lastTokEndLoc) === t.end && !this.canInsertSemicolon() && t.end - t.start == 5 && t.start === this.state.potentialArrowAt
            }
            finishCallExpression(t, r) {
                if ("Import" === t.callee.type)
                    if (2 === t.arguments.length && (this.hasPlugin("moduleAttributes") || this.expectPlugin("importAssertions")),
                    0 === t.arguments.length || t.arguments.length > 2)
                        this.raise(l.ImportCallArity, {
                            node: t
                        }, this.hasPlugin("importAssertions") || this.hasPlugin("moduleAttributes") ? "one or two arguments" : "one argument");
                    else
                        for (const r of t.arguments)
                            "SpreadElement" === r.type && this.raise(l.ImportCallSpreadArgument, {
                                node: r
                            });
                return this.finishNode(t, r ? "OptionalCallExpression" : "CallExpression")
            }
            parseCallExpressionArguments(t, r, i, a, o) {
                const u = [];
                let p = !0;
                const c = this.state.inFSharpPipelineDirectBody;
                for (this.state.inFSharpPipelineDirectBody = !1; !this.eat(t); ) {
                    if (p)
                        p = !1;
                    else if (this.expect(12),
                    this.match(t)) {
                        !r || this.hasPlugin("importAssertions") || this.hasPlugin("moduleAttributes") || this.raise(l.ImportCallArgumentTrailingComma, {
                            at: this.state.lastTokStartLoc
                        }),
                        a && this.addTrailingCommaExtraToNode(a),
                        this.next();
                        break
                    }
                    u.push(this.parseExprListItem(!1, o, i))
                }
                return this.state.inFSharpPipelineDirectBody = c,
                u
            }
            shouldParseAsyncArrow() {
                return this.match(19) && !this.canInsertSemicolon()
            }
            parseAsyncArrowFromCallExpression(t, r) {
                var i;
                return this.resetPreviousNodeTrailingComments(r),
                this.expect(19),
                this.parseArrowExpression(t, r.arguments, !0, null == (i = r.extra) ? void 0 : i.trailingCommaLoc),
                r.innerComments && setInnerComments(t, r.innerComments),
                r.callee.trailingComments && setInnerComments(t, r.callee.trailingComments),
                t
            }
            parseNoCallExpr() {
                const t = this.state.start
                  , r = this.state.startLoc;
                return this.parseSubscripts(this.parseExprAtom(), t, r, !0)
            }
            parseExprAtom(t) {
                let r;
                const {type: i} = this.state;
                switch (i) {
                case 75:
                    return this.parseSuper();
                case 79:
                    return r = this.startNode(),
                    this.next(),
                    this.match(16) ? this.parseImportMetaProperty(r) : (this.match(10) || this.raise(l.UnsupportedImport, {
                        at: this.state.lastTokStartLoc
                    }),
                    this.finishNode(r, "Import"));
                case 74:
                    return r = this.startNode(),
                    this.next(),
                    this.finishNode(r, "ThisExpression");
                case 86:
                    return this.parseDo(this.startNode(), !1);
                case 52:
                case 31:
                    return this.readRegexp(),
                    this.parseRegExpLiteral(this.state.value);
                case 126:
                    return this.parseNumericLiteral(this.state.value);
                case 127:
                    return this.parseBigIntLiteral(this.state.value);
                case 128:
                    return this.parseDecimalLiteral(this.state.value);
                case 125:
                    return this.parseStringLiteral(this.state.value);
                case 80:
                    return this.parseNullLiteral();
                case 81:
                    return this.parseBooleanLiteral(!0);
                case 82:
                    return this.parseBooleanLiteral(!1);
                case 10:
                    {
                        const t = this.state.potentialArrowAt === this.state.start;
                        return this.parseParenAndDistinguishExpression(t)
                    }
                case 2:
                case 1:
                    return this.parseArrayLike(2 === this.state.type ? 4 : 3, !1, !0);
                case 0:
                    return this.parseArrayLike(3, !0, !1, t);
                case 6:
                case 7:
                    return this.parseObjectLike(6 === this.state.type ? 9 : 8, !1, !0);
                case 5:
                    return this.parseObjectLike(8, !1, !1, t);
                case 64:
                    return this.parseFunctionOrFunctionSent();
                case 26:
                    this.parseDecorators();
                case 76:
                    return r = this.startNode(),
                    this.takeDecorators(r),
                    this.parseClass(r, !1);
                case 73:
                    return this.parseNewOrNewTarget();
                case 25:
                case 24:
                    return this.parseTemplate(!1);
                case 15:
                    {
                        r = this.startNode(),
                        this.next(),
                        r.object = null;
                        const t = r.callee = this.parseNoCallExpr();
                        if ("MemberExpression" === t.type)
                            return this.finishNode(r, "BindExpression");
                        throw this.raise(l.UnsupportedBind, {
                            node: t
                        })
                    }
                case 130:
                    return this.raise(l.PrivateInExpectedIn, {
                        at: this.state.startLoc
                    }, this.state.value),
                    this.parsePrivateName();
                case 33:
                    return this.parseTopicReferenceThenEqualsSign(50, "%");
                case 32:
                    return this.parseTopicReferenceThenEqualsSign(42, "^");
                case 42:
                case 50:
                case 27:
                    {
                        const t = this.getPluginOption("pipelineOperator", "proposal");
                        if (t)
                            return this.parseTopicReference(t);
                        throw this.unexpected()
                    }
                case 45:
                    {
                        const t = this.input.codePointAt(this.nextTokenStart());
                        if (isIdentifierStart(t) || 62 === t) {
                            this.expectOnePlugin(["jsx", "flow", "typescript"]);
                            break
                        }
                        throw this.unexpected()
                    }
                default:
                    if (tokenIsIdentifier(i)) {
                        if (this.isContextual(119) && 123 === this.lookaheadCharCode() && !this.hasFollowingLineBreak())
                            return this.parseModuleExpression();
                        const t = this.state.potentialArrowAt === this.state.start
                          , r = this.state.containsEsc
                          , i = this.parseIdentifier();
                        if (!r && "async" === i.name && !this.canInsertSemicolon()) {
                            const {type: t} = this.state;
                            if (64 === t)
                                return this.resetPreviousNodeTrailingComments(i),
                                this.next(),
                                this.parseFunction(this.startNodeAtNode(i), void 0, !0);
                            if (tokenIsIdentifier(t))
                                return 61 === this.lookaheadCharCode() ? this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(i)) : i;
                            if (86 === t)
                                return this.resetPreviousNodeTrailingComments(i),
                                this.parseDo(this.startNodeAtNode(i), !0)
                        }
                        return t && this.match(19) && !this.canInsertSemicolon() ? (this.next(),
                        this.parseArrowExpression(this.startNodeAtNode(i), [i], !1)) : i
                    }
                    throw this.unexpected()
                }
            }
            parseTopicReferenceThenEqualsSign(t, r) {
                const i = this.getPluginOption("pipelineOperator", "proposal");
                if (i)
                    return this.state.type = t,
                    this.state.value = r,
                    this.state.pos--,
                    this.state.end--,
                    this.state.endLoc = createPositionWithColumnOffset(this.state.endLoc, -1),
                    this.parseTopicReference(i);
                throw this.unexpected()
            }
            parseTopicReference(t) {
                const r = this.startNode()
                  , i = this.state.startLoc
                  , a = this.state.type;
                return this.next(),
                this.finishTopicReference(r, i, t, a)
            }
            finishTopicReference(t, r, i, a) {
                if (this.testTopicReferenceConfiguration(i, r, a)) {
                    const a = "smart" === i ? "PipelinePrimaryTopicReference" : "TopicReference";
                    return this.topicReferenceIsAllowedInCurrentContext() || this.raise("smart" === i ? l.PrimaryTopicNotAllowed : l.PipeTopicUnbound, {
                        at: r
                    }),
                    this.registerTopicReference(),
                    this.finishNode(t, a)
                }
                throw this.raise(l.PipeTopicUnconfiguredToken, {
                    at: r
                }, tokenLabelName(a))
            }
            testTopicReferenceConfiguration(t, r, i) {
                switch (t) {
                case "hack":
                    return this.hasPlugin(["pipelineOperator", {
                        topicToken: tokenLabelName(i)
                    }]);
                case "smart":
                    return 27 === i;
                default:
                    throw this.raise(l.PipeTopicRequiresHackPipes, {
                        at: r
                    })
                }
            }
            parseAsyncArrowUnaryFunction(t) {
                this.prodParam.enter(functionFlags(!0, this.prodParam.hasYield));
                const r = [this.parseIdentifier()];
                return this.prodParam.exit(),
                this.hasPrecedingLineBreak() && this.raise(l.LineTerminatorBeforeArrow, {
                    at: this.state.curPosition()
                }),
                this.expect(19),
                this.parseArrowExpression(t, r, !0),
                t
            }
            parseDo(t, r) {
                this.expectPlugin("doExpressions"),
                r && this.expectPlugin("asyncDoExpressions"),
                t.async = r,
                this.next();
                const i = this.state.labels;
                return this.state.labels = [],
                r ? (this.prodParam.enter(2),
                t.body = this.parseBlock(),
                this.prodParam.exit()) : t.body = this.parseBlock(),
                this.state.labels = i,
                this.finishNode(t, "DoExpression")
            }
            parseSuper() {
                const t = this.startNode();
                return this.next(),
                !this.match(10) || this.scope.allowDirectSuper || this.options.allowSuperOutsideMethod ? this.scope.allowSuper || this.options.allowSuperOutsideMethod || this.raise(l.UnexpectedSuper, {
                    node: t
                }) : this.raise(l.SuperNotAllowed, {
                    node: t
                }),
                this.match(10) || this.match(0) || this.match(16) || this.raise(l.UnsupportedSuper, {
                    node: t
                }),
                this.finishNode(t, "Super")
            }
            parsePrivateName() {
                const t = this.startNode()
                  , r = this.startNodeAt(this.state.start + 1, new Position(this.state.curLine,this.state.start + 1 - this.state.lineStart,this.state.start + 1))
                  , i = this.state.value;
                return this.next(),
                t.id = this.createIdentifier(r, i),
                this.finishNode(t, "PrivateName")
            }
            parseFunctionOrFunctionSent() {
                const t = this.startNode();
                if (this.next(),
                this.prodParam.hasYield && this.match(16)) {
                    const r = this.createIdentifier(this.startNodeAtNode(t), "function");
                    return this.next(),
                    this.match(98) ? this.expectPlugin("functionSent") : this.hasPlugin("functionSent") || this.unexpected(),
                    this.parseMetaProperty(t, r, "sent")
                }
                return this.parseFunction(t)
            }
            parseMetaProperty(t, r, i) {
                t.meta = r;
                const a = this.state.containsEsc;
                return t.property = this.parseIdentifier(!0),
                (t.property.name !== i || a) && this.raise(l.UnsupportedMetaProperty, {
                    node: t.property
                }, r.name, i),
                this.finishNode(t, "MetaProperty")
            }
            parseImportMetaProperty(t) {
                const r = this.createIdentifier(this.startNodeAtNode(t), "import");
                return this.next(),
                this.isContextual(96) && (this.inModule || this.raise(u.ImportMetaOutsideModule, {
                    node: r
                }),
                this.sawUnambiguousESM = !0),
                this.parseMetaProperty(t, r, "meta")
            }
            parseLiteralAtNode(t, r, i) {
                return this.addExtra(i, "rawValue", t),
                this.addExtra(i, "raw", this.input.slice(i.start, this.state.end)),
                i.value = t,
                this.next(),
                this.finishNode(i, r)
            }
            parseLiteral(t, r) {
                const i = this.startNode();
                return this.parseLiteralAtNode(t, r, i)
            }
            parseStringLiteral(t) {
                return this.parseLiteral(t, "StringLiteral")
            }
            parseNumericLiteral(t) {
                return this.parseLiteral(t, "NumericLiteral")
            }
            parseBigIntLiteral(t) {
                return this.parseLiteral(t, "BigIntLiteral")
            }
            parseDecimalLiteral(t) {
                return this.parseLiteral(t, "DecimalLiteral")
            }
            parseRegExpLiteral(t) {
                const r = this.parseLiteral(t.value, "RegExpLiteral");
                return r.pattern = t.pattern,
                r.flags = t.flags,
                r
            }
            parseBooleanLiteral(t) {
                const r = this.startNode();
                return r.value = t,
                this.next(),
                this.finishNode(r, "BooleanLiteral")
            }
            parseNullLiteral() {
                const t = this.startNode();
                return this.next(),
                this.finishNode(t, "NullLiteral")
            }
            parseParenAndDistinguishExpression(t) {
                const r = this.state.start
                  , i = this.state.startLoc;
                let o;
                this.next(),
                this.expressionScope.enter(function newArrowHeadScope() {
                    return new ArrowHeadParsingScope(1)
                }());
                const l = this.state.maybeInArrowParameters
                  , u = this.state.inFSharpPipelineDirectBody;
                this.state.maybeInArrowParameters = !0,
                this.state.inFSharpPipelineDirectBody = !1;
                const p = this.state.start
                  , c = this.state.startLoc
                  , d = []
                  , y = new ExpressionErrors;
                let h, m, T = !0;
                for (; !this.match(11); ) {
                    if (T)
                        T = !1;
                    else if (this.expect(12, null === y.optionalParametersLoc ? null : y.optionalParametersLoc),
                    this.match(11)) {
                        m = this.state.startLoc;
                        break
                    }
                    if (this.match(21)) {
                        const t = this.state.start
                          , r = this.state.startLoc;
                        if (h = this.state.startLoc,
                        d.push(this.parseParenItem(this.parseRestBinding(), t, r)),
                        !this.checkCommaAfterRest(41))
                            break
                    } else
                        d.push(this.parseMaybeAssignAllowIn(y, this.parseParenItem))
                }
                const S = this.state.lastTokEndLoc;
                this.expect(11),
                this.state.maybeInArrowParameters = l,
                this.state.inFSharpPipelineDirectBody = u;
                let g = this.startNodeAt(r, i);
                if (t && this.shouldParseArrow(d) && (g = this.parseArrow(g)))
                    return this.expressionScope.validateAsPattern(),
                    this.expressionScope.exit(),
                    this.parseArrowExpression(g, d, !1),
                    g;
                if (this.expressionScope.exit(),
                d.length || this.unexpected(this.state.lastTokStartLoc),
                m && this.unexpected(m),
                h && this.unexpected(h),
                this.checkExpressionErrors(y, !0),
                this.toReferencedListDeep(d, !0),
                d.length > 1 ? (o = this.startNodeAt(p, c),
                o.expressions = d,
                this.finishNode(o, "SequenceExpression"),
                this.resetEndLocation(o, S)) : o = d[0],
                !this.options.createParenthesizedExpressions)
                    return this.addExtra(o, "parenthesized", !0),
                    this.addExtra(o, "parenStart", r),
                    this.takeSurroundingComments(o, r, a.get(this.state.lastTokEndLoc)),
                    o;
                const b = this.startNodeAt(r, i);
                return b.expression = o,
                this.finishNode(b, "ParenthesizedExpression"),
                b
            }
            shouldParseArrow(t) {
                return !this.canInsertSemicolon()
            }
            parseArrow(t) {
                if (this.eat(19))
                    return t
            }
            parseParenItem(t, r, i) {
                return t
            }
            parseNewOrNewTarget() {
                const t = this.startNode();
                if (this.next(),
                this.match(16)) {
                    const r = this.createIdentifier(this.startNodeAtNode(t), "new");
                    this.next();
                    const i = this.parseMetaProperty(t, r, "target");
                    return this.scope.inNonArrowFunction || this.scope.inClass || this.raise(l.UnexpectedNewTarget, {
                        node: i
                    }),
                    i
                }
                return this.parseNew(t)
            }
            parseNew(t) {
                return t.callee = this.parseNoCallExpr(),
                "Import" === t.callee.type ? this.raise(l.ImportCallNotNewExpression, {
                    node: t.callee
                }) : this.isOptionalChain(t.callee) ? this.raise(l.OptionalChainingNoNew, {
                    at: this.state.lastTokEndLoc
                }) : this.eat(18) && this.raise(l.OptionalChainingNoNew, {
                    at: this.state.startLoc
                }),
                this.parseNewArguments(t),
                this.finishNode(t, "NewExpression")
            }
            parseNewArguments(t) {
                if (this.eat(10)) {
                    const r = this.parseExprList(11);
                    this.toReferencedList(r),
                    t.arguments = r
                } else
                    t.arguments = []
            }
            parseTemplateElement(t) {
                const {start: r, startLoc: i, end: a, value: o} = this.state
                  , u = r + 1
                  , p = this.startNodeAt(u, createPositionWithColumnOffset(i, 1));
                null === o && (t || this.raise(l.InvalidEscapeSequenceTemplate, {
                    at: createPositionWithColumnOffset(i, 2)
                }));
                const c = this.match(24)
                  , d = c ? -1 : -2
                  , y = a + d;
                return p.value = {
                    raw: this.input.slice(u, y).replace(/\r\n?/g, "\n"),
                    cooked: null === o ? null : o.slice(1, d)
                },
                p.tail = c,
                this.next(),
                this.finishNode(p, "TemplateElement"),
                this.resetEndLocation(p, createPositionWithColumnOffset(this.state.lastTokEndLoc, d)),
                p
            }
            parseTemplate(t) {
                const r = this.startNode();
                r.expressions = [];
                let i = this.parseTemplateElement(t);
                for (r.quasis = [i]; !i.tail; )
                    r.expressions.push(this.parseTemplateSubstitution()),
                    this.readTemplateContinuation(),
                    r.quasis.push(i = this.parseTemplateElement(t));
                return this.finishNode(r, "TemplateLiteral")
            }
            parseTemplateSubstitution() {
                return this.parseExpression()
            }
            parseObjectLike(t, r, i, a) {
                i && this.expectPlugin("recordAndTuple");
                const o = this.state.inFSharpPipelineDirectBody;
                this.state.inFSharpPipelineDirectBody = !1;
                const u = Object.create(null);
                let p = !0;
                const c = this.startNode();
                for (c.properties = [],
                this.next(); !this.match(t); ) {
                    if (p)
                        p = !1;
                    else if (this.expect(12),
                    this.match(t)) {
                        this.addTrailingCommaExtraToNode(c);
                        break
                    }
                    let o;
                    r ? o = this.parseBindingProperty() : (o = this.parsePropertyDefinition(a),
                    this.checkProto(o, i, u, a)),
                    i && !this.isObjectProperty(o) && "SpreadElement" !== o.type && this.raise(l.InvalidRecordProperty, {
                        node: o
                    }),
                    o.shorthand && this.addExtra(o, "shorthand", !0),
                    c.properties.push(o)
                }
                this.next(),
                this.state.inFSharpPipelineDirectBody = o;
                let d = "ObjectExpression";
                return r ? d = "ObjectPattern" : i && (d = "RecordExpression"),
                this.finishNode(c, d)
            }
            addTrailingCommaExtraToNode(t) {
                this.addExtra(t, "trailingComma", this.state.lastTokStart),
                this.addExtra(t, "trailingCommaLoc", this.state.lastTokStartLoc, !1)
            }
            maybeAsyncOrAccessorProp(t) {
                return !t.computed && "Identifier" === t.key.type && (this.isLiteralPropertyName() || this.match(0) || this.match(51))
            }
            parsePropertyDefinition(t) {
                let r = [];
                if (this.match(26))
                    for (this.hasPlugin("decorators") && this.raise(l.UnsupportedPropertyDecorator, {
                        at: this.state.startLoc
                    }); this.match(26); )
                        r.push(this.parseDecorator());
                const i = this.startNode();
                let a, o, u = !1, p = !1;
                if (this.match(21))
                    return r.length && this.unexpected(),
                    this.parseSpread();
                r.length && (i.decorators = r,
                r = []),
                i.method = !1,
                t && (a = this.state.start,
                o = this.state.startLoc);
                let c = this.eat(51);
                this.parsePropertyNamePrefixOperator(i);
                const d = this.state.containsEsc
                  , y = this.parsePropertyName(i);
                if (!c && !d && this.maybeAsyncOrAccessorProp(i)) {
                    const t = y.name;
                    "async" !== t || this.hasPrecedingLineBreak() || (u = !0,
                    this.resetPreviousNodeTrailingComments(y),
                    c = this.eat(51),
                    this.parsePropertyName(i)),
                    "get" !== t && "set" !== t || (p = !0,
                    this.resetPreviousNodeTrailingComments(y),
                    i.kind = t,
                    this.match(51) && (c = !0,
                    this.raise(l.AccessorIsGenerator, {
                        at: this.state.curPosition()
                    }, t),
                    this.next()),
                    this.parsePropertyName(i))
                }
                return this.parseObjPropValue(i, a, o, c, u, !1, p, t),
                i
            }
            getGetterSetterExpectedParamCount(t) {
                return "get" === t.kind ? 0 : 1
            }
            getObjectOrClassMethodParams(t) {
                return t.params
            }
            checkGetterSetterParams(t) {
                var r;
                const i = this.getGetterSetterExpectedParamCount(t)
                  , a = this.getObjectOrClassMethodParams(t);
                a.length !== i && this.raise("get" === t.kind ? l.BadGetterArity : l.BadSetterArity, {
                    node: t
                }),
                "set" === t.kind && "RestElement" === (null == (r = a[a.length - 1]) ? void 0 : r.type) && this.raise(l.BadSetterRestParameter, {
                    node: t
                })
            }
            parseObjectMethod(t, r, i, a, o) {
                return o ? (this.parseMethod(t, r, !1, !1, !1, "ObjectMethod"),
                this.checkGetterSetterParams(t),
                t) : i || r || this.match(10) ? (a && this.unexpected(),
                t.kind = "method",
                t.method = !0,
                this.parseMethod(t, r, i, !1, !1, "ObjectMethod")) : void 0
            }
            parseObjectProperty(t, r, i, a, o) {
                if (t.shorthand = !1,
                this.eat(14))
                    return t.value = a ? this.parseMaybeDefault(this.state.start, this.state.startLoc) : this.parseMaybeAssignAllowIn(o),
                    this.finishNode(t, "ObjectProperty");
                if (!t.computed && "Identifier" === t.key.type) {
                    if (this.checkReservedWord(t.key.name, t.key.loc.start, !0, !1),
                    a)
                        t.value = this.parseMaybeDefault(r, i, cloneIdentifier(t.key));
                    else if (this.match(29)) {
                        const a = this.state.startLoc;
                        null != o ? null === o.shorthandAssignLoc && (o.shorthandAssignLoc = a) : this.raise(l.InvalidCoverInitializedName, {
                            at: a
                        }),
                        t.value = this.parseMaybeDefault(r, i, cloneIdentifier(t.key))
                    } else
                        t.value = cloneIdentifier(t.key);
                    return t.shorthand = !0,
                    this.finishNode(t, "ObjectProperty")
                }
            }
            parseObjPropValue(t, r, i, a, o, l, u, p) {
                const c = this.parseObjectMethod(t, a, o, l, u) || this.parseObjectProperty(t, r, i, l, p);
                return c || this.unexpected(),
                c
            }
            parsePropertyName(t) {
                if (this.eat(0))
                    t.computed = !0,
                    t.key = this.parseMaybeAssignAllowIn(),
                    this.expect(3);
                else {
                    const {type: r, value: i} = this.state;
                    let a;
                    if (tokenIsKeywordOrIdentifier(r))
                        a = this.parseIdentifier(!0);
                    else
                        switch (r) {
                        case 126:
                            a = this.parseNumericLiteral(i);
                            break;
                        case 125:
                            a = this.parseStringLiteral(i);
                            break;
                        case 127:
                            a = this.parseBigIntLiteral(i);
                            break;
                        case 128:
                            a = this.parseDecimalLiteral(i);
                            break;
                        case 130:
                            this.raise(l.UnexpectedPrivateField, {
                                at: createPositionWithColumnOffset(this.state.startLoc, 1)
                            }),
                            a = this.parsePrivateName();
                            break;
                        default:
                            throw this.unexpected()
                        }
                    t.key = a,
                    130 !== r && (t.computed = !1)
                }
                return t.key
            }
            initFunction(t, r) {
                t.id = null,
                t.generator = !1,
                t.async = !!r
            }
            parseMethod(t, r, i, a, o, l, u=!1) {
                this.initFunction(t, i),
                t.generator = !!r;
                const p = a;
                return this.scope.enter(18 | (u ? 64 : 0) | (o ? 32 : 0)),
                this.prodParam.enter(functionFlags(i, t.generator)),
                this.parseFunctionParams(t, p),
                this.parseFunctionBodyAndFinish(t, l, !0),
                this.prodParam.exit(),
                this.scope.exit(),
                t
            }
            parseArrayLike(t, r, i, a) {
                i && this.expectPlugin("recordAndTuple");
                const o = this.state.inFSharpPipelineDirectBody;
                this.state.inFSharpPipelineDirectBody = !1;
                const l = this.startNode();
                return this.next(),
                l.elements = this.parseExprList(t, !i, a, l),
                this.state.inFSharpPipelineDirectBody = o,
                this.finishNode(l, i ? "TupleExpression" : "ArrayExpression")
            }
            parseArrowExpression(t, r, i, a) {
                this.scope.enter(6);
                let o = functionFlags(i, !1);
                !this.match(5) && this.prodParam.hasIn && (o |= 8),
                this.prodParam.enter(o),
                this.initFunction(t, i);
                const l = this.state.maybeInArrowParameters;
                return r && (this.state.maybeInArrowParameters = !0,
                this.setArrowFunctionParameters(t, r, a)),
                this.state.maybeInArrowParameters = !1,
                this.parseFunctionBody(t, !0),
                this.prodParam.exit(),
                this.scope.exit(),
                this.state.maybeInArrowParameters = l,
                this.finishNode(t, "ArrowFunctionExpression")
            }
            setArrowFunctionParameters(t, r, i) {
                t.params = this.toAssignableList(r, i, !1)
            }
            parseFunctionBodyAndFinish(t, r, i=!1) {
                this.parseFunctionBody(t, !1, i),
                this.finishNode(t, r)
            }
            parseFunctionBody(t, r, i=!1) {
                const a = r && !this.match(5);
                if (this.expressionScope.enter(newExpressionScope()),
                a)
                    t.body = this.parseMaybeAssign(),
                    this.checkParams(t, !1, r, !1);
                else {
                    const a = this.state.strict
                      , o = this.state.labels;
                    this.state.labels = [],
                    this.prodParam.enter(4 | this.prodParam.currentFlags()),
                    t.body = this.parseBlock(!0, !1, o=>{
                        const u = !this.isSimpleParamList(t.params);
                        if (o && u) {
                            const r = "method" !== t.kind && "constructor" !== t.kind || !t.key ? {
                                node: t
                            } : {
                                at: t.key.loc.end
                            };
                            this.raise(l.IllegalLanguageModeDirective, r)
                        }
                        const p = !a && this.state.strict;
                        this.checkParams(t, !(this.state.strict || r || i || u), r, p),
                        this.state.strict && t.id && this.checkLVal(t.id, "function name", 65, void 0, void 0, p)
                    }
                    ),
                    this.prodParam.exit(),
                    this.state.labels = o
                }
                this.expressionScope.exit()
            }
            isSimpleParamList(t) {
                for (let r = 0, i = t.length; r < i; r++)
                    if ("Identifier" !== t[r].type)
                        return !1;
                return !0
            }
            checkParams(t, r, i, a=!0) {
                const o = new Set;
                for (const i of t.params)
                    this.checkLVal(i, "function parameter list", 5, r ? null : o, void 0, a)
            }
            parseExprList(t, r, i, a) {
                const o = [];
                let l = !0;
                for (; !this.eat(t); ) {
                    if (l)
                        l = !1;
                    else if (this.expect(12),
                    this.match(t)) {
                        a && this.addTrailingCommaExtraToNode(a),
                        this.next();
                        break
                    }
                    o.push(this.parseExprListItem(r, i))
                }
                return o
            }
            parseExprListItem(t, r, i) {
                let a;
                if (this.match(12))
                    t || this.raise(l.UnexpectedToken, {
                        at: this.state.curPosition()
                    }, ","),
                    a = null;
                else if (this.match(21)) {
                    const t = this.state.start
                      , i = this.state.startLoc;
                    a = this.parseParenItem(this.parseSpread(r), t, i)
                } else if (this.match(17)) {
                    this.expectPlugin("partialApplication"),
                    i || this.raise(l.UnexpectedArgumentPlaceholder, {
                        at: this.state.startLoc
                    });
                    const t = this.startNode();
                    this.next(),
                    a = this.finishNode(t, "ArgumentPlaceholder")
                } else
                    a = this.parseMaybeAssignAllowIn(r, this.parseParenItem);
                return a
            }
            parseIdentifier(t) {
                const r = this.startNode()
                  , i = this.parseIdentifierName(r.start, t);
                return this.createIdentifier(r, i)
            }
            createIdentifier(t, r) {
                return t.name = r,
                t.loc.identifierName = r,
                this.finishNode(t, "Identifier")
            }
            parseIdentifierName(t, r) {
                let i;
                const {startLoc: a, type: o} = this.state;
                if (!tokenIsKeywordOrIdentifier(o))
                    throw this.unexpected();
                i = this.state.value;
                const l = function tokenKeywordOrIdentifierIsKeyword(t) {
                    return t <= 88
                }(o);
                return r ? l && this.replaceToken(124) : this.checkReservedWord(i, a, l, !1),
                this.next(),
                i
            }
            checkReservedWord(t, r, i, a) {
                if (t.length > 10)
                    return;
                if (!function canBeReservedWord(t) {
                    return _.has(t)
                }(t))
                    return;
                if ("yield" === t) {
                    if (this.prodParam.hasYield)
                        return void this.raise(l.YieldBindingIdentifier, {
                            at: r
                        })
                } else if ("await" === t) {
                    if (this.prodParam.hasAwait)
                        return void this.raise(l.AwaitBindingIdentifier, {
                            at: r
                        });
                    if (this.scope.inStaticBlock)
                        return void this.raise(l.AwaitBindingIdentifierInStaticBlock, {
                            at: r
                        });
                    this.expressionScope.recordAsyncArrowParametersError(l.AwaitBindingIdentifier, r)
                } else if ("arguments" === t && this.scope.inClassAndNotInNonArrowFunction)
                    return void this.raise(l.ArgumentsInClass, {
                        at: r
                    });
                if (i && function isKeyword(t) {
                    return C.has(t)
                }(t))
                    return void this.raise(l.UnexpectedKeyword, {
                        at: r
                    }, t);
                (this.state.strict ? a ? isStrictBindReservedWord : isStrictReservedWord : isReservedWord)(t, this.inModule) && this.raise(l.UnexpectedReservedWord, {
                    at: r
                }, t)
            }
            isAwaitAllowed() {
                return !!this.prodParam.hasAwait || !(!this.options.allowAwaitOutsideFunction || this.scope.inFunction)
            }
            parseAwait(t, r) {
                const i = this.startNodeAt(t, r);
                return this.expressionScope.recordParameterInitializerError(i.loc.start, l.AwaitExpressionFormalParameter),
                this.eat(51) && this.raise(l.ObsoleteAwaitStar, {
                    node: i
                }),
                this.scope.inFunction || this.options.allowAwaitOutsideFunction || (this.isAmbiguousAwait() ? this.ambiguousScriptDifferentAst = !0 : this.sawUnambiguousESM = !0),
                this.state.soloAwait || (i.argument = this.parseMaybeUnary(null, !0)),
                this.finishNode(i, "AwaitExpression")
            }
            isAmbiguousAwait() {
                if (this.hasPrecedingLineBreak())
                    return !0;
                const {type: t} = this.state;
                return 49 === t || 10 === t || 0 === t || tokenIsTemplate(t) || 129 === t || 52 === t || this.hasPlugin("v8intrinsic") && 50 === t
            }
            parseYield() {
                const t = this.startNode();
                this.expressionScope.recordParameterInitializerError(t.loc.start, l.YieldInParameter),
                this.next();
                let r = !1
                  , i = null;
                if (!this.hasPrecedingLineBreak())
                    switch (r = this.eat(51),
                    this.state.type) {
                    case 13:
                    case 131:
                    case 8:
                    case 11:
                    case 3:
                    case 9:
                    case 14:
                    case 12:
                        if (!r)
                            break;
                    default:
                        i = this.parseMaybeAssign()
                    }
                return t.delegate = r,
                t.argument = i,
                this.finishNode(t, "YieldExpression")
            }
            checkPipelineAtInfixOperator(t, r) {
                this.hasPlugin(["pipelineOperator", {
                    proposal: "smart"
                }]) && "SequenceExpression" === t.type && this.raise(l.PipelineHeadSequenceExpression, {
                    at: r
                })
            }
            parseSmartPipelineBodyInStyle(t, r, i) {
                const a = this.startNodeAt(r, i);
                return this.isSimpleReference(t) ? (a.callee = t,
                this.finishNode(a, "PipelineBareFunction")) : (this.checkSmartPipeTopicBodyEarlyErrors(i),
                a.expression = t,
                this.finishNode(a, "PipelineTopicExpression"))
            }
            isSimpleReference(t) {
                switch (t.type) {
                case "MemberExpression":
                    return !t.computed && this.isSimpleReference(t.object);
                case "Identifier":
                    return !0;
                default:
                    return !1
                }
            }
            checkSmartPipeTopicBodyEarlyErrors(t) {
                if (this.match(19))
                    throw this.raise(l.PipelineBodyNoArrow, {
                        at: this.state.startLoc
                    });
                this.topicReferenceWasUsedInCurrentContext() || this.raise(l.PipelineTopicUnused, {
                    at: t
                })
            }
            withTopicBindingContext(t) {
                const r = this.state.topicContext;
                this.state.topicContext = {
                    maxNumOfResolvableTopics: 1,
                    maxTopicIndex: null
                };
                try {
                    return t()
                } finally {
                    this.state.topicContext = r
                }
            }
            withSmartMixTopicForbiddingContext(t) {
                if (!this.hasPlugin(["pipelineOperator", {
                    proposal: "smart"
                }]))
                    return t();
                {
                    const r = this.state.topicContext;
                    this.state.topicContext = {
                        maxNumOfResolvableTopics: 0,
                        maxTopicIndex: null
                    };
                    try {
                        return t()
                    } finally {
                        this.state.topicContext = r
                    }
                }
            }
            withSoloAwaitPermittingContext(t) {
                const r = this.state.soloAwait;
                this.state.soloAwait = !0;
                try {
                    return t()
                } finally {
                    this.state.soloAwait = r
                }
            }
            allowInAnd(t) {
                const r = this.prodParam.currentFlags();
                if (8 & ~r) {
                    this.prodParam.enter(8 | r);
                    try {
                        return t()
                    } finally {
                        this.prodParam.exit()
                    }
                }
                return t()
            }
            disallowInAnd(t) {
                const r = this.prodParam.currentFlags();
                if (8 & r) {
                    this.prodParam.enter(-9 & r);
                    try {
                        return t()
                    } finally {
                        this.prodParam.exit()
                    }
                }
                return t()
            }
            registerTopicReference() {
                this.state.topicContext.maxTopicIndex = 0
            }
            topicReferenceIsAllowedInCurrentContext() {
                return this.state.topicContext.maxNumOfResolvableTopics >= 1
            }
            topicReferenceWasUsedInCurrentContext() {
                return null != this.state.topicContext.maxTopicIndex && this.state.topicContext.maxTopicIndex >= 0
            }
            parseFSharpPipelineBody(t) {
                const r = this.state.start
                  , i = this.state.startLoc;
                this.state.potentialArrowAt = this.state.start;
                const a = this.state.inFSharpPipelineDirectBody;
                this.state.inFSharpPipelineDirectBody = !0;
                const o = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), r, i, t);
                return this.state.inFSharpPipelineDirectBody = a,
                o
            }
            parseModuleExpression() {
                this.expectPlugin("moduleBlocks");
                const t = this.startNode();
                this.next(),
                this.eat(5);
                const r = this.initializeScopes(!0);
                this.enterInitialScopes();
                const i = this.startNode();
                try {
                    t.body = this.parseProgram(i, 8, "module")
                } finally {
                    r()
                }
                return this.eat(8),
                this.finishNode(t, "ModuleExpression")
            }
            parsePropertyNamePrefixOperator(t) {}
        }
        {
            parseTopLevel(t, r) {
                return t.program = this.parseProgram(r),
                t.comments = this.state.comments,
                this.options.tokens && (t.tokens = function babel7CompatTokens(t, r) {
                    for (let i = 0; i < t.length; i++) {
                        const a = t[i]
                          , {type: o} = a;
                        if ("number" == typeof o) {
                            if (130 === o) {
                                const {loc: r, start: o, value: l, end: u} = a
                                  , p = o + 1
                                  , c = createPositionWithColumnOffset(r.start, 1);
                                t.splice(i, 1, new Token({
                                    type: getExportedToken(27),
                                    value: "#",
                                    start: o,
                                    end: p,
                                    startLoc: r.start,
                                    endLoc: c
                                }), new Token({
                                    type: getExportedToken(124),
                                    value: l,
                                    start: p,
                                    end: u,
                                    startLoc: c,
                                    endLoc: r.end
                                })),
                                i++;
                                continue
                            }
                            if (tokenIsTemplate(o)) {
                                const {loc: l, start: u, value: p, end: c} = a
                                  , d = u + 1
                                  , y = createPositionWithColumnOffset(l.start, 1);
                                let h, m, T, S, g;
                                h = 96 === r.charCodeAt(u) ? new Token({
                                    type: getExportedToken(22),
                                    value: "`",
                                    start: u,
                                    end: d,
                                    startLoc: l.start,
                                    endLoc: y
                                }) : new Token({
                                    type: getExportedToken(8),
                                    value: "}",
                                    start: u,
                                    end: d,
                                    startLoc: l.start,
                                    endLoc: y
                                }),
                                24 === o ? (T = c - 1,
                                S = createPositionWithColumnOffset(l.end, -1),
                                m = null === p ? null : p.slice(1, -1),
                                g = new Token({
                                    type: getExportedToken(22),
                                    value: "`",
                                    start: T,
                                    end: c,
                                    startLoc: S,
                                    endLoc: l.end
                                })) : (T = c - 2,
                                S = createPositionWithColumnOffset(l.end, -2),
                                m = null === p ? null : p.slice(1, -2),
                                g = new Token({
                                    type: getExportedToken(23),
                                    value: "${",
                                    start: T,
                                    end: c,
                                    startLoc: S,
                                    endLoc: l.end
                                })),
                                t.splice(i, 1, h, new Token({
                                    type: getExportedToken(20),
                                    value: m,
                                    start: d,
                                    end: T,
                                    startLoc: y,
                                    endLoc: S
                                }), g),
                                i += 2;
                                continue
                            }
                            a.type = getExportedToken(o)
                        }
                    }
                    return t
                }(this.tokens, this.input)),
                this.finishNode(t, "File")
            }
            parseProgram(t, r=131, i=this.options.sourceType) {
                if (t.sourceType = i,
                t.interpreter = this.parseInterpreterDirective(),
                this.parseBlockBody(t, !0, !0, r),
                this.inModule && !this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0)
                    for (const [t,r] of Array.from(this.scope.undefinedExports))
                        this.raise(l.ModuleExportUndefined, {
                            at: r
                        }, t);
                return this.finishNode(t, "Program")
            }
            stmtToDirective(t) {
                const r = t;
                r.type = "Directive",
                r.value = r.expression,
                delete r.expression;
                const i = r.value
                  , a = i.value
                  , o = this.input.slice(i.start, i.end)
                  , l = i.value = o.slice(1, -1);
                return this.addExtra(i, "raw", o),
                this.addExtra(i, "rawValue", l),
                this.addExtra(i, "expressionValue", a),
                i.type = "DirectiveLiteral",
                r
            }
            parseInterpreterDirective() {
                if (!this.match(28))
                    return null;
                const t = this.startNode();
                return t.value = this.state.value,
                this.next(),
                this.finishNode(t, "InterpreterDirective")
            }
            isLet(t) {
                return !!this.isContextual(95) && this.isLetKeyword(t)
            }
            isLetKeyword(t) {
                const r = this.nextTokenStart()
                  , i = this.codePointAtPos(r);
                if (92 === i || 91 === i)
                    return !0;
                if (t)
                    return !1;
                if (123 === i)
                    return !0;
                if (isIdentifierStart(i)) {
                    if (ue.lastIndex = r,
                    ue.test(this.input)) {
                        const t = this.codePointAtPos(ue.lastIndex);
                        if (!isIdentifierChar(t) && 92 !== t)
                            return !1
                    }
                    return !0
                }
                return !1
            }
            parseStatement(t, r) {
                return this.match(26) && this.parseDecorators(!0),
                this.parseStatementContent(t, r)
            }
            parseStatementContent(t, r) {
                let i = this.state.type;
                const a = this.startNode();
                let o;
                switch (this.isLet(t) && (i = 70,
                o = "let"),
                i) {
                case 56:
                    return this.parseBreakContinueStatement(a, !0);
                case 59:
                    return this.parseBreakContinueStatement(a, !1);
                case 60:
                    return this.parseDebuggerStatement(a);
                case 86:
                    return this.parseDoStatement(a);
                case 87:
                    return this.parseForStatement(a);
                case 64:
                    if (46 === this.lookaheadCharCode())
                        break;
                    return t && (this.state.strict ? this.raise(l.StrictFunction, {
                        at: this.state.startLoc
                    }) : "if" !== t && "label" !== t && this.raise(l.SloppyFunction, {
                        at: this.state.startLoc
                    })),
                    this.parseFunctionStatement(a, !1, !t);
                case 76:
                    return t && this.unexpected(),
                    this.parseClass(a, !0);
                case 65:
                    return this.parseIfStatement(a);
                case 66:
                    return this.parseReturnStatement(a);
                case 67:
                    return this.parseSwitchStatement(a);
                case 68:
                    return this.parseThrowStatement(a);
                case 69:
                    return this.parseTryStatement(a);
                case 71:
                case 70:
                    return o = o || this.state.value,
                    t && "var" !== o && this.raise(l.UnexpectedLexicalDeclaration, {
                        at: this.state.startLoc
                    }),
                    this.parseVarStatement(a, o);
                case 88:
                    return this.parseWhileStatement(a);
                case 72:
                    return this.parseWithStatement(a);
                case 5:
                    return this.parseBlock();
                case 13:
                    return this.parseEmptyStatement(a);
                case 79:
                    {
                        const t = this.lookaheadCharCode();
                        if (40 === t || 46 === t)
                            break
                    }
                case 78:
                    {
                        let t;
                        return this.options.allowImportExportEverywhere || r || this.raise(l.UnexpectedImportExport, {
                            at: this.state.startLoc
                        }),
                        this.next(),
                        79 === i ? (t = this.parseImport(a),
                        "ImportDeclaration" !== t.type || t.importKind && "value" !== t.importKind || (this.sawUnambiguousESM = !0)) : (t = this.parseExport(a),
                        ("ExportNamedDeclaration" !== t.type || t.exportKind && "value" !== t.exportKind) && ("ExportAllDeclaration" !== t.type || t.exportKind && "value" !== t.exportKind) && "ExportDefaultDeclaration" !== t.type || (this.sawUnambiguousESM = !0)),
                        this.assertModuleNodeAllowed(a),
                        t
                    }
                default:
                    if (this.isAsyncFunction())
                        return t && this.raise(l.AsyncFunctionInSingleStatementContext, {
                            at: this.state.startLoc
                        }),
                        this.next(),
                        this.parseFunctionStatement(a, !0, !t)
                }
                const u = this.state.value
                  , p = this.parseExpression();
                return tokenIsIdentifier(i) && "Identifier" === p.type && this.eat(14) ? this.parseLabeledStatement(a, u, p, t) : this.parseExpressionStatement(a, p)
            }
            assertModuleNodeAllowed(t) {
                this.options.allowImportExportEverywhere || this.inModule || this.raise(u.ImportOutsideModule, {
                    node: t
                })
            }
            takeDecorators(t) {
                const r = this.state.decoratorStack[this.state.decoratorStack.length - 1];
                r.length && (t.decorators = r,
                this.resetStartLocationFromNode(t, r[0]),
                this.state.decoratorStack[this.state.decoratorStack.length - 1] = [])
            }
            canHaveLeadingDecorator() {
                return this.match(76)
            }
            parseDecorators(t) {
                const r = this.state.decoratorStack[this.state.decoratorStack.length - 1];
                for (; this.match(26); ) {
                    const t = this.parseDecorator();
                    r.push(t)
                }
                if (this.match(78))
                    t || this.unexpected(),
                    this.hasPlugin("decorators") && !this.getPluginOption("decorators", "decoratorsBeforeExport") && this.raise(l.DecoratorExportClass, {
                        at: this.state.startLoc
                    });
                else if (!this.canHaveLeadingDecorator())
                    throw this.raise(l.UnexpectedLeadingDecorator, {
                        at: this.state.startLoc
                    })
            }
            parseDecorator() {
                this.expectOnePlugin(["decorators-legacy", "decorators"]);
                const t = this.startNode();
                if (this.next(),
                this.hasPlugin("decorators")) {
                    this.state.decoratorStack.push([]);
                    const r = this.state.start
                      , i = this.state.startLoc;
                    let a;
                    if (this.eat(10))
                        a = this.parseExpression(),
                        this.expect(11);
                    else
                        for (a = this.parseIdentifier(!1); this.eat(16); ) {
                            const t = this.startNodeAt(r, i);
                            t.object = a,
                            t.property = this.parseIdentifier(!0),
                            t.computed = !1,
                            a = this.finishNode(t, "MemberExpression")
                        }
                    t.expression = this.parseMaybeDecoratorArguments(a),
                    this.state.decoratorStack.pop()
                } else
                    t.expression = this.parseExprSubscripts();
                return this.finishNode(t, "Decorator")
            }
            parseMaybeDecoratorArguments(t) {
                if (this.eat(10)) {
                    const r = this.startNodeAtNode(t);
                    return r.callee = t,
                    r.arguments = this.parseCallExpressionArguments(11, !1),
                    this.toReferencedList(r.arguments),
                    this.finishNode(r, "CallExpression")
                }
                return t
            }
            parseBreakContinueStatement(t, r) {
                return this.next(),
                this.isLineTerminator() ? t.label = null : (t.label = this.parseIdentifier(),
                this.semicolon()),
                this.verifyBreakContinue(t, r),
                this.finishNode(t, r ? "BreakStatement" : "ContinueStatement")
            }
            verifyBreakContinue(t, r) {
                let i;
                for (i = 0; i < this.state.labels.length; ++i) {
                    const a = this.state.labels[i];
                    if (null == t.label || a.name === t.label.name) {
                        if (null != a.kind && (r || "loop" === a.kind))
                            break;
                        if (t.label && r)
                            break
                    }
                }
                i === this.state.labels.length && this.raise(l.IllegalBreakContinue, {
                    node: t
                }, r ? "break" : "continue")
            }
            parseDebuggerStatement(t) {
                return this.next(),
                this.semicolon(),
                this.finishNode(t, "DebuggerStatement")
            }
            parseHeaderExpression() {
                this.expect(10);
                const t = this.parseExpression();
                return this.expect(11),
                t
            }
            parseDoStatement(t) {
                return this.next(),
                this.state.labels.push(se),
                t.body = this.withSmartMixTopicForbiddingContext(()=>this.parseStatement("do")),
                this.state.labels.pop(),
                this.expect(88),
                t.test = this.parseHeaderExpression(),
                this.eat(13),
                this.finishNode(t, "DoWhileStatement")
            }
            parseForStatement(t) {
                this.next(),
                this.state.labels.push(se);
                let r = null;
                if (this.isAwaitAllowed() && this.eatContextual(92) && (r = this.state.lastTokStartLoc),
                this.scope.enter(0),
                this.expect(10),
                this.match(13))
                    return null !== r && this.unexpected(r),
                    this.parseFor(t, null);
                const i = this.isContextual(95)
                  , a = i && this.isLetKeyword();
                if (this.match(70) || this.match(71) || a) {
                    const i = this.startNode()
                      , o = a ? "let" : this.state.value;
                    return this.next(),
                    this.parseVar(i, !0, o),
                    this.finishNode(i, "VariableDeclaration"),
                    (this.match(54) || this.isContextual(97)) && 1 === i.declarations.length ? this.parseForIn(t, i, r) : (null !== r && this.unexpected(r),
                    this.parseFor(t, i))
                }
                const o = this.isContextual(91)
                  , u = new ExpressionErrors
                  , p = this.parseExpression(!0, u)
                  , c = this.isContextual(97);
                if (c && (i && this.raise(l.ForOfLet, {
                    node: p
                }),
                null === r && o && "Identifier" === p.type && this.raise(l.ForOfAsync, {
                    node: p
                })),
                c || this.match(54)) {
                    this.toAssignable(p, !0);
                    const i = c ? "for-of statement" : "for-in statement";
                    return this.checkLVal(p, i),
                    this.parseForIn(t, p, r)
                }
                return this.checkExpressionErrors(u, !0),
                null !== r && this.unexpected(r),
                this.parseFor(t, p)
            }
            parseFunctionStatement(t, r, i) {
                return this.next(),
                this.parseFunction(t, 1 | (i ? 0 : 2), r)
            }
            parseIfStatement(t) {
                return this.next(),
                t.test = this.parseHeaderExpression(),
                t.consequent = this.parseStatement("if"),
                t.alternate = this.eat(62) ? this.parseStatement("if") : null,
                this.finishNode(t, "IfStatement")
            }
            parseReturnStatement(t) {
                return this.prodParam.hasReturn || this.options.allowReturnOutsideFunction || this.raise(l.IllegalReturn, {
                    at: this.state.startLoc
                }),
                this.next(),
                this.isLineTerminator() ? t.argument = null : (t.argument = this.parseExpression(),
                this.semicolon()),
                this.finishNode(t, "ReturnStatement")
            }
            parseSwitchStatement(t) {
                this.next(),
                t.discriminant = this.parseHeaderExpression();
                const r = t.cases = [];
                let i, a;
                for (this.expect(5),
                this.state.labels.push(oe),
                this.scope.enter(0); !this.match(8); )
                    if (this.match(57) || this.match(61)) {
                        const t = this.match(57);
                        i && this.finishNode(i, "SwitchCase"),
                        r.push(i = this.startNode()),
                        i.consequent = [],
                        this.next(),
                        t ? i.test = this.parseExpression() : (a && this.raise(l.MultipleDefaultsInSwitch, {
                            at: this.state.lastTokStartLoc
                        }),
                        a = !0,
                        i.test = null),
                        this.expect(14)
                    } else
                        i ? i.consequent.push(this.parseStatement(null)) : this.unexpected();
                return this.scope.exit(),
                i && this.finishNode(i, "SwitchCase"),
                this.next(),
                this.state.labels.pop(),
                this.finishNode(t, "SwitchStatement")
            }
            parseThrowStatement(t) {
                return this.next(),
                this.hasPrecedingLineBreak() && this.raise(l.NewlineAfterThrow, {
                    at: this.state.lastTokEndLoc
                }),
                t.argument = this.parseExpression(),
                this.semicolon(),
                this.finishNode(t, "ThrowStatement")
            }
            parseCatchClauseParam() {
                const t = this.parseBindingAtom()
                  , r = "Identifier" === t.type;
                return this.scope.enter(r ? 8 : 0),
                this.checkLVal(t, "catch clause", 9),
                t
            }
            parseTryStatement(t) {
                if (this.next(),
                t.block = this.parseBlock(),
                t.handler = null,
                this.match(58)) {
                    const r = this.startNode();
                    this.next(),
                    this.match(10) ? (this.expect(10),
                    r.param = this.parseCatchClauseParam(),
                    this.expect(11)) : (r.param = null,
                    this.scope.enter(0)),
                    r.body = this.withSmartMixTopicForbiddingContext(()=>this.parseBlock(!1, !1)),
                    this.scope.exit(),
                    t.handler = this.finishNode(r, "CatchClause")
                }
                return t.finalizer = this.eat(63) ? this.parseBlock() : null,
                t.handler || t.finalizer || this.raise(l.NoCatchOrFinally, {
                    node: t
                }),
                this.finishNode(t, "TryStatement")
            }
            parseVarStatement(t, r) {
                return this.next(),
                this.parseVar(t, !1, r),
                this.semicolon(),
                this.finishNode(t, "VariableDeclaration")
            }
            parseWhileStatement(t) {
                return this.next(),
                t.test = this.parseHeaderExpression(),
                this.state.labels.push(se),
                t.body = this.withSmartMixTopicForbiddingContext(()=>this.parseStatement("while")),
                this.state.labels.pop(),
                this.finishNode(t, "WhileStatement")
            }
            parseWithStatement(t) {
                return this.state.strict && this.raise(l.StrictWith, {
                    at: this.state.startLoc
                }),
                this.next(),
                t.object = this.parseHeaderExpression(),
                t.body = this.withSmartMixTopicForbiddingContext(()=>this.parseStatement("with")),
                this.finishNode(t, "WithStatement")
            }
            parseEmptyStatement(t) {
                return this.next(),
                this.finishNode(t, "EmptyStatement")
            }
            parseLabeledStatement(t, r, i, a) {
                for (const t of this.state.labels)
                    t.name === r && this.raise(l.LabelRedeclaration, {
                        node: i
                    }, r);
                const o = function tokenIsLoop(t) {
                    return t >= 86 && t <= 88
                }(this.state.type) ? "loop" : this.match(67) ? "switch" : null;
                for (let r = this.state.labels.length - 1; r >= 0; r--) {
                    const i = this.state.labels[r];
                    if (i.statementStart !== t.start)
                        break;
                    i.statementStart = this.state.start,
                    i.kind = o
                }
                return this.state.labels.push({
                    name: r,
                    kind: o,
                    statementStart: this.state.start
                }),
                t.body = this.parseStatement(a ? -1 === a.indexOf("label") ? a + "label" : a : "label"),
                this.state.labels.pop(),
                t.label = i,
                this.finishNode(t, "LabeledStatement")
            }
            parseExpressionStatement(t, r) {
                return t.expression = r,
                this.semicolon(),
                this.finishNode(t, "ExpressionStatement")
            }
            parseBlock(t=!1, r=!0, i) {
                const a = this.startNode();
                return t && this.state.strictErrors.clear(),
                this.expect(5),
                r && this.scope.enter(0),
                this.parseBlockBody(a, t, !1, 8, i),
                r && this.scope.exit(),
                this.finishNode(a, "BlockStatement")
            }
            isValidDirective(t) {
                return "ExpressionStatement" === t.type && "StringLiteral" === t.expression.type && !t.expression.extra.parenthesized
            }
            parseBlockBody(t, r, i, a, o) {
                const l = t.body = []
                  , u = t.directives = [];
                this.parseBlockOrModuleBlockBody(l, r ? u : void 0, i, a, o)
            }
            parseBlockOrModuleBlockBody(t, r, i, a, o) {
                const l = this.state.strict;
                let u = !1
                  , p = !1;
                for (; !this.match(a); ) {
                    const a = this.parseStatement(null, i);
                    if (r && !p) {
                        if (this.isValidDirective(a)) {
                            const t = this.stmtToDirective(a);
                            r.push(t),
                            u || "use strict" !== t.value.value || (u = !0,
                            this.setStrict(!0));
                            continue
                        }
                        p = !0,
                        this.state.strictErrors.clear()
                    }
                    t.push(a)
                }
                o && o.call(this, u),
                l || this.setStrict(!1),
                this.next()
            }
            parseFor(t, r) {
                return t.init = r,
                this.semicolon(!1),
                t.test = this.match(13) ? null : this.parseExpression(),
                this.semicolon(!1),
                t.update = this.match(11) ? null : this.parseExpression(),
                this.expect(11),
                t.body = this.withSmartMixTopicForbiddingContext(()=>this.parseStatement("for")),
                this.scope.exit(),
                this.state.labels.pop(),
                this.finishNode(t, "ForStatement")
            }
            parseForIn(t, r, i) {
                const a = this.match(54);
                return this.next(),
                a ? null !== i && this.unexpected(i) : t.await = null !== i,
                "VariableDeclaration" !== r.type || null == r.declarations[0].init || a && !this.state.strict && "var" === r.kind && "Identifier" === r.declarations[0].id.type || this.raise(l.ForInOfLoopInitializer, {
                    node: r
                }, a ? "for-in" : "for-of"),
                "AssignmentPattern" === r.type && this.raise(l.InvalidLhs, {
                    node: r
                }, "for-loop"),
                t.left = r,
                t.right = a ? this.parseExpression() : this.parseMaybeAssignAllowIn(),
                this.expect(11),
                t.body = this.withSmartMixTopicForbiddingContext(()=>this.parseStatement("for")),
                this.scope.exit(),
                this.state.labels.pop(),
                this.finishNode(t, a ? "ForInStatement" : "ForOfStatement")
            }
            parseVar(t, r, i) {
                const a = t.declarations = []
                  , o = this.hasPlugin("typescript");
                for (t.kind = i; ; ) {
                    const t = this.startNode();
                    if (this.parseVarId(t, i),
                    this.eat(29) ? t.init = r ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn() : ("const" !== i || this.match(54) || this.isContextual(97) ? "Identifier" === t.id.type || r && (this.match(54) || this.isContextual(97)) || this.raise(l.DeclarationMissingInitializer, {
                        at: this.state.lastTokEndLoc
                    }, "Complex binding patterns") : o || this.raise(l.DeclarationMissingInitializer, {
                        at: this.state.lastTokEndLoc
                    }, "Const declarations"),
                    t.init = null),
                    a.push(this.finishNode(t, "VariableDeclarator")),
                    !this.eat(12))
                        break
                }
                return t
            }
            parseVarId(t, r) {
                t.id = this.parseBindingAtom(),
                this.checkLVal(t.id, "variable declaration", "var" === r ? 5 : 9, void 0, "var" !== r)
            }
            parseFunction(t, r=0, i=!1) {
                const a = 1 & r
                  , o = 2 & r
                  , u = !(!a || 4 & r);
                this.initFunction(t, i),
                this.match(51) && o && this.raise(l.GeneratorInSingleStatementContext, {
                    at: this.state.startLoc
                }),
                t.generator = this.eat(51),
                a && (t.id = this.parseFunctionId(u));
                const p = this.state.maybeInArrowParameters;
                return this.state.maybeInArrowParameters = !1,
                this.scope.enter(2),
                this.prodParam.enter(functionFlags(i, t.generator)),
                a || (t.id = this.parseFunctionId()),
                this.parseFunctionParams(t, !1),
                this.withSmartMixTopicForbiddingContext(()=>{
                    this.parseFunctionBodyAndFinish(t, a ? "FunctionDeclaration" : "FunctionExpression")
                }
                ),
                this.prodParam.exit(),
                this.scope.exit(),
                a && !o && this.registerFunctionStatementId(t),
                this.state.maybeInArrowParameters = p,
                t
            }
            parseFunctionId(t) {
                return t || tokenIsIdentifier(this.state.type) ? this.parseIdentifier() : null
            }
            parseFunctionParams(t, r) {
                this.expect(10),
                this.expressionScope.enter(function newParameterDeclarationScope() {
                    return new ExpressionScope(3)
                }()),
                t.params = this.parseBindingList(11, 41, !1, r),
                this.expressionScope.exit()
            }
            registerFunctionStatementId(t) {
                t.id && this.scope.declareName(t.id.name, this.state.strict || t.generator || t.async ? this.scope.treatFunctionsAsVar ? 5 : 9 : 17, t.id.loc.start)
            }
            parseClass(t, r, i) {
                this.next(),
                this.takeDecorators(t);
                const a = this.state.strict;
                return this.state.strict = !0,
                this.parseClassId(t, r, i),
                this.parseClassSuper(t),
                t.body = this.parseClassBody(!!t.superClass, a),
                this.finishNode(t, r ? "ClassDeclaration" : "ClassExpression")
            }
            isClassProperty() {
                return this.match(29) || this.match(13) || this.match(8)
            }
            isClassMethod() {
                return this.match(10)
            }
            isNonstaticConstructor(t) {
                return !(t.computed || t.static || "constructor" !== t.key.name && "constructor" !== t.key.value)
            }
            parseClassBody(t, r) {
                this.classScope.enter();
                const i = {
                    hadConstructor: !1,
                    hadSuperClass: t
                };
                let a = [];
                const o = this.startNode();
                if (o.body = [],
                this.expect(5),
                this.withSmartMixTopicForbiddingContext(()=>{
                    for (; !this.match(8); ) {
                        if (this.eat(13)) {
                            if (a.length > 0)
                                throw this.raise(l.DecoratorSemicolon, {
                                    at: this.state.lastTokEndLoc
                                });
                            continue
                        }
                        if (this.match(26)) {
                            a.push(this.parseDecorator());
                            continue
                        }
                        const t = this.startNode();
                        a.length && (t.decorators = a,
                        this.resetStartLocationFromNode(t, a[0]),
                        a = []),
                        this.parseClassMember(o, t, i),
                        "constructor" === t.kind && t.decorators && t.decorators.length > 0 && this.raise(l.DecoratorConstructor, {
                            node: t
                        })
                    }
                }
                ),
                this.state.strict = r,
                this.next(),
                a.length)
                    throw this.raise(l.TrailingDecorator, {
                        at: this.state.startLoc
                    });
                return this.classScope.exit(),
                this.finishNode(o, "ClassBody")
            }
            parseClassMemberFromModifier(t, r) {
                const i = this.parseIdentifier(!0);
                if (this.isClassMethod()) {
                    const a = r;
                    return a.kind = "method",
                    a.computed = !1,
                    a.key = i,
                    a.static = !1,
                    this.pushClassMethod(t, a, !1, !1, !1, !1),
                    !0
                }
                if (this.isClassProperty()) {
                    const a = r;
                    return a.computed = !1,
                    a.key = i,
                    a.static = !1,
                    t.body.push(this.parseClassProperty(a)),
                    !0
                }
                return this.resetPreviousNodeTrailingComments(i),
                !1
            }
            parseClassMember(t, r, i) {
                const a = this.isContextual(100);
                if (a) {
                    if (this.parseClassMemberFromModifier(t, r))
                        return;
                    if (this.eat(5))
                        return void this.parseClassStaticBlock(t, r)
                }
                this.parseClassMemberWithIsStatic(t, r, i, a)
            }
            parseClassMemberWithIsStatic(t, r, i, a) {
                const o = r
                  , u = r
                  , p = r
                  , c = r
                  , d = o
                  , y = o;
                if (r.static = a,
                this.parsePropertyNamePrefixOperator(r),
                this.eat(51)) {
                    d.kind = "method";
                    const r = this.match(130);
                    return this.parseClassElementName(d),
                    r ? void this.pushClassPrivateMethod(t, u, !0, !1) : (this.isNonstaticConstructor(o) && this.raise(l.ConstructorIsGenerator, {
                        node: o.key
                    }),
                    void this.pushClassMethod(t, o, !0, !1, !1, !1))
                }
                const h = tokenIsIdentifier(this.state.type) && !this.state.containsEsc
                  , m = this.match(130)
                  , T = this.parseClassElementName(r)
                  , S = this.state.startLoc;
                if (this.parsePostMemberNameModifiers(y),
                this.isClassMethod()) {
                    if (d.kind = "method",
                    m)
                        return void this.pushClassPrivateMethod(t, u, !1, !1);
                    const a = this.isNonstaticConstructor(o);
                    let p = !1;
                    a && (o.kind = "constructor",
                    i.hadConstructor && !this.hasPlugin("typescript") && this.raise(l.DuplicateConstructor, {
                        node: T
                    }),
                    a && this.hasPlugin("typescript") && r.override && this.raise(l.OverrideOnConstructor, {
                        node: T
                    }),
                    i.hadConstructor = !0,
                    p = i.hadSuperClass),
                    this.pushClassMethod(t, o, !1, !1, a, p)
                } else if (this.isClassProperty())
                    m ? this.pushClassPrivateProperty(t, c) : this.pushClassProperty(t, p);
                else if (h && "async" === T.name && !this.isLineTerminator()) {
                    this.resetPreviousNodeTrailingComments(T);
                    const r = this.eat(51);
                    y.optional && this.unexpected(S),
                    d.kind = "method";
                    const i = this.match(130);
                    this.parseClassElementName(d),
                    this.parsePostMemberNameModifiers(y),
                    i ? this.pushClassPrivateMethod(t, u, r, !0) : (this.isNonstaticConstructor(o) && this.raise(l.ConstructorIsAsync, {
                        node: o.key
                    }),
                    this.pushClassMethod(t, o, r, !0, !1, !1))
                } else if (!h || "get" !== T.name && "set" !== T.name || this.match(51) && this.isLineTerminator())
                    this.isLineTerminator() ? m ? this.pushClassPrivateProperty(t, c) : this.pushClassProperty(t, p) : this.unexpected();
                else {
                    this.resetPreviousNodeTrailingComments(T),
                    d.kind = T.name;
                    const r = this.match(130);
                    this.parseClassElementName(o),
                    r ? this.pushClassPrivateMethod(t, u, !1, !1) : (this.isNonstaticConstructor(o) && this.raise(l.ConstructorIsAccessor, {
                        node: o.key
                    }),
                    this.pushClassMethod(t, o, !1, !1, !1, !1)),
                    this.checkGetterSetterParams(o)
                }
            }
            parseClassElementName(t) {
                const {type: r, value: i} = this.state;
                if (124 !== r && 125 !== r || !t.static || "prototype" !== i || this.raise(l.StaticPrototype, {
                    at: this.state.startLoc
                }),
                130 === r) {
                    "constructor" === i && this.raise(l.ConstructorClassPrivateField, {
                        at: this.state.startLoc
                    });
                    const r = this.parsePrivateName();
                    return t.key = r,
                    r
                }
                return this.parsePropertyName(t)
            }
            parseClassStaticBlock(t, r) {
                var i;
                this.scope.enter(208);
                const a = this.state.labels;
                this.state.labels = [],
                this.prodParam.enter(0);
                const o = r.body = [];
                this.parseBlockOrModuleBlockBody(o, void 0, !1, 8),
                this.prodParam.exit(),
                this.scope.exit(),
                this.state.labels = a,
                t.body.push(this.finishNode(r, "StaticBlock")),
                null != (i = r.decorators) && i.length && this.raise(l.DecoratorStaticBlock, {
                    node: r
                })
            }
            pushClassProperty(t, r) {
                r.computed || "constructor" !== r.key.name && "constructor" !== r.key.value || this.raise(l.ConstructorClassField, {
                    node: r.key
                }),
                t.body.push(this.parseClassProperty(r))
            }
            pushClassPrivateProperty(t, r) {
                const i = this.parseClassPrivateProperty(r);
                t.body.push(i),
                this.classScope.declarePrivateName(this.getPrivateNameSV(i.key), 0, i.key.loc.start)
            }
            pushClassMethod(t, r, i, a, o, l) {
                t.body.push(this.parseMethod(r, i, a, o, l, "ClassMethod", !0))
            }
            pushClassPrivateMethod(t, r, i, a) {
                const o = this.parseMethod(r, i, a, !1, !1, "ClassPrivateMethod", !0);
                t.body.push(o);
                const l = "get" === o.kind ? o.static ? 6 : 2 : "set" === o.kind ? o.static ? 5 : 1 : 0;
                this.declareClassPrivateMethodInScope(o, l)
            }
            declareClassPrivateMethodInScope(t, r) {
                this.classScope.declarePrivateName(this.getPrivateNameSV(t.key), r, t.key.loc.start)
            }
            parsePostMemberNameModifiers(t) {}
            parseClassPrivateProperty(t) {
                return this.parseInitializer(t),
                this.semicolon(),
                this.finishNode(t, "ClassPrivateProperty")
            }
            parseClassProperty(t) {
                return this.parseInitializer(t),
                this.semicolon(),
                this.finishNode(t, "ClassProperty")
            }
            parseInitializer(t) {
                this.scope.enter(80),
                this.expressionScope.enter(newExpressionScope()),
                this.prodParam.enter(0),
                t.value = this.eat(29) ? this.parseMaybeAssignAllowIn() : null,
                this.expressionScope.exit(),
                this.prodParam.exit(),
                this.scope.exit()
            }
            parseClassId(t, r, i, a=139) {
                if (tokenIsIdentifier(this.state.type))
                    t.id = this.parseIdentifier(),
                    r && this.checkLVal(t.id, "class name", a);
                else {
                    if (!i && r)
                        throw this.raise(l.MissingClassName, {
                            at: this.state.startLoc
                        });
                    t.id = null
                }
            }
            parseClassSuper(t) {
                t.superClass = this.eat(77) ? this.parseExprSubscripts() : null
            }
            parseExport(t) {
                const r = this.maybeParseExportDefaultSpecifier(t)
                  , i = !r || this.eat(12)
                  , a = i && this.eatExportStar(t)
                  , o = a && this.maybeParseExportNamespaceSpecifier(t)
                  , l = i && (!o || this.eat(12))
                  , u = r || a;
                if (a && !o)
                    return r && this.unexpected(),
                    this.parseExportFrom(t, !0),
                    this.finishNode(t, "ExportAllDeclaration");
                const p = this.maybeParseExportNamedSpecifiers(t);
                if (r && i && !a && !p || o && l && !p)
                    throw this.unexpected(null, 5);
                let c;
                if (u || p ? (c = !1,
                this.parseExportFrom(t, u)) : c = this.maybeParseExportDeclaration(t),
                u || p || c)
                    return this.checkExport(t, !0, !1, !!t.source),
                    this.finishNode(t, "ExportNamedDeclaration");
                if (this.eat(61))
                    return t.declaration = this.parseExportDefaultExpression(),
                    this.checkExport(t, !0, !0),
                    this.finishNode(t, "ExportDefaultDeclaration");
                throw this.unexpected(null, 5)
            }
            eatExportStar(t) {
                return this.eat(51)
            }
            maybeParseExportDefaultSpecifier(t) {
                if (this.isExportDefaultSpecifier()) {
                    this.expectPlugin("exportDefaultFrom");
                    const r = this.startNode();
                    return r.exported = this.parseIdentifier(!0),
                    t.specifiers = [this.finishNode(r, "ExportDefaultSpecifier")],
                    !0
                }
                return !1
            }
            maybeParseExportNamespaceSpecifier(t) {
                if (this.isContextual(89)) {
                    t.specifiers || (t.specifiers = []);
                    const r = this.startNodeAt(this.state.lastTokStart, this.state.lastTokStartLoc);
                    return this.next(),
                    r.exported = this.parseModuleExportName(),
                    t.specifiers.push(this.finishNode(r, "ExportNamespaceSpecifier")),
                    !0
                }
                return !1
            }
            maybeParseExportNamedSpecifiers(t) {
                if (this.match(5)) {
                    t.specifiers || (t.specifiers = []);
                    const r = "type" === t.exportKind;
                    return t.specifiers.push(...this.parseExportSpecifiers(r)),
                    t.source = null,
                    t.declaration = null,
                    this.hasPlugin("importAssertions") && (t.assertions = []),
                    !0
                }
                return !1
            }
            maybeParseExportDeclaration(t) {
                return !!this.shouldParseExportDeclaration() && (t.specifiers = [],
                t.source = null,
                this.hasPlugin("importAssertions") && (t.assertions = []),
                t.declaration = this.parseExportDeclaration(t),
                !0)
            }
            isAsyncFunction() {
                if (!this.isContextual(91))
                    return !1;
                const t = this.nextTokenStart();
                return !L.test(this.input.slice(this.state.pos, t)) && this.isUnparsedContextual(t, "function")
            }
            parseExportDefaultExpression() {
                const t = this.startNode()
                  , r = this.isAsyncFunction();
                if (this.match(64) || r)
                    return this.next(),
                    r && this.next(),
                    this.parseFunction(t, 5, r);
                if (this.match(76))
                    return this.parseClass(t, !0, !0);
                if (this.match(26))
                    return this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") && this.raise(l.DecoratorBeforeExport, {
                        at: this.state.startLoc
                    }),
                    this.parseDecorators(!1),
                    this.parseClass(t, !0, !0);
                if (this.match(71) || this.match(70) || this.isLet())
                    throw this.raise(l.UnsupportedDefaultExport, {
                        at: this.state.startLoc
                    });
                const i = this.parseMaybeAssignAllowIn();
                return this.semicolon(),
                i
            }
            parseExportDeclaration(t) {
                return this.parseStatement(null)
            }
            isExportDefaultSpecifier() {
                const {type: t} = this.state;
                if (tokenIsIdentifier(t)) {
                    if (91 === t && !this.state.containsEsc || 95 === t)
                        return !1;
                    if ((122 === t || 121 === t) && !this.state.containsEsc) {
                        const {type: t} = this.lookahead();
                        if (tokenIsIdentifier(t) && 93 !== t || 5 === t)
                            return this.expectOnePlugin(["flow", "typescript"]),
                            !1
                    }
                } else if (!this.match(61))
                    return !1;
                const r = this.nextTokenStart()
                  , i = this.isUnparsedContextual(r, "from");
                if (44 === this.input.charCodeAt(r) || tokenIsIdentifier(this.state.type) && i)
                    return !0;
                if (this.match(61) && i) {
                    const t = this.input.charCodeAt(this.nextTokenStartSince(r + 4));
                    return 34 === t || 39 === t
                }
                return !1
            }
            parseExportFrom(t, r) {
                if (this.eatContextual(93)) {
                    t.source = this.parseImportSource(),
                    this.checkExport(t);
                    const r = this.maybeParseImportAssertions();
                    r && (t.assertions = r)
                } else
                    r && this.unexpected();
                this.semicolon()
            }
            shouldParseExportDeclaration() {
                const {type: t} = this.state;
                if (26 === t && (this.expectOnePlugin(["decorators", "decorators-legacy"]),
                this.hasPlugin("decorators"))) {
                    if (this.getPluginOption("decorators", "decoratorsBeforeExport"))
                        throw this.raise(l.DecoratorBeforeExport, {
                            at: this.state.startLoc
                        });
                    return !0
                }
                return 70 === t || 71 === t || 64 === t || 76 === t || this.isLet() || this.isAsyncFunction()
            }
            checkExport(t, r, i, a) {
                if (r)
                    if (i) {
                        if (this.checkDuplicateExports(t, "default"),
                        this.hasPlugin("exportDefaultFrom")) {
                            var o;
                            const r = t.declaration;
                            "Identifier" !== r.type || "from" !== r.name || r.end - r.start != 4 || null != (o = r.extra) && o.parenthesized || this.raise(l.ExportDefaultFromAsIdentifier, {
                                node: r
                            })
                        }
                    } else if (t.specifiers && t.specifiers.length)
                        for (const r of t.specifiers) {
                            const {exported: t} = r
                              , i = "Identifier" === t.type ? t.name : t.value;
                            if (this.checkDuplicateExports(r, i),
                            !a && r.local) {
                                const {local: t} = r;
                                "Identifier" !== t.type ? this.raise(l.ExportBindingIsString, {
                                    node: r
                                }, t.value, i) : (this.checkReservedWord(t.name, t.loc.start, !0, !1),
                                this.scope.checkLocalExport(t))
                            }
                        }
                    else if (t.declaration)
                        if ("FunctionDeclaration" === t.declaration.type || "ClassDeclaration" === t.declaration.type) {
                            const r = t.declaration.id;
                            if (!r)
                                throw new Error("Assertion failure");
                            this.checkDuplicateExports(t, r.name)
                        } else if ("VariableDeclaration" === t.declaration.type)
                            for (const r of t.declaration.declarations)
                                this.checkDeclaration(r.id);
                if (this.state.decoratorStack[this.state.decoratorStack.length - 1].length)
                    throw this.raise(l.UnsupportedDecoratorExport, {
                        node: t
                    })
            }
            checkDeclaration(t) {
                if ("Identifier" === t.type)
                    this.checkDuplicateExports(t, t.name);
                else if ("ObjectPattern" === t.type)
                    for (const r of t.properties)
                        this.checkDeclaration(r);
                else if ("ArrayPattern" === t.type)
                    for (const r of t.elements)
                        r && this.checkDeclaration(r);
                else
                    "ObjectProperty" === t.type ? this.checkDeclaration(t.value) : "RestElement" === t.type ? this.checkDeclaration(t.argument) : "AssignmentPattern" === t.type && this.checkDeclaration(t.left)
            }
            checkDuplicateExports(t, r) {
                this.exportedIdentifiers.has(r) && this.raise("default" === r ? l.DuplicateDefaultExport : l.DuplicateExport, {
                    node: t
                }, r),
                this.exportedIdentifiers.add(r)
            }
            parseExportSpecifiers(t) {
                const r = [];
                let i = !0;
                for (this.expect(5); !this.eat(8); ) {
                    if (i)
                        i = !1;
                    else if (this.expect(12),
                    this.eat(8))
                        break;
                    const a = this.isContextual(122)
                      , o = this.match(125)
                      , l = this.startNode();
                    l.local = this.parseModuleExportName(),
                    r.push(this.parseExportSpecifier(l, o, t, a))
                }
                return r
            }
            parseExportSpecifier(t, r, i, a) {
                return this.eatContextual(89) ? t.exported = this.parseModuleExportName() : r ? t.exported = cloneStringLiteral(t.local) : t.exported || (t.exported = cloneIdentifier(t.local)),
                this.finishNode(t, "ExportSpecifier")
            }
            parseModuleExportName() {
                if (this.match(125)) {
                    const t = this.parseStringLiteral(this.state.value)
                      , r = t.value.match(le);
                    return r && this.raise(l.ModuleExportNameHasLoneSurrogate, {
                        node: t
                    }, r[0].charCodeAt(0).toString(16)),
                    t
                }
                return this.parseIdentifier(!0)
            }
            parseImport(t) {
                if (t.specifiers = [],
                !this.match(125)) {
                    const r = !this.maybeParseDefaultImportSpecifier(t) || this.eat(12)
                      , i = r && this.maybeParseStarImportSpecifier(t);
                    r && !i && this.parseNamedImportSpecifiers(t),
                    this.expectContextual(93)
                }
                t.source = this.parseImportSource();
                const r = this.maybeParseImportAssertions();
                if (r)
                    t.assertions = r;
                else {
                    const r = this.maybeParseModuleAttributes();
                    r && (t.attributes = r)
                }
                return this.semicolon(),
                this.finishNode(t, "ImportDeclaration")
            }
            parseImportSource() {
                return this.match(125) || this.unexpected(),
                this.parseExprAtom()
            }
            shouldParseDefaultImport(t) {
                return tokenIsIdentifier(this.state.type)
            }
            parseImportSpecifierLocal(t, r, i, a) {
                r.local = this.parseIdentifier(),
                this.checkLVal(r.local, a, 9),
                t.specifiers.push(this.finishNode(r, i))
            }
            parseAssertEntries() {
                const t = []
                  , r = new Set;
                do {
                    if (this.match(8))
                        break;
                    const i = this.startNode()
                      , a = this.state.value;
                    if (r.has(a) && this.raise(l.ModuleAttributesWithDuplicateKeys, {
                        at: this.state.startLoc
                    }, a),
                    r.add(a),
                    this.match(125) ? i.key = this.parseStringLiteral(a) : i.key = this.parseIdentifier(!0),
                    this.expect(14),
                    !this.match(125))
                        throw this.raise(l.ModuleAttributeInvalidValue, {
                            at: this.state.startLoc
                        });
                    i.value = this.parseStringLiteral(this.state.value),
                    this.finishNode(i, "ImportAttribute"),
                    t.push(i)
                } while (this.eat(12));
                return t
            }
            maybeParseModuleAttributes() {
                if (!this.match(72) || this.hasPrecedingLineBreak())
                    return this.hasPlugin("moduleAttributes") ? [] : null;
                this.expectPlugin("moduleAttributes"),
                this.next();
                const t = []
                  , r = new Set;
                do {
                    const i = this.startNode();
                    if (i.key = this.parseIdentifier(!0),
                    "type" !== i.key.name && this.raise(l.ModuleAttributeDifferentFromType, {
                        node: i.key
                    }, i.key.name),
                    r.has(i.key.name) && this.raise(l.ModuleAttributesWithDuplicateKeys, {
                        node: i.key
                    }, i.key.name),
                    r.add(i.key.name),
                    this.expect(14),
                    !this.match(125))
                        throw this.raise(l.ModuleAttributeInvalidValue, {
                            at: this.state.startLoc
                        });
                    i.value = this.parseStringLiteral(this.state.value),
                    this.finishNode(i, "ImportAttribute"),
                    t.push(i)
                } while (this.eat(12));
                return t
            }
            maybeParseImportAssertions() {
                if (!this.isContextual(90) || this.hasPrecedingLineBreak())
                    return this.hasPlugin("importAssertions") ? [] : null;
                this.expectPlugin("importAssertions"),
                this.next(),
                this.eat(5);
                const t = this.parseAssertEntries();
                return this.eat(8),
                t
            }
            maybeParseDefaultImportSpecifier(t) {
                return !!this.shouldParseDefaultImport(t) && (this.parseImportSpecifierLocal(t, this.startNode(), "ImportDefaultSpecifier", "default import specifier"),
                !0)
            }
            maybeParseStarImportSpecifier(t) {
                if (this.match(51)) {
                    const r = this.startNode();
                    return this.next(),
                    this.expectContextual(89),
                    this.parseImportSpecifierLocal(t, r, "ImportNamespaceSpecifier", "import namespace specifier"),
                    !0
                }
                return !1
            }
            parseNamedImportSpecifiers(t) {
                let r = !0;
                for (this.expect(5); !this.eat(8); ) {
                    if (r)
                        r = !1;
                    else {
                        if (this.eat(14))
                            throw this.raise(l.DestructureNamedImport, {
                                at: this.state.startLoc
                            });
                        if (this.expect(12),
                        this.eat(8))
                            break
                    }
                    const i = this.startNode()
                      , a = this.match(125)
                      , o = this.isContextual(122);
                    i.imported = this.parseModuleExportName();
                    const u = this.parseImportSpecifier(i, a, "type" === t.importKind || "typeof" === t.importKind, o);
                    t.specifiers.push(u)
                }
            }
            parseImportSpecifier(t, r, i, a) {
                if (this.eatContextual(89))
                    t.local = this.parseIdentifier();
                else {
                    const {imported: i} = t;
                    if (r)
                        throw this.raise(l.ImportBindingIsString, {
                            node: t
                        }, i.value);
                    this.checkReservedWord(i.name, t.loc.start, !0, !0),
                    t.local || (t.local = cloneIdentifier(i))
                }
                return this.checkLVal(t.local, "import specifier", 9),
                this.finishNode(t, "ImportSpecifier")
            }
            isThisParam(t) {
                return "Identifier" === t.type && "this" === t.name
            }
        }
        {
            constructor(t, r) {
                super(t = function getOptions(t) {
                    const r = {};
                    for (const i of Object.keys(ie))
                        r[i] = t && null != t[i] ? t[i] : ie[i];
                    return r
                }(t), r),
                this.options = t,
                this.initializeScopes(),
                this.plugins = function pluginsMap(t) {
                    const r = new Map;
                    for (const i of t) {
                        const [t,a] = Array.isArray(i) ? i : [i, {}];
                        r.has(t) || r.set(t, a || {})
                    }
                    return r
                }(this.options.plugins),
                this.filename = t.sourceFilename
            }
            getScopeHandler() {
                return ScopeHandler
            }
            parse() {
                this.enterInitialScopes();
                const t = this.startNode()
                  , r = this.startNode();
                return this.nextToken(),
                t.errors = null,
                this.parseTopLevel(t, r),
                t.errors = this.state.errors,
                t
            }
        }
        const pe = function generateExportedTokenTypes(t) {
            const r = {};
            for (const i of Object.keys(t))
                r[i] = getExportedToken(t[i]);
            return r
        }(b);
        function getParser(t, r) {
            let i = Parser;
            return null != t && t.plugins && (!function validatePlugins(t) {
                if (hasPlugin(t, "decorators")) {
                    if (hasPlugin(t, "decorators-legacy"))
                        throw new Error("Cannot use the decorators and decorators-legacy plugin together");
                    const r = getPluginOption(t, "decorators", "decoratorsBeforeExport");
                    if (null == r)
                        throw new Error("The 'decorators' plugin requires a 'decoratorsBeforeExport' option, whose value must be a boolean. If you are migrating from Babylon/Babel 6 or want to use the old decorators proposal, you should use the 'decorators-legacy' plugin instead of 'decorators'.");
                    if ("boolean" != typeof r)
                        throw new Error("'decoratorsBeforeExport' must be a boolean.")
                }
                if (hasPlugin(t, "flow") && hasPlugin(t, "typescript"))
                    throw new Error("Cannot combine flow and typescript plugins.");
                if (hasPlugin(t, "placeholders") && hasPlugin(t, "v8intrinsic"))
                    throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
                if (hasPlugin(t, "pipelineOperator")) {
                    const r = getPluginOption(t, "pipelineOperator", "proposal");
                    if (!Z.includes(r)) {
                        const t = Z.map(t=>`"${t}"`).join(", ");
                        throw new Error(`"pipelineOperator" requires "proposal" option whose value must be one of: ${t}.`)
                    }
                    const i = hasPlugin(t, ["recordAndTuple", {
                        syntaxType: "hash"
                    }]);
                    if ("hack" === r) {
                        if (hasPlugin(t, "placeholders"))
                            throw new Error("Cannot combine placeholders plugin and Hack-style pipes.");
                        if (hasPlugin(t, "v8intrinsic"))
                            throw new Error("Cannot combine v8intrinsic plugin and Hack-style pipes.");
                        const r = getPluginOption(t, "pipelineOperator", "topicToken");
                        if (!ee.includes(r)) {
                            const t = ee.map(t=>`"${t}"`).join(", ");
                            throw new Error(`"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${t}.`)
                        }
                        if ("#" === r && i)
                            throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "hack", topicToken: "#" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.')
                    } else if ("smart" === r && i)
                        throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "smart" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.')
                }
                if (hasPlugin(t, "moduleAttributes")) {
                    if (hasPlugin(t, "importAssertions"))
                        throw new Error("Cannot combine importAssertions and moduleAttributes plugins.");
                    if ("may-2020" !== getPluginOption(t, "moduleAttributes", "version"))
                        throw new Error("The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is 'may-2020'.")
                }
                if (hasPlugin(t, "recordAndTuple") && !te.includes(getPluginOption(t, "recordAndTuple", "syntaxType")))
                    throw new Error("'recordAndTuple' requires 'syntaxType' option whose value should be one of: " + te.map(t=>`'${t}'`).join(", "));
                if (hasPlugin(t, "asyncDoExpressions") && !hasPlugin(t, "doExpressions")) {
                    const t = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
                    throw t.missingPlugins = "doExpressions",
                    t
                }
            }(t.plugins),
            i = function getParserClass(t) {
                const r = ne.filter(r=>hasPlugin(t, r))
                  , i = r.join("/");
                let a = ce[i];
                if (!a) {
                    a = Parser;
                    for (const t of r)
                        a = re[t](a);
                    ce[i] = a
                }
                return a
            }(t.plugins)),
            new i(t,r)
        }
        const ce = {};
        r.parse = function parse(t, r) {
            var i;
            if ("unambiguous" !== (null == (i = r) ? void 0 : i.sourceType))
                return getParser(r, t).parse();
            r = Object.assign({}, r);
            try {
                r.sourceType = "module";
                const i = getParser(r, t)
                  , a = i.parse();
                if (i.sawUnambiguousESM)
                    return a;
                if (i.ambiguousScriptDifferentAst)
                    try {
                        return r.sourceType = "script",
                        getParser(r, t).parse()
                    } catch (t) {}
                else
                    a.program.sourceType = "script";
                return a
            } catch (i) {
                try {
                    return r.sourceType = "script",
                    getParser(r, t).parse()
                } catch (t) {}
                throw i
            }
        }
        ,
        r.parseExpression = function parseExpression(t, r) {
            const i = getParser(r, t);
            return i.options.strictMode && (i.state.strict = !0),
            i.getExpression()
        }
        ,
        r.tokTypes = pe
    },
    GlVh: function(t, r, i) {
        "use strict";
        var a = i("TqRt")
          , o = a(i("iWIM"))
          , l = a(i("7W2i"))
          , u = a(i("a1gu"))
          , p = a(i("Nsbk"))
          , c = a(i("lwsE"))
          , d = a(i("W8MJ"));
        function _createSuper(t) {
            var r = function _isNativeReflectConstruct() {
                if ("undefined" == typeof Reflect || !Reflect.construct)
                    return !1;
                if (Reflect.construct.sham)
                    return !1;
                if ("function" == typeof Proxy)
                    return !0;
                try {
                    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}
                    ))),
                    !0
                } catch (t) {
                    return !1
                }
            }();
            return function _createSuperInternal() {
                var i, a = (0,
                p.default)(t);
                if (r) {
                    var o = (0,
                    p.default)(this).constructor;
                    i = Reflect.construct(a, arguments, o)
                } else
                    i = a.apply(this, arguments);
                return (0,
                u.default)(this, i)
            }
        }
        var y = i("sR6L").Syntax
          , h = i("SCtg")
          , m = i("dYsE")
          , T = i("C+dp").Definition
          , S = i("9lTW");
        function shouldBeStatically(t) {
            return t.type === m.ClassName || t.type === m.Variable && "var" !== t.parent.kind
        }
        var g = function() {
            function Scope(t, r, i, a, o) {
                (0,
                c.default)(this, Scope),
                this.type = r,
                this.set = new Map,
                this.taints = new Map,
                this.dynamic = "global" === this.type || "with" === this.type,
                this.block = a,
                this.through = [],
                this.variables = [],
                this.references = [],
                this.variableScope = "global" === this.type || "function" === this.type || "module" === this.type ? this : i.variableScope,
                this.functionExpressionScope = !1,
                this.directCallToEvalScope = !1,
                this.thisFound = !1,
                this.__left = [],
                this.upper = i,
                this.isStrict = function isStrictScope(t, r, i, a) {
                    var o;
                    if (t.upper && t.upper.isStrict)
                        return !0;
                    if (r.type === y.ArrowFunctionExpression)
                        return !0;
                    if (i)
                        return !0;
                    if ("class" === t.type || "module" === t.type)
                        return !0;
                    if ("block" === t.type || "switch" === t.type)
                        return !1;
                    if ("function" === t.type) {
                        if (!(o = r.type === y.Program ? r : r.body))
                            return !1
                    } else {
                        if ("global" !== t.type)
                            return !1;
                        o = r
                    }
                    if (a)
                        for (var l = 0, u = o.body.length; l < u; ++l) {
                            var p = o.body[l];
                            if (p.type !== y.DirectiveStatement)
                                break;
                            if ('"use strict"' === p.raw || "'use strict'" === p.raw)
                                return !0
                        }
                    else
                        for (var c = 0, d = o.body.length; c < d; ++c) {
                            var h = o.body[c];
                            if (h.type !== y.ExpressionStatement)
                                break;
                            var m = h.expression;
                            if (m.type !== y.Literal || "string" != typeof m.value)
                                break;
                            if (null !== m.raw && void 0 !== m.raw) {
                                if ('"use strict"' === m.raw || "'use strict'" === m.raw)
                                    return !0
                            } else if ("use strict" === m.value)
                                return !0
                        }
                    return !1
                }(this, a, o, t.__useDirective()),
                this.childScopes = [],
                this.upper && this.upper.childScopes.push(this),
                this.__declaredVariables = t.__declaredVariables,
                function registerScope(t, r) {
                    t.scopes.push(r);
                    var i = t.__nodeToScope.get(r.block);
                    i ? i.push(r) : t.__nodeToScope.set(r.block, [r])
                }(t, this)
            }
            return (0,
            d.default)(Scope, [{
                key: "__shouldStaticallyClose",
                value: function __shouldStaticallyClose(t) {
                    return !this.dynamic || t.__isOptimistic()
                }
            }, {
                key: "__shouldStaticallyCloseForGlobal",
                value: function __shouldStaticallyCloseForGlobal(t) {
                    var r = t.identifier.name;
                    if (!this.set.has(r))
                        return !1;
                    var i = this.set.get(r).defs;
                    return i.length > 0 && i.every(shouldBeStatically)
                }
            }, {
                key: "__staticCloseRef",
                value: function __staticCloseRef(t) {
                    this.__resolve(t) || this.__delegateToUpperScope(t)
                }
            }, {
                key: "__dynamicCloseRef",
                value: function __dynamicCloseRef(t) {
                    var r = this;
                    do {
                        r.through.push(t),
                        r = r.upper
                    } while (r)
                }
            }, {
                key: "__globalCloseRef",
                value: function __globalCloseRef(t) {
                    this.__shouldStaticallyCloseForGlobal(t) ? this.__staticCloseRef(t) : this.__dynamicCloseRef(t)
                }
            }, {
                key: "__close",
                value: function __close(t) {
                    var r;
                    r = this.__shouldStaticallyClose(t) ? this.__staticCloseRef : "global" !== this.type ? this.__dynamicCloseRef : this.__globalCloseRef;
                    for (var i = 0, a = this.__left.length; i < a; ++i) {
                        var o = this.__left[i];
                        r.call(this, o)
                    }
                    return this.__left = null,
                    this.upper
                }
            }, {
                key: "__resolve",
                value: function __resolve(t) {
                    var r = t.identifier.name;
                    if (this.set.has(r)) {
                        var i = this.set.get(r);
                        return i.references.push(t),
                        i.stack = i.stack && t.from.variableScope === this.variableScope,
                        t.tainted && (i.tainted = !0,
                        this.taints.set(i.name, !0)),
                        t.resolved = i,
                        !0
                    }
                    return !1
                }
            }, {
                key: "__delegateToUpperScope",
                value: function __delegateToUpperScope(t) {
                    this.upper && this.upper.__left.push(t),
                    this.through.push(t)
                }
            }, {
                key: "__addDeclaredVariablesOfNode",
                value: function __addDeclaredVariablesOfNode(t, r) {
                    if (null != r) {
                        var i = this.__declaredVariables.get(r);
                        null == i && (i = [],
                        this.__declaredVariables.set(r, i)),
                        -1 === i.indexOf(t) && i.push(t)
                    }
                }
            }, {
                key: "__defineGeneric",
                value: function __defineGeneric(t, r, i, a, o) {
                    var l;
                    (l = r.get(t)) || (l = new m(t,this),
                    r.set(t, l),
                    i.push(l)),
                    o && (l.defs.push(o),
                    o.type !== m.TDZ && (this.__addDeclaredVariablesOfNode(l, o.node),
                    this.__addDeclaredVariablesOfNode(l, o.parent))),
                    a && l.identifiers.push(a)
                }
            }, {
                key: "__define",
                value: function __define(t, r) {
                    t && t.type === y.Identifier && this.__defineGeneric(t.name, this.set, this.variables, t, r)
                }
            }, {
                key: "__referencing",
                value: function __referencing(t, r, i, a, o, l) {
                    if (t && t.type === y.Identifier && "super" !== t.name) {
                        var u = new h(t,this,r || h.READ,i,a,!!o,!!l);
                        this.references.push(u),
                        this.__left.push(u)
                    }
                }
            }, {
                key: "__detectEval",
                value: function __detectEval() {
                    var t = this;
                    this.directCallToEvalScope = !0;
                    do {
                        t.dynamic = !0,
                        t = t.upper
                    } while (t)
                }
            }, {
                key: "__detectThis",
                value: function __detectThis() {
                    this.thisFound = !0
                }
            }, {
                key: "__isClosed",
                value: function __isClosed() {
                    return null === this.__left
                }
            }, {
                key: "resolve",
                value: function resolve(t) {
                    var r, i, a;
                    for (S(this.__isClosed(), "Scope should be closed."),
                    S(t.type === y.Identifier, "Target should be identifier."),
                    i = 0,
                    a = this.references.length; i < a; ++i)
                        if ((r = this.references[i]).identifier === t)
                            return r;
                    return null
                }
            }, {
                key: "isStatic",
                value: function isStatic() {
                    return !this.dynamic
                }
            }, {
                key: "isArgumentsMaterialized",
                value: function isArgumentsMaterialized() {
                    return !0
                }
            }, {
                key: "isThisMaterialized",
                value: function isThisMaterialized() {
                    return !0
                }
            }, {
                key: "isUsedName",
                value: function isUsedName(t) {
                    if (this.set.has(t))
                        return !0;
                    for (var r = 0, i = this.through.length; r < i; ++r)
                        if (this.through[r].identifier.name === t)
                            return !0;
                    return !1
                }
            }]),
            Scope
        }()
          , b = function(t) {
            (0,
            l.default)(GlobalScope, t);
            var r = _createSuper(GlobalScope);
            function GlobalScope(t, i) {
                var a;
                return (0,
                c.default)(this, GlobalScope),
                (a = r.call(this, t, "global", null, i, !1)).implicit = {
                    set: new Map,
                    variables: [],
                    left: []
                },
                a
            }
            return (0,
            d.default)(GlobalScope, [{
                key: "__close",
                value: function __close(t) {
                    for (var r = [], i = 0, a = this.__left.length; i < a; ++i) {
                        var l = this.__left[i];
                        l.__maybeImplicitGlobal && !this.set.has(l.identifier.name) && r.push(l.__maybeImplicitGlobal)
                    }
                    for (var u = 0, c = r.length; u < c; ++u) {
                        var d = r[u];
                        this.__defineImplicit(d.pattern, new T(m.ImplicitGlobalVariable,d.pattern,d.node,null,null,null))
                    }
                    return this.implicit.left = this.__left,
                    (0,
                    o.default)((0,
                    p.default)(GlobalScope.prototype), "__close", this).call(this, t)
                }
            }, {
                key: "__defineImplicit",
                value: function __defineImplicit(t, r) {
                    t && t.type === y.Identifier && this.__defineGeneric(t.name, this.implicit.set, this.implicit.variables, t, r)
                }
            }]),
            GlobalScope
        }(g)
          , v = function(t) {
            (0,
            l.default)(ModuleScope, t);
            var r = _createSuper(ModuleScope);
            function ModuleScope(t, i, a) {
                return (0,
                c.default)(this, ModuleScope),
                r.call(this, t, "module", i, a, !1)
            }
            return (0,
            d.default)(ModuleScope)
        }(g)
          , E = function(t) {
            (0,
            l.default)(FunctionExpressionNameScope, t);
            var r = _createSuper(FunctionExpressionNameScope);
            function FunctionExpressionNameScope(t, i, a) {
                var o;
                return (0,
                c.default)(this, FunctionExpressionNameScope),
                (o = r.call(this, t, "function-expression-name", i, a, !1)).__define(a.id, new T(m.FunctionName,a.id,a,null,null,null)),
                o.functionExpressionScope = !0,
                o
            }
            return (0,
            d.default)(FunctionExpressionNameScope)
        }(g)
          , P = function(t) {
            (0,
            l.default)(CatchScope, t);
            var r = _createSuper(CatchScope);
            function CatchScope(t, i, a) {
                return (0,
                c.default)(this, CatchScope),
                r.call(this, t, "catch", i, a, !1)
            }
            return (0,
            d.default)(CatchScope)
        }(g)
          , x = function(t) {
            (0,
            l.default)(WithScope, t);
            var r = _createSuper(WithScope);
            function WithScope(t, i, a) {
                return (0,
                c.default)(this, WithScope),
                r.call(this, t, "with", i, a, !1)
            }
            return (0,
            d.default)(WithScope, [{
                key: "__close",
                value: function __close(t) {
                    if (this.__shouldStaticallyClose(t))
                        return (0,
                        o.default)((0,
                        p.default)(WithScope.prototype), "__close", this).call(this, t);
                    for (var r = 0, i = this.__left.length; r < i; ++r) {
                        var a = this.__left[r];
                        a.tainted = !0,
                        this.__delegateToUpperScope(a)
                    }
                    return this.__left = null,
                    this.upper
                }
            }]),
            WithScope
        }(g)
          , A = function(t) {
            (0,
            l.default)(TDZScope, t);
            var r = _createSuper(TDZScope);
            function TDZScope(t, i, a) {
                return (0,
                c.default)(this, TDZScope),
                r.call(this, t, "TDZ", i, a, !1)
            }
            return (0,
            d.default)(TDZScope)
        }(g)
          , O = function(t) {
            (0,
            l.default)(BlockScope, t);
            var r = _createSuper(BlockScope);
            function BlockScope(t, i, a) {
                return (0,
                c.default)(this, BlockScope),
                r.call(this, t, "block", i, a, !1)
            }
            return (0,
            d.default)(BlockScope)
        }(g)
          , I = function(t) {
            (0,
            l.default)(SwitchScope, t);
            var r = _createSuper(SwitchScope);
            function SwitchScope(t, i, a) {
                return (0,
                c.default)(this, SwitchScope),
                r.call(this, t, "switch", i, a, !1)
            }
            return (0,
            d.default)(SwitchScope)
        }(g)
          , w = function(t) {
            (0,
            l.default)(FunctionScope, t);
            var r = _createSuper(FunctionScope);
            function FunctionScope(t, i, a, o) {
                var l;
                return (0,
                c.default)(this, FunctionScope),
                (l = r.call(this, t, "function", i, a, o)).block.type !== y.ArrowFunctionExpression && l.__defineArguments(),
                l
            }
            return (0,
            d.default)(FunctionScope, [{
                key: "isArgumentsMaterialized",
                value: function isArgumentsMaterialized() {
                    if (this.block.type === y.ArrowFunctionExpression)
                        return !1;
                    if (!this.isStatic())
                        return !0;
                    var t = this.set.get("arguments");
                    return S(t, "Always have arguments variable."),
                    t.tainted || 0 !== t.references.length
                }
            }, {
                key: "isThisMaterialized",
                value: function isThisMaterialized() {
                    return !this.isStatic() || this.thisFound
                }
            }, {
                key: "__defineArguments",
                value: function __defineArguments() {
                    this.__defineGeneric("arguments", this.set, this.variables, null, null),
                    this.taints.set("arguments", !0)
                }
            }]),
            FunctionScope
        }(g)
          , C = function(t) {
            (0,
            l.default)(ForScope, t);
            var r = _createSuper(ForScope);
            function ForScope(t, i, a) {
                return (0,
                c.default)(this, ForScope),
                r.call(this, t, "for", i, a, !1)
            }
            return (0,
            d.default)(ForScope)
        }(g)
          , N = function(t) {
            (0,
            l.default)(ClassScope, t);
            var r = _createSuper(ClassScope);
            function ClassScope(t, i, a) {
                return (0,
                c.default)(this, ClassScope),
                r.call(this, t, "class", i, a, !1)
            }
            return (0,
            d.default)(ClassScope)
        }(g);
        t.exports = {
            Scope: g,
            GlobalScope: b,
            ModuleScope: v,
            FunctionExpressionNameScope: E,
            CatchScope: P,
            WithScope: x,
            TDZScope: A,
            BlockScope: O,
            SwitchScope: I,
            FunctionScope: w,
            ForScope: C,
            ClassScope: N
        }
    },
    Gv8t: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function removeTypeDuplicates(t) {
            const r = {}
              , i = {}
              , o = new Set
              , l = [];
            for (let r = 0; r < t.length; r++) {
                const u = t[r];
                if (u && !(l.indexOf(u) >= 0)) {
                    if ((0,
                    a.isTSAnyKeyword)(u))
                        return [u];
                    (0,
                    a.isTSBaseType)(u) ? i[u.type] = u : (0,
                    a.isTSUnionType)(u) ? o.has(u.types) || (t.push(...u.types),
                    o.add(u.types)) : l.push(u)
                }
            }
            for (const t of Object.keys(i))
                l.push(i[t]);
            for (const t of Object.keys(r))
                l.push(r[t]);
            return l
        }
        ;
        var a = i("xIU+")
    },
    H7XF: function(t, r, i) {
        "use strict";
        r.byteLength = function byteLength(t) {
            var r = getLens(t)
              , i = r[0]
              , a = r[1];
            return 3 * (i + a) / 4 - a
        }
        ,
        r.toByteArray = function toByteArray(t) {
            var r, i, a = getLens(t), u = a[0], p = a[1], c = new l(function _byteLength(t, r, i) {
                return 3 * (r + i) / 4 - i
            }(0, u, p)), d = 0, y = p > 0 ? u - 4 : u;
            for (i = 0; i < y; i += 4)
                r = o[t.charCodeAt(i)] << 18 | o[t.charCodeAt(i + 1)] << 12 | o[t.charCodeAt(i + 2)] << 6 | o[t.charCodeAt(i + 3)],
                c[d++] = r >> 16 & 255,
                c[d++] = r >> 8 & 255,
                c[d++] = 255 & r;
            2 === p && (r = o[t.charCodeAt(i)] << 2 | o[t.charCodeAt(i + 1)] >> 4,
            c[d++] = 255 & r);
            1 === p && (r = o[t.charCodeAt(i)] << 10 | o[t.charCodeAt(i + 1)] << 4 | o[t.charCodeAt(i + 2)] >> 2,
            c[d++] = r >> 8 & 255,
            c[d++] = 255 & r);
            return c
        }
        ,
        r.fromByteArray = function fromByteArray(t) {
            for (var r, i = t.length, o = i % 3, l = [], u = 0, p = i - o; u < p; u += 16383)
                l.push(encodeChunk(t, u, u + 16383 > p ? p : u + 16383));
            1 === o ? (r = t[i - 1],
            l.push(a[r >> 2] + a[r << 4 & 63] + "==")) : 2 === o && (r = (t[i - 2] << 8) + t[i - 1],
            l.push(a[r >> 10] + a[r >> 4 & 63] + a[r << 2 & 63] + "="));
            return l.join("")
        }
        ;
        for (var a = [], o = [], l = "undefined" != typeof Uint8Array ? Uint8Array : Array, u = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", p = 0, c = u.length; p < c; ++p)
            a[p] = u[p],
            o[u.charCodeAt(p)] = p;
        function getLens(t) {
            var r = t.length;
            if (r % 4 > 0)
                throw new Error("Invalid string. Length must be a multiple of 4");
            var i = t.indexOf("=");
            return -1 === i && (i = r),
            [i, i === r ? 0 : 4 - i % 4]
        }
        function encodeChunk(t, r, i) {
            for (var o, l, u = [], p = r; p < i; p += 3)
                o = (t[p] << 16 & 16711680) + (t[p + 1] << 8 & 65280) + (255 & t[p + 2]),
                u.push(a[(l = o) >> 18 & 63] + a[l >> 12 & 63] + a[l >> 6 & 63] + a[63 & l]);
            return u.join("")
        }
        o["-".charCodeAt(0)] = 62,
        o["_".charCodeAt(0)] = 63
    },
    "HG/J": function(t) {
        t.exports = JSON.parse('{"name":"eslint-scope","description":"ECMAScript scope analyzer for ESLint","homepage":"http://github.com/eslint/eslint-scope","main":"lib/index.js","version":"3.7.1","engines":{"node":">=4.0.0"},"repository":"eslint/eslint-scope","bugs":{"url":"https://github.com/eslint/eslint-scope/issues"},"license":"BSD-2-Clause","scripts":{"test":"node Makefile.js test","lint":"node Makefile.js lint","release":"eslint-release","ci-release":"eslint-ci-release","gh-release":"eslint-gh-release","alpharelease":"eslint-prerelease alpha","betarelease":"eslint-prerelease beta"},"files":["LICENSE","README.md","lib"],"dependencies":{"esrecurse":"^4.1.0","estraverse":"^4.1.1"},"devDependencies":{"chai":"^3.4.1","eslint":"^3.15.0","eslint-config-eslint":"^4.0.0","eslint-release":"^0.10.1","espree":"^3.1.1","istanbul":"^0.4.5","mocha":"^3.2.0","npm-license":"^0.3.3","shelljs":"^0.7.6","typescript":"~2.0.10","typescript-eslint-parser":"^1.0.0"}}')
    },
    HPhd: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function clone(t) {
            return (0,
            a.default)(t, !1)
        }
        ;
        var a = i("v3g0")
    },
    Hczm: function(t, r, i) {
        "use strict";
        var a = i("YSHT")
          , o = i("O9f4");
        t.exports = function(t, r, i) {
            var o = {
                source: i
            };
            a.VISITOR_KEYS.Property = a.VISITOR_KEYS.ObjectProperty,
            a.VISITOR_KEYS.MethodDefinition = ["key", "value", "decorators", "returnType", "typeParameters"],
            r(t, l, null, o),
            delete a.VISITOR_KEYS.Property,
            delete a.VISITOR_KEYS.MethodDefinition
        }
        ;
        var l = {
            noScope: !0,
            enter: function enter(t) {
                var r = t.node;
                r._babelType = r.type,
                r.innerComments && (r.trailingComments = r.innerComments,
                delete r.innerComments),
                r.trailingComments && o(r.trailingComments),
                r.leadingComments && o(r.leadingComments)
            },
            exit: function exit(t) {
                var r = t.node;
                if (t.isJSXText() && (r.type = "Literal"),
                t.isRestElement() && t.parent && "ObjectPattern" === t.parent.type && (r.type = "ExperimentalRestProperty"),
                t.isSpreadElement() && t.parent && "ObjectExpression" === t.parent.type && (r.type = "ExperimentalSpreadProperty"),
                t.isTypeParameter() && (r.type = "Identifier",
                r.typeAnnotation = r.bound,
                delete r.bound),
                t.isQualifiedTypeIdentifier() && delete r.id,
                t.isObjectTypeProperty() && delete r.key,
                t.isObjectTypeIndexer() && delete r.id,
                t.isFunctionTypeParam() && delete r.name,
                t.isImportDeclaration() && delete r.isType,
                t.isTemplateLiteral())
                    for (var i = 0; i < r.quasis.length; i++) {
                        var a = r.quasis[i];
                        a.range[0] -= 1,
                        a.tail ? a.range[1] += 1 : a.range[1] += 2,
                        a.loc.start.column -= 1,
                        a.tail ? a.loc.end.column += 1 : a.loc.end.column += 2
                    }
            }
        }
    },
    IAoA: function(t, r, i) {
        "use strict";
        (function(t) {
            var r = i("Po9p")
              , a = i("33yf")
              , o = i("YSHT");
            var l = null
              , u = null;
            t.exports = function(i) {
                if (!l) {
                    var p = function getModules() {
                        try {
                            var i = r._resolveFilename("eslint", t.parent)
                        } catch (t) {
                            try {
                                i = !function webpackMissingModule() {
                                    var t = new Error("Cannot find module 'eslint'");
                                    throw t.code = "MODULE_NOT_FOUND",
                                    t
                                }()
                            } catch (t) {
                                throw new ReferenceError("couldn't resolve eslint")
                            }
                        }
                        var o = new r(i);
                        o.filename = i,
                        o.paths = r._nodeModulePaths(a.dirname(i));
                        try {
                            var l = o.require("eslint-scope")
                              , u = o.require("eslint-scope/lib/definition").Definition
                              , p = o.require("eslint-scope/lib/referencer")
                        } catch (t) {
                            l = o.require("escope"),
                            u = o.require("escope/lib/definition").Definition,
                            p = o.require("escope/lib/referencer")
                        }
                        var c = o.require("estraverse");
                        return p.__esModule && (p = p.default),
                        {
                            Definition: u,
                            escope: l,
                            estraverse: c,
                            referencer: p
                        }
                    }();
                    !function monkeypatch(t) {
                        var r = t.Definition
                          , i = t.escope
                          , a = t.estraverse
                          , l = t.referencer;
                        function visitDecorators(t) {
                            if (t.decorators)
                                for (var r = 0; r < t.decorators.length; r++)
                                    t.decorators[r].expression && this.visit(t.decorators[r])
                        }
                        Object.assign(a.VisitorKeys, o.VISITOR_KEYS),
                        a.VisitorKeys.MethodDefinition.push("decorators"),
                        a.VisitorKeys.Property.push("decorators");
                        var u = o.FLIPPED_ALIAS_KEYS.Flow.concat(["ArrayPattern", "ClassDeclaration", "ClassExpression", "FunctionDeclaration", "FunctionExpression", "Identifier", "ObjectPattern", "RestElement"])
                          , p = Object.keys(o.VISITOR_KEYS).reduce((function(t, r) {
                            var i = o.VISITOR_KEYS[r];
                            return -1 === u.indexOf(i) && (t[r] = i),
                            t
                        }
                        ), {})
                          , c = {
                            callProperties: {
                                type: "loop",
                                values: ["value"]
                            },
                            indexers: {
                                type: "loop",
                                values: ["key", "value"]
                            },
                            properties: {
                                type: "loop",
                                values: ["argument", "value"]
                            },
                            types: {
                                type: "loop"
                            },
                            params: {
                                type: "loop"
                            },
                            argument: {
                                type: "single"
                            },
                            elementType: {
                                type: "single"
                            },
                            qualification: {
                                type: "single"
                            },
                            rest: {
                                type: "single"
                            },
                            returnType: {
                                type: "single"
                            },
                            typeAnnotation: {
                                type: "typeAnnotation"
                            },
                            typeParameters: {
                                type: "typeParameters"
                            },
                            id: {
                                type: "id"
                            }
                        };
                        function visitTypeAnnotation(t) {
                            var r = p[t.type];
                            if (r)
                                for (var i = 0; i < r.length; i++) {
                                    var a = r[i]
                                      , o = c[a]
                                      , l = t[a];
                                    if (null != o && null != l)
                                        if ("loop" === o.type)
                                            for (var u = 0; u < l.length; u++)
                                                if (Array.isArray(o.values))
                                                    for (var d = 0; d < o.values.length; d++) {
                                                        var y = l[u][o.values[d]];
                                                        y && checkIdentifierOrVisit.call(this, y)
                                                    }
                                                else
                                                    checkIdentifierOrVisit.call(this, l[u]);
                                        else if ("single" === o.type)
                                            checkIdentifierOrVisit.call(this, l);
                                        else if ("typeAnnotation" === o.type)
                                            visitTypeAnnotation.call(this, t.typeAnnotation);
                                        else if ("typeParameters" === o.type)
                                            for (var h = 0; h < t.typeParameters.params.length; h++)
                                                checkIdentifierOrVisit.call(this, t.typeParameters.params[h]);
                                        else
                                            "id" === o.type && ("Identifier" === t.id.type ? checkIdentifierOrVisit.call(this, t.id) : visitTypeAnnotation.call(this, t.id))
                                }
                        }
                        function checkIdentifierOrVisit(t) {
                            t.typeAnnotation ? visitTypeAnnotation.call(this, t.typeAnnotation) : "Identifier" === t.type ? this.visit(t) : visitTypeAnnotation.call(this, t)
                        }
                        function nestTypeParamScope(t, a) {
                            var o = t.__currentScope
                              , l = new i.Scope(t,"type-parameters",o,a,!1);
                            t.__nestScope(l);
                            for (var u = 0; u < a.typeParameters.params.length; u++) {
                                var p = a.typeParameters.params[u];
                                l.__define(p, new r("TypeParameter",p,p)),
                                p.typeAnnotation && checkIdentifierOrVisit.call(this, p)
                            }
                            return l.__define = function() {
                                return o.__define.apply(o, arguments)
                            }
                            ,
                            l
                        }
                        var d = l.prototype.visitClass;
                        l.prototype.visitClass = function(t) {
                            var r;
                            if (visitDecorators.call(this, t),
                            t.typeParameters && (r = nestTypeParamScope.call(this, this.scopeManager, t)),
                            t.implements)
                                for (var i = 0; i < t.implements.length; i++)
                                    checkIdentifierOrVisit.call(this, t.implements[i]);
                            if (t.superTypeParameters)
                                for (var a = 0; a < t.superTypeParameters.params.length; a++)
                                    checkIdentifierOrVisit.call(this, t.superTypeParameters.params[a]);
                            d.call(this, t),
                            r && this.close(t)
                        }
                        ;
                        var y = l.prototype.visitProperty;
                        function visitClassProperty(t) {
                            t.typeAnnotation && visitTypeAnnotation.call(this, t.typeAnnotation),
                            this.visitProperty(t)
                        }
                        l.prototype.visitProperty = function(t) {
                            t.value && "TypeCastExpression" === t.value.type && visitTypeAnnotation.call(this, t.value),
                            visitDecorators.call(this, t),
                            y.call(this, t)
                        }
                        ,
                        l.prototype.ClassProperty = visitClassProperty,
                        l.prototype.ClassPrivateProperty = visitClassProperty,
                        l.prototype.OptionalMemberExpression = l.prototype.MemberExpression;
                        var h = l.prototype.visitFunction;
                        l.prototype.visitFunction = function(t) {
                            var r;
                            if (t.typeParameters && (r = nestTypeParamScope.call(this, this.scopeManager, t)),
                            t.returnType && checkIdentifierOrVisit.call(this, t.returnType),
                            t.params)
                                for (var i = 0; i < t.params.length; i++) {
                                    var l = t.params[i];
                                    l.typeAnnotation ? checkIdentifierOrVisit.call(this, l) : o.isAssignmentPattern(l) && l.left.typeAnnotation && checkIdentifierOrVisit.call(this, l.left)
                                }
                            a.VisitorKeys.ObjectPattern = ["properties"],
                            a.VisitorKeys.ArrayPattern = ["elements"],
                            h.call(this, t),
                            a.VisitorKeys.ObjectPattern = o.VISITOR_KEYS.ObjectPattern,
                            a.VisitorKeys.ArrayPattern = o.VISITOR_KEYS.ArrayPattern,
                            r && this.close(t)
                        }
                        ;
                        var m = l.prototype.VariableDeclaration;
                        function createScopeVariable(t, i) {
                            this.currentScope().variableScope.__define(i, new r("Variable",i,t,null,null,null))
                        }
                        l.prototype.VariableDeclaration = function(t) {
                            if (t.declarations)
                                for (var r = 0; r < t.declarations.length; r++) {
                                    var i = t.declarations[r].id.typeAnnotation;
                                    i && checkIdentifierOrVisit.call(this, i)
                                }
                            m.call(this, t)
                        }
                        ,
                        l.prototype.InterfaceDeclaration = function(t) {
                            var r;
                            createScopeVariable.call(this, t, t.id),
                            t.typeParameters && (r = nestTypeParamScope.call(this, this.scopeManager, t));
                            for (var i = 0; i < t.extends.length; i++)
                                visitTypeAnnotation.call(this, t.extends[i]);
                            visitTypeAnnotation.call(this, t.body),
                            r && this.close(t)
                        }
                        ,
                        l.prototype.TypeAlias = function(t) {
                            var r;
                            createScopeVariable.call(this, t, t.id),
                            t.typeParameters && (r = nestTypeParamScope.call(this, this.scopeManager, t)),
                            t.right && visitTypeAnnotation.call(this, t.right),
                            r && this.close(t)
                        }
                        ,
                        l.prototype.DeclareModule = l.prototype.DeclareFunction = l.prototype.DeclareVariable = l.prototype.DeclareClass = function(t) {
                            var r;
                            t.id && createScopeVariable.call(this, t, t.id),
                            t.typeParameters && (r = nestTypeParamScope.call(this, this.scopeManager, t)),
                            r && this.close(t)
                        }
                        ,
                        l._babelEslintPatched = !0
                    }(p),
                    l = p.escope,
                    u = p.escope.analyze
                }
                l.analyze = function(t, r) {
                    return (r = r || {}).ecmaVersion = i.ecmaVersion,
                    r.sourceType = i.sourceType,
                    r.nodejsScope = "script" === t.sourceType && !0 === (i.ecmaFeatures && i.ecmaFeatures.globalReturn),
                    u.call(this, t, r)
                }
            }
        }
        ).call(this, i("YuTi")(t))
    },
    "IQ/f": function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function assertNode(t) {
            if (!(0,
            a.default)(t)) {
                var r, i = null != (r = null == t ? void 0 : t.type) ? r : JSON.stringify(t);
                throw new TypeError('Not a valid node of type "'.concat(i, '"'))
            }
        }
        ;
        var a = i("buHe")
    },
    IXBh: function(t, r, i) {
        "use strict";
        (function(t) {
            Object.defineProperty(r, "__esModule", {
                value: !0
            }),
            r.codeFrameColumns = codeFrameColumns,
            r.default = function _default(r, i, a, l={}) {
                if (!o) {
                    o = !0;
                    const r = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
                    if (t.emitWarning)
                        t.emitWarning(r, "DeprecationWarning");
                    else {
                        new Error(r).name = "DeprecationWarning",
                        console.warn(new Error(r))
                    }
                }
                return a = Math.max(a, 0),
                codeFrameColumns(r, {
                    start: {
                        column: a,
                        line: i
                    }
                }, l)
            }
            ;
            var a = i("yKvr");
            let o = !1;
            const l = /\r\n|[\n\r\u2028\u2029]/;
            function codeFrameColumns(t, r, i={}) {
                const o = (i.highlightCode || i.forceColor) && (0,
                a.shouldHighlight)(i)
                  , u = (0,
                a.getChalk)(i)
                  , p = function getDefs(t) {
                    return {
                        gutter: t.grey,
                        marker: t.red.bold,
                        message: t.red.bold
                    }
                }(u)
                  , maybeHighlight = (t,r)=>o ? t(r) : r
                  , c = t.split(l)
                  , {start: d, end: y, markerLines: h} = function getMarkerLines(t, r, i) {
                    const a = Object.assign({
                        column: 0,
                        line: -1
                    }, t.start)
                      , o = Object.assign({}, a, t.end)
                      , {linesAbove: l=2, linesBelow: u=3} = i || {}
                      , p = a.line
                      , c = a.column
                      , d = o.line
                      , y = o.column;
                    let h = Math.max(p - (l + 1), 0)
                      , m = Math.min(r.length, d + u);
                    -1 === p && (h = 0),
                    -1 === d && (m = r.length);
                    const T = d - p
                      , S = {};
                    if (T)
                        for (let t = 0; t <= T; t++) {
                            const i = t + p;
                            if (c)
                                if (0 === t) {
                                    const t = r[i - 1].length;
                                    S[i] = [c, t - c + 1]
                                } else if (t === T)
                                    S[i] = [0, y];
                                else {
                                    const a = r[i - t].length;
                                    S[i] = [0, a]
                                }
                            else
                                S[i] = !0
                        }
                    else
                        S[p] = c === y ? !c || [c, 0] : [c, y - c];
                    return {
                        start: h,
                        end: m,
                        markerLines: S
                    }
                }(r, c, i)
                  , m = r.start && "number" == typeof r.start.column
                  , T = String(y).length;
                let S = (o ? (0,
                a.default)(t, i) : t).split(l, y).slice(d, y).map((t,r)=>{
                    const a = d + 1 + r
                      , o = ` ${(" " + a).slice(-T)} |`
                      , l = h[a]
                      , u = !h[a + 1];
                    if (l) {
                        let r = "";
                        if (Array.isArray(l)) {
                            const a = t.slice(0, Math.max(l[0] - 1, 0)).replace(/[^\t]/g, " ")
                              , c = l[1] || 1;
                            r = ["\n ", maybeHighlight(p.gutter, o.replace(/\d/g, " ")), " ", a, maybeHighlight(p.marker, "^").repeat(c)].join(""),
                            u && i.message && (r += " " + maybeHighlight(p.message, i.message))
                        }
                        return [maybeHighlight(p.marker, ">"), maybeHighlight(p.gutter, o), t.length > 0 ? " " + t : "", r].join("")
                    }
                    return ` ${maybeHighlight(p.gutter, o)}${t.length > 0 ? " " + t : ""}`
                }
                ).join("\n");
                return i.message && !m && (S = `${" ".repeat(T + 1)}${i.message}\n${S}`),
                o ? u.reset(S) : S
            }
        }
        ).call(this, i("8oxB"))
    },
    IaKS: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function inheritLeadingComments(t, r) {
            (0,
            a.default)("leadingComments", t, r)
        }
        ;
        var a = i("P3pX")
    },
    Iges: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = void 0;
        var a = (0,
        i("OPXu").default)("React.Component");
        r.default = a
    },
    "J/a/": function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function toIdentifier(t) {
            t += "";
            let r = "";
            for (const i of t)
                r += (0,
                o.isIdentifierChar)(i.codePointAt(0)) ? i : "-";
            r = r.replace(/^[-0-9]+/, ""),
            r = r.replace(/[-\s]+(.)?/g, (function(t, r) {
                return r ? r.toUpperCase() : ""
            }
            )),
            (0,
            a.default)(r) || (r = "_" + r);
            return r || "_"
        }
        ;
        var a = i("ucPi")
          , o = i("A27I")
    },
    J7WE: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = toKeyAlias;
        var a = i("xIU+")
          , o = i("v3g0")
          , l = i("mXO1");
        function toKeyAlias(t, r=t.key) {
            let i;
            return "method" === t.kind ? toKeyAlias.increment() + "" : (i = (0,
            a.isIdentifier)(r) ? r.name : (0,
            a.isStringLiteral)(r) ? JSON.stringify(r.value) : JSON.stringify((0,
            l.default)((0,
            o.default)(r))),
            t.computed && (i = `[${i}]`),
            t.static && (i = "static:" + i),
            i)
        }
        toKeyAlias.uid = 0,
        toKeyAlias.increment = function() {
            return toKeyAlias.uid >= Number.MAX_SAFE_INTEGER ? toKeyAlias.uid = 0 : toKeyAlias.uid++
        }
    },
    JSq2: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        });
        var a = {
            react: !0,
            assertNode: !0,
            createTypeAnnotationBasedOnTypeof: !0,
            createUnionTypeAnnotation: !0,
            createFlowUnionType: !0,
            createTSUnionType: !0,
            cloneNode: !0,
            clone: !0,
            cloneDeep: !0,
            cloneDeepWithoutLoc: !0,
            cloneWithoutLoc: !0,
            addComment: !0,
            addComments: !0,
            inheritInnerComments: !0,
            inheritLeadingComments: !0,
            inheritsComments: !0,
            inheritTrailingComments: !0,
            removeComments: !0,
            ensureBlock: !0,
            toBindingIdentifierName: !0,
            toBlock: !0,
            toComputedKey: !0,
            toExpression: !0,
            toIdentifier: !0,
            toKeyAlias: !0,
            toSequenceExpression: !0,
            toStatement: !0,
            valueToNode: !0,
            appendToMemberExpression: !0,
            inherits: !0,
            prependToMemberExpression: !0,
            removeProperties: !0,
            removePropertiesDeep: !0,
            removeTypeDuplicates: !0,
            getBindingIdentifiers: !0,
            getOuterBindingIdentifiers: !0,
            traverse: !0,
            traverseFast: !0,
            shallowEqual: !0,
            is: !0,
            isBinding: !0,
            isBlockScoped: !0,
            isImmutable: !0,
            isLet: !0,
            isNode: !0,
            isNodesEquivalent: !0,
            isPlaceholderType: !0,
            isReferenced: !0,
            isScope: !0,
            isSpecifierDefault: !0,
            isType: !0,
            isValidES3Identifier: !0,
            isValidIdentifier: !0,
            isVar: !0,
            matchesPattern: !0,
            validate: !0,
            buildMatchMemberExpression: !0
        };
        Object.defineProperty(r, "addComment", {
            enumerable: !0,
            get: function() {
                return P.default
            }
        }),
        Object.defineProperty(r, "addComments", {
            enumerable: !0,
            get: function() {
                return x.default
            }
        }),
        Object.defineProperty(r, "appendToMemberExpression", {
            enumerable: !0,
            get: function() {
                return X.default
            }
        }),
        Object.defineProperty(r, "assertNode", {
            enumerable: !0,
            get: function() {
                return p.default
            }
        }),
        Object.defineProperty(r, "buildMatchMemberExpression", {
            enumerable: !0,
            get: function() {
                return Se.default
            }
        }),
        Object.defineProperty(r, "clone", {
            enumerable: !0,
            get: function() {
                return g.default
            }
        }),
        Object.defineProperty(r, "cloneDeep", {
            enumerable: !0,
            get: function() {
                return b.default
            }
        }),
        Object.defineProperty(r, "cloneDeepWithoutLoc", {
            enumerable: !0,
            get: function() {
                return v.default
            }
        }),
        Object.defineProperty(r, "cloneNode", {
            enumerable: !0,
            get: function() {
                return S.default
            }
        }),
        Object.defineProperty(r, "cloneWithoutLoc", {
            enumerable: !0,
            get: function() {
                return E.default
            }
        }),
        Object.defineProperty(r, "createFlowUnionType", {
            enumerable: !0,
            get: function() {
                return y.default
            }
        }),
        Object.defineProperty(r, "createTSUnionType", {
            enumerable: !0,
            get: function() {
                return h.default
            }
        }),
        Object.defineProperty(r, "createTypeAnnotationBasedOnTypeof", {
            enumerable: !0,
            get: function() {
                return d.default
            }
        }),
        Object.defineProperty(r, "createUnionTypeAnnotation", {
            enumerable: !0,
            get: function() {
                return y.default
            }
        }),
        Object.defineProperty(r, "ensureBlock", {
            enumerable: !0,
            get: function() {
                return _.default
            }
        }),
        Object.defineProperty(r, "getBindingIdentifiers", {
            enumerable: !0,
            get: function() {
                return z.default
            }
        }),
        Object.defineProperty(r, "getOuterBindingIdentifiers", {
            enumerable: !0,
            get: function() {
                return Q.default
            }
        }),
        Object.defineProperty(r, "inheritInnerComments", {
            enumerable: !0,
            get: function() {
                return A.default
            }
        }),
        Object.defineProperty(r, "inheritLeadingComments", {
            enumerable: !0,
            get: function() {
                return O.default
            }
        }),
        Object.defineProperty(r, "inheritTrailingComments", {
            enumerable: !0,
            get: function() {
                return w.default
            }
        }),
        Object.defineProperty(r, "inherits", {
            enumerable: !0,
            get: function() {
                return J.default
            }
        }),
        Object.defineProperty(r, "inheritsComments", {
            enumerable: !0,
            get: function() {
                return I.default
            }
        }),
        Object.defineProperty(r, "is", {
            enumerable: !0,
            get: function() {
                return te.default
            }
        }),
        Object.defineProperty(r, "isBinding", {
            enumerable: !0,
            get: function() {
                return re.default
            }
        }),
        Object.defineProperty(r, "isBlockScoped", {
            enumerable: !0,
            get: function() {
                return ne.default
            }
        }),
        Object.defineProperty(r, "isImmutable", {
            enumerable: !0,
            get: function() {
                return ie.default
            }
        }),
        Object.defineProperty(r, "isLet", {
            enumerable: !0,
            get: function() {
                return ae.default
            }
        }),
        Object.defineProperty(r, "isNode", {
            enumerable: !0,
            get: function() {
                return se.default
            }
        }),
        Object.defineProperty(r, "isNodesEquivalent", {
            enumerable: !0,
            get: function() {
                return oe.default
            }
        }),
        Object.defineProperty(r, "isPlaceholderType", {
            enumerable: !0,
            get: function() {
                return le.default
            }
        }),
        Object.defineProperty(r, "isReferenced", {
            enumerable: !0,
            get: function() {
                return ue.default
            }
        }),
        Object.defineProperty(r, "isScope", {
            enumerable: !0,
            get: function() {
                return pe.default
            }
        }),
        Object.defineProperty(r, "isSpecifierDefault", {
            enumerable: !0,
            get: function() {
                return ce.default
            }
        }),
        Object.defineProperty(r, "isType", {
            enumerable: !0,
            get: function() {
                return de.default
            }
        }),
        Object.defineProperty(r, "isValidES3Identifier", {
            enumerable: !0,
            get: function() {
                return fe.default
            }
        }),
        Object.defineProperty(r, "isValidIdentifier", {
            enumerable: !0,
            get: function() {
                return ye.default
            }
        }),
        Object.defineProperty(r, "isVar", {
            enumerable: !0,
            get: function() {
                return he.default
            }
        }),
        Object.defineProperty(r, "matchesPattern", {
            enumerable: !0,
            get: function() {
                return me.default
            }
        }),
        Object.defineProperty(r, "prependToMemberExpression", {
            enumerable: !0,
            get: function() {
                return W.default
            }
        }),
        r.react = void 0,
        Object.defineProperty(r, "removeComments", {
            enumerable: !0,
            get: function() {
                return C.default
            }
        }),
        Object.defineProperty(r, "removeProperties", {
            enumerable: !0,
            get: function() {
                return q.default
            }
        }),
        Object.defineProperty(r, "removePropertiesDeep", {
            enumerable: !0,
            get: function() {
                return H.default
            }
        }),
        Object.defineProperty(r, "removeTypeDuplicates", {
            enumerable: !0,
            get: function() {
                return G.default
            }
        }),
        Object.defineProperty(r, "shallowEqual", {
            enumerable: !0,
            get: function() {
                return ee.default
            }
        }),
        Object.defineProperty(r, "toBindingIdentifierName", {
            enumerable: !0,
            get: function() {
                return L.default
            }
        }),
        Object.defineProperty(r, "toBlock", {
            enumerable: !0,
            get: function() {
                return k.default
            }
        }),
        Object.defineProperty(r, "toComputedKey", {
            enumerable: !0,
            get: function() {
                return M.default
            }
        }),
        Object.defineProperty(r, "toExpression", {
            enumerable: !0,
            get: function() {
                return j.default
            }
        }),
        Object.defineProperty(r, "toIdentifier", {
            enumerable: !0,
            get: function() {
                return B.default
            }
        }),
        Object.defineProperty(r, "toKeyAlias", {
            enumerable: !0,
            get: function() {
                return R.default
            }
        }),
        Object.defineProperty(r, "toSequenceExpression", {
            enumerable: !0,
            get: function() {
                return K.default
            }
        }),
        Object.defineProperty(r, "toStatement", {
            enumerable: !0,
            get: function() {
                return V.default
            }
        }),
        Object.defineProperty(r, "traverse", {
            enumerable: !0,
            get: function() {
                return $.default
            }
        }),
        Object.defineProperty(r, "traverseFast", {
            enumerable: !0,
            get: function() {
                return Z.default
            }
        }),
        Object.defineProperty(r, "validate", {
            enumerable: !0,
            get: function() {
                return Te.default
            }
        }),
        Object.defineProperty(r, "valueToNode", {
            enumerable: !0,
            get: function() {
                return U.default
            }
        });
        var o = i("2n+e")
          , l = i("4E18")
          , u = i("cuf3")
          , p = i("m5M9")
          , c = i("BMrg");
        Object.keys(c).forEach((function(t) {
            "default" !== t && "__esModule" !== t && (Object.prototype.hasOwnProperty.call(a, t) || t in r && r[t] === c[t] || Object.defineProperty(r, t, {
                enumerable: !0,
                get: function() {
                    return c[t]
                }
            }))
        }
        ));
        var d = i("RNM3")
          , y = i("Yp+L")
          , h = i("YqAK")
          , m = i("61uC");
        Object.keys(m).forEach((function(t) {
            "default" !== t && "__esModule" !== t && (Object.prototype.hasOwnProperty.call(a, t) || t in r && r[t] === m[t] || Object.defineProperty(r, t, {
                enumerable: !0,
                get: function() {
                    return m[t]
                }
            }))
        }
        ));
        var T = i("lrmr");
        Object.keys(T).forEach((function(t) {
            "default" !== t && "__esModule" !== t && (Object.prototype.hasOwnProperty.call(a, t) || t in r && r[t] === T[t] || Object.defineProperty(r, t, {
                enumerable: !0,
                get: function() {
                    return T[t]
                }
            }))
        }
        ));
        var S = i("v3g0")
          , g = i("HPhd")
          , b = i("xl6+")
          , v = i("zMfr")
          , E = i("71/9")
          , P = i("YQA8")
          , x = i("RwJ3")
          , A = i("fkdI")
          , O = i("+l3Y")
          , I = i("pw2U")
          , w = i("QoWe")
          , C = i("3YeA")
          , N = i("noBd");
        Object.keys(N).forEach((function(t) {
            "default" !== t && "__esModule" !== t && (Object.prototype.hasOwnProperty.call(a, t) || t in r && r[t] === N[t] || Object.defineProperty(r, t, {
                enumerable: !0,
                get: function() {
                    return N[t]
                }
            }))
        }
        ));
        var D = i("kEZX");
        Object.keys(D).forEach((function(t) {
            "default" !== t && "__esModule" !== t && (Object.prototype.hasOwnProperty.call(a, t) || t in r && r[t] === D[t] || Object.defineProperty(r, t, {
                enumerable: !0,
                get: function() {
                    return D[t]
                }
            }))
        }
        ));
        var _ = i("Mv50")
          , L = i("WlzW")
          , k = i("fwxm")
          , M = i("vW+O")
          , j = i("2Hwn")
          , B = i("J/a/")
          , R = i("J7WE")
          , K = i("xJ6i")
          , V = i("kUnP")
          , U = i("k4iN")
          , Y = i("uXiX");
        Object.keys(Y).forEach((function(t) {
            "default" !== t && "__esModule" !== t && (Object.prototype.hasOwnProperty.call(a, t) || t in r && r[t] === Y[t] || Object.defineProperty(r, t, {
                enumerable: !0,
                get: function() {
                    return Y[t]
                }
            }))
        }
        ));
        var X = i("gEKJ")
          , J = i("LIY4")
          , W = i("0fRI")
          , q = i("X6wd")
          , H = i("mXO1")
          , G = i("6tYi")
          , z = i("wffa")
          , Q = i("qwL7")
          , $ = i("YIMe");
        Object.keys($).forEach((function(t) {
            "default" !== t && "__esModule" !== t && (Object.prototype.hasOwnProperty.call(a, t) || t in r && r[t] === $[t] || Object.defineProperty(r, t, {
                enumerable: !0,
                get: function() {
                    return $[t]
                }
            }))
        }
        ));
        var Z = i("+v0W")
          , ee = i("OS6d")
          , te = i("F3vi")
          , re = i("RFFR")
          , ne = i("iBAI")
          , ie = i("lTly")
          , ae = i("wQ14")
          , se = i("L4Kc")
          , oe = i("Ywlc")
          , le = i("49gG")
          , ue = i("shor")
          , pe = i("i0Q+")
          , ce = i("mj3m")
          , de = i("EJNx")
          , fe = i("mgDx")
          , ye = i("ucPi")
          , he = i("QKP5")
          , me = i("/g1/")
          , Te = i("YupJ")
          , Se = i("V/pm")
          , ge = i("xIU+");
        Object.keys(ge).forEach((function(t) {
            "default" !== t && "__esModule" !== t && (Object.prototype.hasOwnProperty.call(a, t) || t in r && r[t] === ge[t] || Object.defineProperty(r, t, {
                enumerable: !0,
                get: function() {
                    return ge[t]
                }
            }))
        }
        ));
        var be = i("B17m");
        Object.keys(be).forEach((function(t) {
            "default" !== t && "__esModule" !== t && (Object.prototype.hasOwnProperty.call(a, t) || t in r && r[t] === be[t] || Object.defineProperty(r, t, {
                enumerable: !0,
                get: function() {
                    return be[t]
                }
            }))
        }
        ));
        const ve = {
            isReactComponent: o.default,
            isCompatTag: l.default,
            buildChildren: u.default
        };
        r.react = ve
    },
    JwF5: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        });
        var a = i("uQT7");
        Object.keys(a).forEach((function(t) {
            "default" !== t && "__esModule" !== t && (t in r && r[t] === a[t] || Object.defineProperty(r, t, {
                enumerable: !0,
                get: function() {
                    return a[t]
                }
            }))
        }
        ));
        var o = i("1a3c");
        Object.keys(o).forEach((function(t) {
            "default" !== t && "__esModule" !== t && (t in r && r[t] === o[t] || Object.defineProperty(r, t, {
                enumerable: !0,
                get: function() {
                    return o[t]
                }
            }))
        }
        ));
        var l = i("ar3U");
        Object.keys(l).forEach((function(t) {
            "default" !== t && "__esModule" !== t && (t in r && r[t] === l[t] || Object.defineProperty(r, t, {
                enumerable: !0,
                get: function() {
                    return l[t]
                }
            }))
        }
        ));
        var u = i("Wb6z");
        Object.keys(u).forEach((function(t) {
            "default" !== t && "__esModule" !== t && (t in r && r[t] === u[t] || Object.defineProperty(r, t, {
                enumerable: !0,
                get: function() {
                    return u[t]
                }
            }))
        }
        ));
        var p = i("rXlq");
        Object.keys(p).forEach((function(t) {
            "default" !== t && "__esModule" !== t && (t in r && r[t] === p[t] || Object.defineProperty(r, t, {
                enumerable: !0,
                get: function() {
                    return p[t]
                }
            }))
        }
        ));
        var c = i("Ns23");
        Object.keys(c).forEach((function(t) {
            "default" !== t && "__esModule" !== t && (t in r && r[t] === c[t] || Object.defineProperty(r, t, {
                enumerable: !0,
                get: function() {
                    return c[t]
                }
            }))
        }
        ));
        var d = i("0GJC");
        Object.keys(d).forEach((function(t) {
            "default" !== t && "__esModule" !== t && (t in r && r[t] === d[t] || Object.defineProperty(r, t, {
                enumerable: !0,
                get: function() {
                    return d[t]
                }
            }))
        }
        ));
        var y = i("tGnh");
        Object.keys(y).forEach((function(t) {
            "default" !== t && "__esModule" !== t && (t in r && r[t] === y[t] || Object.defineProperty(r, t, {
                enumerable: !0,
                get: function() {
                    return y[t]
                }
            }))
        }
        ));
        var h = i("sNN5");
        Object.keys(h).forEach((function(t) {
            "default" !== t && "__esModule" !== t && (t in r && r[t] === h[t] || Object.defineProperty(r, t, {
                enumerable: !0,
                get: function() {
                    return h[t]
                }
            }))
        }
        ));
        var m = i("1h53");
        Object.keys(m).forEach((function(t) {
            "default" !== t && "__esModule" !== t && (t in r && r[t] === m[t] || Object.defineProperty(r, t, {
                enumerable: !0,
                get: function() {
                    return m[t]
                }
            }))
        }
        ));
        var T = i("sP6y");
        Object.keys(T).forEach((function(t) {
            "default" !== t && "__esModule" !== t && (t in r && r[t] === T[t] || Object.defineProperty(r, t, {
                enumerable: !0,
                get: function() {
                    return T[t]
                }
            }))
        }
        ))
    },
    K95w: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function isLet(t) {
            return (0,
            a.isVariableDeclaration)(t) && ("var" !== t.kind || t[o.BLOCK_SCOPED_SYMBOL])
        }
        ;
        var a = i("pbIU")
          , o = i("M7ys")
    },
    KCd3: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = void 0;
        var a = i("UuI8")
          , o = function createTypeAnnotationBasedOnTypeof(t) {
            switch (t) {
            case "string":
                return (0,
                a.stringTypeAnnotation)();
            case "number":
                return (0,
                a.numberTypeAnnotation)();
            case "undefined":
                return (0,
                a.voidTypeAnnotation)();
            case "boolean":
                return (0,
                a.booleanTypeAnnotation)();
            case "function":
                return (0,
                a.genericTypeAnnotation)((0,
                a.identifier)("Function"));
            case "object":
                return (0,
                a.genericTypeAnnotation)((0,
                a.identifier)("Object"));
            case "symbol":
                return (0,
                a.genericTypeAnnotation)((0,
                a.identifier)("Symbol"));
            case "bigint":
                return (0,
                a.anyTypeAnnotation)()
            }
            throw new Error("Invalid typeof value: " + t)
        };
        r.default = o
    },
    KDMj: function(t, r, i) {
        "use strict";
        var a = i("TqRt")(i("cDf5"));
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = void 0;
        var o = i("Aniq")
          , l = i("UuI8")
          , u = function valueToNode(t) {
            if (void 0 === t)
                return (0,
                l.identifier)("undefined");
            if (!0 === t || !1 === t)
                return (0,
                l.booleanLiteral)(t);
            if (null === t)
                return (0,
                l.nullLiteral)();
            if ("string" == typeof t)
                return (0,
                l.stringLiteral)(t);
            if ("number" == typeof t) {
                var r, i;
                if (Number.isFinite(t))
                    r = (0,
                    l.numericLiteral)(Math.abs(t));
                else
                    i = Number.isNaN(t) ? (0,
                    l.numericLiteral)(0) : (0,
                    l.numericLiteral)(1),
                    r = (0,
                    l.binaryExpression)("/", i, (0,
                    l.numericLiteral)(0));
                return (t < 0 || Object.is(t, -0)) && (r = (0,
                l.unaryExpression)("-", r)),
                r
            }
            if (function isRegExp(t) {
                return "[object RegExp]" === p(t)
            }(t)) {
                var u = t.source
                  , c = t.toString().match(/\/([a-z]+|)$/)[1];
                return (0,
                l.regExpLiteral)(u, c)
            }
            if (Array.isArray(t))
                return (0,
                l.arrayExpression)(t.map(valueToNode));
            if (function isPlainObject(t) {
                if ("object" !== (0,
                a.default)(t) || null === t || "[object Object]" !== Object.prototype.toString.call(t))
                    return !1;
                var r = Object.getPrototypeOf(t);
                return null === r || null === Object.getPrototypeOf(r)
            }(t)) {
                for (var d = [], y = 0, h = Object.keys(t); y < h.length; y++) {
                    var m = h[y]
                      , T = void 0;
                    T = (0,
                    o.default)(m) ? (0,
                    l.identifier)(m) : (0,
                    l.stringLiteral)(m),
                    d.push((0,
                    l.objectProperty)(T, valueToNode(t[m])))
                }
                return (0,
                l.objectExpression)(d)
            }
            throw new Error("don't know how to turn this value into a node")
        };
        r.default = u;
        var p = Function.call.bind(Object.prototype.toString)
    },
    KKCa: function(t, r) {
        "function" == typeof Object.create ? t.exports = function inherits(t, r) {
            t.super_ = r,
            t.prototype = Object.create(r.prototype, {
                constructor: {
                    value: t,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            })
        }
        : t.exports = function inherits(t, r) {
            t.super_ = r;
            var TempCtor = function() {};
            TempCtor.prototype = r.prototype,
            t.prototype = new TempCtor,
            t.prototype.constructor = t
        }
    },
    KPS7: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        Object.defineProperty(r, "isIdentifierName", {
            enumerable: !0,
            get: function get() {
                return a.isIdentifierName
            }
        }),
        Object.defineProperty(r, "isIdentifierChar", {
            enumerable: !0,
            get: function get() {
                return a.isIdentifierChar
            }
        }),
        Object.defineProperty(r, "isIdentifierStart", {
            enumerable: !0,
            get: function get() {
                return a.isIdentifierStart
            }
        }),
        Object.defineProperty(r, "isReservedWord", {
            enumerable: !0,
            get: function get() {
                return o.isReservedWord
            }
        }),
        Object.defineProperty(r, "isStrictBindOnlyReservedWord", {
            enumerable: !0,
            get: function get() {
                return o.isStrictBindOnlyReservedWord
            }
        }),
        Object.defineProperty(r, "isStrictBindReservedWord", {
            enumerable: !0,
            get: function get() {
                return o.isStrictBindReservedWord
            }
        }),
        Object.defineProperty(r, "isStrictReservedWord", {
            enumerable: !0,
            get: function get() {
                return o.isStrictReservedWord
            }
        }),
        Object.defineProperty(r, "isKeyword", {
            enumerable: !0,
            get: function get() {
                return o.isKeyword
            }
        });
        var a = i("vKzK")
          , o = i("5Yb/")
    },
    KZm0: function(t, r, i) {
        !function() {
            "use strict";
            var t = i("9vpr");
            function isNode(t) {
                return null != t && ("object" == typeof t && "string" == typeof t.type)
            }
            function Visitor(r, i) {
                i = i || {},
                this.__visitor = r || this,
                this.__childVisitorKeys = i.childVisitorKeys ? Object.assign({}, t.VisitorKeys, i.childVisitorKeys) : t.VisitorKeys,
                "iteration" === i.fallback ? this.__fallback = Object.keys : "function" == typeof i.fallback && (this.__fallback = i.fallback)
            }
            Visitor.prototype.visitChildren = function(r) {
                var i, a, o, l, u, p, c;
                if (null != r) {
                    if (i = r.type || t.Syntax.Property,
                    !(a = this.__childVisitorKeys[i])) {
                        if (!this.__fallback)
                            throw new Error("Unknown node type " + i + ".");
                        a = this.__fallback(r)
                    }
                    for (o = 0,
                    l = a.length; o < l; ++o)
                        if (c = r[a[o]])
                            if (Array.isArray(c))
                                for (u = 0,
                                p = c.length; u < p; ++u)
                                    c[u] && (!isNode(c[u]) && (d = i,
                                    y = a[o],
                                    d !== t.Syntax.ObjectExpression && d !== t.Syntax.ObjectPattern || "properties" !== y) || this.visit(c[u]));
                            else
                                isNode(c) && this.visit(c);
                    var d, y
                }
            }
            ,
            Visitor.prototype.visit = function(r) {
                var i;
                null != r && (i = r.type || t.Syntax.Property,
                this.__visitor[i] ? this.__visitor[i].call(this, r) : this.visitChildren(r))
            }
            ,
            r.version = i("i+xC").version,
            r.Visitor = Visitor,
            r.visit = function(t, r, i) {
                new Visitor(r,i).visit(t)
            }
        }()
    },
    KZrR: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function builder() {
            const t = this
              , r = a.BUILDER_KEYS[t]
              , i = arguments.length;
            if (i > r.length)
                throw new Error(`${t}: Too many arguments passed. Received ${i} but can receive no more than ${r.length}`);
            const l = {
                type: t
            };
            for (let o = 0; o < r.length; ++o) {
                const u = r[o]
                  , p = a.NODE_FIELDS[t][u];
                let c;
                o < i && (c = arguments[o]),
                void 0 === c && (c = Array.isArray(p.default) ? [] : p.default),
                l[u] = c
            }
            for (const t in l)
                (0,
                o.default)(l, t, l[t]);
            return l
        }
        ;
        var a = i("uXiX")
          , o = i("YupJ")
    },
    L4Kc: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function isNode(t) {
            return !(!t || !a.VISITOR_KEYS[t.type])
        }
        ;
        var a = i("uXiX")
    },
    LIY4: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function inherits(t, r) {
            if (!t || !r)
                return t;
            for (const i of a.INHERIT_KEYS.optional)
                null == t[i] && (t[i] = r[i]);
            for (const i of Object.keys(r))
                "_" === i[0] && "__clone" !== i && (t[i] = r[i]);
            for (const i of a.INHERIT_KEYS.force)
                t[i] = r[i];
            return (0,
            o.default)(t, r),
            t
        }
        ;
        var a = i("kEZX")
          , o = i("pw2U")
    },
    "LR/y": function(t, r, i) {
        "use strict";
        function _createForOfIteratorHelper(t, r) {
            var i = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
            if (!i) {
                if (Array.isArray(t) || (i = function _unsupportedIterableToArray(t, r) {
                    if (!t)
                        return;
                    if ("string" == typeof t)
                        return _arrayLikeToArray(t, r);
                    var i = Object.prototype.toString.call(t).slice(8, -1);
                    "Object" === i && t.constructor && (i = t.constructor.name);
                    if ("Map" === i || "Set" === i)
                        return Array.from(t);
                    if ("Arguments" === i || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i))
                        return _arrayLikeToArray(t, r)
                }(t)) || r && t && "number" == typeof t.length) {
                    i && (t = i);
                    var a = 0
                      , o = function F() {};
                    return {
                        s: o,
                        n: function n() {
                            return a >= t.length ? {
                                done: !0
                            } : {
                                done: !1,
                                value: t[a++]
                            }
                        },
                        e: function e(t) {
                            throw t
                        },
                        f: o
                    }
                }
                throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
            }
            var l, u = !0, p = !1;
            return {
                s: function s() {
                    i = i.call(t)
                },
                n: function n() {
                    var t = i.next();
                    return u = t.done,
                    t
                },
                e: function e(t) {
                    p = !0,
                    l = t
                },
                f: function f() {
                    try {
                        u || null == i.return || i.return()
                    } finally {
                        if (p)
                            throw l
                    }
                }
            }
        }
        function _arrayLikeToArray(t, r) {
            (null == r || r > t.length) && (r = t.length);
            for (var i = 0, a = new Array(r); i < r; i++)
                a[i] = t[i];
            return a
        }
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        Object.defineProperty(r, "NodePath", {
            enumerable: !0,
            get: function get() {
                return p.default
            }
        }),
        Object.defineProperty(r, "Scope", {
            enumerable: !0,
            get: function get() {
                return c.default
            }
        }),
        Object.defineProperty(r, "Hub", {
            enumerable: !0,
            get: function get() {
                return d.default
            }
        }),
        r.visitors = r.default = void 0;
        var a = i("xDlH")
          , o = i("E+Px");
        r.visitors = o;
        var l = i("ZtNB")
          , u = i("qMwM")
          , p = i("MBGo")
          , c = i("rZZI")
          , d = i("583I");
        function traverse(t) {
            var r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}
              , i = arguments.length > 2 ? arguments[2] : void 0
              , a = arguments.length > 3 ? arguments[3] : void 0
              , u = arguments.length > 4 ? arguments[4] : void 0;
            if (t) {
                if (!r.noScope && !i && "Program" !== t.type && "File" !== t.type)
                    throw new Error("You must pass a scope and parentPath unless traversing a Program/File. " + "Instead of that you tried to traverse a ".concat(t.type, " node without ") + "passing scope and parentPath.");
                l.VISITOR_KEYS[t.type] && (o.explode(r),
                traverse.node(t, r, i, a, u))
            }
        }
        var y = traverse;
        function hasDenylistedType(t, r) {
            t.node.type === r.type && (r.has = !0,
            t.stop())
        }
        r.default = y,
        traverse.visitors = o,
        traverse.verify = o.verify,
        traverse.explode = o.explode,
        traverse.cheap = function(t, r) {
            return l.traverseFast(t, r)
        }
        ,
        traverse.node = function(t, r, i, o, u, p) {
            var c = l.VISITOR_KEYS[t.type];
            if (c) {
                var d, y = new a.default(i,r,o,u), h = _createForOfIteratorHelper(c);
                try {
                    for (h.s(); !(d = h.n()).done; ) {
                        var m = d.value;
                        if ((!p || !p[m]) && y.visit(t, m))
                            return
                    }
                } catch (t) {
                    h.e(t)
                } finally {
                    h.f()
                }
            }
        }
        ,
        traverse.clearNode = function(t, r) {
            l.removeProperties(t, r),
            u.path.delete(t)
        }
        ,
        traverse.removeProperties = function(t, r) {
            return l.traverseFast(t, traverse.clearNode, r),
            t
        }
        ,
        traverse.hasType = function(t, r, i) {
            if (null != i && i.includes(t.type))
                return !1;
            if (t.type === r)
                return !0;
            var a = {
                has: !1,
                type: r
            };
            return traverse(t, {
                noScope: !0,
                denylist: i,
                enter: hasDenylistedType
            }, null, a),
            a.has
        }
        ,
        traverse.cache = u
    },
    LdJy: function(t, r, i) {
        "use strict";
        function _createForOfIteratorHelper(t, r) {
            var i = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
            if (!i) {
                if (Array.isArray(t) || (i = function _unsupportedIterableToArray(t, r) {
                    if (!t)
                        return;
                    if ("string" == typeof t)
                        return _arrayLikeToArray(t, r);
                    var i = Object.prototype.toString.call(t).slice(8, -1);
                    "Object" === i && t.constructor && (i = t.constructor.name);
                    if ("Map" === i || "Set" === i)
                        return Array.from(t);
                    if ("Arguments" === i || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i))
                        return _arrayLikeToArray(t, r)
                }(t)) || r && t && "number" == typeof t.length) {
                    i && (t = i);
                    var a = 0
                      , o = function F() {};
                    return {
                        s: o,
                        n: function n() {
                            return a >= t.length ? {
                                done: !0
                            } : {
                                done: !1,
                                value: t[a++]
                            }
                        },
                        e: function e(t) {
                            throw t
                        },
                        f: o
                    }
                }
                throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
            }
            var l, u = !0, p = !1;
            return {
                s: function s() {
                    i = i.call(t)
                },
                n: function n() {
                    var t = i.next();
                    return u = t.done,
                    t
                },
                e: function e(t) {
                    p = !0,
                    l = t
                },
                f: function f() {
                    try {
                        u || null == i.return || i.return()
                    } finally {
                        if (p)
                            throw l
                    }
                }
            }
        }
        function _arrayLikeToArray(t, r) {
            (null == r || r > t.length) && (r = t.length);
            for (var i = 0, a = new Array(r); i < r; i++)
                a[i] = t[i];
            return a
        }
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function gatherSequenceExpressions(t, r, i) {
            var p, c = [], d = !0, y = _createForOfIteratorHelper(t);
            try {
                for (y.s(); !(p = y.n()).done; ) {
                    var h = p.value;
                    if ((0,
                    o.isEmptyStatement)(h) || (d = !1),
                    (0,
                    o.isExpression)(h))
                        c.push(h);
                    else if ((0,
                    o.isExpressionStatement)(h))
                        c.push(h.expression);
                    else if ((0,
                    o.isVariableDeclaration)(h)) {
                        if ("var" !== h.kind)
                            return;
                        var m, T = _createForOfIteratorHelper(h.declarations);
                        try {
                            for (T.s(); !(m = T.n()).done; ) {
                                for (var S = m.value, g = (0,
                                a.default)(S), b = 0, v = Object.keys(g); b < v.length; b++) {
                                    var E = v[b];
                                    i.push({
                                        kind: h.kind,
                                        id: (0,
                                        u.default)(g[E])
                                    })
                                }
                                S.init && c.push((0,
                                l.assignmentExpression)("=", S.id, S.init))
                            }
                        } catch (t) {
                            T.e(t)
                        } finally {
                            T.f()
                        }
                        d = !0
                    } else if ((0,
                    o.isIfStatement)(h)) {
                        var P = h.consequent ? gatherSequenceExpressions([h.consequent], r, i) : r.buildUndefinedNode()
                          , x = h.alternate ? gatherSequenceExpressions([h.alternate], r, i) : r.buildUndefinedNode();
                        if (!P || !x)
                            return;
                        c.push((0,
                        l.conditionalExpression)(h.test, P, x))
                    } else if ((0,
                    o.isBlockStatement)(h)) {
                        var A = gatherSequenceExpressions(h.body, r, i);
                        if (!A)
                            return;
                        c.push(A)
                    } else {
                        if (!(0,
                        o.isEmptyStatement)(h))
                            return;
                        0 === t.indexOf(h) && (d = !0)
                    }
                }
            } catch (t) {
                y.e(t)
            } finally {
                y.f()
            }
            d && c.push(r.buildUndefinedNode());
            return 1 === c.length ? c[0] : (0,
            l.sequenceExpression)(c)
        }
        ;
        var a = i("V20z")
          , o = i("pbIU")
          , l = i("UuI8")
          , u = i("aHlp")
    },
    LluO: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function stringTemplate(t, r, i) {
            let u;
            return r = t.code(r),
            p=>{
                const c = (0,
                a.normalizeReplacements)(p);
                return u || (u = (0,
                o.default)(t, r, i)),
                t.unwrap((0,
                l.default)(u, c))
            }
        }
        ;
        var a = i("+zpO")
          , o = i("kSM9")
          , l = i("wOpn")
    },
    Lo2p: function(t, r, i) {
        "use strict";
        function _createForOfIteratorHelper(t, r) {
            var i = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
            if (!i) {
                if (Array.isArray(t) || (i = function _unsupportedIterableToArray(t, r) {
                    if (!t)
                        return;
                    if ("string" == typeof t)
                        return _arrayLikeToArray(t, r);
                    var i = Object.prototype.toString.call(t).slice(8, -1);
                    "Object" === i && t.constructor && (i = t.constructor.name);
                    if ("Map" === i || "Set" === i)
                        return Array.from(t);
                    if ("Arguments" === i || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i))
                        return _arrayLikeToArray(t, r)
                }(t)) || r && t && "number" == typeof t.length) {
                    i && (t = i);
                    var a = 0
                      , o = function F() {};
                    return {
                        s: o,
                        n: function n() {
                            return a >= t.length ? {
                                done: !0
                            } : {
                                done: !1,
                                value: t[a++]
                            }
                        },
                        e: function e(t) {
                            throw t
                        },
                        f: o
                    }
                }
                throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
            }
            var l, u = !0, p = !1;
            return {
                s: function s() {
                    i = i.call(t)
                },
                n: function n() {
                    var t = i.next();
                    return u = t.done,
                    t
                },
                e: function e(t) {
                    p = !0,
                    l = t
                },
                f: function f() {
                    try {
                        u || null == i.return || i.return()
                    } finally {
                        if (p)
                            throw l
                    }
                }
            }
        }
        function _arrayLikeToArray(t, r) {
            (null == r || r > t.length) && (r = t.length);
            for (var i = 0, a = new Array(r); i < r; i++)
                a[i] = t[i];
            return a
        }
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.matchesPattern = function matchesPattern(t, r) {
            return a.matchesPattern(this.node, t, r)
        }
        ,
        r.has = has,
        r.isStatic = function isStatic() {
            return this.scope.isStatic(this.node)
        }
        ,
        r.isnt = function isnt(t) {
            return !this.has(t)
        }
        ,
        r.equals = function equals(t, r) {
            return this.node[t] === r
        }
        ,
        r.isNodeType = function isNodeType(t) {
            return a.isType(this.type, t)
        }
        ,
        r.canHaveVariableDeclarationOrExpression = function canHaveVariableDeclarationOrExpression() {
            return ("init" === this.key || "left" === this.key) && this.parentPath.isFor()
        }
        ,
        r.canSwapBetweenExpressionAndStatement = function canSwapBetweenExpressionAndStatement(t) {
            if ("body" !== this.key || !this.parentPath.isArrowFunctionExpression())
                return !1;
            if (this.isExpression())
                return a.isBlockStatement(t);
            if (this.isBlockStatement())
                return a.isExpression(t);
            return !1
        }
        ,
        r.isCompletionRecord = function isCompletionRecord(t) {
            var r = this
              , i = !0;
            do {
                var a = r.container;
                if (r.isFunction() && !i)
                    return !!t;
                if (i = !1,
                Array.isArray(a) && r.key !== a.length - 1)
                    return !1
            } while ((r = r.parentPath) && !r.isProgram());
            return !0
        }
        ,
        r.isStatementOrBlock = function isStatementOrBlock() {
            return !this.parentPath.isLabeledStatement() && !a.isBlockStatement(this.container) && a.STATEMENT_OR_BLOCK_KEYS.includes(this.key)
        }
        ,
        r.referencesImport = function referencesImport(t, r) {
            if (!this.isReferencedIdentifier()) {
                if ((this.isMemberExpression() || this.isOptionalMemberExpression()) && (this.node.computed ? a.isStringLiteral(this.node.property, {
                    value: r
                }) : this.node.property.name === r)) {
                    var i = this.get("object");
                    return i.isReferencedIdentifier() && i.referencesImport(t, "*")
                }
                return !1
            }
            var o = this.scope.getBinding(this.node.name);
            if (!o || "module" !== o.kind)
                return !1;
            var l = o.path
              , u = l.parentPath;
            if (!u.isImportDeclaration())
                return !1;
            if (u.node.source.value !== t)
                return !1;
            if (!r)
                return !0;
            if (l.isImportDefaultSpecifier() && "default" === r)
                return !0;
            if (l.isImportNamespaceSpecifier() && "*" === r)
                return !0;
            if (l.isImportSpecifier() && a.isIdentifier(l.node.imported, {
                name: r
            }))
                return !0;
            return !1
        }
        ,
        r.getSource = function getSource() {
            var t = this.node;
            if (t.end) {
                var r = this.hub.getCode();
                if (r)
                    return r.slice(t.start, t.end)
            }
            return ""
        }
        ,
        r.willIMaybeExecuteBefore = function willIMaybeExecuteBefore(t) {
            return "after" !== this._guessExecutionStatusRelativeTo(t)
        }
        ,
        r._guessExecutionStatusRelativeTo = function _guessExecutionStatusRelativeTo(t) {
            var r = {
                this: getOuterFunction(this),
                target: getOuterFunction(t)
            };
            if (r.target.node !== r.this.node)
                return this._guessExecutionStatusRelativeToDifferentFunctions(r.target);
            var i, o = {
                target: t.getAncestry(),
                this: this.getAncestry()
            };
            if (o.target.indexOf(this) >= 0)
                return "after";
            if (o.this.indexOf(t) >= 0)
                return "before";
            var l = {
                target: 0,
                this: 0
            };
            for (; !i && l.this < o.this.length; ) {
                var u = o.this[l.this];
                l.target = o.target.indexOf(u),
                l.target >= 0 ? i = u : l.this++
            }
            if (!i)
                throw new Error("Internal Babel error - The two compared nodes don't appear to belong to the same program.");
            if (isExecutionUncertainInList(o.this, l.this - 1) || isExecutionUncertainInList(o.target, l.target - 1))
                return "unknown";
            var p = {
                this: o.this[l.this - 1],
                target: o.target[l.target - 1]
            };
            if (p.target.listKey && p.this.listKey && p.target.container === p.this.container)
                return p.target.key > p.this.key ? "before" : "after";
            var c = a.VISITOR_KEYS[i.type]
              , d = {
                this: c.indexOf(p.this.parentKey),
                target: c.indexOf(p.target.parentKey)
            };
            return d.target > d.this ? "before" : "after"
        }
        ,
        r._guessExecutionStatusRelativeToDifferentFunctions = function _guessExecutionStatusRelativeToDifferentFunctions(t) {
            if (!t.isFunctionDeclaration() || t.parentPath.isExportDeclaration())
                return "unknown";
            var r = t.scope.getBinding(t.node.id.name);
            if (!r.references)
                return "before";
            var i, a, o = _createForOfIteratorHelper(r.referencePaths);
            try {
                for (o.s(); !(a = o.n()).done; ) {
                    var u = a.value;
                    if (!!!u.find((function(r) {
                        return r.node === t.node
                    }
                    ))) {
                        if ("callee" !== u.key || !u.parentPath.isCallExpression())
                            return "unknown";
                        if (!l.has(u.node)) {
                            l.add(u.node);
                            var p = this._guessExecutionStatusRelativeTo(u);
                            if (l.delete(u.node),
                            i && i !== p)
                                return "unknown";
                            i = p
                        }
                    }
                }
            } catch (t) {
                o.e(t)
            } finally {
                o.f()
            }
            return i
        }
        ,
        r.resolve = function resolve(t, r) {
            return this._resolve(t, r) || this
        }
        ,
        r._resolve = function _resolve(t, r) {
            if (r && r.indexOf(this) >= 0)
                return;
            if ((r = r || []).push(this),
            this.isVariableDeclarator()) {
                if (this.get("id").isIdentifier())
                    return this.get("init").resolve(t, r)
            } else if (this.isReferencedIdentifier()) {
                var i = this.scope.getBinding(this.node.name);
                if (!i)
                    return;
                if (!i.constant)
                    return;
                if ("module" === i.kind)
                    return;
                if (i.path !== this) {
                    var o = i.path.resolve(t, r);
                    if (this.find((function(t) {
                        return t.node === o.node
                    }
                    )))
                        return;
                    return o
                }
            } else {
                if (this.isTypeCastExpression())
                    return this.get("expression").resolve(t, r);
                if (t && this.isMemberExpression()) {
                    var l = this.toComputedKey();
                    if (!a.isLiteral(l))
                        return;
                    var u = l.value
                      , p = this.get("object").resolve(t, r);
                    if (p.isObjectExpression()) {
                        var c, d = _createForOfIteratorHelper(p.get("properties"));
                        try {
                            for (d.s(); !(c = d.n()).done; ) {
                                var y = c.value;
                                if (y.isProperty()) {
                                    var h = y.get("key")
                                      , m = y.isnt("computed") && h.isIdentifier({
                                        name: u
                                    });
                                    if (m = m || h.isLiteral({
                                        value: u
                                    }))
                                        return y.get("value").resolve(t, r)
                                }
                            }
                        } catch (t) {
                            d.e(t)
                        } finally {
                            d.f()
                        }
                    } else if (p.isArrayExpression() && !isNaN(+u)) {
                        var T = p.get("elements")[u];
                        if (T)
                            return T.resolve(t, r)
                    }
                }
            }
        }
        ,
        r.isConstantExpression = function isConstantExpression() {
            if (this.isIdentifier()) {
                var t = this.scope.getBinding(this.node.name);
                return !!t && t.constant
            }
            if (this.isLiteral())
                return !this.isRegExpLiteral() && (!this.isTemplateLiteral() || this.get("expressions").every((function(t) {
                    return t.isConstantExpression()
                }
                )));
            if (this.isUnaryExpression())
                return "void" === this.node.operator && this.get("argument").isConstantExpression();
            if (this.isBinaryExpression())
                return this.get("left").isConstantExpression() && this.get("right").isConstantExpression();
            return !1
        }
        ,
        r.isInStrictMode = function isInStrictMode() {
            return !!(this.isProgram() ? this : this.parentPath).find((function(t) {
                if (t.isProgram({
                    sourceType: "module"
                }))
                    return !0;
                if (t.isClass())
                    return !0;
                if (!t.isProgram() && !t.isFunction())
                    return !1;
                if (t.isArrowFunctionExpression() && !t.get("body").isBlockStatement())
                    return !1;
                var r, i = _createForOfIteratorHelper((t.isFunction() ? t.node.body : t.node).directives);
                try {
                    for (i.s(); !(r = i.n()).done; ) {
                        if ("use strict" === r.value.value.value)
                            return !0
                    }
                } catch (t) {
                    i.e(t)
                } finally {
                    i.f()
                }
            }
            ))
        }
        ,
        r.is = void 0;
        var a = i("ZtNB");
        function has(t) {
            var r = this.node && this.node[t];
            return r && Array.isArray(r) ? !!r.length : !!r
        }
        var o = has;
        function getOuterFunction(t) {
            return (t.scope.getFunctionParent() || t.scope.getProgramParent()).path
        }
        function isExecutionUncertain(t, r) {
            switch (t) {
            case "LogicalExpression":
                return "right" === r;
            case "ConditionalExpression":
            case "IfStatement":
                return "consequent" === r || "alternate" === r;
            case "WhileStatement":
            case "DoWhileStatement":
            case "ForInStatement":
            case "ForOfStatement":
                return "body" === r;
            case "ForStatement":
                return "body" === r || "update" === r;
            case "SwitchStatement":
                return "cases" === r;
            case "TryStatement":
                return "handler" === r;
            case "AssignmentPattern":
                return "right" === r;
            case "OptionalMemberExpression":
                return "property" === r;
            case "OptionalCallExpression":
                return "arguments" === r;
            default:
                return !1
            }
        }
        function isExecutionUncertainInList(t, r) {
            for (var i = 0; i < r; i++) {
                var a = t[i];
                if (isExecutionUncertain(a.parent.type, a.parentKey))
                    return !0
            }
            return !1
        }
        r.is = o;
        var l = new WeakSet
    },
    LrfX: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function createTSUnionType(t) {
            var r = t.map((function(t) {
                return t.typeAnnotation
            }
            ))
              , i = (0,
            o.default)(r);
            return 1 === i.length ? i[0] : (0,
            a.tsUnionType)(i)
        }
        ;
        var a = i("57mi")
          , o = i("aeMg")
    },
    LtBJ: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        Object.defineProperty(r, "ArrayExpression", {
            enumerable: !0,
            get: function get() {
                return a.arrayExpression
            }
        }),
        Object.defineProperty(r, "AssignmentExpression", {
            enumerable: !0,
            get: function get() {
                return a.assignmentExpression
            }
        }),
        Object.defineProperty(r, "BinaryExpression", {
            enumerable: !0,
            get: function get() {
                return a.binaryExpression
            }
        }),
        Object.defineProperty(r, "InterpreterDirective", {
            enumerable: !0,
            get: function get() {
                return a.interpreterDirective
            }
        }),
        Object.defineProperty(r, "Directive", {
            enumerable: !0,
            get: function get() {
                return a.directive
            }
        }),
        Object.defineProperty(r, "DirectiveLiteral", {
            enumerable: !0,
            get: function get() {
                return a.directiveLiteral
            }
        }),
        Object.defineProperty(r, "BlockStatement", {
            enumerable: !0,
            get: function get() {
                return a.blockStatement
            }
        }),
        Object.defineProperty(r, "BreakStatement", {
            enumerable: !0,
            get: function get() {
                return a.breakStatement
            }
        }),
        Object.defineProperty(r, "CallExpression", {
            enumerable: !0,
            get: function get() {
                return a.callExpression
            }
        }),
        Object.defineProperty(r, "CatchClause", {
            enumerable: !0,
            get: function get() {
                return a.catchClause
            }
        }),
        Object.defineProperty(r, "ConditionalExpression", {
            enumerable: !0,
            get: function get() {
                return a.conditionalExpression
            }
        }),
        Object.defineProperty(r, "ContinueStatement", {
            enumerable: !0,
            get: function get() {
                return a.continueStatement
            }
        }),
        Object.defineProperty(r, "DebuggerStatement", {
            enumerable: !0,
            get: function get() {
                return a.debuggerStatement
            }
        }),
        Object.defineProperty(r, "DoWhileStatement", {
            enumerable: !0,
            get: function get() {
                return a.doWhileStatement
            }
        }),
        Object.defineProperty(r, "EmptyStatement", {
            enumerable: !0,
            get: function get() {
                return a.emptyStatement
            }
        }),
        Object.defineProperty(r, "ExpressionStatement", {
            enumerable: !0,
            get: function get() {
                return a.expressionStatement
            }
        }),
        Object.defineProperty(r, "File", {
            enumerable: !0,
            get: function get() {
                return a.file
            }
        }),
        Object.defineProperty(r, "ForInStatement", {
            enumerable: !0,
            get: function get() {
                return a.forInStatement
            }
        }),
        Object.defineProperty(r, "ForStatement", {
            enumerable: !0,
            get: function get() {
                return a.forStatement
            }
        }),
        Object.defineProperty(r, "FunctionDeclaration", {
            enumerable: !0,
            get: function get() {
                return a.functionDeclaration
            }
        }),
        Object.defineProperty(r, "FunctionExpression", {
            enumerable: !0,
            get: function get() {
                return a.functionExpression
            }
        }),
        Object.defineProperty(r, "Identifier", {
            enumerable: !0,
            get: function get() {
                return a.identifier
            }
        }),
        Object.defineProperty(r, "IfStatement", {
            enumerable: !0,
            get: function get() {
                return a.ifStatement
            }
        }),
        Object.defineProperty(r, "LabeledStatement", {
            enumerable: !0,
            get: function get() {
                return a.labeledStatement
            }
        }),
        Object.defineProperty(r, "StringLiteral", {
            enumerable: !0,
            get: function get() {
                return a.stringLiteral
            }
        }),
        Object.defineProperty(r, "NumericLiteral", {
            enumerable: !0,
            get: function get() {
                return a.numericLiteral
            }
        }),
        Object.defineProperty(r, "NullLiteral", {
            enumerable: !0,
            get: function get() {
                return a.nullLiteral
            }
        }),
        Object.defineProperty(r, "BooleanLiteral", {
            enumerable: !0,
            get: function get() {
                return a.booleanLiteral
            }
        }),
        Object.defineProperty(r, "RegExpLiteral", {
            enumerable: !0,
            get: function get() {
                return a.regExpLiteral
            }
        }),
        Object.defineProperty(r, "LogicalExpression", {
            enumerable: !0,
            get: function get() {
                return a.logicalExpression
            }
        }),
        Object.defineProperty(r, "MemberExpression", {
            enumerable: !0,
            get: function get() {
                return a.memberExpression
            }
        }),
        Object.defineProperty(r, "NewExpression", {
            enumerable: !0,
            get: function get() {
                return a.newExpression
            }
        }),
        Object.defineProperty(r, "Program", {
            enumerable: !0,
            get: function get() {
                return a.program
            }
        }),
        Object.defineProperty(r, "ObjectExpression", {
            enumerable: !0,
            get: function get() {
                return a.objectExpression
            }
        }),
        Object.defineProperty(r, "ObjectMethod", {
            enumerable: !0,
            get: function get() {
                return a.objectMethod
            }
        }),
        Object.defineProperty(r, "ObjectProperty", {
            enumerable: !0,
            get: function get() {
                return a.objectProperty
            }
        }),
        Object.defineProperty(r, "RestElement", {
            enumerable: !0,
            get: function get() {
                return a.restElement
            }
        }),
        Object.defineProperty(r, "ReturnStatement", {
            enumerable: !0,
            get: function get() {
                return a.returnStatement
            }
        }),
        Object.defineProperty(r, "SequenceExpression", {
            enumerable: !0,
            get: function get() {
                return a.sequenceExpression
            }
        }),
        Object.defineProperty(r, "ParenthesizedExpression", {
            enumerable: !0,
            get: function get() {
                return a.parenthesizedExpression
            }
        }),
        Object.defineProperty(r, "SwitchCase", {
            enumerable: !0,
            get: function get() {
                return a.switchCase
            }
        }),
        Object.defineProperty(r, "SwitchStatement", {
            enumerable: !0,
            get: function get() {
                return a.switchStatement
            }
        }),
        Object.defineProperty(r, "ThisExpression", {
            enumerable: !0,
            get: function get() {
                return a.thisExpression
            }
        }),
        Object.defineProperty(r, "ThrowStatement", {
            enumerable: !0,
            get: function get() {
                return a.throwStatement
            }
        }),
        Object.defineProperty(r, "TryStatement", {
            enumerable: !0,
            get: function get() {
                return a.tryStatement
            }
        }),
        Object.defineProperty(r, "UnaryExpression", {
            enumerable: !0,
            get: function get() {
                return a.unaryExpression
            }
        }),
        Object.defineProperty(r, "UpdateExpression", {
            enumerable: !0,
            get: function get() {
                return a.updateExpression
            }
        }),
        Object.defineProperty(r, "VariableDeclaration", {
            enumerable: !0,
            get: function get() {
                return a.variableDeclaration
            }
        }),
        Object.defineProperty(r, "VariableDeclarator", {
            enumerable: !0,
            get: function get() {
                return a.variableDeclarator
            }
        }),
        Object.defineProperty(r, "WhileStatement", {
            enumerable: !0,
            get: function get() {
                return a.whileStatement
            }
        }),
        Object.defineProperty(r, "WithStatement", {
            enumerable: !0,
            get: function get() {
                return a.withStatement
            }
        }),
        Object.defineProperty(r, "AssignmentPattern", {
            enumerable: !0,
            get: function get() {
                return a.assignmentPattern
            }
        }),
        Object.defineProperty(r, "ArrayPattern", {
            enumerable: !0,
            get: function get() {
                return a.arrayPattern
            }
        }),
        Object.defineProperty(r, "ArrowFunctionExpression", {
            enumerable: !0,
            get: function get() {
                return a.arrowFunctionExpression
            }
        }),
        Object.defineProperty(r, "ClassBody", {
            enumerable: !0,
            get: function get() {
                return a.classBody
            }
        }),
        Object.defineProperty(r, "ClassExpression", {
            enumerable: !0,
            get: function get() {
                return a.classExpression
            }
        }),
        Object.defineProperty(r, "ClassDeclaration", {
            enumerable: !0,
            get: function get() {
                return a.classDeclaration
            }
        }),
        Object.defineProperty(r, "ExportAllDeclaration", {
            enumerable: !0,
            get: function get() {
                return a.exportAllDeclaration
            }
        }),
        Object.defineProperty(r, "ExportDefaultDeclaration", {
            enumerable: !0,
            get: function get() {
                return a.exportDefaultDeclaration
            }
        }),
        Object.defineProperty(r, "ExportNamedDeclaration", {
            enumerable: !0,
            get: function get() {
                return a.exportNamedDeclaration
            }
        }),
        Object.defineProperty(r, "ExportSpecifier", {
            enumerable: !0,
            get: function get() {
                return a.exportSpecifier
            }
        }),
        Object.defineProperty(r, "ForOfStatement", {
            enumerable: !0,
            get: function get() {
                return a.forOfStatement
            }
        }),
        Object.defineProperty(r, "ImportDeclaration", {
            enumerable: !0,
            get: function get() {
                return a.importDeclaration
            }
        }),
        Object.defineProperty(r, "ImportDefaultSpecifier", {
            enumerable: !0,
            get: function get() {
                return a.importDefaultSpecifier
            }
        }),
        Object.defineProperty(r, "ImportNamespaceSpecifier", {
            enumerable: !0,
            get: function get() {
                return a.importNamespaceSpecifier
            }
        }),
        Object.defineProperty(r, "ImportSpecifier", {
            enumerable: !0,
            get: function get() {
                return a.importSpecifier
            }
        }),
        Object.defineProperty(r, "MetaProperty", {
            enumerable: !0,
            get: function get() {
                return a.metaProperty
            }
        }),
        Object.defineProperty(r, "ClassMethod", {
            enumerable: !0,
            get: function get() {
                return a.classMethod
            }
        }),
        Object.defineProperty(r, "ObjectPattern", {
            enumerable: !0,
            get: function get() {
                return a.objectPattern
            }
        }),
        Object.defineProperty(r, "SpreadElement", {
            enumerable: !0,
            get: function get() {
                return a.spreadElement
            }
        }),
        Object.defineProperty(r, "Super", {
            enumerable: !0,
            get: function get() {
                return a.super
            }
        }),
        Object.defineProperty(r, "TaggedTemplateExpression", {
            enumerable: !0,
            get: function get() {
                return a.taggedTemplateExpression
            }
        }),
        Object.defineProperty(r, "TemplateElement", {
            enumerable: !0,
            get: function get() {
                return a.templateElement
            }
        }),
        Object.defineProperty(r, "TemplateLiteral", {
            enumerable: !0,
            get: function get() {
                return a.templateLiteral
            }
        }),
        Object.defineProperty(r, "YieldExpression", {
            enumerable: !0,
            get: function get() {
                return a.yieldExpression
            }
        }),
        Object.defineProperty(r, "AwaitExpression", {
            enumerable: !0,
            get: function get() {
                return a.awaitExpression
            }
        }),
        Object.defineProperty(r, "Import", {
            enumerable: !0,
            get: function get() {
                return a.import
            }
        }),
        Object.defineProperty(r, "BigIntLiteral", {
            enumerable: !0,
            get: function get() {
                return a.bigIntLiteral
            }
        }),
        Object.defineProperty(r, "ExportNamespaceSpecifier", {
            enumerable: !0,
            get: function get() {
                return a.exportNamespaceSpecifier
            }
        }),
        Object.defineProperty(r, "OptionalMemberExpression", {
            enumerable: !0,
            get: function get() {
                return a.optionalMemberExpression
            }
        }),
        Object.defineProperty(r, "OptionalCallExpression", {
            enumerable: !0,
            get: function get() {
                return a.optionalCallExpression
            }
        }),
        Object.defineProperty(r, "ClassProperty", {
            enumerable: !0,
            get: function get() {
                return a.classProperty
            }
        }),
        Object.defineProperty(r, "ClassPrivateProperty", {
            enumerable: !0,
            get: function get() {
                return a.classPrivateProperty
            }
        }),
        Object.defineProperty(r, "ClassPrivateMethod", {
            enumerable: !0,
            get: function get() {
                return a.classPrivateMethod
            }
        }),
        Object.defineProperty(r, "PrivateName", {
            enumerable: !0,
            get: function get() {
                return a.privateName
            }
        }),
        Object.defineProperty(r, "AnyTypeAnnotation", {
            enumerable: !0,
            get: function get() {
                return a.anyTypeAnnotation
            }
        }),
        Object.defineProperty(r, "ArrayTypeAnnotation", {
            enumerable: !0,
            get: function get() {
                return a.arrayTypeAnnotation
            }
        }),
        Object.defineProperty(r, "BooleanTypeAnnotation", {
            enumerable: !0,
            get: function get() {
                return a.booleanTypeAnnotation
            }
        }),
        Object.defineProperty(r, "BooleanLiteralTypeAnnotation", {
            enumerable: !0,
            get: function get() {
                return a.booleanLiteralTypeAnnotation
            }
        }),
        Object.defineProperty(r, "NullLiteralTypeAnnotation", {
            enumerable: !0,
            get: function get() {
                return a.nullLiteralTypeAnnotation
            }
        }),
        Object.defineProperty(r, "ClassImplements", {
            enumerable: !0,
            get: function get() {
                return a.classImplements
            }
        }),
        Object.defineProperty(r, "DeclareClass", {
            enumerable: !0,
            get: function get() {
                return a.declareClass
            }
        }),
        Object.defineProperty(r, "DeclareFunction", {
            enumerable: !0,
            get: function get() {
                return a.declareFunction
            }
        }),
        Object.defineProperty(r, "DeclareInterface", {
            enumerable: !0,
            get: function get() {
                return a.declareInterface
            }
        }),
        Object.defineProperty(r, "DeclareModule", {
            enumerable: !0,
            get: function get() {
                return a.declareModule
            }
        }),
        Object.defineProperty(r, "DeclareModuleExports", {
            enumerable: !0,
            get: function get() {
                return a.declareModuleExports
            }
        }),
        Object.defineProperty(r, "DeclareTypeAlias", {
            enumerable: !0,
            get: function get() {
                return a.declareTypeAlias
            }
        }),
        Object.defineProperty(r, "DeclareOpaqueType", {
            enumerable: !0,
            get: function get() {
                return a.declareOpaqueType
            }
        }),
        Object.defineProperty(r, "DeclareVariable", {
            enumerable: !0,
            get: function get() {
                return a.declareVariable
            }
        }),
        Object.defineProperty(r, "DeclareExportDeclaration", {
            enumerable: !0,
            get: function get() {
                return a.declareExportDeclaration
            }
        }),
        Object.defineProperty(r, "DeclareExportAllDeclaration", {
            enumerable: !0,
            get: function get() {
                return a.declareExportAllDeclaration
            }
        }),
        Object.defineProperty(r, "DeclaredPredicate", {
            enumerable: !0,
            get: function get() {
                return a.declaredPredicate
            }
        }),
        Object.defineProperty(r, "ExistsTypeAnnotation", {
            enumerable: !0,
            get: function get() {
                return a.existsTypeAnnotation
            }
        }),
        Object.defineProperty(r, "FunctionTypeAnnotation", {
            enumerable: !0,
            get: function get() {
                return a.functionTypeAnnotation
            }
        }),
        Object.defineProperty(r, "FunctionTypeParam", {
            enumerable: !0,
            get: function get() {
                return a.functionTypeParam
            }
        }),
        Object.defineProperty(r, "GenericTypeAnnotation", {
            enumerable: !0,
            get: function get() {
                return a.genericTypeAnnotation
            }
        }),
        Object.defineProperty(r, "InferredPredicate", {
            enumerable: !0,
            get: function get() {
                return a.inferredPredicate
            }
        }),
        Object.defineProperty(r, "InterfaceExtends", {
            enumerable: !0,
            get: function get() {
                return a.interfaceExtends
            }
        }),
        Object.defineProperty(r, "InterfaceDeclaration", {
            enumerable: !0,
            get: function get() {
                return a.interfaceDeclaration
            }
        }),
        Object.defineProperty(r, "InterfaceTypeAnnotation", {
            enumerable: !0,
            get: function get() {
                return a.interfaceTypeAnnotation
            }
        }),
        Object.defineProperty(r, "IntersectionTypeAnnotation", {
            enumerable: !0,
            get: function get() {
                return a.intersectionTypeAnnotation
            }
        }),
        Object.defineProperty(r, "MixedTypeAnnotation", {
            enumerable: !0,
            get: function get() {
                return a.mixedTypeAnnotation
            }
        }),
        Object.defineProperty(r, "EmptyTypeAnnotation", {
            enumerable: !0,
            get: function get() {
                return a.emptyTypeAnnotation
            }
        }),
        Object.defineProperty(r, "NullableTypeAnnotation", {
            enumerable: !0,
            get: function get() {
                return a.nullableTypeAnnotation
            }
        }),
        Object.defineProperty(r, "NumberLiteralTypeAnnotation", {
            enumerable: !0,
            get: function get() {
                return a.numberLiteralTypeAnnotation
            }
        }),
        Object.defineProperty(r, "NumberTypeAnnotation", {
            enumerable: !0,
            get: function get() {
                return a.numberTypeAnnotation
            }
        }),
        Object.defineProperty(r, "ObjectTypeAnnotation", {
            enumerable: !0,
            get: function get() {
                return a.objectTypeAnnotation
            }
        }),
        Object.defineProperty(r, "ObjectTypeInternalSlot", {
            enumerable: !0,
            get: function get() {
                return a.objectTypeInternalSlot
            }
        }),
        Object.defineProperty(r, "ObjectTypeCallProperty", {
            enumerable: !0,
            get: function get() {
                return a.objectTypeCallProperty
            }
        }),
        Object.defineProperty(r, "ObjectTypeIndexer", {
            enumerable: !0,
            get: function get() {
                return a.objectTypeIndexer
            }
        }),
        Object.defineProperty(r, "ObjectTypeProperty", {
            enumerable: !0,
            get: function get() {
                return a.objectTypeProperty
            }
        }),
        Object.defineProperty(r, "ObjectTypeSpreadProperty", {
            enumerable: !0,
            get: function get() {
                return a.objectTypeSpreadProperty
            }
        }),
        Object.defineProperty(r, "OpaqueType", {
            enumerable: !0,
            get: function get() {
                return a.opaqueType
            }
        }),
        Object.defineProperty(r, "QualifiedTypeIdentifier", {
            enumerable: !0,
            get: function get() {
                return a.qualifiedTypeIdentifier
            }
        }),
        Object.defineProperty(r, "StringLiteralTypeAnnotation", {
            enumerable: !0,
            get: function get() {
                return a.stringLiteralTypeAnnotation
            }
        }),
        Object.defineProperty(r, "StringTypeAnnotation", {
            enumerable: !0,
            get: function get() {
                return a.stringTypeAnnotation
            }
        }),
        Object.defineProperty(r, "SymbolTypeAnnotation", {
            enumerable: !0,
            get: function get() {
                return a.symbolTypeAnnotation
            }
        }),
        Object.defineProperty(r, "ThisTypeAnnotation", {
            enumerable: !0,
            get: function get() {
                return a.thisTypeAnnotation
            }
        }),
        Object.defineProperty(r, "TupleTypeAnnotation", {
            enumerable: !0,
            get: function get() {
                return a.tupleTypeAnnotation
            }
        }),
        Object.defineProperty(r, "TypeofTypeAnnotation", {
            enumerable: !0,
            get: function get() {
                return a.typeofTypeAnnotation
            }
        }),
        Object.defineProperty(r, "TypeAlias", {
            enumerable: !0,
            get: function get() {
                return a.typeAlias
            }
        }),
        Object.defineProperty(r, "TypeAnnotation", {
            enumerable: !0,
            get: function get() {
                return a.typeAnnotation
            }
        }),
        Object.defineProperty(r, "TypeCastExpression", {
            enumerable: !0,
            get: function get() {
                return a.typeCastExpression
            }
        }),
        Object.defineProperty(r, "TypeParameter", {
            enumerable: !0,
            get: function get() {
                return a.typeParameter
            }
        }),
        Object.defineProperty(r, "TypeParameterDeclaration", {
            enumerable: !0,
            get: function get() {
                return a.typeParameterDeclaration
            }
        }),
        Object.defineProperty(r, "TypeParameterInstantiation", {
            enumerable: !0,
            get: function get() {
                return a.typeParameterInstantiation
            }
        }),
        Object.defineProperty(r, "UnionTypeAnnotation", {
            enumerable: !0,
            get: function get() {
                return a.unionTypeAnnotation
            }
        }),
        Object.defineProperty(r, "Variance", {
            enumerable: !0,
            get: function get() {
                return a.variance
            }
        }),
        Object.defineProperty(r, "VoidTypeAnnotation", {
            enumerable: !0,
            get: function get() {
                return a.voidTypeAnnotation
            }
        }),
        Object.defineProperty(r, "EnumDeclaration", {
            enumerable: !0,
            get: function get() {
                return a.enumDeclaration
            }
        }),
        Object.defineProperty(r, "EnumBooleanBody", {
            enumerable: !0,
            get: function get() {
                return a.enumBooleanBody
            }
        }),
        Object.defineProperty(r, "EnumNumberBody", {
            enumerable: !0,
            get: function get() {
                return a.enumNumberBody
            }
        }),
        Object.defineProperty(r, "EnumStringBody", {
            enumerable: !0,
            get: function get() {
                return a.enumStringBody
            }
        }),
        Object.defineProperty(r, "EnumSymbolBody", {
            enumerable: !0,
            get: function get() {
                return a.enumSymbolBody
            }
        }),
        Object.defineProperty(r, "EnumBooleanMember", {
            enumerable: !0,
            get: function get() {
                return a.enumBooleanMember
            }
        }),
        Object.defineProperty(r, "EnumNumberMember", {
            enumerable: !0,
            get: function get() {
                return a.enumNumberMember
            }
        }),
        Object.defineProperty(r, "EnumStringMember", {
            enumerable: !0,
            get: function get() {
                return a.enumStringMember
            }
        }),
        Object.defineProperty(r, "EnumDefaultedMember", {
            enumerable: !0,
            get: function get() {
                return a.enumDefaultedMember
            }
        }),
        Object.defineProperty(r, "IndexedAccessType", {
            enumerable: !0,
            get: function get() {
                return a.indexedAccessType
            }
        }),
        Object.defineProperty(r, "OptionalIndexedAccessType", {
            enumerable: !0,
            get: function get() {
                return a.optionalIndexedAccessType
            }
        }),
        Object.defineProperty(r, "JSXAttribute", {
            enumerable: !0,
            get: function get() {
                return a.jsxAttribute
            }
        }),
        Object.defineProperty(r, "JSXClosingElement", {
            enumerable: !0,
            get: function get() {
                return a.jsxClosingElement
            }
        }),
        Object.defineProperty(r, "JSXElement", {
            enumerable: !0,
            get: function get() {
                return a.jsxElement
            }
        }),
        Object.defineProperty(r, "JSXEmptyExpression", {
            enumerable: !0,
            get: function get() {
                return a.jsxEmptyExpression
            }
        }),
        Object.defineProperty(r, "JSXExpressionContainer", {
            enumerable: !0,
            get: function get() {
                return a.jsxExpressionContainer
            }
        }),
        Object.defineProperty(r, "JSXSpreadChild", {
            enumerable: !0,
            get: function get() {
                return a.jsxSpreadChild
            }
        }),
        Object.defineProperty(r, "JSXIdentifier", {
            enumerable: !0,
            get: function get() {
                return a.jsxIdentifier
            }
        }),
        Object.defineProperty(r, "JSXMemberExpression", {
            enumerable: !0,
            get: function get() {
                return a.jsxMemberExpression
            }
        }),
        Object.defineProperty(r, "JSXNamespacedName", {
            enumerable: !0,
            get: function get() {
                return a.jsxNamespacedName
            }
        }),
        Object.defineProperty(r, "JSXOpeningElement", {
            enumerable: !0,
            get: function get() {
                return a.jsxOpeningElement
            }
        }),
        Object.defineProperty(r, "JSXSpreadAttribute", {
            enumerable: !0,
            get: function get() {
                return a.jsxSpreadAttribute
            }
        }),
        Object.defineProperty(r, "JSXText", {
            enumerable: !0,
            get: function get() {
                return a.jsxText
            }
        }),
        Object.defineProperty(r, "JSXFragment", {
            enumerable: !0,
            get: function get() {
                return a.jsxFragment
            }
        }),
        Object.defineProperty(r, "JSXOpeningFragment", {
            enumerable: !0,
            get: function get() {
                return a.jsxOpeningFragment
            }
        }),
        Object.defineProperty(r, "JSXClosingFragment", {
            enumerable: !0,
            get: function get() {
                return a.jsxClosingFragment
            }
        }),
        Object.defineProperty(r, "Noop", {
            enumerable: !0,
            get: function get() {
                return a.noop
            }
        }),
        Object.defineProperty(r, "Placeholder", {
            enumerable: !0,
            get: function get() {
                return a.placeholder
            }
        }),
        Object.defineProperty(r, "V8IntrinsicIdentifier", {
            enumerable: !0,
            get: function get() {
                return a.v8IntrinsicIdentifier
            }
        }),
        Object.defineProperty(r, "ArgumentPlaceholder", {
            enumerable: !0,
            get: function get() {
                return a.argumentPlaceholder
            }
        }),
        Object.defineProperty(r, "BindExpression", {
            enumerable: !0,
            get: function get() {
                return a.bindExpression
            }
        }),
        Object.defineProperty(r, "ImportAttribute", {
            enumerable: !0,
            get: function get() {
                return a.importAttribute
            }
        }),
        Object.defineProperty(r, "Decorator", {
            enumerable: !0,
            get: function get() {
                return a.decorator
            }
        }),
        Object.defineProperty(r, "DoExpression", {
            enumerable: !0,
            get: function get() {
                return a.doExpression
            }
        }),
        Object.defineProperty(r, "ExportDefaultSpecifier", {
            enumerable: !0,
            get: function get() {
                return a.exportDefaultSpecifier
            }
        }),
        Object.defineProperty(r, "RecordExpression", {
            enumerable: !0,
            get: function get() {
                return a.recordExpression
            }
        }),
        Object.defineProperty(r, "TupleExpression", {
            enumerable: !0,
            get: function get() {
                return a.tupleExpression
            }
        }),
        Object.defineProperty(r, "DecimalLiteral", {
            enumerable: !0,
            get: function get() {
                return a.decimalLiteral
            }
        }),
        Object.defineProperty(r, "StaticBlock", {
            enumerable: !0,
            get: function get() {
                return a.staticBlock
            }
        }),
        Object.defineProperty(r, "ModuleExpression", {
            enumerable: !0,
            get: function get() {
                return a.moduleExpression
            }
        }),
        Object.defineProperty(r, "TopicReference", {
            enumerable: !0,
            get: function get() {
                return a.topicReference
            }
        }),
        Object.defineProperty(r, "PipelineTopicExpression", {
            enumerable: !0,
            get: function get() {
                return a.pipelineTopicExpression
            }
        }),
        Object.defineProperty(r, "PipelineBareFunction", {
            enumerable: !0,
            get: function get() {
                return a.pipelineBareFunction
            }
        }),
        Object.defineProperty(r, "PipelinePrimaryTopicReference", {
            enumerable: !0,
            get: function get() {
                return a.pipelinePrimaryTopicReference
            }
        }),
        Object.defineProperty(r, "TSParameterProperty", {
            enumerable: !0,
            get: function get() {
                return a.tsParameterProperty
            }
        }),
        Object.defineProperty(r, "TSDeclareFunction", {
            enumerable: !0,
            get: function get() {
                return a.tsDeclareFunction
            }
        }),
        Object.defineProperty(r, "TSDeclareMethod", {
            enumerable: !0,
            get: function get() {
                return a.tsDeclareMethod
            }
        }),
        Object.defineProperty(r, "TSQualifiedName", {
            enumerable: !0,
            get: function get() {
                return a.tsQualifiedName
            }
        }),
        Object.defineProperty(r, "TSCallSignatureDeclaration", {
            enumerable: !0,
            get: function get() {
                return a.tsCallSignatureDeclaration
            }
        }),
        Object.defineProperty(r, "TSConstructSignatureDeclaration", {
            enumerable: !0,
            get: function get() {
                return a.tsConstructSignatureDeclaration
            }
        }),
        Object.defineProperty(r, "TSPropertySignature", {
            enumerable: !0,
            get: function get() {
                return a.tsPropertySignature
            }
        }),
        Object.defineProperty(r, "TSMethodSignature", {
            enumerable: !0,
            get: function get() {
                return a.tsMethodSignature
            }
        }),
        Object.defineProperty(r, "TSIndexSignature", {
            enumerable: !0,
            get: function get() {
                return a.tsIndexSignature
            }
        }),
        Object.defineProperty(r, "TSAnyKeyword", {
            enumerable: !0,
            get: function get() {
                return a.tsAnyKeyword
            }
        }),
        Object.defineProperty(r, "TSBooleanKeyword", {
            enumerable: !0,
            get: function get() {
                return a.tsBooleanKeyword
            }
        }),
        Object.defineProperty(r, "TSBigIntKeyword", {
            enumerable: !0,
            get: function get() {
                return a.tsBigIntKeyword
            }
        }),
        Object.defineProperty(r, "TSIntrinsicKeyword", {
            enumerable: !0,
            get: function get() {
                return a.tsIntrinsicKeyword
            }
        }),
        Object.defineProperty(r, "TSNeverKeyword", {
            enumerable: !0,
            get: function get() {
                return a.tsNeverKeyword
            }
        }),
        Object.defineProperty(r, "TSNullKeyword", {
            enumerable: !0,
            get: function get() {
                return a.tsNullKeyword
            }
        }),
        Object.defineProperty(r, "TSNumberKeyword", {
            enumerable: !0,
            get: function get() {
                return a.tsNumberKeyword
            }
        }),
        Object.defineProperty(r, "TSObjectKeyword", {
            enumerable: !0,
            get: function get() {
                return a.tsObjectKeyword
            }
        }),
        Object.defineProperty(r, "TSStringKeyword", {
            enumerable: !0,
            get: function get() {
                return a.tsStringKeyword
            }
        }),
        Object.defineProperty(r, "TSSymbolKeyword", {
            enumerable: !0,
            get: function get() {
                return a.tsSymbolKeyword
            }
        }),
        Object.defineProperty(r, "TSUndefinedKeyword", {
            enumerable: !0,
            get: function get() {
                return a.tsUndefinedKeyword
            }
        }),
        Object.defineProperty(r, "TSUnknownKeyword", {
            enumerable: !0,
            get: function get() {
                return a.tsUnknownKeyword
            }
        }),
        Object.defineProperty(r, "TSVoidKeyword", {
            enumerable: !0,
            get: function get() {
                return a.tsVoidKeyword
            }
        }),
        Object.defineProperty(r, "TSThisType", {
            enumerable: !0,
            get: function get() {
                return a.tsThisType
            }
        }),
        Object.defineProperty(r, "TSFunctionType", {
            enumerable: !0,
            get: function get() {
                return a.tsFunctionType
            }
        }),
        Object.defineProperty(r, "TSConstructorType", {
            enumerable: !0,
            get: function get() {
                return a.tsConstructorType
            }
        }),
        Object.defineProperty(r, "TSTypeReference", {
            enumerable: !0,
            get: function get() {
                return a.tsTypeReference
            }
        }),
        Object.defineProperty(r, "TSTypePredicate", {
            enumerable: !0,
            get: function get() {
                return a.tsTypePredicate
            }
        }),
        Object.defineProperty(r, "TSTypeQuery", {
            enumerable: !0,
            get: function get() {
                return a.tsTypeQuery
            }
        }),
        Object.defineProperty(r, "TSTypeLiteral", {
            enumerable: !0,
            get: function get() {
                return a.tsTypeLiteral
            }
        }),
        Object.defineProperty(r, "TSArrayType", {
            enumerable: !0,
            get: function get() {
                return a.tsArrayType
            }
        }),
        Object.defineProperty(r, "TSTupleType", {
            enumerable: !0,
            get: function get() {
                return a.tsTupleType
            }
        }),
        Object.defineProperty(r, "TSOptionalType", {
            enumerable: !0,
            get: function get() {
                return a.tsOptionalType
            }
        }),
        Object.defineProperty(r, "TSRestType", {
            enumerable: !0,
            get: function get() {
                return a.tsRestType
            }
        }),
        Object.defineProperty(r, "TSNamedTupleMember", {
            enumerable: !0,
            get: function get() {
                return a.tsNamedTupleMember
            }
        }),
        Object.defineProperty(r, "TSUnionType", {
            enumerable: !0,
            get: function get() {
                return a.tsUnionType
            }
        }),
        Object.defineProperty(r, "TSIntersectionType", {
            enumerable: !0,
            get: function get() {
                return a.tsIntersectionType
            }
        }),
        Object.defineProperty(r, "TSConditionalType", {
            enumerable: !0,
            get: function get() {
                return a.tsConditionalType
            }
        }),
        Object.defineProperty(r, "TSInferType", {
            enumerable: !0,
            get: function get() {
                return a.tsInferType
            }
        }),
        Object.defineProperty(r, "TSParenthesizedType", {
            enumerable: !0,
            get: function get() {
                return a.tsParenthesizedType
            }
        }),
        Object.defineProperty(r, "TSTypeOperator", {
            enumerable: !0,
            get: function get() {
                return a.tsTypeOperator
            }
        }),
        Object.defineProperty(r, "TSIndexedAccessType", {
            enumerable: !0,
            get: function get() {
                return a.tsIndexedAccessType
            }
        }),
        Object.defineProperty(r, "TSMappedType", {
            enumerable: !0,
            get: function get() {
                return a.tsMappedType
            }
        }),
        Object.defineProperty(r, "TSLiteralType", {
            enumerable: !0,
            get: function get() {
                return a.tsLiteralType
            }
        }),
        Object.defineProperty(r, "TSExpressionWithTypeArguments", {
            enumerable: !0,
            get: function get() {
                return a.tsExpressionWithTypeArguments
            }
        }),
        Object.defineProperty(r, "TSInterfaceDeclaration", {
            enumerable: !0,
            get: function get() {
                return a.tsInterfaceDeclaration
            }
        }),
        Object.defineProperty(r, "TSInterfaceBody", {
            enumerable: !0,
            get: function get() {
                return a.tsInterfaceBody
            }
        }),
        Object.defineProperty(r, "TSTypeAliasDeclaration", {
            enumerable: !0,
            get: function get() {
                return a.tsTypeAliasDeclaration
            }
        }),
        Object.defineProperty(r, "TSAsExpression", {
            enumerable: !0,
            get: function get() {
                return a.tsAsExpression
            }
        }),
        Object.defineProperty(r, "TSTypeAssertion", {
            enumerable: !0,
            get: function get() {
                return a.tsTypeAssertion
            }
        }),
        Object.defineProperty(r, "TSEnumDeclaration", {
            enumerable: !0,
            get: function get() {
                return a.tsEnumDeclaration
            }
        }),
        Object.defineProperty(r, "TSEnumMember", {
            enumerable: !0,
            get: function get() {
                return a.tsEnumMember
            }
        }),
        Object.defineProperty(r, "TSModuleDeclaration", {
            enumerable: !0,
            get: function get() {
                return a.tsModuleDeclaration
            }
        }),
        Object.defineProperty(r, "TSModuleBlock", {
            enumerable: !0,
            get: function get() {
                return a.tsModuleBlock
            }
        }),
        Object.defineProperty(r, "TSImportType", {
            enumerable: !0,
            get: function get() {
                return a.tsImportType
            }
        }),
        Object.defineProperty(r, "TSImportEqualsDeclaration", {
            enumerable: !0,
            get: function get() {
                return a.tsImportEqualsDeclaration
            }
        }),
        Object.defineProperty(r, "TSExternalModuleReference", {
            enumerable: !0,
            get: function get() {
                return a.tsExternalModuleReference
            }
        }),
        Object.defineProperty(r, "TSNonNullExpression", {
            enumerable: !0,
            get: function get() {
                return a.tsNonNullExpression
            }
        }),
        Object.defineProperty(r, "TSExportAssignment", {
            enumerable: !0,
            get: function get() {
                return a.tsExportAssignment
            }
        }),
        Object.defineProperty(r, "TSNamespaceExportDeclaration", {
            enumerable: !0,
            get: function get() {
                return a.tsNamespaceExportDeclaration
            }
        }),
        Object.defineProperty(r, "TSTypeAnnotation", {
            enumerable: !0,
            get: function get() {
                return a.tsTypeAnnotation
            }
        }),
        Object.defineProperty(r, "TSTypeParameterInstantiation", {
            enumerable: !0,
            get: function get() {
                return a.tsTypeParameterInstantiation
            }
        }),
        Object.defineProperty(r, "TSTypeParameterDeclaration", {
            enumerable: !0,
            get: function get() {
                return a.tsTypeParameterDeclaration
            }
        }),
        Object.defineProperty(r, "TSTypeParameter", {
            enumerable: !0,
            get: function get() {
                return a.tsTypeParameter
            }
        }),
        Object.defineProperty(r, "NumberLiteral", {
            enumerable: !0,
            get: function get() {
                return a.numberLiteral
            }
        }),
        Object.defineProperty(r, "RegexLiteral", {
            enumerable: !0,
            get: function get() {
                return a.regexLiteral
            }
        }),
        Object.defineProperty(r, "RestProperty", {
            enumerable: !0,
            get: function get() {
                return a.restProperty
            }
        }),
        Object.defineProperty(r, "SpreadProperty", {
            enumerable: !0,
            get: function get() {
                return a.spreadProperty
            }
        });
        var a = i("57mi")
    },
    M7ys: function(t, r, i) {
        "use strict";
        var a = i("TqRt")(i("RIqP"));
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.UPDATE_OPERATORS = r.UNARY_OPERATORS = r.STRING_UNARY_OPERATORS = r.STATEMENT_OR_BLOCK_KEYS = r.NUMBER_UNARY_OPERATORS = r.NUMBER_BINARY_OPERATORS = r.NOT_LOCAL_BINDING = r.LOGICAL_OPERATORS = r.INHERIT_KEYS = r.FOR_INIT_KEYS = r.FLATTENABLE_KEYS = r.EQUALITY_BINARY_OPERATORS = r.COMPARISON_BINARY_OPERATORS = r.COMMENT_KEYS = r.BOOLEAN_UNARY_OPERATORS = r.BOOLEAN_NUMBER_BINARY_OPERATORS = r.BOOLEAN_BINARY_OPERATORS = r.BLOCK_SCOPED_SYMBOL = r.BINARY_OPERATORS = r.ASSIGNMENT_OPERATORS = void 0;
        r.STATEMENT_OR_BLOCK_KEYS = ["consequent", "body", "alternate"];
        r.FLATTENABLE_KEYS = ["body", "expressions"];
        r.FOR_INIT_KEYS = ["left", "init"];
        r.COMMENT_KEYS = ["leadingComments", "trailingComments", "innerComments"];
        var o = ["||", "&&", "??"];
        r.LOGICAL_OPERATORS = o;
        r.UPDATE_OPERATORS = ["++", "--"];
        var l = [">", "<", ">=", "<="];
        r.BOOLEAN_NUMBER_BINARY_OPERATORS = l;
        var u = ["==", "===", "!=", "!=="];
        r.EQUALITY_BINARY_OPERATORS = u;
        var p = [].concat(u, ["in", "instanceof"]);
        r.COMPARISON_BINARY_OPERATORS = p;
        var c = [].concat((0,
        a.default)(p), l);
        r.BOOLEAN_BINARY_OPERATORS = c;
        var d = ["-", "/", "%", "*", "**", "&", "|", ">>", ">>>", "<<", "^"];
        r.NUMBER_BINARY_OPERATORS = d;
        var y = ["+"].concat(d, (0,
        a.default)(c));
        r.BINARY_OPERATORS = y;
        var h = ["=", "+="].concat((0,
        a.default)(d.map((function(t) {
            return t + "="
        }
        ))), (0,
        a.default)(o.map((function(t) {
            return t + "="
        }
        ))));
        r.ASSIGNMENT_OPERATORS = h;
        var m = ["delete", "!"];
        r.BOOLEAN_UNARY_OPERATORS = m;
        var T = ["+", "-", "~"];
        r.NUMBER_UNARY_OPERATORS = T;
        var S = ["typeof"];
        r.STRING_UNARY_OPERATORS = S;
        var g = ["void", "throw"].concat(m, T, S);
        r.UNARY_OPERATORS = g;
        r.INHERIT_KEYS = {
            optional: ["typeAnnotation", "typeParameters", "returnType"],
            force: ["start", "loc", "end"]
        };
        var b = Symbol.for("var used to be block scoped");
        r.BLOCK_SCOPED_SYMBOL = b;
        var v = Symbol.for("should not be considered a local binding");
        r.NOT_LOCAL_BINDING = v
    },
    MBGo: function(t, r, i) {
        "use strict";
        var a = i("TqRt")
          , o = a(i("lwsE"))
          , l = a(i("W8MJ"));
        function _arrayLikeToArray(t, r) {
            (null == r || r > t.length) && (r = t.length);
            for (var i = 0, a = new Array(r); i < r; i++)
                a[i] = t[i];
            return a
        }
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = r.SHOULD_SKIP = r.SHOULD_STOP = r.REMOVED = void 0;
        var u = i("D0vZ")
          , p = i("UcGn")
          , c = i("LR/y")
          , d = i("rZZI")
          , y = i("ZtNB")
          , h = i("qMwM")
          , m = i("e9y/")
          , T = i("9YWw")
          , S = i("WP/u")
          , g = i("1/cg")
          , b = i("z/7U")
          , v = i("alMP")
          , E = i("Lo2p")
          , P = i("lllF")
          , x = i("wqfs")
          , A = i("CuUK")
          , O = i("POQp")
          , I = i("wJi8")
          , w = p("babel");
        r.REMOVED = 1;
        r.SHOULD_STOP = 2;
        r.SHOULD_SKIP = 4;
        var C = function() {
            function NodePath(t, r) {
                (0,
                o.default)(this, NodePath),
                this.contexts = [],
                this.state = null,
                this.opts = null,
                this._traverseFlags = 0,
                this.skipKeys = null,
                this.parentPath = null,
                this.container = null,
                this.listKey = null,
                this.key = null,
                this.node = null,
                this.type = null,
                this.parent = r,
                this.hub = t,
                this.data = null,
                this.context = null,
                this.scope = null
            }
            return (0,
            l.default)(NodePath, [{
                key: "getScope",
                value: function getScope(t) {
                    return this.isScope() ? new d.default(this) : t
                }
            }, {
                key: "setData",
                value: function setData(t, r) {
                    return null == this.data && (this.data = Object.create(null)),
                    this.data[t] = r
                }
            }, {
                key: "getData",
                value: function getData(t, r) {
                    null == this.data && (this.data = Object.create(null));
                    var i = this.data[t];
                    return void 0 === i && void 0 !== r && (i = this.data[t] = r),
                    i
                }
            }, {
                key: "buildCodeFrameError",
                value: function buildCodeFrameError(t) {
                    var r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : SyntaxError;
                    return this.hub.buildError(this.node, t, r)
                }
            }, {
                key: "traverse",
                value: function traverse(t, r) {
                    (0,
                    c.default)(this.node, t, this.scope, r, this)
                }
            }, {
                key: "set",
                value: function set(t, r) {
                    y.validate(this.node, t, r),
                    this.node[t] = r
                }
            }, {
                key: "getPathLocation",
                value: function getPathLocation() {
                    var t = []
                      , r = this;
                    do {
                        var i = r.key;
                        r.inList && (i = "".concat(r.listKey, "[").concat(i, "]")),
                        t.unshift(i)
                    } while (r = r.parentPath);
                    return t.join(".")
                }
            }, {
                key: "debug",
                value: function debug(t) {
                    w.enabled && w("".concat(this.getPathLocation(), " ").concat(this.type, ": ").concat(t))
                }
            }, {
                key: "toString",
                value: function toString() {
                    return (0,
                    m.default)(this.node).code
                }
            }, {
                key: "inList",
                get: function get() {
                    return !!this.listKey
                },
                set: function set(t) {
                    t || (this.listKey = null)
                }
            }, {
                key: "parentKey",
                get: function get() {
                    return this.listKey || this.key
                }
            }, {
                key: "shouldSkip",
                get: function get() {
                    return !!(4 & this._traverseFlags)
                },
                set: function set(t) {
                    t ? this._traverseFlags |= 4 : this._traverseFlags &= -5
                }
            }, {
                key: "shouldStop",
                get: function get() {
                    return !!(2 & this._traverseFlags)
                },
                set: function set(t) {
                    t ? this._traverseFlags |= 2 : this._traverseFlags &= -3
                }
            }, {
                key: "removed",
                get: function get() {
                    return !!(1 & this._traverseFlags)
                },
                set: function set(t) {
                    t ? this._traverseFlags |= 1 : this._traverseFlags &= -2
                }
            }], [{
                key: "get",
                value: function get(t) {
                    var r = t.hub
                      , i = t.parentPath
                      , a = t.parent
                      , o = t.container
                      , l = t.listKey
                      , u = t.key;
                    if (!r && i && (r = i.hub),
                    !a)
                        throw new Error("To get a node path the parent needs to exist");
                    var p = o[u]
                      , c = h.path.get(a);
                    c || (c = new Map,
                    h.path.set(a, c));
                    var d = c.get(p);
                    return d || (d = new NodePath(r,a),
                    p && c.set(p, d)),
                    d.setup(i, o, l, u),
                    d
                }
            }]),
            NodePath
        }();
        Object.assign(C.prototype, T, S, g, b, v, E, P, x, A, O, I);
        var N, D = function _createForOfIteratorHelper(t, r) {
            var i = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
            if (!i) {
                if (Array.isArray(t) || (i = function _unsupportedIterableToArray(t, r) {
                    if (!t)
                        return;
                    if ("string" == typeof t)
                        return _arrayLikeToArray(t, r);
                    var i = Object.prototype.toString.call(t).slice(8, -1);
                    "Object" === i && t.constructor && (i = t.constructor.name);
                    if ("Map" === i || "Set" === i)
                        return Array.from(t);
                    if ("Arguments" === i || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i))
                        return _arrayLikeToArray(t, r)
                }(t)) || r && t && "number" == typeof t.length) {
                    i && (t = i);
                    var a = 0
                      , o = function F() {};
                    return {
                        s: o,
                        n: function n() {
                            return a >= t.length ? {
                                done: !0
                            } : {
                                done: !1,
                                value: t[a++]
                            }
                        },
                        e: function e(t) {
                            throw t
                        },
                        f: o
                    }
                }
                throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
            }
            var l, u = !0, p = !1;
            return {
                s: function s() {
                    i = i.call(t)
                },
                n: function n() {
                    var t = i.next();
                    return u = t.done,
                    t
                },
                e: function e(t) {
                    p = !0,
                    l = t
                },
                f: function f() {
                    try {
                        u || null == i.return || i.return()
                    } finally {
                        if (p)
                            throw l
                    }
                }
            }
        }(y.TYPES);
        try {
            var _ = function _loop2() {
                var t = N.value
                  , r = "is".concat(t)
                  , i = y[r];
                C.prototype[r] = function(t) {
                    return i(this.node, t)
                }
                ,
                C.prototype["assert".concat(t)] = function(r) {
                    if (!i(this.node, r))
                        throw new TypeError("Expected node path of type ".concat(t))
                }
            };
            for (D.s(); !(N = D.n()).done; )
                _()
        } catch (t) {
            D.e(t)
        } finally {
            D.f()
        }
        for (var L = function _loop() {
            var t = M[k];
            if ("_" === t[0])
                return "continue";
            y.TYPES.indexOf(t) < 0 && y.TYPES.push(t);
            var r = u[t];
            C.prototype["is".concat(t)] = function(t) {
                return r.checkPath(this, t)
            }
        }, k = 0, M = Object.keys(u); k < M.length; k++)
            L();
        var j = C;
        r.default = j
    },
    MCLT: function(t, r, i) {
        (function(t) {
            var a = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors(t) {
                for (var r = Object.keys(t), i = {}, a = 0; a < r.length; a++)
                    i[r[a]] = Object.getOwnPropertyDescriptor(t, r[a]);
                return i
            }
              , o = /%[sdj%]/g;
            r.format = function(t) {
                if (!isString(t)) {
                    for (var r = [], i = 0; i < arguments.length; i++)
                        r.push(inspect(arguments[i]));
                    return r.join(" ")
                }
                i = 1;
                for (var a = arguments, l = a.length, u = String(t).replace(o, (function(t) {
                    if ("%%" === t)
                        return "%";
                    if (i >= l)
                        return t;
                    switch (t) {
                    case "%s":
                        return String(a[i++]);
                    case "%d":
                        return Number(a[i++]);
                    case "%j":
                        try {
                            return JSON.stringify(a[i++])
                        } catch (t) {
                            return "[Circular]"
                        }
                    default:
                        return t
                    }
                }
                )), p = a[i]; i < l; p = a[++i])
                    isNull(p) || !isObject(p) ? u += " " + p : u += " " + inspect(p);
                return u
            }
            ,
            r.deprecate = function(i, a) {
                if (void 0 !== t && !0 === t.noDeprecation)
                    return i;
                if (void 0 === t)
                    return function() {
                        return r.deprecate(i, a).apply(this, arguments)
                    }
                    ;
                var o = !1;
                return function deprecated() {
                    if (!o) {
                        if (t.throwDeprecation)
                            throw new Error(a);
                        t.traceDeprecation ? console.trace(a) : console.error(a),
                        o = !0
                    }
                    return i.apply(this, arguments)
                }
            }
            ;
            var l, u = {};
            function inspect(t, i) {
                var a = {
                    seen: [],
                    stylize: stylizeNoColor
                };
                return arguments.length >= 3 && (a.depth = arguments[2]),
                arguments.length >= 4 && (a.colors = arguments[3]),
                isBoolean(i) ? a.showHidden = i : i && r._extend(a, i),
                isUndefined(a.showHidden) && (a.showHidden = !1),
                isUndefined(a.depth) && (a.depth = 2),
                isUndefined(a.colors) && (a.colors = !1),
                isUndefined(a.customInspect) && (a.customInspect = !0),
                a.colors && (a.stylize = stylizeWithColor),
                formatValue(a, t, a.depth)
            }
            function stylizeWithColor(t, r) {
                var i = inspect.styles[r];
                return i ? "[" + inspect.colors[i][0] + "m" + t + "[" + inspect.colors[i][1] + "m" : t
            }
            function stylizeNoColor(t, r) {
                return t
            }
            function formatValue(t, i, a) {
                if (t.customInspect && i && isFunction(i.inspect) && i.inspect !== r.inspect && (!i.constructor || i.constructor.prototype !== i)) {
                    var o = i.inspect(a, t);
                    return isString(o) || (o = formatValue(t, o, a)),
                    o
                }
                var l = function formatPrimitive(t, r) {
                    if (isUndefined(r))
                        return t.stylize("undefined", "undefined");
                    if (isString(r)) {
                        var i = "'" + JSON.stringify(r).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
                        return t.stylize(i, "string")
                    }
                    if (isNumber(r))
                        return t.stylize("" + r, "number");
                    if (isBoolean(r))
                        return t.stylize("" + r, "boolean");
                    if (isNull(r))
                        return t.stylize("null", "null")
                }(t, i);
                if (l)
                    return l;
                var u = Object.keys(i)
                  , p = function arrayToHash(t) {
                    var r = {};
                    return t.forEach((function(t, i) {
                        r[t] = !0
                    }
                    )),
                    r
                }(u);
                if (t.showHidden && (u = Object.getOwnPropertyNames(i)),
                isError(i) && (u.indexOf("message") >= 0 || u.indexOf("description") >= 0))
                    return formatError(i);
                if (0 === u.length) {
                    if (isFunction(i)) {
                        var c = i.name ? ": " + i.name : "";
                        return t.stylize("[Function" + c + "]", "special")
                    }
                    if (isRegExp(i))
                        return t.stylize(RegExp.prototype.toString.call(i), "regexp");
                    if (isDate(i))
                        return t.stylize(Date.prototype.toString.call(i), "date");
                    if (isError(i))
                        return formatError(i)
                }
                var d, y = "", h = !1, m = ["{", "}"];
                (isArray(i) && (h = !0,
                m = ["[", "]"]),
                isFunction(i)) && (y = " [Function" + (i.name ? ": " + i.name : "") + "]");
                return isRegExp(i) && (y = " " + RegExp.prototype.toString.call(i)),
                isDate(i) && (y = " " + Date.prototype.toUTCString.call(i)),
                isError(i) && (y = " " + formatError(i)),
                0 !== u.length || h && 0 != i.length ? a < 0 ? isRegExp(i) ? t.stylize(RegExp.prototype.toString.call(i), "regexp") : t.stylize("[Object]", "special") : (t.seen.push(i),
                d = h ? function formatArray(t, r, i, a, o) {
                    for (var l = [], u = 0, p = r.length; u < p; ++u)
                        hasOwnProperty(r, String(u)) ? l.push(formatProperty(t, r, i, a, String(u), !0)) : l.push("");
                    return o.forEach((function(o) {
                        o.match(/^\d+$/) || l.push(formatProperty(t, r, i, a, o, !0))
                    }
                    )),
                    l
                }(t, i, a, p, u) : u.map((function(r) {
                    return formatProperty(t, i, a, p, r, h)
                }
                )),
                t.seen.pop(),
                function reduceToSingleString(t, r, i) {
                    if (t.reduce((function(t, r) {
                        return r.indexOf("\n") >= 0 && 0,
                        t + r.replace(/\u001b\[\d\d?m/g, "").length + 1
                    }
                    ), 0) > 60)
                        return i[0] + ("" === r ? "" : r + "\n ") + " " + t.join(",\n  ") + " " + i[1];
                    return i[0] + r + " " + t.join(", ") + " " + i[1]
                }(d, y, m)) : m[0] + y + m[1]
            }
            function formatError(t) {
                return "[" + Error.prototype.toString.call(t) + "]"
            }
            function formatProperty(t, r, i, a, o, l) {
                var u, p, c;
                if ((c = Object.getOwnPropertyDescriptor(r, o) || {
                    value: r[o]
                }).get ? p = c.set ? t.stylize("[Getter/Setter]", "special") : t.stylize("[Getter]", "special") : c.set && (p = t.stylize("[Setter]", "special")),
                hasOwnProperty(a, o) || (u = "[" + o + "]"),
                p || (t.seen.indexOf(c.value) < 0 ? (p = isNull(i) ? formatValue(t, c.value, null) : formatValue(t, c.value, i - 1)).indexOf("\n") > -1 && (p = l ? p.split("\n").map((function(t) {
                    return "  " + t
                }
                )).join("\n").substr(2) : "\n" + p.split("\n").map((function(t) {
                    return "   " + t
                }
                )).join("\n")) : p = t.stylize("[Circular]", "special")),
                isUndefined(u)) {
                    if (l && o.match(/^\d+$/))
                        return p;
                    (u = JSON.stringify("" + o)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (u = u.substr(1, u.length - 2),
                    u = t.stylize(u, "name")) : (u = u.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"),
                    u = t.stylize(u, "string"))
                }
                return u + ": " + p
            }
            function isArray(t) {
                return Array.isArray(t)
            }
            function isBoolean(t) {
                return "boolean" == typeof t
            }
            function isNull(t) {
                return null === t
            }
            function isNumber(t) {
                return "number" == typeof t
            }
            function isString(t) {
                return "string" == typeof t
            }
            function isUndefined(t) {
                return void 0 === t
            }
            function isRegExp(t) {
                return isObject(t) && "[object RegExp]" === objectToString(t)
            }
            function isObject(t) {
                return "object" == typeof t && null !== t
            }
            function isDate(t) {
                return isObject(t) && "[object Date]" === objectToString(t)
            }
            function isError(t) {
                return isObject(t) && ("[object Error]" === objectToString(t) || t instanceof Error)
            }
            function isFunction(t) {
                return "function" == typeof t
            }
            function objectToString(t) {
                return Object.prototype.toString.call(t)
            }
            function pad(t) {
                return t < 10 ? "0" + t.toString(10) : t.toString(10)
            }
            r.debuglog = function(i) {
                if (isUndefined(l) && (l = t.env.NODE_DEBUG || ""),
                i = i.toUpperCase(),
                !u[i])
                    if (new RegExp("\\b" + i + "\\b","i").test(l)) {
                        var a = t.pid;
                        u[i] = function() {
                            var t = r.format.apply(r, arguments);
                            console.error("%s %d: %s", i, a, t)
                        }
                    } else
                        u[i] = function() {}
                        ;
                return u[i]
            }
            ,
            r.inspect = inspect,
            inspect.colors = {
                bold: [1, 22],
                italic: [3, 23],
                underline: [4, 24],
                inverse: [7, 27],
                white: [37, 39],
                grey: [90, 39],
                black: [30, 39],
                blue: [34, 39],
                cyan: [36, 39],
                green: [32, 39],
                magenta: [35, 39],
                red: [31, 39],
                yellow: [33, 39]
            },
            inspect.styles = {
                special: "cyan",
                number: "yellow",
                boolean: "yellow",
                undefined: "grey",
                null: "bold",
                string: "green",
                date: "magenta",
                regexp: "red"
            },
            r.isArray = isArray,
            r.isBoolean = isBoolean,
            r.isNull = isNull,
            r.isNullOrUndefined = function isNullOrUndefined(t) {
                return null == t
            }
            ,
            r.isNumber = isNumber,
            r.isString = isString,
            r.isSymbol = function isSymbol(t) {
                return "symbol" == typeof t
            }
            ,
            r.isUndefined = isUndefined,
            r.isRegExp = isRegExp,
            r.isObject = isObject,
            r.isDate = isDate,
            r.isError = isError,
            r.isFunction = isFunction,
            r.isPrimitive = function isPrimitive(t) {
                return null === t || "boolean" == typeof t || "number" == typeof t || "string" == typeof t || "symbol" == typeof t || void 0 === t
            }
            ,
            r.isBuffer = i("1gqn");
            var p = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
            function timestamp() {
                var t = new Date
                  , r = [pad(t.getHours()), pad(t.getMinutes()), pad(t.getSeconds())].join(":");
                return [t.getDate(), p[t.getMonth()], r].join(" ")
            }
            function hasOwnProperty(t, r) {
                return Object.prototype.hasOwnProperty.call(t, r)
            }
            r.log = function() {
                console.log("%s - %s", timestamp(), r.format.apply(r, arguments))
            }
            ,
            r.inherits = i("KKCa"),
            r._extend = function(t, r) {
                if (!r || !isObject(r))
                    return t;
                for (var i = Object.keys(r), a = i.length; a--; )
                    t[i[a]] = r[i[a]];
                return t
            }
            ;
            var c = "undefined" != typeof Symbol ? Symbol("util.promisify.custom") : void 0;
            function callbackifyOnRejected(t, r) {
                if (!t) {
                    var i = new Error("Promise was rejected with a falsy value");
                    i.reason = t,
                    t = i
                }
                return r(t)
            }
            r.promisify = function promisify(t) {
                if ("function" != typeof t)
                    throw new TypeError('The "original" argument must be of type Function');
                if (c && t[c]) {
                    var r;
                    if ("function" != typeof (r = t[c]))
                        throw new TypeError('The "util.promisify.custom" argument must be of type Function');
                    return Object.defineProperty(r, c, {
                        value: r,
                        enumerable: !1,
                        writable: !1,
                        configurable: !0
                    }),
                    r
                }
                function r() {
                    for (var r, i, a = new Promise((function(t, a) {
                        r = t,
                        i = a
                    }
                    )), o = [], l = 0; l < arguments.length; l++)
                        o.push(arguments[l]);
                    o.push((function(t, a) {
                        t ? i(t) : r(a)
                    }
                    ));
                    try {
                        t.apply(this, o)
                    } catch (t) {
                        i(t)
                    }
                    return a
                }
                return Object.setPrototypeOf(r, Object.getPrototypeOf(t)),
                c && Object.defineProperty(r, c, {
                    value: r,
                    enumerable: !1,
                    writable: !1,
                    configurable: !0
                }),
                Object.defineProperties(r, a(t))
            }
            ,
            r.promisify.custom = c,
            r.callbackify = function callbackify(r) {
                if ("function" != typeof r)
                    throw new TypeError('The "original" argument must be of type Function');
                function callbackified() {
                    for (var i = [], a = 0; a < arguments.length; a++)
                        i.push(arguments[a]);
                    var o = i.pop();
                    if ("function" != typeof o)
                        throw new TypeError("The last argument must be of type Function");
                    var l = this
                      , cb = function() {
                        return o.apply(l, arguments)
                    };
                    r.apply(this, i).then((function(r) {
                        t.nextTick(cb, null, r)
                    }
                    ), (function(r) {
                        t.nextTick(callbackifyOnRejected, r, cb)
                    }
                    ))
                }
                return Object.setPrototypeOf(callbackified, Object.getPrototypeOf(r)),
                Object.defineProperties(callbackified, a(r)),
                callbackified
            }
        }
        ).call(this, i("8oxB"))
    },
    MRdt: function(t, r, i) {
        var a = i("ub0H");
        function MappingList() {
            this._array = [],
            this._sorted = !0,
            this._last = {
                generatedLine: -1,
                generatedColumn: 0
            }
        }
        MappingList.prototype.unsortedForEach = function MappingList_forEach(t, r) {
            this._array.forEach(t, r)
        }
        ,
        MappingList.prototype.add = function MappingList_add(t) {
            !function generatedPositionAfter(t, r) {
                var i = t.generatedLine
                  , o = r.generatedLine
                  , l = t.generatedColumn
                  , u = r.generatedColumn;
                return o > i || o == i && u >= l || a.compareByGeneratedPositionsInflated(t, r) <= 0
            }(this._last, t) ? (this._sorted = !1,
            this._array.push(t)) : (this._last = t,
            this._array.push(t))
        }
        ,
        MappingList.prototype.toArray = function MappingList_toArray() {
            return this._sorted || (this._array.sort(a.compareByGeneratedPositionsInflated),
            this._sorted = !0),
            this._array
        }
        ,
        r.MappingList = MappingList
    },
    Maqe: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.statements = r.statement = r.smart = r.program = r.expression = void 0;
        var a = i("JSq2");
        const {assertExpressionStatement: o} = a;
        function makeStatementFormatter(t) {
            return {
                code: t=>"/* @babel/template */;\n" + t,
                validate: ()=>{}
                ,
                unwrap: r=>t(r.program.body.slice(1))
            }
        }
        const l = makeStatementFormatter(t=>t.length > 1 ? t : t[0]);
        r.smart = l;
        const u = makeStatementFormatter(t=>t);
        r.statements = u;
        const p = makeStatementFormatter(t=>{
            if (0 === t.length)
                throw new Error("Found nothing to return.");
            if (t.length > 1)
                throw new Error("Found multiple statements but wanted one");
            return t[0]
        }
        );
        r.statement = p;
        const c = {
            code: t=>`(\n${t}\n)`,
            validate: t=>{
                if (t.program.body.length > 1)
                    throw new Error("Found multiple statements but wanted one");
                if (0 === c.unwrap(t).start)
                    throw new Error("Parse result included parens.")
            }
            ,
            unwrap: ({program: t})=>{
                const [r] = t.body;
                return o(r),
                r.expression
            }
        };
        r.expression = c;
        r.program = {
            code: t=>t,
            validate: ()=>{}
            ,
            unwrap: t=>t.program
        }
    },
    MqCK: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = void 0;
        var a = i("V20z")
          , o = function getOuterBindingIdentifiers(t, r) {
            return (0,
            a.default)(t, r, !0)
        };
        r.default = o
    },
    Mrar: function(t, r, i) {
        "use strict";
        function _createForOfIteratorHelper(t, r) {
            var i = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
            if (!i) {
                if (Array.isArray(t) || (i = function _unsupportedIterableToArray(t, r) {
                    if (!t)
                        return;
                    if ("string" == typeof t)
                        return _arrayLikeToArray(t, r);
                    var i = Object.prototype.toString.call(t).slice(8, -1);
                    "Object" === i && t.constructor && (i = t.constructor.name);
                    if ("Map" === i || "Set" === i)
                        return Array.from(t);
                    if ("Arguments" === i || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i))
                        return _arrayLikeToArray(t, r)
                }(t)) || r && t && "number" == typeof t.length) {
                    i && (t = i);
                    var a = 0
                      , o = function F() {};
                    return {
                        s: o,
                        n: function n() {
                            return a >= t.length ? {
                                done: !0
                            } : {
                                done: !1,
                                value: t[a++]
                            }
                        },
                        e: function e(t) {
                            throw t
                        },
                        f: o
                    }
                }
                throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
            }
            var l, u = !0, p = !1;
            return {
                s: function s() {
                    i = i.call(t)
                },
                n: function n() {
                    var t = i.next();
                    return u = t.done,
                    t
                },
                e: function e(t) {
                    p = !0,
                    l = t
                },
                f: function f() {
                    try {
                        u || null == i.return || i.return()
                    } finally {
                        if (p)
                            throw l
                    }
                }
            }
        }
        function _arrayLikeToArray(t, r) {
            (null == r || r > t.length) && (r = t.length);
            for (var i = 0, a = new Array(r); i < r; i++)
                a[i] = t[i];
            return a
        }
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function isType(t, r) {
            if (t === r)
                return !0;
            if (a.ALIAS_KEYS[r])
                return !1;
            var i = a.FLIPPED_ALIAS_KEYS[r];
            if (i) {
                if (i[0] === t)
                    return !0;
                var o, l = _createForOfIteratorHelper(i);
                try {
                    for (l.s(); !(o = l.n()).done; ) {
                        var u = o.value;
                        if (t === u)
                            return !0
                    }
                } catch (t) {
                    l.e(t)
                } finally {
                    l.f()
                }
            }
            return !1
        }
        ;
        var a = i("Resm")
    },
    Mv50: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function ensureBlock(t, r="body") {
            return t[r] = (0,
            a.default)(t[r], t)
        }
        ;
        var a = i("fwxm")
    },
    N2Vh: function(t, r, i) {
        "use strict";
        function _createForOfIteratorHelper(t, r) {
            var i = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
            if (!i) {
                if (Array.isArray(t) || (i = function _unsupportedIterableToArray(t, r) {
                    if (!t)
                        return;
                    if ("string" == typeof t)
                        return _arrayLikeToArray(t, r);
                    var i = Object.prototype.toString.call(t).slice(8, -1);
                    "Object" === i && t.constructor && (i = t.constructor.name);
                    if ("Map" === i || "Set" === i)
                        return Array.from(t);
                    if ("Arguments" === i || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i))
                        return _arrayLikeToArray(t, r)
                }(t)) || r && t && "number" == typeof t.length) {
                    i && (t = i);
                    var a = 0
                      , o = function F() {};
                    return {
                        s: o,
                        n: function n() {
                            return a >= t.length ? {
                                done: !0
                            } : {
                                done: !1,
                                value: t[a++]
                            }
                        },
                        e: function e(t) {
                            throw t
                        },
                        f: o
                    }
                }
                throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
            }
            var l, u = !0, p = !1;
            return {
                s: function s() {
                    i = i.call(t)
                },
                n: function n() {
                    var t = i.next();
                    return u = t.done,
                    t
                },
                e: function e(t) {
                    p = !0,
                    l = t
                },
                f: function f() {
                    try {
                        u || null == i.return || i.return()
                    } finally {
                        if (p)
                            throw l
                    }
                }
            }
        }
        function _arrayLikeToArray(t, r) {
            (null == r || r > t.length) && (r = t.length);
            for (var i = 0, a = new Array(r); i < r; i++)
                a[i] = t[i];
            return a
        }
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function removeProperties(t) {
            var r, i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, a = i.preserveComments ? o : l, u = _createForOfIteratorHelper(a);
            try {
                for (u.s(); !(r = u.n()).done; ) {
                    var p = r.value;
                    null != t[p] && (t[p] = void 0)
                }
            } catch (t) {
                u.e(t)
            } finally {
                u.f()
            }
            for (var c = 0, d = Object.keys(t); c < d.length; c++) {
                var y = d[c];
                "_" === y[0] && null != t[y] && (t[y] = void 0)
            }
            var h, m = Object.getOwnPropertySymbols(t), T = _createForOfIteratorHelper(m);
            try {
                for (T.s(); !(h = T.n()).done; ) {
                    var S = h.value;
                    t[S] = null
                }
            } catch (t) {
                T.e(t)
            } finally {
                T.f()
            }
        }
        ;
        var a = i("RS7Y")
          , o = ["tokens", "start", "end", "loc", "raw", "rawValue"]
          , l = a.COMMENT_KEYS.concat(["comments"]).concat(o)
    },
    NFYY: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function inheritInnerComments(t, r) {
            (0,
            a.default)("innerComments", t, r)
        }
        ;
        var a = i("P3pX")
    },
    NRCf: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function appendToMemberExpression(t, r) {
            var i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
            return t.object = (0,
            a.memberExpression)(t.object, t.property, t.computed),
            t.property = r,
            t.computed = !!i,
            t
        }
        ;
        var a = i("UuI8")
    },
    Ns23: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.ExportAllDeclaration = function ExportAllDeclaration(t) {
            this.word("export"),
            this.space(),
            "type" === t.exportKind && (this.word("type"),
            this.space());
            this.token("*"),
            this.space(),
            this.word("from"),
            this.space(),
            this.print(t.source, t),
            this.printAssertions(t),
            this.semicolon()
        }
        ,
        r.ExportDefaultDeclaration = function ExportDefaultDeclaration(t) {
            this.format.decoratorsBeforeExport && o(t.declaration) && this.printJoin(t.declaration.decorators, t);
            this.word("export"),
            this.space(),
            this.word("default"),
            this.space(),
            ExportDeclaration.apply(this, arguments)
        }
        ,
        r.ExportDefaultSpecifier = function ExportDefaultSpecifier(t) {
            this.print(t.exported, t)
        }
        ,
        r.ExportNamedDeclaration = function ExportNamedDeclaration(t) {
            this.format.decoratorsBeforeExport && o(t.declaration) && this.printJoin(t.declaration.decorators, t);
            this.word("export"),
            this.space(),
            ExportDeclaration.apply(this, arguments)
        }
        ,
        r.ExportNamespaceSpecifier = function ExportNamespaceSpecifier(t) {
            this.token("*"),
            this.space(),
            this.word("as"),
            this.space(),
            this.print(t.exported, t)
        }
        ,
        r.ExportSpecifier = function ExportSpecifier(t) {
            "type" === t.exportKind && (this.word("type"),
            this.space());
            this.print(t.local, t),
            t.exported && t.local.name !== t.exported.name && (this.space(),
            this.word("as"),
            this.space(),
            this.print(t.exported, t))
        }
        ,
        r.ImportAttribute = function ImportAttribute(t) {
            this.print(t.key),
            this.token(":"),
            this.space(),
            this.print(t.value)
        }
        ,
        r.ImportDeclaration = function ImportDeclaration(t) {
            this.word("import"),
            this.space(),
            ("type" === t.importKind || "typeof" === t.importKind) && (this.word(t.importKind),
            this.space());
            const r = t.specifiers.slice(0);
            if (null != r && r.length) {
                for (; ; ) {
                    const i = r[0];
                    if (!p(i) && !c(i))
                        break;
                    this.print(r.shift(), t),
                    r.length && (this.token(","),
                    this.space())
                }
                r.length && (this.token("{"),
                this.space(),
                this.printList(r, t),
                this.space(),
                this.token("}")),
                this.space(),
                this.word("from"),
                this.space()
            }
            var i;
            this.print(t.source, t),
            this.printAssertions(t),
            null != (i = t.attributes) && i.length && (this.space(),
            this.word("with"),
            this.space(),
            this.printList(t.attributes, t));
            this.semicolon()
        }
        ,
        r.ImportDefaultSpecifier = function ImportDefaultSpecifier(t) {
            this.print(t.local, t)
        }
        ,
        r.ImportNamespaceSpecifier = function ImportNamespaceSpecifier(t) {
            this.token("*"),
            this.space(),
            this.word("as"),
            this.space(),
            this.print(t.local, t)
        }
        ,
        r.ImportSpecifier = function ImportSpecifier(t) {
            "type" !== t.importKind && "typeof" !== t.importKind || (this.word(t.importKind),
            this.space());
            this.print(t.imported, t),
            t.local && t.local.name !== t.imported.name && (this.space(),
            this.word("as"),
            this.space(),
            this.print(t.local, t))
        }
        ;
        var a = i("JSq2");
        const {isClassDeclaration: o, isExportDefaultSpecifier: l, isExportNamespaceSpecifier: u, isImportDefaultSpecifier: p, isImportNamespaceSpecifier: c, isStatement: d} = a;
        function ExportDeclaration(t) {
            if (t.declaration) {
                const r = t.declaration;
                this.print(r, t),
                d(r) || this.semicolon()
            } else {
                "type" === t.exportKind && (this.word("type"),
                this.space());
                const r = t.specifiers.slice(0);
                let i = !1;
                for (; ; ) {
                    const a = r[0];
                    if (!l(a) && !u(a))
                        break;
                    i = !0,
                    this.print(r.shift(), t),
                    r.length && (this.token(","),
                    this.space())
                }
                (r.length || !r.length && !i) && (this.token("{"),
                r.length && (this.space(),
                this.printList(r, t),
                this.space()),
                this.token("}")),
                t.source && (this.space(),
                this.word("from"),
                this.space(),
                this.print(t.source, t),
                this.printAssertions(t)),
                this.semicolon()
            }
        }
    },
    "O0/1": function(t, r, i) {
        "use strict";
        var a = i("TqRt")
          , o = a(i("lwsE"))
          , l = a(i("W8MJ"));
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = void 0;
        var u = function() {
            function Binding(t) {
                var r = t.identifier
                  , i = t.scope
                  , a = t.path
                  , l = t.kind;
                (0,
                o.default)(this, Binding),
                this.identifier = void 0,
                this.scope = void 0,
                this.path = void 0,
                this.kind = void 0,
                this.constantViolations = [],
                this.constant = !0,
                this.referencePaths = [],
                this.referenced = !1,
                this.references = 0,
                this.identifier = r,
                this.scope = i,
                this.path = a,
                this.kind = l,
                this.clearValue()
            }
            return (0,
            l.default)(Binding, [{
                key: "deoptValue",
                value: function deoptValue() {
                    this.clearValue(),
                    this.hasDeoptedValue = !0
                }
            }, {
                key: "setValue",
                value: function setValue(t) {
                    this.hasDeoptedValue || (this.hasValue = !0,
                    this.value = t)
                }
            }, {
                key: "clearValue",
                value: function clearValue() {
                    this.hasDeoptedValue = !1,
                    this.hasValue = !1,
                    this.value = null
                }
            }, {
                key: "reassign",
                value: function reassign(t) {
                    this.constant = !1,
                    -1 === this.constantViolations.indexOf(t) && this.constantViolations.push(t)
                }
            }, {
                key: "reference",
                value: function reference(t) {
                    -1 === this.referencePaths.indexOf(t) && (this.referenced = !0,
                    this.references++,
                    this.referencePaths.push(t))
                }
            }, {
                key: "dereference",
                value: function dereference() {
                    this.references--,
                    this.referenced = !!this.references
                }
            }]),
            Binding
        }();
        r.default = u
    },
    O4gS: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function addComments(t, r, i) {
            if (!i || !t)
                return t;
            var a = "".concat(r, "Comments");
            t[a] ? t[a] = "leading" === r ? i.concat(t[a]) : t[a].concat(i) : t[a] = i;
            return t
        }
    },
    O9f4: function(t, r, i) {
        "use strict";
        t.exports = function(t) {
            for (var r = 0; r < t.length; r++) {
                var i = t[r];
                "CommentBlock" === i.type ? i.type = "Block" : "CommentLine" === i.type && (i.type = "Line"),
                i.range || (i.range = [i.start, i.end])
            }
        }
    },
    OLSu: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function inheritTrailingComments(t, r) {
            (0,
            a.default)("trailingComments", t, r)
        }
        ;
        var a = i("Df4y")
    },
    OPXu: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function buildMatchMemberExpression(t, r) {
            var i = t.split(".");
            return function(t) {
                return (0,
                a.default)(t, i, r)
            }
        }
        ;
        var a = i("z2IN")
    },
    OS6d: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function shallowEqual(t, r) {
            const i = Object.keys(r);
            for (const a of i)
                if (t[a] !== r[a])
                    return !1;
            return !0
        }
    },
    Oz16: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function inheritTrailingComments(t, r) {
            (0,
            a.default)("trailingComments", t, r)
        }
        ;
        var a = i("P3pX")
    },
    OzTh: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function cloneDeepWithoutLoc(t) {
            return (0,
            a.default)(t, !0, !0)
        }
        ;
        var a = i("sN7J")
    },
    P3pX: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function inherit(t, r, i) {
            r && i && (r[t] = Array.from(new Set([].concat(r[t], i[t]).filter(Boolean))))
        }
    },
    POQp: function(t, r, i) {
        "use strict";
        function _createForOfIteratorHelper(t, r) {
            var i = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
            if (!i) {
                if (Array.isArray(t) || (i = function _unsupportedIterableToArray(t, r) {
                    if (!t)
                        return;
                    if ("string" == typeof t)
                        return _arrayLikeToArray(t, r);
                    var i = Object.prototype.toString.call(t).slice(8, -1);
                    "Object" === i && t.constructor && (i = t.constructor.name);
                    if ("Map" === i || "Set" === i)
                        return Array.from(t);
                    if ("Arguments" === i || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i))
                        return _arrayLikeToArray(t, r)
                }(t)) || r && t && "number" == typeof t.length) {
                    i && (t = i);
                    var a = 0
                      , o = function F() {};
                    return {
                        s: o,
                        n: function n() {
                            return a >= t.length ? {
                                done: !0
                            } : {
                                done: !1,
                                value: t[a++]
                            }
                        },
                        e: function e(t) {
                            throw t
                        },
                        f: o
                    }
                }
                throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
            }
            var l, u = !0, p = !1;
            return {
                s: function s() {
                    i = i.call(t)
                },
                n: function n() {
                    var t = i.next();
                    return u = t.done,
                    t
                },
                e: function e(t) {
                    p = !0,
                    l = t
                },
                f: function f() {
                    try {
                        u || null == i.return || i.return()
                    } finally {
                        if (p)
                            throw l
                    }
                }
            }
        }
        function _arrayLikeToArray(t, r) {
            (null == r || r > t.length) && (r = t.length);
            for (var i = 0, a = new Array(r); i < r; i++)
                a[i] = t[i];
            return a
        }
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.getOpposite = function getOpposite() {
            if ("left" === this.key)
                return this.getSibling("right");
            if ("right" === this.key)
                return this.getSibling("left");
            return null
        }
        ,
        r.getCompletionRecords = function getCompletionRecords() {
            return _getCompletionRecords(this, {
                canHaveBreak: !1,
                shouldPopulateBreak: !1,
                inCaseClause: !1
            }).map((function(t) {
                return t.path
            }
            ))
        }
        ,
        r.getSibling = function getSibling(t) {
            return a.default.get({
                parentPath: this.parentPath,
                parent: this.parent,
                container: this.container,
                listKey: this.listKey,
                key: t
            }).setContext(this.context)
        }
        ,
        r.getPrevSibling = function getPrevSibling() {
            return this.getSibling(this.key - 1)
        }
        ,
        r.getNextSibling = function getNextSibling() {
            return this.getSibling(this.key + 1)
        }
        ,
        r.getAllNextSiblings = function getAllNextSiblings() {
            var t = this.key
              , r = this.getSibling(++t)
              , i = [];
            for (; r.node; )
                i.push(r),
                r = this.getSibling(++t);
            return i
        }
        ,
        r.getAllPrevSiblings = function getAllPrevSiblings() {
            var t = this.key
              , r = this.getSibling(--t)
              , i = [];
            for (; r.node; )
                i.push(r),
                r = this.getSibling(--t);
            return i
        }
        ,
        r.get = function get(t) {
            var r = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
            !0 === r && (r = this.context);
            var i = t.split(".");
            return 1 === i.length ? this._getKey(t, r) : this._getPattern(i, r)
        }
        ,
        r._getKey = function _getKey(t, r) {
            var i = this
              , o = this.node
              , l = o[t];
            return Array.isArray(l) ? l.map((function(u, p) {
                return a.default.get({
                    listKey: t,
                    parentPath: i,
                    parent: o,
                    container: l,
                    key: p
                }).setContext(r)
            }
            )) : a.default.get({
                parentPath: this,
                parent: o,
                container: o,
                key: t
            }).setContext(r)
        }
        ,
        r._getPattern = function _getPattern(t, r) {
            var i, a = this, o = _createForOfIteratorHelper(t);
            try {
                for (o.s(); !(i = o.n()).done; ) {
                    var l = i.value;
                    a = "." === l ? a.parentPath : Array.isArray(a) ? a[l] : a.get(l, r)
                }
            } catch (t) {
                o.e(t)
            } finally {
                o.f()
            }
            return a
        }
        ,
        r.getBindingIdentifiers = function getBindingIdentifiers(t) {
            return o.getBindingIdentifiers(this.node, t)
        }
        ,
        r.getOuterBindingIdentifiers = function getOuterBindingIdentifiers(t) {
            return o.getOuterBindingIdentifiers(this.node, t)
        }
        ,
        r.getBindingIdentifierPaths = function getBindingIdentifierPaths() {
            var t = arguments.length > 0 && void 0 !== arguments[0] && arguments[0]
              , r = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]
              , i = this
              , a = [].concat(i)
              , l = Object.create(null);
            for (; a.length; ) {
                var u = a.shift();
                if (u && u.node) {
                    var p = o.getBindingIdentifiers.keys[u.node.type];
                    if (u.isIdentifier())
                        if (t) {
                            var c = l[u.node.name] = l[u.node.name] || [];
                            c.push(u)
                        } else
                            l[u.node.name] = u;
                    else if (u.isExportDeclaration()) {
                        var d = u.get("declaration");
                        d.isDeclaration() && a.push(d)
                    } else {
                        if (r) {
                            if (u.isFunctionDeclaration()) {
                                a.push(u.get("id"));
                                continue
                            }
                            if (u.isFunctionExpression())
                                continue
                        }
                        if (p)
                            for (var y = 0; y < p.length; y++) {
                                var h = p[y]
                                  , m = u.get(h);
                                (Array.isArray(m) || m.node) && (a = a.concat(m))
                            }
                    }
                }
            }
            return l
        }
        ,
        r.getOuterBindingIdentifierPaths = function getOuterBindingIdentifierPaths(t) {
            return this.getBindingIdentifierPaths(t, !0)
        }
        ;
        var a = i("MBGo")
          , o = i("ZtNB");
        function addCompletionRecords(t, r, i) {
            return t ? r.concat(_getCompletionRecords(t, i)) : r
        }
        function normalCompletionToBreak(t) {
            t.forEach((function(t) {
                t.type = 1
            }
            ))
        }
        function replaceBreakStatementInBreakCompletion(t, r) {
            t.forEach((function(t) {
                t.path.isBreakStatement({
                    label: null
                }) && (r ? t.path.replaceWith(o.unaryExpression("void", o.numericLiteral(0))) : t.path.remove())
            }
            ))
        }
        function getStatementListCompletion(t, r) {
            var i = [];
            if (r.canHaveBreak)
                for (var a = [], o = 0; o < t.length; o++) {
                    var l = t[o]
                      , u = Object.assign({}, r, {
                        inCaseClause: !1
                    });
                    l.isBlockStatement() && (r.inCaseClause || r.shouldPopulateBreak) ? u.shouldPopulateBreak = !0 : u.shouldPopulateBreak = !1;
                    var p = _getCompletionRecords(l, u);
                    if (p.length > 0 && p.every((function(t) {
                        return 1 === t.type
                    }
                    ))) {
                        a.length > 0 && p.every((function(t) {
                            return t.path.isBreakStatement({
                                label: null
                            })
                        }
                        )) ? (normalCompletionToBreak(a),
                        i = i.concat(a),
                        a.some((function(t) {
                            return t.path.isDeclaration()
                        }
                        )) && (i = i.concat(p),
                        replaceBreakStatementInBreakCompletion(p, !0)),
                        replaceBreakStatementInBreakCompletion(p, !1)) : (i = i.concat(p),
                        r.shouldPopulateBreak || replaceBreakStatementInBreakCompletion(p, !0));
                        break
                    }
                    o === t.length - 1 ? i = i.concat(p) : (i = i.concat(p.filter((function(t) {
                        return 1 === t.type
                    }
                    ))),
                    a = p.filter((function(t) {
                        return 0 === t.type
                    }
                    )))
                }
            else if (t.length)
                for (var c = t.length - 1; c >= 0; c--) {
                    var d = _getCompletionRecords(t[c], r);
                    if (d.length > 1 || 1 === d.length && !d[0].path.isVariableDeclaration()) {
                        i = i.concat(d);
                        break
                    }
                }
            return i
        }
        function _getCompletionRecords(t, r) {
            var i = [];
            if (t.isIfStatement())
                i = addCompletionRecords(t.get("consequent"), i, r),
                i = addCompletionRecords(t.get("alternate"), i, r);
            else if (t.isDoExpression() || t.isFor() || t.isWhile() || t.isLabeledStatement())
                i = addCompletionRecords(t.get("body"), i, r);
            else if (t.isProgram() || t.isBlockStatement())
                i = i.concat(getStatementListCompletion(t.get("body"), r));
            else {
                if (t.isFunction())
                    return _getCompletionRecords(t.get("body"), r);
                t.isTryStatement() ? (i = addCompletionRecords(t.get("block"), i, r),
                i = addCompletionRecords(t.get("handler"), i, r)) : t.isCatchClause() ? i = addCompletionRecords(t.get("body"), i, r) : t.isSwitchStatement() ? i = function completionRecordForSwitch(t, r, i) {
                    for (var a = [], o = 0; o < t.length; o++) {
                        var l, u = [], p = [], c = _createForOfIteratorHelper(_getCompletionRecords(t[o], i));
                        try {
                            for (c.s(); !(l = c.n()).done; ) {
                                var d = l.value;
                                0 === d.type && u.push(d),
                                1 === d.type && p.push(d)
                            }
                        } catch (t) {
                            c.e(t)
                        } finally {
                            c.f()
                        }
                        u.length && (a = u),
                        r = r.concat(p)
                    }
                    return r = r.concat(a)
                }(t.get("cases"), i, r) : t.isSwitchCase() ? i = i.concat(getStatementListCompletion(t.get("consequent"), {
                    canHaveBreak: !0,
                    shouldPopulateBreak: !1,
                    inCaseClause: !0
                })) : t.isBreakStatement() ? i.push(function BreakCompletion(t) {
                    return {
                        type: 1,
                        path: t
                    }
                }(t)) : i.push(function NormalCompletion(t) {
                    return {
                        type: 0,
                        path: t
                    }
                }(t))
            }
            return i
        }
    },
    PUqz: function(t, r, i) {
        "use strict";
        var a = i("+DtF")
          , o = i("GGH7").parse
          , l = i("GGH7").tokTypes
          , u = i("LR/y").default
          , p = i("8xt1").codeFrameColumns;
        t.exports = function(t, r) {
            var i, c = r.ecmaFeatures && r.ecmaFeatures.legacyDecorators, d = {
                codeFrame: !r.hasOwnProperty("codeFrame") || r.codeFrame,
                sourceType: r.sourceType,
                allowImportExportEverywhere: r.allowImportExportEverywhere,
                allowReturnOutsideFunction: !0,
                allowSuperOutsideMethod: !0,
                ranges: !0,
                tokens: !0,
                plugins: [["flow", {
                    all: !0
                }], "jsx", "estree", "asyncFunctions", "asyncGenerators", "classConstructorCall", "classProperties", c ? "decorators-legacy" : ["decorators", {
                    decoratorsBeforeExport: !1
                }], "doExpressions", "exponentiationOperator", "exportDefaultFrom", "exportNamespaceFrom", "functionBind", "functionSent", "objectRestSpread", "trailingFunctionCommas", "dynamicImport", "numericSeparator", "optionalChaining", "importMeta", "classPrivateProperties", "bigInt", "optionalCatchBinding", "throwExpressions", ["pipelineOperator", {
                    proposal: "minimal"
                }], "nullishCoalescingOperator", "logicalAssignment"]
            };
            try {
                i = o(t, d)
            } catch (r) {
                throw r instanceof SyntaxError && (r.lineNumber = r.loc.line,
                r.column = r.loc.column,
                d.codeFrame && (r.lineNumber = r.loc.line,
                r.column = r.loc.column + 1,
                r.message = "Line " + r.lineNumber + ": " + r.message.replace(/ \((\d+):(\d+)\)$/, "") + "\n\n" + p(t, {
                    start: {
                        line: r.lineNumber,
                        column: r.column
                    }
                }, {
                    highlightCode: !0
                }))),
                r
            }
            return a(i, u, l, t),
            i
        }
    },
    Pe1b: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function cloneDeep(t) {
            return (0,
            a.default)(t)
        }
        ;
        var a = i("aHlp")
    },
    Po9p: function(t, r) {},
    "Q/1+": function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.needsParens = function needsParens(t, r, i) {
            if (!r)
                return !1;
            if (y(r) && r.callee === t && function isOrHasCallExpression(t) {
                if (p(t))
                    return !0;
                return d(t) && isOrHasCallExpression(t.object)
            }(t))
                return !0;
            return find(h, t, r, i)
        }
        ,
        r.needsWhitespace = needsWhitespace,
        r.needsWhitespaceAfter = function needsWhitespaceAfter(t, r) {
            return needsWhitespace(t, r, "after")
        }
        ,
        r.needsWhitespaceBefore = function needsWhitespaceBefore(t, r) {
            return needsWhitespace(t, r, "before")
        }
        ;
        var a = i("+4SP")
          , o = i("qnHE")
          , l = i("JSq2");
        const {FLIPPED_ALIAS_KEYS: u, isCallExpression: p, isExpressionStatement: c, isMemberExpression: d, isNewExpression: y} = l;
        function expandAliases(t) {
            const r = {};
            function add(t, i) {
                const a = r[t];
                r[t] = a ? function(t, r, o) {
                    const l = a(t, r, o);
                    return null == l ? i(t, r, o) : l
                }
                : i
            }
            for (const r of Object.keys(t)) {
                const i = u[r];
                if (i)
                    for (const a of i)
                        add(a, t[r]);
                else
                    add(r, t[r])
            }
            return r
        }
        const h = expandAliases(o)
          , m = expandAliases(a.nodes)
          , T = expandAliases(a.list);
        function find(t, r, i, a) {
            const o = t[r.type];
            return o ? o(r, i, a) : null
        }
        function needsWhitespace(t, r, i) {
            if (!t)
                return 0;
            c(t) && (t = t.expression);
            let a = find(m, t, r);
            if (!a) {
                const o = find(T, t, r);
                if (o)
                    for (let r = 0; r < o.length && (a = needsWhitespace(o[r], t, i),
                    !a); r++)
                        ;
            }
            return "object" == typeof a && null !== a && a[i] || 0
        }
    },
    "Q/XA": function(t, r, i) {
        var a = i("SxUr").SourceMapGenerator
          , o = i("ub0H")
          , l = /(\r?\n)/
          , u = "$$$isSourceNode$$$";
        function SourceNode(t, r, i, a, o) {
            this.children = [],
            this.sourceContents = {},
            this.line = null == t ? null : t,
            this.column = null == r ? null : r,
            this.source = null == i ? null : i,
            this.name = null == o ? null : o,
            this[u] = !0,
            null != a && this.add(a)
        }
        SourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(t, r, i) {
            var a = new SourceNode
              , u = t.split(l)
              , p = 0
              , shiftNextLine = function() {
                return getNextLine() + (getNextLine() || "");
                function getNextLine() {
                    return p < u.length ? u[p++] : void 0
                }
            }
              , c = 1
              , d = 0
              , y = null;
            return r.eachMapping((function(t) {
                if (null !== y) {
                    if (!(c < t.generatedLine)) {
                        var r = (i = u[p]).substr(0, t.generatedColumn - d);
                        return u[p] = i.substr(t.generatedColumn - d),
                        d = t.generatedColumn,
                        addMappingWithCode(y, r),
                        void (y = t)
                    }
                    addMappingWithCode(y, shiftNextLine()),
                    c++,
                    d = 0
                }
                for (; c < t.generatedLine; )
                    a.add(shiftNextLine()),
                    c++;
                if (d < t.generatedColumn) {
                    var i = u[p];
                    a.add(i.substr(0, t.generatedColumn)),
                    u[p] = i.substr(t.generatedColumn),
                    d = t.generatedColumn
                }
                y = t
            }
            ), this),
            p < u.length && (y && addMappingWithCode(y, shiftNextLine()),
            a.add(u.splice(p).join(""))),
            r.sources.forEach((function(t) {
                var l = r.sourceContentFor(t);
                null != l && (null != i && (t = o.join(i, t)),
                a.setSourceContent(t, l))
            }
            )),
            a;
            function addMappingWithCode(t, r) {
                if (null === t || void 0 === t.source)
                    a.add(r);
                else {
                    var l = i ? o.join(i, t.source) : t.source;
                    a.add(new SourceNode(t.originalLine,t.originalColumn,l,r,t.name))
                }
            }
        }
        ,
        SourceNode.prototype.add = function SourceNode_add(t) {
            if (Array.isArray(t))
                t.forEach((function(t) {
                    this.add(t)
                }
                ), this);
            else {
                if (!t[u] && "string" != typeof t)
                    throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + t);
                t && this.children.push(t)
            }
            return this
        }
        ,
        SourceNode.prototype.prepend = function SourceNode_prepend(t) {
            if (Array.isArray(t))
                for (var r = t.length - 1; r >= 0; r--)
                    this.prepend(t[r]);
            else {
                if (!t[u] && "string" != typeof t)
                    throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + t);
                this.children.unshift(t)
            }
            return this
        }
        ,
        SourceNode.prototype.walk = function SourceNode_walk(t) {
            for (var r, i = 0, a = this.children.length; i < a; i++)
                (r = this.children[i])[u] ? r.walk(t) : "" !== r && t(r, {
                    source: this.source,
                    line: this.line,
                    column: this.column,
                    name: this.name
                })
        }
        ,
        SourceNode.prototype.join = function SourceNode_join(t) {
            var r, i, a = this.children.length;
            if (a > 0) {
                for (r = [],
                i = 0; i < a - 1; i++)
                    r.push(this.children[i]),
                    r.push(t);
                r.push(this.children[i]),
                this.children = r
            }
            return this
        }
        ,
        SourceNode.prototype.replaceRight = function SourceNode_replaceRight(t, r) {
            var i = this.children[this.children.length - 1];
            return i[u] ? i.replaceRight(t, r) : "string" == typeof i ? this.children[this.children.length - 1] = i.replace(t, r) : this.children.push("".replace(t, r)),
            this
        }
        ,
        SourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(t, r) {
            this.sourceContents[o.toSetString(t)] = r
        }
        ,
        SourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents(t) {
            for (var r = 0, i = this.children.length; r < i; r++)
                this.children[r][u] && this.children[r].walkSourceContents(t);
            var a = Object.keys(this.sourceContents);
            for (r = 0,
            i = a.length; r < i; r++)
                t(o.fromSetString(a[r]), this.sourceContents[a[r]])
        }
        ,
        SourceNode.prototype.toString = function SourceNode_toString() {
            var t = "";
            return this.walk((function(r) {
                t += r
            }
            )),
            t
        }
        ,
        SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(t) {
            var r = {
                code: "",
                line: 1,
                column: 0
            }
              , i = new a(t)
              , o = !1
              , l = null
              , u = null
              , p = null
              , c = null;
            return this.walk((function(t, a) {
                r.code += t,
                null !== a.source && null !== a.line && null !== a.column ? (l === a.source && u === a.line && p === a.column && c === a.name || i.addMapping({
                    source: a.source,
                    original: {
                        line: a.line,
                        column: a.column
                    },
                    generated: {
                        line: r.line,
                        column: r.column
                    },
                    name: a.name
                }),
                l = a.source,
                u = a.line,
                p = a.column,
                c = a.name,
                o = !0) : o && (i.addMapping({
                    generated: {
                        line: r.line,
                        column: r.column
                    }
                }),
                l = null,
                o = !1);
                for (var d = 0, y = t.length; d < y; d++)
                    10 === t.charCodeAt(d) ? (r.line++,
                    r.column = 0,
                    d + 1 === y ? (l = null,
                    o = !1) : o && i.addMapping({
                        source: a.source,
                        original: {
                            line: a.line,
                            column: a.column
                        },
                        generated: {
                            line: r.line,
                            column: r.column
                        },
                        name: a.name
                    })) : r.column++
            }
            )),
            this.walkSourceContents((function(t, r) {
                i.setSourceContent(t, r)
            }
            )),
            {
                code: r.code,
                map: i
            }
        }
        ,
        r.SourceNode = SourceNode
    },
    QKP5: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function isVar(t) {
            return (0,
            a.isVariableDeclaration)(t, {
                kind: "var"
            }) && !t[o.BLOCK_SCOPED_SYMBOL]
        }
        ;
        var a = i("xIU+")
          , o = i("kEZX")
    },
    QmCO: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.PLACEHOLDERS_FLIPPED_ALIAS = r.PLACEHOLDERS_ALIAS = r.PLACEHOLDERS = void 0;
        var a = i("aaMo")
          , o = ["Identifier", "StringLiteral", "Expression", "Statement", "Declaration", "BlockStatement", "ClassBody", "Pattern"];
        r.PLACEHOLDERS = o;
        var l = {
            Declaration: ["Statement"],
            Pattern: ["PatternLike", "LVal"]
        };
        r.PLACEHOLDERS_ALIAS = l;
        for (var u = 0, p = o; u < p.length; u++) {
            var c = p[u]
              , d = a.ALIAS_KEYS[c];
            null != d && d.length && (l[c] = d)
        }
        var y = {};
        r.PLACEHOLDERS_FLIPPED_ALIAS = y,
        Object.keys(l).forEach((function(t) {
            l[t].forEach((function(r) {
                Object.hasOwnProperty.call(y, r) || (y[r] = []),
                y[r].push(t)
            }
            ))
        }
        ))
    },
    QoWe: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function inheritTrailingComments(t, r) {
            (0,
            a.default)("trailingComments", t, r)
        }
        ;
        var a = i("ExWc")
    },
    Qveh: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function cloneDeep(t) {
            return (0,
            a.default)(t)
        }
        ;
        var a = i("sN7J")
    },
    RFFR: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function isBinding(t, r, i) {
            if (i && "Identifier" === t.type && "ObjectProperty" === r.type && "ObjectExpression" === i.type)
                return !1;
            const o = a.default.keys[r.type];
            if (o)
                for (let i = 0; i < o.length; i++) {
                    const a = o[i]
                      , l = r[a];
                    if (Array.isArray(l)) {
                        if (l.indexOf(t) >= 0)
                            return !0
                    } else if (l === t)
                        return !0
                }
            return !1
        }
        ;
        var a = i("wffa")
    },
    RNM3: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = void 0;
        var a = i("61uC")
          , o = function createTypeAnnotationBasedOnTypeof(t) {
            switch (t) {
            case "string":
                return (0,
                a.stringTypeAnnotation)();
            case "number":
                return (0,
                a.numberTypeAnnotation)();
            case "undefined":
                return (0,
                a.voidTypeAnnotation)();
            case "boolean":
                return (0,
                a.booleanTypeAnnotation)();
            case "function":
                return (0,
                a.genericTypeAnnotation)((0,
                a.identifier)("Function"));
            case "object":
                return (0,
                a.genericTypeAnnotation)((0,
                a.identifier)("Object"));
            case "symbol":
                return (0,
                a.genericTypeAnnotation)((0,
                a.identifier)("Symbol"));
            case "bigint":
                return (0,
                a.anyTypeAnnotation)()
            }
            throw new Error("Invalid typeof value: " + t)
        };
        r.default = o
    },
    RRSc: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function isCompatTag(t) {
            return !!t && /^[a-z]/.test(t)
        }
    },
    RS7Y: function(t, r, i) {
        "use strict";
        var a = i("TqRt")(i("RIqP"));
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.NOT_LOCAL_BINDING = r.BLOCK_SCOPED_SYMBOL = r.INHERIT_KEYS = r.UNARY_OPERATORS = r.STRING_UNARY_OPERATORS = r.NUMBER_UNARY_OPERATORS = r.BOOLEAN_UNARY_OPERATORS = r.ASSIGNMENT_OPERATORS = r.BINARY_OPERATORS = r.NUMBER_BINARY_OPERATORS = r.BOOLEAN_BINARY_OPERATORS = r.COMPARISON_BINARY_OPERATORS = r.EQUALITY_BINARY_OPERATORS = r.BOOLEAN_NUMBER_BINARY_OPERATORS = r.UPDATE_OPERATORS = r.LOGICAL_OPERATORS = r.COMMENT_KEYS = r.FOR_INIT_KEYS = r.FLATTENABLE_KEYS = r.STATEMENT_OR_BLOCK_KEYS = void 0;
        r.STATEMENT_OR_BLOCK_KEYS = ["consequent", "body", "alternate"];
        r.FLATTENABLE_KEYS = ["body", "expressions"];
        r.FOR_INIT_KEYS = ["left", "init"];
        r.COMMENT_KEYS = ["leadingComments", "trailingComments", "innerComments"];
        var o = ["||", "&&", "??"];
        r.LOGICAL_OPERATORS = o;
        r.UPDATE_OPERATORS = ["++", "--"];
        var l = [">", "<", ">=", "<="];
        r.BOOLEAN_NUMBER_BINARY_OPERATORS = l;
        var u = ["==", "===", "!=", "!=="];
        r.EQUALITY_BINARY_OPERATORS = u;
        var p = [].concat(u, ["in", "instanceof"]);
        r.COMPARISON_BINARY_OPERATORS = p;
        var c = [].concat((0,
        a.default)(p), l);
        r.BOOLEAN_BINARY_OPERATORS = c;
        var d = ["-", "/", "%", "*", "**", "&", "|", ">>", ">>>", "<<", "^"];
        r.NUMBER_BINARY_OPERATORS = d;
        var y = ["+"].concat(d, (0,
        a.default)(c));
        r.BINARY_OPERATORS = y;
        var h = ["=", "+="].concat((0,
        a.default)(d.map((function(t) {
            return t + "="
        }
        ))), (0,
        a.default)(o.map((function(t) {
            return t + "="
        }
        ))));
        r.ASSIGNMENT_OPERATORS = h;
        var m = ["delete", "!"];
        r.BOOLEAN_UNARY_OPERATORS = m;
        var T = ["+", "-", "~"];
        r.NUMBER_UNARY_OPERATORS = T;
        var S = ["typeof"];
        r.STRING_UNARY_OPERATORS = S;
        var g = ["void", "throw"].concat(m, T, S);
        r.UNARY_OPERATORS = g;
        r.INHERIT_KEYS = {
            optional: ["typeAnnotation", "typeParameters", "returnType"],
            force: ["start", "loc", "end"]
        };
        var b = Symbol.for("var used to be block scoped");
        r.BLOCK_SCOPED_SYMBOL = b;
        var v = Symbol.for("should not be considered a local binding");
        r.NOT_LOCAL_BINDING = v
    },
    Rd5i: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function toBindingIdentifierName(t) {
            "eval" !== (t = (0,
            a.default)(t)) && "arguments" !== t || (t = "_" + t);
            return t
        }
        ;
        var a = i("wv99")
    },
    Resm: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        Object.defineProperty(r, "VISITOR_KEYS", {
            enumerable: !0,
            get: function get() {
                return o.VISITOR_KEYS
            }
        }),
        Object.defineProperty(r, "ALIAS_KEYS", {
            enumerable: !0,
            get: function get() {
                return o.ALIAS_KEYS
            }
        }),
        Object.defineProperty(r, "FLIPPED_ALIAS_KEYS", {
            enumerable: !0,
            get: function get() {
                return o.FLIPPED_ALIAS_KEYS
            }
        }),
        Object.defineProperty(r, "NODE_FIELDS", {
            enumerable: !0,
            get: function get() {
                return o.NODE_FIELDS
            }
        }),
        Object.defineProperty(r, "BUILDER_KEYS", {
            enumerable: !0,
            get: function get() {
                return o.BUILDER_KEYS
            }
        }),
        Object.defineProperty(r, "DEPRECATED_KEYS", {
            enumerable: !0,
            get: function get() {
                return o.DEPRECATED_KEYS
            }
        }),
        Object.defineProperty(r, "NODE_PARENT_VALIDATIONS", {
            enumerable: !0,
            get: function get() {
                return o.NODE_PARENT_VALIDATIONS
            }
        }),
        Object.defineProperty(r, "PLACEHOLDERS", {
            enumerable: !0,
            get: function get() {
                return l.PLACEHOLDERS
            }
        }),
        Object.defineProperty(r, "PLACEHOLDERS_ALIAS", {
            enumerable: !0,
            get: function get() {
                return l.PLACEHOLDERS_ALIAS
            }
        }),
        Object.defineProperty(r, "PLACEHOLDERS_FLIPPED_ALIAS", {
            enumerable: !0,
            get: function get() {
                return l.PLACEHOLDERS_FLIPPED_ALIAS
            }
        }),
        r.TYPES = void 0;
        var a = i("0ZK1");
        i("DrtQ"),
        i("UiF8"),
        i("ZeCc"),
        i("ag9y"),
        i("5uIQ"),
        i("lxMW");
        var o = i("7ePq")
          , l = i("5Y2g");
        a(o.VISITOR_KEYS),
        a(o.ALIAS_KEYS),
        a(o.FLIPPED_ALIAS_KEYS),
        a(o.NODE_FIELDS),
        a(o.BUILDER_KEYS),
        a(o.DEPRECATED_KEYS),
        a(l.PLACEHOLDERS_ALIAS),
        a(l.PLACEHOLDERS_FLIPPED_ALIAS);
        var u = Object.keys(o.VISITOR_KEYS).concat(Object.keys(o.FLIPPED_ALIAS_KEYS)).concat(Object.keys(o.DEPRECATED_KEYS));
        r.TYPES = u
    },
    RwJ3: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function addComments(t, r, i) {
            if (!i || !t)
                return t;
            const a = r + "Comments";
            t[a] ? "leading" === r ? t[a] = i.concat(t[a]) : t[a].push(...i) : t[a] = i;
            return t
        }
    },
    SCtg: function(t, r, i) {
        "use strict";
        var a = i("TqRt")
          , o = a(i("lwsE"))
          , l = a(i("W8MJ"))
          , u = function() {
            function Reference(t, r, i, a, l, u, p) {
                (0,
                o.default)(this, Reference),
                this.identifier = t,
                this.from = r,
                this.tainted = !1,
                this.resolved = null,
                this.flag = i,
                this.isWrite() && (this.writeExpr = a,
                this.partial = u,
                this.init = p),
                this.__maybeImplicitGlobal = l
            }
            return (0,
            l.default)(Reference, [{
                key: "isStatic",
                value: function isStatic() {
                    return !this.tainted && this.resolved && this.resolved.scope.isStatic()
                }
            }, {
                key: "isWrite",
                value: function isWrite() {
                    return !!(this.flag & Reference.WRITE)
                }
            }, {
                key: "isRead",
                value: function isRead() {
                    return !!(this.flag & Reference.READ)
                }
            }, {
                key: "isReadOnly",
                value: function isReadOnly() {
                    return this.flag === Reference.READ
                }
            }, {
                key: "isWriteOnly",
                value: function isWriteOnly() {
                    return this.flag === Reference.WRITE
                }
            }, {
                key: "isReadWrite",
                value: function isReadWrite() {
                    return this.flag === Reference.RW
                }
            }]),
            Reference
        }();
        u.READ = 1,
        u.WRITE = 2,
        u.RW = 3,
        t.exports = u
    },
    SDP1: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function isValidES3Identifier(t) {
            return (0,
            a.default)(t) && !o.has(t)
        }
        ;
        var a = i("yK+d")
          , o = new Set(["abstract", "boolean", "byte", "char", "double", "enum", "final", "float", "goto", "implements", "int", "interface", "long", "native", "package", "private", "protected", "public", "short", "static", "synchronized", "throws", "transient", "volatile"])
    },
    SLOx: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function isReferenced(t, r, i) {
            switch (r.type) {
            case "MemberExpression":
            case "OptionalMemberExpression":
                return r.property === t ? !!r.computed : r.object === t;
            case "JSXMemberExpression":
                return r.object === t;
            case "VariableDeclarator":
                return r.init === t;
            case "ArrowFunctionExpression":
                return r.body === t;
            case "PrivateName":
                return !1;
            case "ClassMethod":
            case "ClassPrivateMethod":
            case "ObjectMethod":
                return r.key === t && !!r.computed;
            case "ObjectProperty":
                return r.key === t ? !!r.computed : !i || "ObjectPattern" !== i.type;
            case "ClassProperty":
                return r.key !== t || !!r.computed;
            case "ClassPrivateProperty":
                return r.key !== t;
            case "ClassDeclaration":
            case "ClassExpression":
                return r.superClass === t;
            case "AssignmentExpression":
            case "AssignmentPattern":
                return r.right === t;
            case "LabeledStatement":
            case "CatchClause":
            case "RestElement":
                return !1;
            case "BreakStatement":
            case "ContinueStatement":
                return !1;
            case "FunctionDeclaration":
            case "FunctionExpression":
                return !1;
            case "ExportNamespaceSpecifier":
            case "ExportDefaultSpecifier":
                return !1;
            case "ExportSpecifier":
                return (null == i || !i.source) && r.local === t;
            case "ImportDefaultSpecifier":
            case "ImportNamespaceSpecifier":
            case "ImportSpecifier":
            case "ImportAttribute":
            case "JSXAttribute":
                return !1;
            case "ObjectPattern":
            case "ArrayPattern":
            case "MetaProperty":
                return !1;
            case "ObjectTypeProperty":
                return r.key !== t;
            case "TSEnumMember":
                return r.id !== t;
            case "TSPropertySignature":
                return r.key !== t || !!r.computed
            }
            return !0
        }
    },
    SxUr: function(t, r, i) {
        var a = i("DW02")
          , o = i("ub0H")
          , l = i("kkH2").ArraySet
          , u = i("MRdt").MappingList;
        function SourceMapGenerator(t) {
            t || (t = {}),
            this._file = o.getArg(t, "file", null),
            this._sourceRoot = o.getArg(t, "sourceRoot", null),
            this._skipValidation = o.getArg(t, "skipValidation", !1),
            this._sources = new l,
            this._names = new l,
            this._mappings = new u,
            this._sourcesContents = null
        }
        SourceMapGenerator.prototype._version = 3,
        SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(t) {
            var r = t.sourceRoot
              , i = new SourceMapGenerator({
                file: t.file,
                sourceRoot: r
            });
            return t.eachMapping((function(t) {
                var a = {
                    generated: {
                        line: t.generatedLine,
                        column: t.generatedColumn
                    }
                };
                null != t.source && (a.source = t.source,
                null != r && (a.source = o.relative(r, a.source)),
                a.original = {
                    line: t.originalLine,
                    column: t.originalColumn
                },
                null != t.name && (a.name = t.name)),
                i.addMapping(a)
            }
            )),
            t.sources.forEach((function(r) {
                var a = t.sourceContentFor(r);
                null != a && i.setSourceContent(r, a)
            }
            )),
            i
        }
        ,
        SourceMapGenerator.prototype.addMapping = function SourceMapGenerator_addMapping(t) {
            var r = o.getArg(t, "generated")
              , i = o.getArg(t, "original", null)
              , a = o.getArg(t, "source", null)
              , l = o.getArg(t, "name", null);
            this._skipValidation || this._validateMapping(r, i, a, l),
            null != a && (a = String(a),
            this._sources.has(a) || this._sources.add(a)),
            null != l && (l = String(l),
            this._names.has(l) || this._names.add(l)),
            this._mappings.add({
                generatedLine: r.line,
                generatedColumn: r.column,
                originalLine: null != i && i.line,
                originalColumn: null != i && i.column,
                source: a,
                name: l
            })
        }
        ,
        SourceMapGenerator.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(t, r) {
            var i = t;
            null != this._sourceRoot && (i = o.relative(this._sourceRoot, i)),
            null != r ? (this._sourcesContents || (this._sourcesContents = Object.create(null)),
            this._sourcesContents[o.toSetString(i)] = r) : this._sourcesContents && (delete this._sourcesContents[o.toSetString(i)],
            0 === Object.keys(this._sourcesContents).length && (this._sourcesContents = null))
        }
        ,
        SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(t, r, i) {
            var a = r;
            if (null == r) {
                if (null == t.file)
                    throw new Error('SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map\'s "file" property. Both were omitted.');
                a = t.file
            }
            var u = this._sourceRoot;
            null != u && (a = o.relative(u, a));
            var p = new l
              , c = new l;
            this._mappings.unsortedForEach((function(r) {
                if (r.source === a && null != r.originalLine) {
                    var l = t.originalPositionFor({
                        line: r.originalLine,
                        column: r.originalColumn
                    });
                    null != l.source && (r.source = l.source,
                    null != i && (r.source = o.join(i, r.source)),
                    null != u && (r.source = o.relative(u, r.source)),
                    r.originalLine = l.line,
                    r.originalColumn = l.column,
                    null != l.name && (r.name = l.name))
                }
                var d = r.source;
                null == d || p.has(d) || p.add(d);
                var y = r.name;
                null == y || c.has(y) || c.add(y)
            }
            ), this),
            this._sources = p,
            this._names = c,
            t.sources.forEach((function(r) {
                var a = t.sourceContentFor(r);
                null != a && (null != i && (r = o.join(i, r)),
                null != u && (r = o.relative(u, r)),
                this.setSourceContent(r, a))
            }
            ), this)
        }
        ,
        SourceMapGenerator.prototype._validateMapping = function SourceMapGenerator_validateMapping(t, r, i, a) {
            if (r && "number" != typeof r.line && "number" != typeof r.column)
                throw new Error("original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values.");
            if ((!(t && "line"in t && "column"in t && t.line > 0 && t.column >= 0) || r || i || a) && !(t && "line"in t && "column"in t && r && "line"in r && "column"in r && t.line > 0 && t.column >= 0 && r.line > 0 && r.column >= 0 && i))
                throw new Error("Invalid mapping: " + JSON.stringify({
                    generated: t,
                    source: i,
                    original: r,
                    name: a
                }))
        }
        ,
        SourceMapGenerator.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
            for (var t, r, i, l, u = 0, p = 1, c = 0, d = 0, y = 0, h = 0, m = "", T = this._mappings.toArray(), S = 0, g = T.length; S < g; S++) {
                if (t = "",
                (r = T[S]).generatedLine !== p)
                    for (u = 0; r.generatedLine !== p; )
                        t += ";",
                        p++;
                else if (S > 0) {
                    if (!o.compareByGeneratedPositionsInflated(r, T[S - 1]))
                        continue;
                    t += ","
                }
                t += a.encode(r.generatedColumn - u),
                u = r.generatedColumn,
                null != r.source && (l = this._sources.indexOf(r.source),
                t += a.encode(l - h),
                h = l,
                t += a.encode(r.originalLine - 1 - d),
                d = r.originalLine - 1,
                t += a.encode(r.originalColumn - c),
                c = r.originalColumn,
                null != r.name && (i = this._names.indexOf(r.name),
                t += a.encode(i - y),
                y = i)),
                m += t
            }
            return m
        }
        ,
        SourceMapGenerator.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(t, r) {
            return t.map((function(t) {
                if (!this._sourcesContents)
                    return null;
                null != r && (t = o.relative(r, t));
                var i = o.toSetString(t);
                return Object.prototype.hasOwnProperty.call(this._sourcesContents, i) ? this._sourcesContents[i] : null
            }
            ), this)
        }
        ,
        SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {
            var t = {
                version: this._version,
                sources: this._sources.toArray(),
                names: this._names.toArray(),
                mappings: this._serializeMappings()
            };
            return null != this._file && (t.file = this._file),
            null != this._sourceRoot && (t.sourceRoot = this._sourceRoot),
            this._sourcesContents && (t.sourcesContent = this._generateSourcesContent(t.sources, t.sourceRoot)),
            t
        }
        ,
        SourceMapGenerator.prototype.toString = function SourceMapGenerator_toString() {
            return JSON.stringify(this.toJSON())
        }
        ,
        r.SourceMapGenerator = SourceMapGenerator
    },
    TR6X: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function removeComments(t) {
            return a.COMMENT_KEYS.forEach((function(r) {
                t[r] = null
            }
            )),
            t
        }
        ;
        var a = i("RS7Y")
    },
    TkAf: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function isReferenced(t, r, i) {
            switch (r.type) {
            case "MemberExpression":
            case "JSXMemberExpression":
            case "OptionalMemberExpression":
                return r.property === t ? !!r.computed : r.object === t;
            case "VariableDeclarator":
                return r.init === t;
            case "ArrowFunctionExpression":
                return r.body === t;
            case "PrivateName":
                return !1;
            case "ClassMethod":
            case "ClassPrivateMethod":
            case "ObjectMethod":
                if (r.params.includes(t))
                    return !1;
            case "ObjectProperty":
            case "ClassProperty":
            case "ClassPrivateProperty":
                return r.key === t ? !!r.computed : r.value !== t || (!i || "ObjectPattern" !== i.type);
            case "ClassDeclaration":
            case "ClassExpression":
                return r.superClass === t;
            case "AssignmentExpression":
            case "AssignmentPattern":
                return r.right === t;
            case "LabeledStatement":
            case "CatchClause":
            case "RestElement":
                return !1;
            case "BreakStatement":
            case "ContinueStatement":
                return !1;
            case "FunctionDeclaration":
            case "FunctionExpression":
                return !1;
            case "ExportNamespaceSpecifier":
            case "ExportDefaultSpecifier":
                return !1;
            case "ExportSpecifier":
                return (null == i || !i.source) && r.local === t;
            case "ImportDefaultSpecifier":
            case "ImportNamespaceSpecifier":
            case "ImportSpecifier":
            case "JSXAttribute":
                return !1;
            case "ObjectPattern":
            case "ArrayPattern":
            case "MetaProperty":
                return !1;
            case "ObjectTypeProperty":
                return r.key !== t;
            case "TSEnumMember":
                return r.id !== t;
            case "TSPropertySignature":
                return r.key !== t || !!r.computed
            }
            return !0
        }
    },
    TrjT: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function addComment(t, r, i, o) {
            return (0,
            a.default)(t, r, [{
                type: o ? "CommentLine" : "CommentBlock",
                value: i
            }])
        }
        ;
        var a = i("O4gS")
    },
    TuKl: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = void 0;
        var a = i("baCj")
          , o = i("Q/1+")
          , l = i("JSq2")
          , u = i("JwF5");
        const {isProgram: p, isFile: c, isEmptyStatement: d} = l
          , y = /e/i
          , h = /\.0+$/
          , m = /^0[box]/
          , T = /^\s*[@#]__PURE__\s*$/
          , {needsParens: S, needsWhitespaceAfter: g, needsWhitespaceBefore: b} = o;
        class Printer {
            constructor(t, r) {
                this.inForStatementInitCounter = 0,
                this._printStack = [],
                this._indent = 0,
                this._insideAux = !1,
                this._parenPushNewlineState = null,
                this._noLineTerminator = !1,
                this._printAuxAfterOnNextUserNode = !1,
                this._printedComments = new WeakSet,
                this._endsWithInteger = !1,
                this._endsWithWord = !1,
                this.format = t,
                this._buf = new a.default(r)
            }
            generate(t) {
                return this.print(t),
                this._maybeAddAuxComment(),
                this._buf.get()
            }
            indent() {
                this.format.compact || this.format.concise || this._indent++
            }
            dedent() {
                this.format.compact || this.format.concise || this._indent--
            }
            semicolon(t=!1) {
                this._maybeAddAuxComment(),
                this._append(";", !t)
            }
            rightBrace() {
                this.format.minified && this._buf.removeLastSemicolon(),
                this.token("}")
            }
            space(t=!1) {
                if (!this.format.compact)
                    if (t)
                        this._space();
                    else if (this._buf.hasContent()) {
                        const t = this.getLastChar();
                        32 !== t && 10 !== t && this._space()
                    }
            }
            word(t) {
                (this._endsWithWord || this.endsWith(47) && 47 === t.charCodeAt(0)) && this._space(),
                this._maybeAddAuxComment(),
                this._append(t),
                this._endsWithWord = !0
            }
            number(t) {
                this.word(t),
                this._endsWithInteger = Number.isInteger(+t) && !m.test(t) && !y.test(t) && !h.test(t) && 46 !== t.charCodeAt(t.length - 1)
            }
            token(t) {
                const r = this.getLastChar()
                  , i = t.charCodeAt(0);
                ("--" === t && 33 === r || 43 === i && 43 === r || 45 === i && 45 === r || 46 === i && this._endsWithInteger) && this._space(),
                this._maybeAddAuxComment(),
                this._append(t)
            }
            newline(t=1) {
                if (this.format.retainLines || this.format.compact)
                    return;
                if (this.format.concise)
                    return void this.space();
                const r = this.endsWithCharAndNewline();
                if (10 !== r && (123 !== r && 58 !== r || t--,
                !(t <= 0)))
                    for (let r = 0; r < t; r++)
                        this._newline()
            }
            endsWith(t) {
                return this.getLastChar() === t
            }
            getLastChar() {
                return this._buf.getLastChar()
            }
            endsWithCharAndNewline() {
                return this._buf.endsWithCharAndNewline()
            }
            removeTrailingNewline() {
                this._buf.removeTrailingNewline()
            }
            exactSource(t, r) {
                this._catchUp("start", t),
                this._buf.exactSource(t, r)
            }
            source(t, r) {
                this._catchUp(t, r),
                this._buf.source(t, r)
            }
            withSource(t, r, i) {
                this._catchUp(t, r),
                this._buf.withSource(t, r, i)
            }
            _space() {
                this._append(" ", !0)
            }
            _newline() {
                this._append("\n", !0)
            }
            _append(t, r=!1) {
                this._maybeAddParen(t),
                this._maybeIndent(t),
                r ? this._buf.queue(t) : this._buf.append(t),
                this._endsWithWord = !1,
                this._endsWithInteger = !1
            }
            _maybeIndent(t) {
                this._indent && this.endsWith(10) && 10 !== t.charCodeAt(0) && this._buf.queue(this._getIndent())
            }
            _maybeAddParen(t) {
                const r = this._parenPushNewlineState;
                if (!r)
                    return;
                let i;
                for (i = 0; i < t.length && " " === t[i]; i++)
                    continue;
                if (i === t.length)
                    return;
                const a = t[i];
                if ("\n" !== a) {
                    if ("/" !== a || i + 1 === t.length)
                        return void (this._parenPushNewlineState = null);
                    const r = t[i + 1];
                    if ("*" === r) {
                        if (T.test(t.slice(i + 2, t.length - 2)))
                            return
                    } else if ("/" !== r)
                        return void (this._parenPushNewlineState = null)
                }
                this.token("("),
                this.indent(),
                r.printed = !0
            }
            _catchUp(t, r) {
                if (!this.format.retainLines)
                    return;
                const i = r ? r[t] : null;
                if (null != (null == i ? void 0 : i.line)) {
                    const t = i.line - this._buf.getCurrentLine();
                    for (let r = 0; r < t; r++)
                        this._newline()
                }
            }
            _getIndent() {
                return this.format.indent.style.repeat(this._indent)
            }
            startTerminatorless(t=!1) {
                return t ? (this._noLineTerminator = !0,
                null) : this._parenPushNewlineState = {
                    printed: !1
                }
            }
            endTerminatorless(t) {
                this._noLineTerminator = !1,
                null != t && t.printed && (this.dedent(),
                this.newline(),
                this.token(")"))
            }
            print(t, r) {
                if (!t)
                    return;
                const i = this.format.concise;
                t._compact && (this.format.concise = !0);
                const a = this[t.type];
                if (!a)
                    throw new ReferenceError(`unknown node of type ${JSON.stringify(t.type)} with constructor ${JSON.stringify(null == t ? void 0 : t.constructor.name)}`);
                this._printStack.push(t);
                const o = this._insideAux;
                this._insideAux = !t.loc,
                this._maybeAddAuxComment(this._insideAux && !o);
                let l = S(t, r, this._printStack);
                this.format.retainFunctionParens && "FunctionExpression" === t.type && t.extra && t.extra.parenthesized && (l = !0),
                l && this.token("("),
                this._printLeadingComments(t);
                const u = p(t) || c(t) ? null : t.loc;
                this.withSource("start", u, ()=>{
                    a.call(this, t, r)
                }
                ),
                this._printTrailingComments(t),
                l && this.token(")"),
                this._printStack.pop(),
                this.format.concise = i,
                this._insideAux = o
            }
            _maybeAddAuxComment(t) {
                t && this._printAuxBeforeComment(),
                this._insideAux || this._printAuxAfterComment()
            }
            _printAuxBeforeComment() {
                if (this._printAuxAfterOnNextUserNode)
                    return;
                this._printAuxAfterOnNextUserNode = !0;
                const t = this.format.auxiliaryCommentBefore;
                t && this._printComment({
                    type: "CommentBlock",
                    value: t
                })
            }
            _printAuxAfterComment() {
                if (!this._printAuxAfterOnNextUserNode)
                    return;
                this._printAuxAfterOnNextUserNode = !1;
                const t = this.format.auxiliaryCommentAfter;
                t && this._printComment({
                    type: "CommentBlock",
                    value: t
                })
            }
            getPossibleRaw(t) {
                const r = t.extra;
                if (r && null != r.raw && null != r.rawValue && t.value === r.rawValue)
                    return r.raw
            }
            printJoin(t, r, i={}) {
                if (null == t || !t.length)
                    return;
                i.indent && this.indent();
                const a = {
                    addNewlines: i.addNewlines
                };
                for (let o = 0; o < t.length; o++) {
                    const l = t[o];
                    l && (i.statement && this._printNewline(!0, l, r, a),
                    this.print(l, r),
                    i.iterator && i.iterator(l, o),
                    i.separator && o < t.length - 1 && i.separator.call(this),
                    i.statement && this._printNewline(!1, l, r, a))
                }
                i.indent && this.dedent()
            }
            printAndIndentOnComments(t, r) {
                const i = t.leadingComments && t.leadingComments.length > 0;
                i && this.indent(),
                this.print(t, r),
                i && this.dedent()
            }
            printBlock(t) {
                const r = t.body;
                d(r) || this.space(),
                this.print(r, t)
            }
            _printTrailingComments(t) {
                this._printComments(this._getComments(!1, t))
            }
            _printLeadingComments(t) {
                this._printComments(this._getComments(!0, t), !0)
            }
            printInnerComments(t, r=!0) {
                var i;
                null != (i = t.innerComments) && i.length && (r && this.indent(),
                this._printComments(t.innerComments),
                r && this.dedent())
            }
            printSequence(t, r, i={}) {
                return i.statement = !0,
                this.printJoin(t, r, i)
            }
            printList(t, r, i={}) {
                return null == i.separator && (i.separator = commaSeparator),
                this.printJoin(t, r, i)
            }
            _printNewline(t, r, i, a) {
                if (this.format.retainLines || this.format.compact)
                    return;
                if (this.format.concise)
                    return void this.space();
                let o = 0;
                if (this._buf.hasContent()) {
                    t || o++,
                    a.addNewlines && (o += a.addNewlines(t, r) || 0),
                    (t ? b : g)(r, i) && o++
                }
                this.newline(Math.min(2, o))
            }
            _getComments(t, r) {
                return r && (t ? r.leadingComments : r.trailingComments) || []
            }
            _printComment(t, r) {
                if (!this.format.shouldPrintComment(t.value))
                    return;
                if (t.ignore)
                    return;
                if (this._printedComments.has(t))
                    return;
                this._printedComments.add(t);
                const i = "CommentBlock" === t.type
                  , a = i && !r && !this._noLineTerminator;
                a && this._buf.hasContent() && this.newline(1);
                const o = this.getLastChar();
                91 !== o && 123 !== o && this.space();
                let l = i || this._noLineTerminator ? `/*${t.value}*/` : `//${t.value}\n`;
                if (i && this.format.indent.adjustMultilineComment) {
                    var u;
                    const r = null == (u = t.loc) ? void 0 : u.start.column;
                    if (r) {
                        const t = new RegExp("\\n\\s{1," + r + "}","g");
                        l = l.replace(t, "\n")
                    }
                    const i = Math.max(this._getIndent().length, this.format.retainLines ? 0 : this._buf.getCurrentColumn());
                    l = l.replace(/\n(?!$)/g, "\n" + " ".repeat(i))
                }
                this.endsWith(47) && this._space(),
                this.withSource("start", t.loc, ()=>{
                    this._append(l)
                }
                ),
                a && this.newline(1)
            }
            _printComments(t, r) {
                if (null != t && t.length)
                    if (r && 1 === t.length && T.test(t[0].value))
                        this._printComment(t[0], this._buf.hasContent() && !this.endsWith(10));
                    else
                        for (const r of t)
                            this._printComment(r)
            }
            printAssertions(t) {
                var r;
                null != (r = t.assertions) && r.length && (this.space(),
                this.word("assert"),
                this.space(),
                this.token("{"),
                this.space(),
                this.printList(t.assertions, t),
                this.space(),
                this.token("}"))
            }
        }
        Object.assign(Printer.prototype, u),
        Printer.prototype.Noop = function Noop() {}
        ;
        var v = Printer;
        function commaSeparator() {
            this.token(","),
            this.space()
        }
        r.default = v
    },
    TyJS: function(t, r, i) {
        "use strict";
        t.exports = {
            aliceblue: [240, 248, 255],
            antiquewhite: [250, 235, 215],
            aqua: [0, 255, 255],
            aquamarine: [127, 255, 212],
            azure: [240, 255, 255],
            beige: [245, 245, 220],
            bisque: [255, 228, 196],
            black: [0, 0, 0],
            blanchedalmond: [255, 235, 205],
            blue: [0, 0, 255],
            blueviolet: [138, 43, 226],
            brown: [165, 42, 42],
            burlywood: [222, 184, 135],
            cadetblue: [95, 158, 160],
            chartreuse: [127, 255, 0],
            chocolate: [210, 105, 30],
            coral: [255, 127, 80],
            cornflowerblue: [100, 149, 237],
            cornsilk: [255, 248, 220],
            crimson: [220, 20, 60],
            cyan: [0, 255, 255],
            darkblue: [0, 0, 139],
            darkcyan: [0, 139, 139],
            darkgoldenrod: [184, 134, 11],
            darkgray: [169, 169, 169],
            darkgreen: [0, 100, 0],
            darkgrey: [169, 169, 169],
            darkkhaki: [189, 183, 107],
            darkmagenta: [139, 0, 139],
            darkolivegreen: [85, 107, 47],
            darkorange: [255, 140, 0],
            darkorchid: [153, 50, 204],
            darkred: [139, 0, 0],
            darksalmon: [233, 150, 122],
            darkseagreen: [143, 188, 143],
            darkslateblue: [72, 61, 139],
            darkslategray: [47, 79, 79],
            darkslategrey: [47, 79, 79],
            darkturquoise: [0, 206, 209],
            darkviolet: [148, 0, 211],
            deeppink: [255, 20, 147],
            deepskyblue: [0, 191, 255],
            dimgray: [105, 105, 105],
            dimgrey: [105, 105, 105],
            dodgerblue: [30, 144, 255],
            firebrick: [178, 34, 34],
            floralwhite: [255, 250, 240],
            forestgreen: [34, 139, 34],
            fuchsia: [255, 0, 255],
            gainsboro: [220, 220, 220],
            ghostwhite: [248, 248, 255],
            gold: [255, 215, 0],
            goldenrod: [218, 165, 32],
            gray: [128, 128, 128],
            green: [0, 128, 0],
            greenyellow: [173, 255, 47],
            grey: [128, 128, 128],
            honeydew: [240, 255, 240],
            hotpink: [255, 105, 180],
            indianred: [205, 92, 92],
            indigo: [75, 0, 130],
            ivory: [255, 255, 240],
            khaki: [240, 230, 140],
            lavender: [230, 230, 250],
            lavenderblush: [255, 240, 245],
            lawngreen: [124, 252, 0],
            lemonchiffon: [255, 250, 205],
            lightblue: [173, 216, 230],
            lightcoral: [240, 128, 128],
            lightcyan: [224, 255, 255],
            lightgoldenrodyellow: [250, 250, 210],
            lightgray: [211, 211, 211],
            lightgreen: [144, 238, 144],
            lightgrey: [211, 211, 211],
            lightpink: [255, 182, 193],
            lightsalmon: [255, 160, 122],
            lightseagreen: [32, 178, 170],
            lightskyblue: [135, 206, 250],
            lightslategray: [119, 136, 153],
            lightslategrey: [119, 136, 153],
            lightsteelblue: [176, 196, 222],
            lightyellow: [255, 255, 224],
            lime: [0, 255, 0],
            limegreen: [50, 205, 50],
            linen: [250, 240, 230],
            magenta: [255, 0, 255],
            maroon: [128, 0, 0],
            mediumaquamarine: [102, 205, 170],
            mediumblue: [0, 0, 205],
            mediumorchid: [186, 85, 211],
            mediumpurple: [147, 112, 219],
            mediumseagreen: [60, 179, 113],
            mediumslateblue: [123, 104, 238],
            mediumspringgreen: [0, 250, 154],
            mediumturquoise: [72, 209, 204],
            mediumvioletred: [199, 21, 133],
            midnightblue: [25, 25, 112],
            mintcream: [245, 255, 250],
            mistyrose: [255, 228, 225],
            moccasin: [255, 228, 181],
            navajowhite: [255, 222, 173],
            navy: [0, 0, 128],
            oldlace: [253, 245, 230],
            olive: [128, 128, 0],
            olivedrab: [107, 142, 35],
            orange: [255, 165, 0],
            orangered: [255, 69, 0],
            orchid: [218, 112, 214],
            palegoldenrod: [238, 232, 170],
            palegreen: [152, 251, 152],
            paleturquoise: [175, 238, 238],
            palevioletred: [219, 112, 147],
            papayawhip: [255, 239, 213],
            peachpuff: [255, 218, 185],
            peru: [205, 133, 63],
            pink: [255, 192, 203],
            plum: [221, 160, 221],
            powderblue: [176, 224, 230],
            purple: [128, 0, 128],
            rebeccapurple: [102, 51, 153],
            red: [255, 0, 0],
            rosybrown: [188, 143, 143],
            royalblue: [65, 105, 225],
            saddlebrown: [139, 69, 19],
            salmon: [250, 128, 114],
            sandybrown: [244, 164, 96],
            seagreen: [46, 139, 87],
            seashell: [255, 245, 238],
            sienna: [160, 82, 45],
            silver: [192, 192, 192],
            skyblue: [135, 206, 235],
            slateblue: [106, 90, 205],
            slategray: [112, 128, 144],
            slategrey: [112, 128, 144],
            snow: [255, 250, 250],
            springgreen: [0, 255, 127],
            steelblue: [70, 130, 180],
            tan: [210, 180, 140],
            teal: [0, 128, 128],
            thistle: [216, 191, 216],
            tomato: [255, 99, 71],
            turquoise: [64, 224, 208],
            violet: [238, 130, 238],
            wheat: [245, 222, 179],
            white: [255, 255, 255],
            whitesmoke: [245, 245, 245],
            yellow: [255, 255, 0],
            yellowgreen: [154, 205, 50]
        }
    },
    U7Gz: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function isCompatTag(t) {
            return !!t && /^[a-z]/.test(t)
        }
    },
    UHlb: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        Object.defineProperty(r, "ALIAS_KEYS", {
            enumerable: !0,
            get: function get() {
                return o.ALIAS_KEYS
            }
        }),
        Object.defineProperty(r, "BUILDER_KEYS", {
            enumerable: !0,
            get: function get() {
                return o.BUILDER_KEYS
            }
        }),
        Object.defineProperty(r, "DEPRECATED_KEYS", {
            enumerable: !0,
            get: function get() {
                return o.DEPRECATED_KEYS
            }
        }),
        Object.defineProperty(r, "FLIPPED_ALIAS_KEYS", {
            enumerable: !0,
            get: function get() {
                return o.FLIPPED_ALIAS_KEYS
            }
        }),
        Object.defineProperty(r, "NODE_FIELDS", {
            enumerable: !0,
            get: function get() {
                return o.NODE_FIELDS
            }
        }),
        Object.defineProperty(r, "NODE_PARENT_VALIDATIONS", {
            enumerable: !0,
            get: function get() {
                return o.NODE_PARENT_VALIDATIONS
            }
        }),
        Object.defineProperty(r, "PLACEHOLDERS", {
            enumerable: !0,
            get: function get() {
                return l.PLACEHOLDERS
            }
        }),
        Object.defineProperty(r, "PLACEHOLDERS_ALIAS", {
            enumerable: !0,
            get: function get() {
                return l.PLACEHOLDERS_ALIAS
            }
        }),
        Object.defineProperty(r, "PLACEHOLDERS_FLIPPED_ALIAS", {
            enumerable: !0,
            get: function get() {
                return l.PLACEHOLDERS_FLIPPED_ALIAS
            }
        }),
        r.TYPES = void 0,
        Object.defineProperty(r, "VISITOR_KEYS", {
            enumerable: !0,
            get: function get() {
                return o.VISITOR_KEYS
            }
        });
        var a = i("0ZK1");
        i("z6L1"),
        i("dr59"),
        i("wh3u"),
        i("A5Ry"),
        i("fivu"),
        i("EYvB");
        var o = i("aaMo")
          , l = i("QmCO");
        a(o.VISITOR_KEYS),
        a(o.ALIAS_KEYS),
        a(o.FLIPPED_ALIAS_KEYS),
        a(o.NODE_FIELDS),
        a(o.BUILDER_KEYS),
        a(o.DEPRECATED_KEYS),
        a(l.PLACEHOLDERS_ALIAS),
        a(l.PLACEHOLDERS_FLIPPED_ALIAS);
        var u = [].concat(Object.keys(o.VISITOR_KEYS), Object.keys(o.FLIPPED_ALIAS_KEYS), Object.keys(o.DEPRECATED_KEYS));
        r.TYPES = u
    },
    UcGn: function(t, r, i) {
        "use strict";
        (function(a) {
            var o;
            r.formatArgs = function formatArgs(r) {
                if (r[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + r[0] + (this.useColors ? "%c " : " ") + "+" + t.exports.humanize(this.diff),
                !this.useColors)
                    return;
                var i = "color: " + this.color;
                r.splice(1, 0, i, "color: inherit");
                var a = 0
                  , o = 0;
                r[0].replace(/%[a-zA-Z%]/g, (function(t) {
                    "%%" !== t && (a++,
                    "%c" === t && (o = a))
                }
                )),
                r.splice(o, 0, i)
            }
            ,
            r.save = function save(t) {
                try {
                    t ? r.storage.setItem("debug", t) : r.storage.removeItem("debug")
                } catch (t) {}
            }
            ,
            r.load = function load() {
                var t;
                try {
                    t = r.storage.getItem("debug")
                } catch (t) {}
                !t && void 0 !== a && "env"in a && (t = a.env.DEBUG);
                return t
            }
            ,
            r.useColors = function useColors() {
                if ("undefined" != typeof window && window.process && ("renderer" === window.process.type || window.process.__nwjs))
                    return !0;
                if ("undefined" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/))
                    return !1;
                return "undefined" != typeof document && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || "undefined" != typeof window && window.console && (window.console.firebug || window.console.exception && window.console.table) || "undefined" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || "undefined" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/)
            }
            ,
            r.storage = function localstorage() {
                try {
                    return localStorage
                } catch (t) {}
            }(),
            r.destroy = (o = !1,
            function() {
                o || (o = !0,
                console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."))
            }
            ),
            r.colors = ["#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33"],
            r.log = console.debug || console.log || function() {}
            ,
            t.exports = i("4HAq")(r),
            t.exports.formatters.j = function(t) {
                try {
                    return JSON.stringify(t)
                } catch (t) {
                    return "[UnexpectedJSONParseError]: " + t.message
                }
            }
        }
        ).call(this, i("8oxB"))
    },
    UiF8: function(t, r, i) {
        "use strict";
        var a = i("7ePq")
          , o = function defineInterfaceishType(t) {
            var r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "TypeParameterDeclaration";
            (0,
            a.default)(t, {
                builder: ["id", "typeParameters", "extends", "body"],
                visitor: ["id", "typeParameters", "extends", "mixins", "implements", "body"],
                aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
                fields: {
                    id: (0,
                    a.validateType)("Identifier"),
                    typeParameters: (0,
                    a.validateOptionalType)(r),
                    extends: (0,
                    a.validateOptional)((0,
                    a.arrayOfType)("InterfaceExtends")),
                    mixins: (0,
                    a.validateOptional)((0,
                    a.arrayOfType)("InterfaceExtends")),
                    implements: (0,
                    a.validateOptional)((0,
                    a.arrayOfType)("ClassImplements")),
                    body: (0,
                    a.validateType)("ObjectTypeAnnotation")
                }
            })
        };
        (0,
        a.default)("AnyTypeAnnotation", {
            aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
        }),
        (0,
        a.default)("ArrayTypeAnnotation", {
            visitor: ["elementType"],
            aliases: ["Flow", "FlowType"],
            fields: {
                elementType: (0,
                a.validateType)("FlowType")
            }
        }),
        (0,
        a.default)("BooleanTypeAnnotation", {
            aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
        }),
        (0,
        a.default)("BooleanLiteralTypeAnnotation", {
            builder: ["value"],
            aliases: ["Flow", "FlowType"],
            fields: {
                value: (0,
                a.validate)((0,
                a.assertValueType)("boolean"))
            }
        }),
        (0,
        a.default)("NullLiteralTypeAnnotation", {
            aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
        }),
        (0,
        a.default)("ClassImplements", {
            visitor: ["id", "typeParameters"],
            aliases: ["Flow"],
            fields: {
                id: (0,
                a.validateType)("Identifier"),
                typeParameters: (0,
                a.validateOptionalType)("TypeParameterInstantiation")
            }
        }),
        o("DeclareClass"),
        (0,
        a.default)("DeclareFunction", {
            visitor: ["id"],
            aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
            fields: {
                id: (0,
                a.validateType)("Identifier"),
                predicate: (0,
                a.validateOptionalType)("DeclaredPredicate")
            }
        }),
        o("DeclareInterface"),
        (0,
        a.default)("DeclareModule", {
            builder: ["id", "body", "kind"],
            visitor: ["id", "body"],
            aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
            fields: {
                id: (0,
                a.validateType)(["Identifier", "StringLiteral"]),
                body: (0,
                a.validateType)("BlockStatement"),
                kind: (0,
                a.validateOptional)((0,
                a.assertOneOf)("CommonJS", "ES"))
            }
        }),
        (0,
        a.default)("DeclareModuleExports", {
            visitor: ["typeAnnotation"],
            aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
            fields: {
                typeAnnotation: (0,
                a.validateType)("TypeAnnotation")
            }
        }),
        (0,
        a.default)("DeclareTypeAlias", {
            visitor: ["id", "typeParameters", "right"],
            aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
            fields: {
                id: (0,
                a.validateType)("Identifier"),
                typeParameters: (0,
                a.validateOptionalType)("TypeParameterDeclaration"),
                right: (0,
                a.validateType)("FlowType")
            }
        }),
        (0,
        a.default)("DeclareOpaqueType", {
            visitor: ["id", "typeParameters", "supertype"],
            aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
            fields: {
                id: (0,
                a.validateType)("Identifier"),
                typeParameters: (0,
                a.validateOptionalType)("TypeParameterDeclaration"),
                supertype: (0,
                a.validateOptionalType)("FlowType"),
                impltype: (0,
                a.validateOptionalType)("FlowType")
            }
        }),
        (0,
        a.default)("DeclareVariable", {
            visitor: ["id"],
            aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
            fields: {
                id: (0,
                a.validateType)("Identifier")
            }
        }),
        (0,
        a.default)("DeclareExportDeclaration", {
            visitor: ["declaration", "specifiers", "source"],
            aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
            fields: {
                declaration: (0,
                a.validateOptionalType)("Flow"),
                specifiers: (0,
                a.validateOptional)((0,
                a.arrayOfType)(["ExportSpecifier", "ExportNamespaceSpecifier"])),
                source: (0,
                a.validateOptionalType)("StringLiteral"),
                default: (0,
                a.validateOptional)((0,
                a.assertValueType)("boolean"))
            }
        }),
        (0,
        a.default)("DeclareExportAllDeclaration", {
            visitor: ["source"],
            aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
            fields: {
                source: (0,
                a.validateType)("StringLiteral"),
                exportKind: (0,
                a.validateOptional)((0,
                a.assertOneOf)("type", "value"))
            }
        }),
        (0,
        a.default)("DeclaredPredicate", {
            visitor: ["value"],
            aliases: ["Flow", "FlowPredicate"],
            fields: {
                value: (0,
                a.validateType)("Flow")
            }
        }),
        (0,
        a.default)("ExistsTypeAnnotation", {
            aliases: ["Flow", "FlowType"]
        }),
        (0,
        a.default)("FunctionTypeAnnotation", {
            visitor: ["typeParameters", "params", "rest", "returnType"],
            aliases: ["Flow", "FlowType"],
            fields: {
                typeParameters: (0,
                a.validateOptionalType)("TypeParameterDeclaration"),
                params: (0,
                a.validate)((0,
                a.arrayOfType)("FunctionTypeParam")),
                rest: (0,
                a.validateOptionalType)("FunctionTypeParam"),
                this: (0,
                a.validateOptionalType)("FunctionTypeParam"),
                returnType: (0,
                a.validateType)("FlowType")
            }
        }),
        (0,
        a.default)("FunctionTypeParam", {
            visitor: ["name", "typeAnnotation"],
            aliases: ["Flow"],
            fields: {
                name: (0,
                a.validateOptionalType)("Identifier"),
                typeAnnotation: (0,
                a.validateType)("FlowType"),
                optional: (0,
                a.validateOptional)((0,
                a.assertValueType)("boolean"))
            }
        }),
        (0,
        a.default)("GenericTypeAnnotation", {
            visitor: ["id", "typeParameters"],
            aliases: ["Flow", "FlowType"],
            fields: {
                id: (0,
                a.validateType)(["Identifier", "QualifiedTypeIdentifier"]),
                typeParameters: (0,
                a.validateOptionalType)("TypeParameterInstantiation")
            }
        }),
        (0,
        a.default)("InferredPredicate", {
            aliases: ["Flow", "FlowPredicate"]
        }),
        (0,
        a.default)("InterfaceExtends", {
            visitor: ["id", "typeParameters"],
            aliases: ["Flow"],
            fields: {
                id: (0,
                a.validateType)(["Identifier", "QualifiedTypeIdentifier"]),
                typeParameters: (0,
                a.validateOptionalType)("TypeParameterInstantiation")
            }
        }),
        o("InterfaceDeclaration"),
        (0,
        a.default)("InterfaceTypeAnnotation", {
            visitor: ["extends", "body"],
            aliases: ["Flow", "FlowType"],
            fields: {
                extends: (0,
                a.validateOptional)((0,
                a.arrayOfType)("InterfaceExtends")),
                body: (0,
                a.validateType)("ObjectTypeAnnotation")
            }
        }),
        (0,
        a.default)("IntersectionTypeAnnotation", {
            visitor: ["types"],
            aliases: ["Flow", "FlowType"],
            fields: {
                types: (0,
                a.validate)((0,
                a.arrayOfType)("FlowType"))
            }
        }),
        (0,
        a.default)("MixedTypeAnnotation", {
            aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
        }),
        (0,
        a.default)("EmptyTypeAnnotation", {
            aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
        }),
        (0,
        a.default)("NullableTypeAnnotation", {
            visitor: ["typeAnnotation"],
            aliases: ["Flow", "FlowType"],
            fields: {
                typeAnnotation: (0,
                a.validateType)("FlowType")
            }
        }),
        (0,
        a.default)("NumberLiteralTypeAnnotation", {
            builder: ["value"],
            aliases: ["Flow", "FlowType"],
            fields: {
                value: (0,
                a.validate)((0,
                a.assertValueType)("number"))
            }
        }),
        (0,
        a.default)("NumberTypeAnnotation", {
            aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
        }),
        (0,
        a.default)("ObjectTypeAnnotation", {
            visitor: ["properties", "indexers", "callProperties", "internalSlots"],
            aliases: ["Flow", "FlowType"],
            builder: ["properties", "indexers", "callProperties", "internalSlots", "exact"],
            fields: {
                properties: (0,
                a.validate)((0,
                a.arrayOfType)(["ObjectTypeProperty", "ObjectTypeSpreadProperty"])),
                indexers: (0,
                a.validateOptional)((0,
                a.arrayOfType)("ObjectTypeIndexer")),
                callProperties: (0,
                a.validateOptional)((0,
                a.arrayOfType)("ObjectTypeCallProperty")),
                internalSlots: (0,
                a.validateOptional)((0,
                a.arrayOfType)("ObjectTypeInternalSlot")),
                exact: {
                    validate: (0,
                    a.assertValueType)("boolean"),
                    default: !1
                },
                inexact: (0,
                a.validateOptional)((0,
                a.assertValueType)("boolean"))
            }
        }),
        (0,
        a.default)("ObjectTypeInternalSlot", {
            visitor: ["id", "value", "optional", "static", "method"],
            aliases: ["Flow", "UserWhitespacable"],
            fields: {
                id: (0,
                a.validateType)("Identifier"),
                value: (0,
                a.validateType)("FlowType"),
                optional: (0,
                a.validate)((0,
                a.assertValueType)("boolean")),
                static: (0,
                a.validate)((0,
                a.assertValueType)("boolean")),
                method: (0,
                a.validate)((0,
                a.assertValueType)("boolean"))
            }
        }),
        (0,
        a.default)("ObjectTypeCallProperty", {
            visitor: ["value"],
            aliases: ["Flow", "UserWhitespacable"],
            fields: {
                value: (0,
                a.validateType)("FlowType"),
                static: (0,
                a.validate)((0,
                a.assertValueType)("boolean"))
            }
        }),
        (0,
        a.default)("ObjectTypeIndexer", {
            visitor: ["id", "key", "value", "variance"],
            aliases: ["Flow", "UserWhitespacable"],
            fields: {
                id: (0,
                a.validateOptionalType)("Identifier"),
                key: (0,
                a.validateType)("FlowType"),
                value: (0,
                a.validateType)("FlowType"),
                static: (0,
                a.validate)((0,
                a.assertValueType)("boolean")),
                variance: (0,
                a.validateOptionalType)("Variance")
            }
        }),
        (0,
        a.default)("ObjectTypeProperty", {
            visitor: ["key", "value", "variance"],
            aliases: ["Flow", "UserWhitespacable"],
            fields: {
                key: (0,
                a.validateType)(["Identifier", "StringLiteral"]),
                value: (0,
                a.validateType)("FlowType"),
                kind: (0,
                a.validate)((0,
                a.assertOneOf)("init", "get", "set")),
                static: (0,
                a.validate)((0,
                a.assertValueType)("boolean")),
                proto: (0,
                a.validate)((0,
                a.assertValueType)("boolean")),
                optional: (0,
                a.validate)((0,
                a.assertValueType)("boolean")),
                variance: (0,
                a.validateOptionalType)("Variance"),
                method: (0,
                a.validate)((0,
                a.assertValueType)("boolean"))
            }
        }),
        (0,
        a.default)("ObjectTypeSpreadProperty", {
            visitor: ["argument"],
            aliases: ["Flow", "UserWhitespacable"],
            fields: {
                argument: (0,
                a.validateType)("FlowType")
            }
        }),
        (0,
        a.default)("OpaqueType", {
            visitor: ["id", "typeParameters", "supertype", "impltype"],
            aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
            fields: {
                id: (0,
                a.validateType)("Identifier"),
                typeParameters: (0,
                a.validateOptionalType)("TypeParameterDeclaration"),
                supertype: (0,
                a.validateOptionalType)("FlowType"),
                impltype: (0,
                a.validateType)("FlowType")
            }
        }),
        (0,
        a.default)("QualifiedTypeIdentifier", {
            visitor: ["id", "qualification"],
            aliases: ["Flow"],
            fields: {
                id: (0,
                a.validateType)("Identifier"),
                qualification: (0,
                a.validateType)(["Identifier", "QualifiedTypeIdentifier"])
            }
        }),
        (0,
        a.default)("StringLiteralTypeAnnotation", {
            builder: ["value"],
            aliases: ["Flow", "FlowType"],
            fields: {
                value: (0,
                a.validate)((0,
                a.assertValueType)("string"))
            }
        }),
        (0,
        a.default)("StringTypeAnnotation", {
            aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
        }),
        (0,
        a.default)("SymbolTypeAnnotation", {
            aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
        }),
        (0,
        a.default)("ThisTypeAnnotation", {
            aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
        }),
        (0,
        a.default)("TupleTypeAnnotation", {
            visitor: ["types"],
            aliases: ["Flow", "FlowType"],
            fields: {
                types: (0,
                a.validate)((0,
                a.arrayOfType)("FlowType"))
            }
        }),
        (0,
        a.default)("TypeofTypeAnnotation", {
            visitor: ["argument"],
            aliases: ["Flow", "FlowType"],
            fields: {
                argument: (0,
                a.validateType)("FlowType")
            }
        }),
        (0,
        a.default)("TypeAlias", {
            visitor: ["id", "typeParameters", "right"],
            aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
            fields: {
                id: (0,
                a.validateType)("Identifier"),
                typeParameters: (0,
                a.validateOptionalType)("TypeParameterDeclaration"),
                right: (0,
                a.validateType)("FlowType")
            }
        }),
        (0,
        a.default)("TypeAnnotation", {
            aliases: ["Flow"],
            visitor: ["typeAnnotation"],
            fields: {
                typeAnnotation: (0,
                a.validateType)("FlowType")
            }
        }),
        (0,
        a.default)("TypeCastExpression", {
            visitor: ["expression", "typeAnnotation"],
            aliases: ["Flow", "ExpressionWrapper", "Expression"],
            fields: {
                expression: (0,
                a.validateType)("Expression"),
                typeAnnotation: (0,
                a.validateType)("TypeAnnotation")
            }
        }),
        (0,
        a.default)("TypeParameter", {
            aliases: ["Flow"],
            visitor: ["bound", "default", "variance"],
            fields: {
                name: (0,
                a.validate)((0,
                a.assertValueType)("string")),
                bound: (0,
                a.validateOptionalType)("TypeAnnotation"),
                default: (0,
                a.validateOptionalType)("FlowType"),
                variance: (0,
                a.validateOptionalType)("Variance")
            }
        }),
        (0,
        a.default)("TypeParameterDeclaration", {
            aliases: ["Flow"],
            visitor: ["params"],
            fields: {
                params: (0,
                a.validate)((0,
                a.arrayOfType)("TypeParameter"))
            }
        }),
        (0,
        a.default)("TypeParameterInstantiation", {
            aliases: ["Flow"],
            visitor: ["params"],
            fields: {
                params: (0,
                a.validate)((0,
                a.arrayOfType)("FlowType"))
            }
        }),
        (0,
        a.default)("UnionTypeAnnotation", {
            visitor: ["types"],
            aliases: ["Flow", "FlowType"],
            fields: {
                types: (0,
                a.validate)((0,
                a.arrayOfType)("FlowType"))
            }
        }),
        (0,
        a.default)("Variance", {
            aliases: ["Flow"],
            builder: ["kind"],
            fields: {
                kind: (0,
                a.validate)((0,
                a.assertOneOf)("minus", "plus"))
            }
        }),
        (0,
        a.default)("VoidTypeAnnotation", {
            aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
        }),
        (0,
        a.default)("EnumDeclaration", {
            aliases: ["Statement", "Declaration"],
            visitor: ["id", "body"],
            fields: {
                id: (0,
                a.validateType)("Identifier"),
                body: (0,
                a.validateType)(["EnumBooleanBody", "EnumNumberBody", "EnumStringBody", "EnumSymbolBody"])
            }
        }),
        (0,
        a.default)("EnumBooleanBody", {
            aliases: ["EnumBody"],
            visitor: ["members"],
            fields: {
                explicitType: (0,
                a.validate)((0,
                a.assertValueType)("boolean")),
                members: (0,
                a.validateArrayOfType)("EnumBooleanMember"),
                hasUnknownMembers: (0,
                a.validate)((0,
                a.assertValueType)("boolean"))
            }
        }),
        (0,
        a.default)("EnumNumberBody", {
            aliases: ["EnumBody"],
            visitor: ["members"],
            fields: {
                explicitType: (0,
                a.validate)((0,
                a.assertValueType)("boolean")),
                members: (0,
                a.validateArrayOfType)("EnumNumberMember"),
                hasUnknownMembers: (0,
                a.validate)((0,
                a.assertValueType)("boolean"))
            }
        }),
        (0,
        a.default)("EnumStringBody", {
            aliases: ["EnumBody"],
            visitor: ["members"],
            fields: {
                explicitType: (0,
                a.validate)((0,
                a.assertValueType)("boolean")),
                members: (0,
                a.validateArrayOfType)(["EnumStringMember", "EnumDefaultedMember"]),
                hasUnknownMembers: (0,
                a.validate)((0,
                a.assertValueType)("boolean"))
            }
        }),
        (0,
        a.default)("EnumSymbolBody", {
            aliases: ["EnumBody"],
            visitor: ["members"],
            fields: {
                members: (0,
                a.validateArrayOfType)("EnumDefaultedMember"),
                hasUnknownMembers: (0,
                a.validate)((0,
                a.assertValueType)("boolean"))
            }
        }),
        (0,
        a.default)("EnumBooleanMember", {
            aliases: ["EnumMember"],
            visitor: ["id"],
            fields: {
                id: (0,
                a.validateType)("Identifier"),
                init: (0,
                a.validateType)("BooleanLiteral")
            }
        }),
        (0,
        a.default)("EnumNumberMember", {
            aliases: ["EnumMember"],
            visitor: ["id", "init"],
            fields: {
                id: (0,
                a.validateType)("Identifier"),
                init: (0,
                a.validateType)("NumericLiteral")
            }
        }),
        (0,
        a.default)("EnumStringMember", {
            aliases: ["EnumMember"],
            visitor: ["id", "init"],
            fields: {
                id: (0,
                a.validateType)("Identifier"),
                init: (0,
                a.validateType)("StringLiteral")
            }
        }),
        (0,
        a.default)("EnumDefaultedMember", {
            aliases: ["EnumMember"],
            visitor: ["id"],
            fields: {
                id: (0,
                a.validateType)("Identifier")
            }
        }),
        (0,
        a.default)("IndexedAccessType", {
            visitor: ["objectType", "indexType"],
            aliases: ["Flow", "FlowType"],
            fields: {
                objectType: (0,
                a.validateType)("FlowType"),
                indexType: (0,
                a.validateType)("FlowType")
            }
        }),
        (0,
        a.default)("OptionalIndexedAccessType", {
            visitor: ["objectType", "indexType"],
            aliases: ["Flow", "FlowType"],
            fields: {
                objectType: (0,
                a.validateType)("FlowType"),
                indexType: (0,
                a.validateType)("FlowType"),
                optional: (0,
                a.validate)((0,
                a.assertValueType)("boolean"))
            }
        })
    },
    UuI8: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.anyTypeAnnotation = function anyTypeAnnotation() {
            return a.default.apply("AnyTypeAnnotation", arguments)
        }
        ,
        r.argumentPlaceholder = function argumentPlaceholder() {
            return a.default.apply("ArgumentPlaceholder", arguments)
        }
        ,
        r.arrayExpression = function arrayExpression(t) {
            return a.default.apply("ArrayExpression", arguments)
        }
        ,
        r.arrayPattern = function arrayPattern(t) {
            return a.default.apply("ArrayPattern", arguments)
        }
        ,
        r.arrayTypeAnnotation = function arrayTypeAnnotation(t) {
            return a.default.apply("ArrayTypeAnnotation", arguments)
        }
        ,
        r.arrowFunctionExpression = function arrowFunctionExpression(t, r, i) {
            return a.default.apply("ArrowFunctionExpression", arguments)
        }
        ,
        r.assignmentExpression = function assignmentExpression(t, r, i) {
            return a.default.apply("AssignmentExpression", arguments)
        }
        ,
        r.assignmentPattern = function assignmentPattern(t, r) {
            return a.default.apply("AssignmentPattern", arguments)
        }
        ,
        r.awaitExpression = function awaitExpression(t) {
            return a.default.apply("AwaitExpression", arguments)
        }
        ,
        r.bigIntLiteral = function bigIntLiteral(t) {
            return a.default.apply("BigIntLiteral", arguments)
        }
        ,
        r.binaryExpression = function binaryExpression(t, r, i) {
            return a.default.apply("BinaryExpression", arguments)
        }
        ,
        r.bindExpression = function bindExpression(t, r) {
            return a.default.apply("BindExpression", arguments)
        }
        ,
        r.blockStatement = function blockStatement(t, r) {
            return a.default.apply("BlockStatement", arguments)
        }
        ,
        r.booleanLiteral = function booleanLiteral(t) {
            return a.default.apply("BooleanLiteral", arguments)
        }
        ,
        r.booleanLiteralTypeAnnotation = function booleanLiteralTypeAnnotation(t) {
            return a.default.apply("BooleanLiteralTypeAnnotation", arguments)
        }
        ,
        r.booleanTypeAnnotation = function booleanTypeAnnotation() {
            return a.default.apply("BooleanTypeAnnotation", arguments)
        }
        ,
        r.breakStatement = function breakStatement(t) {
            return a.default.apply("BreakStatement", arguments)
        }
        ,
        r.callExpression = function callExpression(t, r) {
            return a.default.apply("CallExpression", arguments)
        }
        ,
        r.catchClause = function catchClause(t, r) {
            return a.default.apply("CatchClause", arguments)
        }
        ,
        r.classBody = function classBody(t) {
            return a.default.apply("ClassBody", arguments)
        }
        ,
        r.classDeclaration = function classDeclaration(t, r, i, o) {
            return a.default.apply("ClassDeclaration", arguments)
        }
        ,
        r.classExpression = function classExpression(t, r, i, o) {
            return a.default.apply("ClassExpression", arguments)
        }
        ,
        r.classImplements = function classImplements(t, r) {
            return a.default.apply("ClassImplements", arguments)
        }
        ,
        r.classMethod = function classMethod(t, r, i, o, l, u, p, c) {
            return a.default.apply("ClassMethod", arguments)
        }
        ,
        r.classPrivateMethod = function classPrivateMethod(t, r, i, o, l) {
            return a.default.apply("ClassPrivateMethod", arguments)
        }
        ,
        r.classPrivateProperty = function classPrivateProperty(t, r, i, o) {
            return a.default.apply("ClassPrivateProperty", arguments)
        }
        ,
        r.classProperty = function classProperty(t, r, i, o, l, u) {
            return a.default.apply("ClassProperty", arguments)
        }
        ,
        r.conditionalExpression = function conditionalExpression(t, r, i) {
            return a.default.apply("ConditionalExpression", arguments)
        }
        ,
        r.continueStatement = function continueStatement(t) {
            return a.default.apply("ContinueStatement", arguments)
        }
        ,
        r.debuggerStatement = function debuggerStatement() {
            return a.default.apply("DebuggerStatement", arguments)
        }
        ,
        r.decimalLiteral = function decimalLiteral(t) {
            return a.default.apply("DecimalLiteral", arguments)
        }
        ,
        r.declareClass = function declareClass(t, r, i, o) {
            return a.default.apply("DeclareClass", arguments)
        }
        ,
        r.declareExportAllDeclaration = function declareExportAllDeclaration(t) {
            return a.default.apply("DeclareExportAllDeclaration", arguments)
        }
        ,
        r.declareExportDeclaration = function declareExportDeclaration(t, r, i) {
            return a.default.apply("DeclareExportDeclaration", arguments)
        }
        ,
        r.declareFunction = function declareFunction(t) {
            return a.default.apply("DeclareFunction", arguments)
        }
        ,
        r.declareInterface = function declareInterface(t, r, i, o) {
            return a.default.apply("DeclareInterface", arguments)
        }
        ,
        r.declareModule = function declareModule(t, r, i) {
            return a.default.apply("DeclareModule", arguments)
        }
        ,
        r.declareModuleExports = function declareModuleExports(t) {
            return a.default.apply("DeclareModuleExports", arguments)
        }
        ,
        r.declareOpaqueType = function declareOpaqueType(t, r, i) {
            return a.default.apply("DeclareOpaqueType", arguments)
        }
        ,
        r.declareTypeAlias = function declareTypeAlias(t, r, i) {
            return a.default.apply("DeclareTypeAlias", arguments)
        }
        ,
        r.declareVariable = function declareVariable(t) {
            return a.default.apply("DeclareVariable", arguments)
        }
        ,
        r.declaredPredicate = function declaredPredicate(t) {
            return a.default.apply("DeclaredPredicate", arguments)
        }
        ,
        r.decorator = function decorator(t) {
            return a.default.apply("Decorator", arguments)
        }
        ,
        r.directive = function directive(t) {
            return a.default.apply("Directive", arguments)
        }
        ,
        r.directiveLiteral = function directiveLiteral(t) {
            return a.default.apply("DirectiveLiteral", arguments)
        }
        ,
        r.doExpression = function doExpression(t, r) {
            return a.default.apply("DoExpression", arguments)
        }
        ,
        r.doWhileStatement = function doWhileStatement(t, r) {
            return a.default.apply("DoWhileStatement", arguments)
        }
        ,
        r.emptyStatement = function emptyStatement() {
            return a.default.apply("EmptyStatement", arguments)
        }
        ,
        r.emptyTypeAnnotation = function emptyTypeAnnotation() {
            return a.default.apply("EmptyTypeAnnotation", arguments)
        }
        ,
        r.enumBooleanBody = function enumBooleanBody(t) {
            return a.default.apply("EnumBooleanBody", arguments)
        }
        ,
        r.enumBooleanMember = function enumBooleanMember(t) {
            return a.default.apply("EnumBooleanMember", arguments)
        }
        ,
        r.enumDeclaration = function enumDeclaration(t, r) {
            return a.default.apply("EnumDeclaration", arguments)
        }
        ,
        r.enumDefaultedMember = function enumDefaultedMember(t) {
            return a.default.apply("EnumDefaultedMember", arguments)
        }
        ,
        r.enumNumberBody = function enumNumberBody(t) {
            return a.default.apply("EnumNumberBody", arguments)
        }
        ,
        r.enumNumberMember = function enumNumberMember(t, r) {
            return a.default.apply("EnumNumberMember", arguments)
        }
        ,
        r.enumStringBody = function enumStringBody(t) {
            return a.default.apply("EnumStringBody", arguments)
        }
        ,
        r.enumStringMember = function enumStringMember(t, r) {
            return a.default.apply("EnumStringMember", arguments)
        }
        ,
        r.enumSymbolBody = function enumSymbolBody(t) {
            return a.default.apply("EnumSymbolBody", arguments)
        }
        ,
        r.existsTypeAnnotation = function existsTypeAnnotation() {
            return a.default.apply("ExistsTypeAnnotation", arguments)
        }
        ,
        r.exportAllDeclaration = function exportAllDeclaration(t) {
            return a.default.apply("ExportAllDeclaration", arguments)
        }
        ,
        r.exportDefaultDeclaration = function exportDefaultDeclaration(t) {
            return a.default.apply("ExportDefaultDeclaration", arguments)
        }
        ,
        r.exportDefaultSpecifier = function exportDefaultSpecifier(t) {
            return a.default.apply("ExportDefaultSpecifier", arguments)
        }
        ,
        r.exportNamedDeclaration = function exportNamedDeclaration(t, r, i) {
            return a.default.apply("ExportNamedDeclaration", arguments)
        }
        ,
        r.exportNamespaceSpecifier = function exportNamespaceSpecifier(t) {
            return a.default.apply("ExportNamespaceSpecifier", arguments)
        }
        ,
        r.exportSpecifier = function exportSpecifier(t, r) {
            return a.default.apply("ExportSpecifier", arguments)
        }
        ,
        r.expressionStatement = function expressionStatement(t) {
            return a.default.apply("ExpressionStatement", arguments)
        }
        ,
        r.file = function file(t, r, i) {
            return a.default.apply("File", arguments)
        }
        ,
        r.forInStatement = function forInStatement(t, r, i) {
            return a.default.apply("ForInStatement", arguments)
        }
        ,
        r.forOfStatement = function forOfStatement(t, r, i, o) {
            return a.default.apply("ForOfStatement", arguments)
        }
        ,
        r.forStatement = function forStatement(t, r, i, o) {
            return a.default.apply("ForStatement", arguments)
        }
        ,
        r.functionDeclaration = function functionDeclaration(t, r, i, o, l) {
            return a.default.apply("FunctionDeclaration", arguments)
        }
        ,
        r.functionExpression = function functionExpression(t, r, i, o, l) {
            return a.default.apply("FunctionExpression", arguments)
        }
        ,
        r.functionTypeAnnotation = function functionTypeAnnotation(t, r, i, o) {
            return a.default.apply("FunctionTypeAnnotation", arguments)
        }
        ,
        r.functionTypeParam = function functionTypeParam(t, r) {
            return a.default.apply("FunctionTypeParam", arguments)
        }
        ,
        r.genericTypeAnnotation = function genericTypeAnnotation(t, r) {
            return a.default.apply("GenericTypeAnnotation", arguments)
        }
        ,
        r.identifier = function identifier(t) {
            return a.default.apply("Identifier", arguments)
        }
        ,
        r.ifStatement = function ifStatement(t, r, i) {
            return a.default.apply("IfStatement", arguments)
        }
        ,
        r.import = function _import() {
            return a.default.apply("Import", arguments)
        }
        ,
        r.importAttribute = function importAttribute(t, r) {
            return a.default.apply("ImportAttribute", arguments)
        }
        ,
        r.importDeclaration = function importDeclaration(t, r) {
            return a.default.apply("ImportDeclaration", arguments)
        }
        ,
        r.importDefaultSpecifier = function importDefaultSpecifier(t) {
            return a.default.apply("ImportDefaultSpecifier", arguments)
        }
        ,
        r.importNamespaceSpecifier = function importNamespaceSpecifier(t) {
            return a.default.apply("ImportNamespaceSpecifier", arguments)
        }
        ,
        r.importSpecifier = function importSpecifier(t, r) {
            return a.default.apply("ImportSpecifier", arguments)
        }
        ,
        r.indexedAccessType = function indexedAccessType(t, r) {
            return a.default.apply("IndexedAccessType", arguments)
        }
        ,
        r.inferredPredicate = function inferredPredicate() {
            return a.default.apply("InferredPredicate", arguments)
        }
        ,
        r.interfaceDeclaration = function interfaceDeclaration(t, r, i, o) {
            return a.default.apply("InterfaceDeclaration", arguments)
        }
        ,
        r.interfaceExtends = function interfaceExtends(t, r) {
            return a.default.apply("InterfaceExtends", arguments)
        }
        ,
        r.interfaceTypeAnnotation = function interfaceTypeAnnotation(t, r) {
            return a.default.apply("InterfaceTypeAnnotation", arguments)
        }
        ,
        r.interpreterDirective = function interpreterDirective(t) {
            return a.default.apply("InterpreterDirective", arguments)
        }
        ,
        r.intersectionTypeAnnotation = function intersectionTypeAnnotation(t) {
            return a.default.apply("IntersectionTypeAnnotation", arguments)
        }
        ,
        r.jSXAttribute = r.jsxAttribute = function jsxAttribute(t, r) {
            return a.default.apply("JSXAttribute", arguments)
        }
        ,
        r.jSXClosingElement = r.jsxClosingElement = function jsxClosingElement(t) {
            return a.default.apply("JSXClosingElement", arguments)
        }
        ,
        r.jSXClosingFragment = r.jsxClosingFragment = function jsxClosingFragment() {
            return a.default.apply("JSXClosingFragment", arguments)
        }
        ,
        r.jSXElement = r.jsxElement = function jsxElement(t, r, i, o) {
            return a.default.apply("JSXElement", arguments)
        }
        ,
        r.jSXEmptyExpression = r.jsxEmptyExpression = function jsxEmptyExpression() {
            return a.default.apply("JSXEmptyExpression", arguments)
        }
        ,
        r.jSXExpressionContainer = r.jsxExpressionContainer = function jsxExpressionContainer(t) {
            return a.default.apply("JSXExpressionContainer", arguments)
        }
        ,
        r.jSXFragment = r.jsxFragment = function jsxFragment(t, r, i) {
            return a.default.apply("JSXFragment", arguments)
        }
        ,
        r.jSXIdentifier = r.jsxIdentifier = function jsxIdentifier(t) {
            return a.default.apply("JSXIdentifier", arguments)
        }
        ,
        r.jSXMemberExpression = r.jsxMemberExpression = function jsxMemberExpression(t, r) {
            return a.default.apply("JSXMemberExpression", arguments)
        }
        ,
        r.jSXNamespacedName = r.jsxNamespacedName = function jsxNamespacedName(t, r) {
            return a.default.apply("JSXNamespacedName", arguments)
        }
        ,
        r.jSXOpeningElement = r.jsxOpeningElement = function jsxOpeningElement(t, r, i) {
            return a.default.apply("JSXOpeningElement", arguments)
        }
        ,
        r.jSXOpeningFragment = r.jsxOpeningFragment = function jsxOpeningFragment() {
            return a.default.apply("JSXOpeningFragment", arguments)
        }
        ,
        r.jSXSpreadAttribute = r.jsxSpreadAttribute = function jsxSpreadAttribute(t) {
            return a.default.apply("JSXSpreadAttribute", arguments)
        }
        ,
        r.jSXSpreadChild = r.jsxSpreadChild = function jsxSpreadChild(t) {
            return a.default.apply("JSXSpreadChild", arguments)
        }
        ,
        r.jSXText = r.jsxText = function jsxText(t) {
            return a.default.apply("JSXText", arguments)
        }
        ,
        r.labeledStatement = function labeledStatement(t, r) {
            return a.default.apply("LabeledStatement", arguments)
        }
        ,
        r.logicalExpression = function logicalExpression(t, r, i) {
            return a.default.apply("LogicalExpression", arguments)
        }
        ,
        r.memberExpression = function memberExpression(t, r, i, o) {
            return a.default.apply("MemberExpression", arguments)
        }
        ,
        r.metaProperty = function metaProperty(t, r) {
            return a.default.apply("MetaProperty", arguments)
        }
        ,
        r.mixedTypeAnnotation = function mixedTypeAnnotation() {
            return a.default.apply("MixedTypeAnnotation", arguments)
        }
        ,
        r.moduleExpression = function moduleExpression(t) {
            return a.default.apply("ModuleExpression", arguments)
        }
        ,
        r.newExpression = function newExpression(t, r) {
            return a.default.apply("NewExpression", arguments)
        }
        ,
        r.noop = function noop() {
            return a.default.apply("Noop", arguments)
        }
        ,
        r.nullLiteral = function nullLiteral() {
            return a.default.apply("NullLiteral", arguments)
        }
        ,
        r.nullLiteralTypeAnnotation = function nullLiteralTypeAnnotation() {
            return a.default.apply("NullLiteralTypeAnnotation", arguments)
        }
        ,
        r.nullableTypeAnnotation = function nullableTypeAnnotation(t) {
            return a.default.apply("NullableTypeAnnotation", arguments)
        }
        ,
        r.numberLiteral = function NumberLiteral(t) {
            return console.trace("The node type NumberLiteral has been renamed to NumericLiteral"),
            a.default.apply("NumberLiteral", arguments)
        }
        ,
        r.numberLiteralTypeAnnotation = function numberLiteralTypeAnnotation(t) {
            return a.default.apply("NumberLiteralTypeAnnotation", arguments)
        }
        ,
        r.numberTypeAnnotation = function numberTypeAnnotation() {
            return a.default.apply("NumberTypeAnnotation", arguments)
        }
        ,
        r.numericLiteral = function numericLiteral(t) {
            return a.default.apply("NumericLiteral", arguments)
        }
        ,
        r.objectExpression = function objectExpression(t) {
            return a.default.apply("ObjectExpression", arguments)
        }
        ,
        r.objectMethod = function objectMethod(t, r, i, o, l, u, p) {
            return a.default.apply("ObjectMethod", arguments)
        }
        ,
        r.objectPattern = function objectPattern(t) {
            return a.default.apply("ObjectPattern", arguments)
        }
        ,
        r.objectProperty = function objectProperty(t, r, i, o, l) {
            return a.default.apply("ObjectProperty", arguments)
        }
        ,
        r.objectTypeAnnotation = function objectTypeAnnotation(t, r, i, o, l) {
            return a.default.apply("ObjectTypeAnnotation", arguments)
        }
        ,
        r.objectTypeCallProperty = function objectTypeCallProperty(t) {
            return a.default.apply("ObjectTypeCallProperty", arguments)
        }
        ,
        r.objectTypeIndexer = function objectTypeIndexer(t, r, i, o) {
            return a.default.apply("ObjectTypeIndexer", arguments)
        }
        ,
        r.objectTypeInternalSlot = function objectTypeInternalSlot(t, r, i, o, l) {
            return a.default.apply("ObjectTypeInternalSlot", arguments)
        }
        ,
        r.objectTypeProperty = function objectTypeProperty(t, r, i) {
            return a.default.apply("ObjectTypeProperty", arguments)
        }
        ,
        r.objectTypeSpreadProperty = function objectTypeSpreadProperty(t) {
            return a.default.apply("ObjectTypeSpreadProperty", arguments)
        }
        ,
        r.opaqueType = function opaqueType(t, r, i, o) {
            return a.default.apply("OpaqueType", arguments)
        }
        ,
        r.optionalCallExpression = function optionalCallExpression(t, r, i) {
            return a.default.apply("OptionalCallExpression", arguments)
        }
        ,
        r.optionalIndexedAccessType = function optionalIndexedAccessType(t, r) {
            return a.default.apply("OptionalIndexedAccessType", arguments)
        }
        ,
        r.optionalMemberExpression = function optionalMemberExpression(t, r, i, o) {
            return a.default.apply("OptionalMemberExpression", arguments)
        }
        ,
        r.parenthesizedExpression = function parenthesizedExpression(t) {
            return a.default.apply("ParenthesizedExpression", arguments)
        }
        ,
        r.pipelineBareFunction = function pipelineBareFunction(t) {
            return a.default.apply("PipelineBareFunction", arguments)
        }
        ,
        r.pipelinePrimaryTopicReference = function pipelinePrimaryTopicReference() {
            return a.default.apply("PipelinePrimaryTopicReference", arguments)
        }
        ,
        r.pipelineTopicExpression = function pipelineTopicExpression(t) {
            return a.default.apply("PipelineTopicExpression", arguments)
        }
        ,
        r.placeholder = function placeholder(t, r) {
            return a.default.apply("Placeholder", arguments)
        }
        ,
        r.privateName = function privateName(t) {
            return a.default.apply("PrivateName", arguments)
        }
        ,
        r.program = function program(t, r, i, o) {
            return a.default.apply("Program", arguments)
        }
        ,
        r.qualifiedTypeIdentifier = function qualifiedTypeIdentifier(t, r) {
            return a.default.apply("QualifiedTypeIdentifier", arguments)
        }
        ,
        r.recordExpression = function recordExpression(t) {
            return a.default.apply("RecordExpression", arguments)
        }
        ,
        r.regExpLiteral = function regExpLiteral(t, r) {
            return a.default.apply("RegExpLiteral", arguments)
        }
        ,
        r.regexLiteral = function RegexLiteral(t, r) {
            return console.trace("The node type RegexLiteral has been renamed to RegExpLiteral"),
            a.default.apply("RegexLiteral", arguments)
        }
        ,
        r.restElement = function restElement(t) {
            return a.default.apply("RestElement", arguments)
        }
        ,
        r.restProperty = function RestProperty(t) {
            return console.trace("The node type RestProperty has been renamed to RestElement"),
            a.default.apply("RestProperty", arguments)
        }
        ,
        r.returnStatement = function returnStatement(t) {
            return a.default.apply("ReturnStatement", arguments)
        }
        ,
        r.sequenceExpression = function sequenceExpression(t) {
            return a.default.apply("SequenceExpression", arguments)
        }
        ,
        r.spreadElement = function spreadElement(t) {
            return a.default.apply("SpreadElement", arguments)
        }
        ,
        r.spreadProperty = function SpreadProperty(t) {
            return console.trace("The node type SpreadProperty has been renamed to SpreadElement"),
            a.default.apply("SpreadProperty", arguments)
        }
        ,
        r.staticBlock = function staticBlock(t) {
            return a.default.apply("StaticBlock", arguments)
        }
        ,
        r.stringLiteral = function stringLiteral(t) {
            return a.default.apply("StringLiteral", arguments)
        }
        ,
        r.stringLiteralTypeAnnotation = function stringLiteralTypeAnnotation(t) {
            return a.default.apply("StringLiteralTypeAnnotation", arguments)
        }
        ,
        r.stringTypeAnnotation = function stringTypeAnnotation() {
            return a.default.apply("StringTypeAnnotation", arguments)
        }
        ,
        r.super = function _super() {
            return a.default.apply("Super", arguments)
        }
        ,
        r.switchCase = function switchCase(t, r) {
            return a.default.apply("SwitchCase", arguments)
        }
        ,
        r.switchStatement = function switchStatement(t, r) {
            return a.default.apply("SwitchStatement", arguments)
        }
        ,
        r.symbolTypeAnnotation = function symbolTypeAnnotation() {
            return a.default.apply("SymbolTypeAnnotation", arguments)
        }
        ,
        r.taggedTemplateExpression = function taggedTemplateExpression(t, r) {
            return a.default.apply("TaggedTemplateExpression", arguments)
        }
        ,
        r.templateElement = function templateElement(t, r) {
            return a.default.apply("TemplateElement", arguments)
        }
        ,
        r.templateLiteral = function templateLiteral(t, r) {
            return a.default.apply("TemplateLiteral", arguments)
        }
        ,
        r.thisExpression = function thisExpression() {
            return a.default.apply("ThisExpression", arguments)
        }
        ,
        r.thisTypeAnnotation = function thisTypeAnnotation() {
            return a.default.apply("ThisTypeAnnotation", arguments)
        }
        ,
        r.throwStatement = function throwStatement(t) {
            return a.default.apply("ThrowStatement", arguments)
        }
        ,
        r.topicReference = function topicReference() {
            return a.default.apply("TopicReference", arguments)
        }
        ,
        r.tryStatement = function tryStatement(t, r, i) {
            return a.default.apply("TryStatement", arguments)
        }
        ,
        r.tSAnyKeyword = r.tsAnyKeyword = function tsAnyKeyword() {
            return a.default.apply("TSAnyKeyword", arguments)
        }
        ,
        r.tSArrayType = r.tsArrayType = function tsArrayType(t) {
            return a.default.apply("TSArrayType", arguments)
        }
        ,
        r.tSAsExpression = r.tsAsExpression = function tsAsExpression(t, r) {
            return a.default.apply("TSAsExpression", arguments)
        }
        ,
        r.tSBigIntKeyword = r.tsBigIntKeyword = function tsBigIntKeyword() {
            return a.default.apply("TSBigIntKeyword", arguments)
        }
        ,
        r.tSBooleanKeyword = r.tsBooleanKeyword = function tsBooleanKeyword() {
            return a.default.apply("TSBooleanKeyword", arguments)
        }
        ,
        r.tSCallSignatureDeclaration = r.tsCallSignatureDeclaration = function tsCallSignatureDeclaration(t, r, i) {
            return a.default.apply("TSCallSignatureDeclaration", arguments)
        }
        ,
        r.tSConditionalType = r.tsConditionalType = function tsConditionalType(t, r, i, o) {
            return a.default.apply("TSConditionalType", arguments)
        }
        ,
        r.tSConstructSignatureDeclaration = r.tsConstructSignatureDeclaration = function tsConstructSignatureDeclaration(t, r, i) {
            return a.default.apply("TSConstructSignatureDeclaration", arguments)
        }
        ,
        r.tSConstructorType = r.tsConstructorType = function tsConstructorType(t, r, i) {
            return a.default.apply("TSConstructorType", arguments)
        }
        ,
        r.tSDeclareFunction = r.tsDeclareFunction = function tsDeclareFunction(t, r, i, o) {
            return a.default.apply("TSDeclareFunction", arguments)
        }
        ,
        r.tSDeclareMethod = r.tsDeclareMethod = function tsDeclareMethod(t, r, i, o, l) {
            return a.default.apply("TSDeclareMethod", arguments)
        }
        ,
        r.tSEnumDeclaration = r.tsEnumDeclaration = function tsEnumDeclaration(t, r) {
            return a.default.apply("TSEnumDeclaration", arguments)
        }
        ,
        r.tSEnumMember = r.tsEnumMember = function tsEnumMember(t, r) {
            return a.default.apply("TSEnumMember", arguments)
        }
        ,
        r.tSExportAssignment = r.tsExportAssignment = function tsExportAssignment(t) {
            return a.default.apply("TSExportAssignment", arguments)
        }
        ,
        r.tSExpressionWithTypeArguments = r.tsExpressionWithTypeArguments = function tsExpressionWithTypeArguments(t, r) {
            return a.default.apply("TSExpressionWithTypeArguments", arguments)
        }
        ,
        r.tSExternalModuleReference = r.tsExternalModuleReference = function tsExternalModuleReference(t) {
            return a.default.apply("TSExternalModuleReference", arguments)
        }
        ,
        r.tSFunctionType = r.tsFunctionType = function tsFunctionType(t, r, i) {
            return a.default.apply("TSFunctionType", arguments)
        }
        ,
        r.tSImportEqualsDeclaration = r.tsImportEqualsDeclaration = function tsImportEqualsDeclaration(t, r) {
            return a.default.apply("TSImportEqualsDeclaration", arguments)
        }
        ,
        r.tSImportType = r.tsImportType = function tsImportType(t, r, i) {
            return a.default.apply("TSImportType", arguments)
        }
        ,
        r.tSIndexSignature = r.tsIndexSignature = function tsIndexSignature(t, r) {
            return a.default.apply("TSIndexSignature", arguments)
        }
        ,
        r.tSIndexedAccessType = r.tsIndexedAccessType = function tsIndexedAccessType(t, r) {
            return a.default.apply("TSIndexedAccessType", arguments)
        }
        ,
        r.tSInferType = r.tsInferType = function tsInferType(t) {
            return a.default.apply("TSInferType", arguments)
        }
        ,
        r.tSInterfaceBody = r.tsInterfaceBody = function tsInterfaceBody(t) {
            return a.default.apply("TSInterfaceBody", arguments)
        }
        ,
        r.tSInterfaceDeclaration = r.tsInterfaceDeclaration = function tsInterfaceDeclaration(t, r, i, o) {
            return a.default.apply("TSInterfaceDeclaration", arguments)
        }
        ,
        r.tSIntersectionType = r.tsIntersectionType = function tsIntersectionType(t) {
            return a.default.apply("TSIntersectionType", arguments)
        }
        ,
        r.tSIntrinsicKeyword = r.tsIntrinsicKeyword = function tsIntrinsicKeyword() {
            return a.default.apply("TSIntrinsicKeyword", arguments)
        }
        ,
        r.tSLiteralType = r.tsLiteralType = function tsLiteralType(t) {
            return a.default.apply("TSLiteralType", arguments)
        }
        ,
        r.tSMappedType = r.tsMappedType = function tsMappedType(t, r, i) {
            return a.default.apply("TSMappedType", arguments)
        }
        ,
        r.tSMethodSignature = r.tsMethodSignature = function tsMethodSignature(t, r, i, o) {
            return a.default.apply("TSMethodSignature", arguments)
        }
        ,
        r.tSModuleBlock = r.tsModuleBlock = function tsModuleBlock(t) {
            return a.default.apply("TSModuleBlock", arguments)
        }
        ,
        r.tSModuleDeclaration = r.tsModuleDeclaration = function tsModuleDeclaration(t, r) {
            return a.default.apply("TSModuleDeclaration", arguments)
        }
        ,
        r.tSNamedTupleMember = r.tsNamedTupleMember = function tsNamedTupleMember(t, r, i) {
            return a.default.apply("TSNamedTupleMember", arguments)
        }
        ,
        r.tSNamespaceExportDeclaration = r.tsNamespaceExportDeclaration = function tsNamespaceExportDeclaration(t) {
            return a.default.apply("TSNamespaceExportDeclaration", arguments)
        }
        ,
        r.tSNeverKeyword = r.tsNeverKeyword = function tsNeverKeyword() {
            return a.default.apply("TSNeverKeyword", arguments)
        }
        ,
        r.tSNonNullExpression = r.tsNonNullExpression = function tsNonNullExpression(t) {
            return a.default.apply("TSNonNullExpression", arguments)
        }
        ,
        r.tSNullKeyword = r.tsNullKeyword = function tsNullKeyword() {
            return a.default.apply("TSNullKeyword", arguments)
        }
        ,
        r.tSNumberKeyword = r.tsNumberKeyword = function tsNumberKeyword() {
            return a.default.apply("TSNumberKeyword", arguments)
        }
        ,
        r.tSObjectKeyword = r.tsObjectKeyword = function tsObjectKeyword() {
            return a.default.apply("TSObjectKeyword", arguments)
        }
        ,
        r.tSOptionalType = r.tsOptionalType = function tsOptionalType(t) {
            return a.default.apply("TSOptionalType", arguments)
        }
        ,
        r.tSParameterProperty = r.tsParameterProperty = function tsParameterProperty(t) {
            return a.default.apply("TSParameterProperty", arguments)
        }
        ,
        r.tSParenthesizedType = r.tsParenthesizedType = function tsParenthesizedType(t) {
            return a.default.apply("TSParenthesizedType", arguments)
        }
        ,
        r.tSPropertySignature = r.tsPropertySignature = function tsPropertySignature(t, r, i) {
            return a.default.apply("TSPropertySignature", arguments)
        }
        ,
        r.tSQualifiedName = r.tsQualifiedName = function tsQualifiedName(t, r) {
            return a.default.apply("TSQualifiedName", arguments)
        }
        ,
        r.tSRestType = r.tsRestType = function tsRestType(t) {
            return a.default.apply("TSRestType", arguments)
        }
        ,
        r.tSStringKeyword = r.tsStringKeyword = function tsStringKeyword() {
            return a.default.apply("TSStringKeyword", arguments)
        }
        ,
        r.tSSymbolKeyword = r.tsSymbolKeyword = function tsSymbolKeyword() {
            return a.default.apply("TSSymbolKeyword", arguments)
        }
        ,
        r.tSThisType = r.tsThisType = function tsThisType() {
            return a.default.apply("TSThisType", arguments)
        }
        ,
        r.tSTupleType = r.tsTupleType = function tsTupleType(t) {
            return a.default.apply("TSTupleType", arguments)
        }
        ,
        r.tSTypeAliasDeclaration = r.tsTypeAliasDeclaration = function tsTypeAliasDeclaration(t, r, i) {
            return a.default.apply("TSTypeAliasDeclaration", arguments)
        }
        ,
        r.tSTypeAnnotation = r.tsTypeAnnotation = function tsTypeAnnotation(t) {
            return a.default.apply("TSTypeAnnotation", arguments)
        }
        ,
        r.tSTypeAssertion = r.tsTypeAssertion = function tsTypeAssertion(t, r) {
            return a.default.apply("TSTypeAssertion", arguments)
        }
        ,
        r.tSTypeLiteral = r.tsTypeLiteral = function tsTypeLiteral(t) {
            return a.default.apply("TSTypeLiteral", arguments)
        }
        ,
        r.tSTypeOperator = r.tsTypeOperator = function tsTypeOperator(t) {
            return a.default.apply("TSTypeOperator", arguments)
        }
        ,
        r.tSTypeParameter = r.tsTypeParameter = function tsTypeParameter(t, r, i) {
            return a.default.apply("TSTypeParameter", arguments)
        }
        ,
        r.tSTypeParameterDeclaration = r.tsTypeParameterDeclaration = function tsTypeParameterDeclaration(t) {
            return a.default.apply("TSTypeParameterDeclaration", arguments)
        }
        ,
        r.tSTypeParameterInstantiation = r.tsTypeParameterInstantiation = function tsTypeParameterInstantiation(t) {
            return a.default.apply("TSTypeParameterInstantiation", arguments)
        }
        ,
        r.tSTypePredicate = r.tsTypePredicate = function tsTypePredicate(t, r, i) {
            return a.default.apply("TSTypePredicate", arguments)
        }
        ,
        r.tSTypeQuery = r.tsTypeQuery = function tsTypeQuery(t) {
            return a.default.apply("TSTypeQuery", arguments)
        }
        ,
        r.tSTypeReference = r.tsTypeReference = function tsTypeReference(t, r) {
            return a.default.apply("TSTypeReference", arguments)
        }
        ,
        r.tSUndefinedKeyword = r.tsUndefinedKeyword = function tsUndefinedKeyword() {
            return a.default.apply("TSUndefinedKeyword", arguments)
        }
        ,
        r.tSUnionType = r.tsUnionType = function tsUnionType(t) {
            return a.default.apply("TSUnionType", arguments)
        }
        ,
        r.tSUnknownKeyword = r.tsUnknownKeyword = function tsUnknownKeyword() {
            return a.default.apply("TSUnknownKeyword", arguments)
        }
        ,
        r.tSVoidKeyword = r.tsVoidKeyword = function tsVoidKeyword() {
            return a.default.apply("TSVoidKeyword", arguments)
        }
        ,
        r.tupleExpression = function tupleExpression(t) {
            return a.default.apply("TupleExpression", arguments)
        }
        ,
        r.tupleTypeAnnotation = function tupleTypeAnnotation(t) {
            return a.default.apply("TupleTypeAnnotation", arguments)
        }
        ,
        r.typeAlias = function typeAlias(t, r, i) {
            return a.default.apply("TypeAlias", arguments)
        }
        ,
        r.typeAnnotation = function typeAnnotation(t) {
            return a.default.apply("TypeAnnotation", arguments)
        }
        ,
        r.typeCastExpression = function typeCastExpression(t, r) {
            return a.default.apply("TypeCastExpression", arguments)
        }
        ,
        r.typeParameter = function typeParameter(t, r, i) {
            return a.default.apply("TypeParameter", arguments)
        }
        ,
        r.typeParameterDeclaration = function typeParameterDeclaration(t) {
            return a.default.apply("TypeParameterDeclaration", arguments)
        }
        ,
        r.typeParameterInstantiation = function typeParameterInstantiation(t) {
            return a.default.apply("TypeParameterInstantiation", arguments)
        }
        ,
        r.typeofTypeAnnotation = function typeofTypeAnnotation(t) {
            return a.default.apply("TypeofTypeAnnotation", arguments)
        }
        ,
        r.unaryExpression = function unaryExpression(t, r, i) {
            return a.default.apply("UnaryExpression", arguments)
        }
        ,
        r.unionTypeAnnotation = function unionTypeAnnotation(t) {
            return a.default.apply("UnionTypeAnnotation", arguments)
        }
        ,
        r.updateExpression = function updateExpression(t, r, i) {
            return a.default.apply("UpdateExpression", arguments)
        }
        ,
        r.v8IntrinsicIdentifier = function v8IntrinsicIdentifier(t) {
            return a.default.apply("V8IntrinsicIdentifier", arguments)
        }
        ,
        r.variableDeclaration = function variableDeclaration(t, r) {
            return a.default.apply("VariableDeclaration", arguments)
        }
        ,
        r.variableDeclarator = function variableDeclarator(t, r) {
            return a.default.apply("VariableDeclarator", arguments)
        }
        ,
        r.variance = function variance(t) {
            return a.default.apply("Variance", arguments)
        }
        ,
        r.voidTypeAnnotation = function voidTypeAnnotation() {
            return a.default.apply("VoidTypeAnnotation", arguments)
        }
        ,
        r.whileStatement = function whileStatement(t, r) {
            return a.default.apply("WhileStatement", arguments)
        }
        ,
        r.withStatement = function withStatement(t, r) {
            return a.default.apply("WithStatement", arguments)
        }
        ,
        r.yieldExpression = function yieldExpression(t, r) {
            return a.default.apply("YieldExpression", arguments)
        }
        ;
        var a = i("iyG3")
    },
    "V+V6": function(t, r, i) {
        "use strict";
        var a = i("TqRt")
          , o = a(i("lwsE"))
          , l = a(i("W8MJ"))
          , u = a(i("7W2i"))
          , p = a(i("a1gu"))
          , c = a(i("Nsbk"));
        function _createSuper(t) {
            var r = function _isNativeReflectConstruct() {
                if ("undefined" == typeof Reflect || !Reflect.construct)
                    return !1;
                if (Reflect.construct.sham)
                    return !1;
                if ("function" == typeof Proxy)
                    return !0;
                try {
                    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}
                    ))),
                    !0
                } catch (t) {
                    return !1
                }
            }();
            return function _createSuperInternal() {
                var i, a = (0,
                c.default)(t);
                if (r) {
                    var o = (0,
                    c.default)(this).constructor;
                    i = Reflect.construct(a, arguments, o)
                } else
                    i = a.apply(this, arguments);
                return (0,
                p.default)(this, i)
            }
        }
        var d = i("sR6L").Syntax
          , y = i("KZm0")
          , h = i("SCtg")
          , m = i("dYsE")
          , T = i("lTU0")
          , S = i("C+dp")
          , g = i("9lTW")
          , b = S.ParameterDefinition
          , v = S.Definition;
        var E = function(t) {
            (0,
            u.default)(Importer, t);
            var r = _createSuper(Importer);
            function Importer(t, i) {
                var a;
                return (0,
                o.default)(this, Importer),
                (a = r.call(this, null, i.options)).declaration = t,
                a.referencer = i,
                a
            }
            return (0,
            l.default)(Importer, [{
                key: "visitImport",
                value: function visitImport(t, r) {
                    var i = this;
                    this.referencer.visitPattern(t, (function(t) {
                        i.referencer.currentScope().__define(t, new v(m.ImportBinding,t,r,i.declaration,null,null))
                    }
                    ))
                }
            }, {
                key: "ImportNamespaceSpecifier",
                value: function ImportNamespaceSpecifier(t) {
                    var r = t.local || t.id;
                    r && this.visitImport(r, t)
                }
            }, {
                key: "ImportDefaultSpecifier",
                value: function ImportDefaultSpecifier(t) {
                    var r = t.local || t.id;
                    this.visitImport(r, t)
                }
            }, {
                key: "ImportSpecifier",
                value: function ImportSpecifier(t) {
                    var r = t.local || t.id;
                    t.name ? this.visitImport(t.name, t) : this.visitImport(r, t)
                }
            }]),
            Importer
        }(y.Visitor)
          , P = function(t) {
            (0,
            u.default)(Referencer, t);
            var r = _createSuper(Referencer);
            function Referencer(t, i) {
                var a;
                return (0,
                o.default)(this, Referencer),
                (a = r.call(this, null, t)).options = t,
                a.scopeManager = i,
                a.parent = null,
                a.isInnerMethodDefinition = !1,
                a
            }
            return (0,
            l.default)(Referencer, [{
                key: "currentScope",
                value: function currentScope() {
                    return this.scopeManager.__currentScope
                }
            }, {
                key: "close",
                value: function close(t) {
                    for (; this.currentScope() && t === this.currentScope().block; )
                        this.scopeManager.__currentScope = this.currentScope().__close(this.scopeManager)
                }
            }, {
                key: "pushInnerMethodDefinition",
                value: function pushInnerMethodDefinition(t) {
                    var r = this.isInnerMethodDefinition;
                    return this.isInnerMethodDefinition = t,
                    r
                }
            }, {
                key: "popInnerMethodDefinition",
                value: function popInnerMethodDefinition(t) {
                    this.isInnerMethodDefinition = t
                }
            }, {
                key: "materializeTDZScope",
                value: function materializeTDZScope(t, r) {
                    this.scopeManager.__nestTDZScope(t, r),
                    this.visitVariableDeclaration(this.currentScope(), m.TDZ, r.left, 0, !0)
                }
            }, {
                key: "materializeIterationScope",
                value: function materializeIterationScope(t) {
                    var r = this
                      , i = t.left;
                    this.scopeManager.__nestForScope(t),
                    this.visitVariableDeclaration(this.currentScope(), m.Variable, i, 0),
                    this.visitPattern(i.declarations[0].id, (function(i) {
                        r.currentScope().__referencing(i, h.WRITE, t.right, null, !0, !0)
                    }
                    ))
                }
            }, {
                key: "referencingDefaultValue",
                value: function referencingDefaultValue(t, r, i, a) {
                    var o = this.currentScope();
                    r.forEach((function(r) {
                        o.__referencing(t, h.WRITE, r.right, i, t !== r.left, a)
                    }
                    ))
                }
            }, {
                key: "visitPattern",
                value: function visitPattern(t, r, i) {
                    "function" == typeof r && (i = r,
                    r = {
                        processRightHandNodes: !1
                    }),
                    function traverseIdentifierInPattern(t, r, i, a) {
                        var o = new T(t,r,a);
                        o.visit(r),
                        null != i && o.rightHandNodes.forEach(i.visit, i)
                    }(this.options, t, r.processRightHandNodes ? this : null, i)
                }
            }, {
                key: "visitFunction",
                value: function visitFunction(t) {
                    var r, i, a = this;
                    t.type === d.FunctionDeclaration && this.currentScope().__define(t.id, new v(m.FunctionName,t.id,t,null,null,null)),
                    t.type === d.FunctionExpression && t.id && this.scopeManager.__nestFunctionExpressionNameScope(t),
                    this.scopeManager.__nestFunctionScope(t, this.isInnerMethodDefinition);
                    var o = this;
                    function visitPatternCallback(i, a) {
                        o.currentScope().__define(i, new b(i,t,r,a.rest)),
                        o.referencingDefaultValue(i, a.assignments, null, !0)
                    }
                    for (r = 0,
                    i = t.params.length; r < i; ++r)
                        this.visitPattern(t.params[r], {
                            processRightHandNodes: !0
                        }, visitPatternCallback);
                    t.rest && this.visitPattern({
                        type: "RestElement",
                        argument: t.rest
                    }, (function(r) {
                        a.currentScope().__define(r, new b(r,t,t.params.length,!0))
                    }
                    )),
                    t.body && (t.body.type === d.BlockStatement ? this.visitChildren(t.body) : this.visit(t.body)),
                    this.close(t)
                }
            }, {
                key: "visitClass",
                value: function visitClass(t) {
                    t.type === d.ClassDeclaration && this.currentScope().__define(t.id, new v(m.ClassName,t.id,t,null,null,null)),
                    this.visit(t.superClass),
                    this.scopeManager.__nestClassScope(t),
                    t.id && this.currentScope().__define(t.id, new v(m.ClassName,t.id,t)),
                    this.visit(t.body),
                    this.close(t)
                }
            }, {
                key: "visitProperty",
                value: function visitProperty(t) {
                    var r;
                    t.computed && this.visit(t.key);
                    var i = t.type === d.MethodDefinition;
                    i && (r = this.pushInnerMethodDefinition(!0)),
                    this.visit(t.value),
                    i && this.popInnerMethodDefinition(r)
                }
            }, {
                key: "visitForIn",
                value: function visitForIn(t) {
                    var r = this;
                    t.left.type === d.VariableDeclaration && "var" !== t.left.kind ? (this.materializeTDZScope(t.right, t),
                    this.visit(t.right),
                    this.close(t.right),
                    this.materializeIterationScope(t),
                    this.visit(t.body),
                    this.close(t)) : (t.left.type === d.VariableDeclaration ? (this.visit(t.left),
                    this.visitPattern(t.left.declarations[0].id, (function(i) {
                        r.currentScope().__referencing(i, h.WRITE, t.right, null, !0, !0)
                    }
                    ))) : this.visitPattern(t.left, {
                        processRightHandNodes: !0
                    }, (function(i, a) {
                        var o = null;
                        r.currentScope().isStrict || (o = {
                            pattern: i,
                            node: t
                        }),
                        r.referencingDefaultValue(i, a.assignments, o, !1),
                        r.currentScope().__referencing(i, h.WRITE, t.right, o, !0, !1)
                    }
                    )),
                    this.visit(t.right),
                    this.visit(t.body))
                }
            }, {
                key: "visitVariableDeclaration",
                value: function visitVariableDeclaration(t, r, i, a, o) {
                    var l = this
                      , u = i.declarations[a]
                      , p = u.init;
                    this.visitPattern(u.id, {
                        processRightHandNodes: !o
                    }, (function(c, d) {
                        t.__define(c, new v(r,c,u,i,a,i.kind)),
                        o || l.referencingDefaultValue(c, d.assignments, null, !0),
                        p && l.currentScope().__referencing(c, h.WRITE, p, null, !d.topLevel, !0)
                    }
                    ))
                }
            }, {
                key: "AssignmentExpression",
                value: function AssignmentExpression(t) {
                    var r = this;
                    T.isPattern(t.left) ? "=" === t.operator ? this.visitPattern(t.left, {
                        processRightHandNodes: !0
                    }, (function(i, a) {
                        var o = null;
                        r.currentScope().isStrict || (o = {
                            pattern: i,
                            node: t
                        }),
                        r.referencingDefaultValue(i, a.assignments, o, !1),
                        r.currentScope().__referencing(i, h.WRITE, t.right, o, !a.topLevel, !1)
                    }
                    )) : this.currentScope().__referencing(t.left, h.RW, t.right) : this.visit(t.left),
                    this.visit(t.right)
                }
            }, {
                key: "CatchClause",
                value: function CatchClause(t) {
                    var r = this;
                    this.scopeManager.__nestCatchScope(t),
                    this.visitPattern(t.param, {
                        processRightHandNodes: !0
                    }, (function(i, a) {
                        r.currentScope().__define(i, new v(m.CatchClause,t.param,t,null,null,null)),
                        r.referencingDefaultValue(i, a.assignments, null, !0)
                    }
                    )),
                    this.visit(t.body),
                    this.close(t)
                }
            }, {
                key: "Program",
                value: function Program(t) {
                    this.scopeManager.__nestGlobalScope(t),
                    this.scopeManager.__isNodejsScope() && (this.currentScope().isStrict = !1,
                    this.scopeManager.__nestFunctionScope(t, !1)),
                    this.scopeManager.__isES6() && this.scopeManager.isModule() && this.scopeManager.__nestModuleScope(t),
                    this.scopeManager.isStrictModeSupported() && this.scopeManager.isImpliedStrict() && (this.currentScope().isStrict = !0),
                    this.visitChildren(t),
                    this.close(t)
                }
            }, {
                key: "Identifier",
                value: function Identifier(t) {
                    this.currentScope().__referencing(t)
                }
            }, {
                key: "UpdateExpression",
                value: function UpdateExpression(t) {
                    T.isPattern(t.argument) ? this.currentScope().__referencing(t.argument, h.RW, null) : this.visitChildren(t)
                }
            }, {
                key: "MemberExpression",
                value: function MemberExpression(t) {
                    this.visit(t.object),
                    t.computed && this.visit(t.property)
                }
            }, {
                key: "Property",
                value: function Property(t) {
                    this.visitProperty(t)
                }
            }, {
                key: "MethodDefinition",
                value: function MethodDefinition(t) {
                    this.visitProperty(t)
                }
            }, {
                key: "BreakStatement",
                value: function BreakStatement() {}
            }, {
                key: "ContinueStatement",
                value: function ContinueStatement() {}
            }, {
                key: "LabeledStatement",
                value: function LabeledStatement(t) {
                    this.visit(t.body)
                }
            }, {
                key: "ForStatement",
                value: function ForStatement(t) {
                    t.init && t.init.type === d.VariableDeclaration && "var" !== t.init.kind && this.scopeManager.__nestForScope(t),
                    this.visitChildren(t),
                    this.close(t)
                }
            }, {
                key: "ClassExpression",
                value: function ClassExpression(t) {
                    this.visitClass(t)
                }
            }, {
                key: "ClassDeclaration",
                value: function ClassDeclaration(t) {
                    this.visitClass(t)
                }
            }, {
                key: "CallExpression",
                value: function CallExpression(t) {
                    this.scopeManager.__ignoreEval() || t.callee.type !== d.Identifier || "eval" !== t.callee.name || this.currentScope().variableScope.__detectEval(),
                    this.visitChildren(t)
                }
            }, {
                key: "BlockStatement",
                value: function BlockStatement(t) {
                    this.scopeManager.__isES6() && this.scopeManager.__nestBlockScope(t),
                    this.visitChildren(t),
                    this.close(t)
                }
            }, {
                key: "ThisExpression",
                value: function ThisExpression() {
                    this.currentScope().variableScope.__detectThis()
                }
            }, {
                key: "WithStatement",
                value: function WithStatement(t) {
                    this.visit(t.object),
                    this.scopeManager.__nestWithScope(t),
                    this.visit(t.body),
                    this.close(t)
                }
            }, {
                key: "VariableDeclaration",
                value: function VariableDeclaration(t) {
                    for (var r = "var" === t.kind ? this.currentScope().variableScope : this.currentScope(), i = 0, a = t.declarations.length; i < a; ++i) {
                        var o = t.declarations[i];
                        this.visitVariableDeclaration(r, m.Variable, t, i),
                        o.init && this.visit(o.init)
                    }
                }
            }, {
                key: "SwitchStatement",
                value: function SwitchStatement(t) {
                    this.visit(t.discriminant),
                    this.scopeManager.__isES6() && this.scopeManager.__nestSwitchScope(t);
                    for (var r = 0, i = t.cases.length; r < i; ++r)
                        this.visit(t.cases[r]);
                    this.close(t)
                }
            }, {
                key: "FunctionDeclaration",
                value: function FunctionDeclaration(t) {
                    this.visitFunction(t)
                }
            }, {
                key: "FunctionExpression",
                value: function FunctionExpression(t) {
                    this.visitFunction(t)
                }
            }, {
                key: "ForOfStatement",
                value: function ForOfStatement(t) {
                    this.visitForIn(t)
                }
            }, {
                key: "ForInStatement",
                value: function ForInStatement(t) {
                    this.visitForIn(t)
                }
            }, {
                key: "ArrowFunctionExpression",
                value: function ArrowFunctionExpression(t) {
                    this.visitFunction(t)
                }
            }, {
                key: "ImportDeclaration",
                value: function ImportDeclaration(t) {
                    g(this.scopeManager.__isES6() && this.scopeManager.isModule(), "ImportDeclaration should appear when the mode is ES6 and in the module context."),
                    new E(t,this).visit(t)
                }
            }, {
                key: "visitExportDeclaration",
                value: function visitExportDeclaration(t) {
                    t.source || (t.declaration ? this.visit(t.declaration) : this.visitChildren(t))
                }
            }, {
                key: "ExportDeclaration",
                value: function ExportDeclaration(t) {
                    this.visitExportDeclaration(t)
                }
            }, {
                key: "ExportNamedDeclaration",
                value: function ExportNamedDeclaration(t) {
                    this.visitExportDeclaration(t)
                }
            }, {
                key: "ExportSpecifier",
                value: function ExportSpecifier(t) {
                    var r = t.id || t.local;
                    this.visit(r)
                }
            }, {
                key: "MetaProperty",
                value: function MetaProperty() {}
            }]),
            Referencer
        }(y.Visitor);
        t.exports = P
    },
    "V/pm": function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function buildMatchMemberExpression(t, r) {
            const i = t.split(".");
            return t=>(0,
            a.default)(t, i, r)
        }
        ;
        var a = i("/g1/")
    },
    V20z: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = getBindingIdentifiers;
        var a = i("pbIU");
        function getBindingIdentifiers(t, r, i) {
            for (var o = [].concat(t), l = Object.create(null); o.length; ) {
                var u = o.shift();
                if (u) {
                    var p = getBindingIdentifiers.keys[u.type];
                    if ((0,
                    a.isIdentifier)(u))
                        r ? (l[u.name] = l[u.name] || []).push(u) : l[u.name] = u;
                    else if (!(0,
                    a.isExportDeclaration)(u) || (0,
                    a.isExportAllDeclaration)(u)) {
                        if (i) {
                            if ((0,
                            a.isFunctionDeclaration)(u)) {
                                o.push(u.id);
                                continue
                            }
                            if ((0,
                            a.isFunctionExpression)(u))
                                continue
                        }
                        if (p)
                            for (var c = 0; c < p.length; c++) {
                                var d = p[c];
                                u[d] && (o = o.concat(u[d]))
                            }
                    } else
                        (0,
                        a.isDeclaration)(u.declaration) && o.push(u.declaration)
                }
            }
            return l
        }
        getBindingIdentifiers.keys = {
            DeclareClass: ["id"],
            DeclareFunction: ["id"],
            DeclareModule: ["id"],
            DeclareVariable: ["id"],
            DeclareInterface: ["id"],
            DeclareTypeAlias: ["id"],
            DeclareOpaqueType: ["id"],
            InterfaceDeclaration: ["id"],
            TypeAlias: ["id"],
            OpaqueType: ["id"],
            CatchClause: ["param"],
            LabeledStatement: ["label"],
            UnaryExpression: ["argument"],
            AssignmentExpression: ["left"],
            ImportSpecifier: ["local"],
            ImportNamespaceSpecifier: ["local"],
            ImportDefaultSpecifier: ["local"],
            ImportDeclaration: ["specifiers"],
            ExportSpecifier: ["exported"],
            ExportNamespaceSpecifier: ["exported"],
            ExportDefaultSpecifier: ["exported"],
            FunctionDeclaration: ["id", "params"],
            FunctionExpression: ["id", "params"],
            ArrowFunctionExpression: ["params"],
            ObjectMethod: ["params"],
            ClassMethod: ["params"],
            ClassPrivateMethod: ["params"],
            ForInStatement: ["left"],
            ForOfStatement: ["left"],
            ClassDeclaration: ["id"],
            ClassExpression: ["id"],
            RestElement: ["argument"],
            UpdateExpression: ["argument"],
            ObjectProperty: ["value"],
            AssignmentPattern: ["left"],
            ArrayPattern: ["elements"],
            ObjectPattern: ["properties"],
            VariableDeclaration: ["declarations"],
            VariableDeclarator: ["id"]
        }
    },
    "V97+": function(t, r, i) {
        "use strict";
        (function(t) {
            Object.defineProperty(r, "__esModule", {
                value: !0
            }),
            r.VISITOR_KEYS = r.NODE_PARENT_VALIDATIONS = r.NODE_FIELDS = r.FLIPPED_ALIAS_KEYS = r.DEPRECATED_KEYS = r.BUILDER_KEYS = r.ALIAS_KEYS = void 0,
            r.arrayOf = arrayOf,
            r.arrayOfType = arrayOfType,
            r.assertEach = assertEach,
            r.assertNodeOrValueType = function assertNodeOrValueType(...t) {
                function validate(r, i, l) {
                    for (const u of t)
                        if (getType(l) === u || (0,
                        a.default)(u, l))
                            return void (0,
                            o.validateChild)(r, i, l);
                    throw new TypeError(`Property ${i} of ${r.type} expected node to be of a type ${JSON.stringify(t)} but instead got ${JSON.stringify(null == l ? void 0 : l.type)}`)
                }
                return validate.oneOfNodeOrValueTypes = t,
                validate
            }
            ,
            r.assertNodeType = assertNodeType,
            r.assertOneOf = function assertOneOf(...t) {
                function validate(r, i, a) {
                    if (t.indexOf(a) < 0)
                        throw new TypeError(`Property ${i} expected value to be one of ${JSON.stringify(t)} but got ${JSON.stringify(a)}`)
                }
                return validate.oneOf = t,
                validate
            }
            ,
            r.assertOptionalChainStart = function assertOptionalChainStart() {
                return function validate(t) {
                    var r;
                    let i = t;
                    for (; t; ) {
                        const {type: t} = i;
                        if ("OptionalCallExpression" !== t) {
                            if ("OptionalMemberExpression" !== t)
                                break;
                            if (i.optional)
                                return;
                            i = i.object
                        } else {
                            if (i.optional)
                                return;
                            i = i.callee
                        }
                    }
                    throw new TypeError(`Non-optional ${t.type} must chain from an optional OptionalMemberExpression or OptionalCallExpression. Found chain from ${null == (r = i) ? void 0 : r.type}`)
                }
            }
            ,
            r.assertShape = function assertShape(t) {
                function validate(r, i, a) {
                    const l = [];
                    for (const i of Object.keys(t))
                        try {
                            (0,
                            o.validateField)(r, i, a[i], t[i])
                        } catch (t) {
                            if (t instanceof TypeError) {
                                l.push(t.message);
                                continue
                            }
                            throw t
                        }
                    if (l.length)
                        throw new TypeError(`Property ${i} of ${r.type} expected to have the following:\n${l.join("\n")}`)
                }
                return validate.shapeOf = t,
                validate
            }
            ,
            r.assertValueType = assertValueType,
            r.chain = chain,
            r.default = defineType,
            r.defineAliasedType = function defineAliasedType(...t) {
                return (r,i={})=>{
                    let a = i.aliases;
                    var o;
                    a || (i.inherits && (a = null == (o = S[i.inherits].aliases) ? void 0 : o.slice()),
                    null != a || (a = []),
                    i.aliases = a);
                    const l = t.filter(t=>!a.includes(t));
                    return a.unshift(...l),
                    defineType(r, i)
                }
            }
            ,
            r.typeIs = typeIs,
            r.validate = validate,
            r.validateArrayOfType = function validateArrayOfType(t) {
                return validate(arrayOfType(t))
            }
            ,
            r.validateOptional = function validateOptional(t) {
                return {
                    validate: t,
                    optional: !0
                }
            }
            ,
            r.validateOptionalType = function validateOptionalType(t) {
                return {
                    validate: typeIs(t),
                    optional: !0
                }
            }
            ,
            r.validateType = function validateType(t) {
                return validate(typeIs(t))
            }
            ;
            var a = i("F3vi")
              , o = i("YupJ");
            const l = {};
            r.VISITOR_KEYS = l;
            const u = {};
            r.ALIAS_KEYS = u;
            const p = {};
            r.FLIPPED_ALIAS_KEYS = p;
            const c = {};
            r.NODE_FIELDS = c;
            const d = {};
            r.BUILDER_KEYS = d;
            const y = {};
            r.DEPRECATED_KEYS = y;
            const h = {};
            function getType(t) {
                return Array.isArray(t) ? "array" : null === t ? "null" : typeof t
            }
            function validate(t) {
                return {
                    validate: t
                }
            }
            function typeIs(t) {
                return "string" == typeof t ? assertNodeType(t) : assertNodeType(...t)
            }
            function arrayOf(t) {
                return chain(assertValueType("array"), assertEach(t))
            }
            function arrayOfType(t) {
                return arrayOf(typeIs(t))
            }
            function assertEach(r) {
                function validator(i, a, l) {
                    if (Array.isArray(l))
                        for (let u = 0; u < l.length; u++) {
                            const p = `${a}[${u}]`
                              , c = l[u];
                            r(i, p, c),
                            t.env.BABEL_TYPES_8_BREAKING && (0,
                            o.validateChild)(i, p, c)
                        }
                }
                return validator.each = r,
                validator
            }
            function assertNodeType(...t) {
                function validate(r, i, l) {
                    for (const u of t)
                        if ((0,
                        a.default)(u, l))
                            return void (0,
                            o.validateChild)(r, i, l);
                    throw new TypeError(`Property ${i} of ${r.type} expected node to be of a type ${JSON.stringify(t)} but instead got ${JSON.stringify(null == l ? void 0 : l.type)}`)
                }
                return validate.oneOfNodeTypes = t,
                validate
            }
            function assertValueType(t) {
                function validate(r, i, a) {
                    if (!(getType(a) === t))
                        throw new TypeError(`Property ${i} expected type of ${t} but got ${getType(a)}`)
                }
                return validate.type = t,
                validate
            }
            function chain(...t) {
                function validate(...r) {
                    for (const i of t)
                        i(...r)
                }
                if (validate.chainOf = t,
                t.length >= 2 && "type"in t[0] && "array" === t[0].type && !("each"in t[1]))
                    throw new Error('An assertValueType("array") validator can only be followed by an assertEach(...) validator.');
                return validate
            }
            r.NODE_PARENT_VALIDATIONS = h;
            const m = ["aliases", "builder", "deprecatedAlias", "fields", "inherits", "visitor", "validate"]
              , T = ["default", "optional", "validate"];
            function defineType(t, r={}) {
                const i = r.inherits && S[r.inherits] || {};
                let a = r.fields;
                if (!a && (a = {},
                i.fields)) {
                    const t = Object.getOwnPropertyNames(i.fields);
                    for (const r of t) {
                        const t = i.fields[r]
                          , o = t.default;
                        if (Array.isArray(o) ? o.length > 0 : o && "object" == typeof o)
                            throw new Error("field defaults can only be primitives or empty arrays currently");
                        a[r] = {
                            default: Array.isArray(o) ? [] : o,
                            optional: t.optional,
                            validate: t.validate
                        }
                    }
                }
                const o = r.visitor || i.visitor || []
                  , g = r.aliases || i.aliases || []
                  , b = r.builder || i.builder || r.visitor || [];
                for (const i of Object.keys(r))
                    if (-1 === m.indexOf(i))
                        throw new Error(`Unknown type option "${i}" on ${t}`);
                r.deprecatedAlias && (y[r.deprecatedAlias] = t);
                for (const t of o.concat(b))
                    a[t] = a[t] || {};
                for (const r of Object.keys(a)) {
                    const i = a[r];
                    void 0 !== i.default && -1 === b.indexOf(r) && (i.optional = !0),
                    void 0 === i.default ? i.default = null : i.validate || null == i.default || (i.validate = assertValueType(getType(i.default)));
                    for (const a of Object.keys(i))
                        if (-1 === T.indexOf(a))
                            throw new Error(`Unknown field key "${a}" on ${t}.${r}`)
                }
                l[t] = r.visitor = o,
                d[t] = r.builder = b,
                c[t] = r.fields = a,
                u[t] = r.aliases = g,
                g.forEach(r=>{
                    p[r] = p[r] || [],
                    p[r].push(t)
                }
                ),
                r.validate && (h[t] = r.validate),
                S[t] = r
            }
            const S = {}
        }
        ).call(this, i("8oxB"))
    },
    V9Y0: function(t) {
        t.exports = JSON.parse('{"name":"estraverse","description":"ECMAScript JS AST traversal functions","homepage":"https://github.com/estools/estraverse","main":"estraverse.js","version":"4.3.0","engines":{"node":">=4.0"},"maintainers":[{"name":"Yusuke Suzuki","email":"utatane.tea@gmail.com","web":"http://github.com/Constellation"}],"repository":{"type":"git","url":"http://github.com/estools/estraverse.git"},"devDependencies":{"babel-preset-env":"^1.6.1","babel-register":"^6.3.13","chai":"^2.1.1","espree":"^1.11.0","gulp":"^3.8.10","gulp-bump":"^0.2.2","gulp-filter":"^2.0.0","gulp-git":"^1.0.1","gulp-tag-version":"^1.3.0","jshint":"^2.5.6","mocha":"^2.1.0"},"license":"BSD-2-Clause","scripts":{"test":"npm run-script lint && npm run-script unit-test","lint":"jshint estraverse.js","unit-test":"mocha --compilers js:babel-register"}}')
    },
    VVhL: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function removeComments(t) {
            return a.COMMENT_KEYS.forEach((function(r) {
                t[r] = null
            }
            )),
            t
        }
        ;
        var a = i("M7ys")
    },
    VxTX: function(t, r, i) {
        "use strict";
        function _createForOfIteratorHelper(t, r) {
            var i = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
            if (!i) {
                if (Array.isArray(t) || (i = function _unsupportedIterableToArray(t, r) {
                    if (!t)
                        return;
                    if ("string" == typeof t)
                        return _arrayLikeToArray(t, r);
                    var i = Object.prototype.toString.call(t).slice(8, -1);
                    "Object" === i && t.constructor && (i = t.constructor.name);
                    if ("Map" === i || "Set" === i)
                        return Array.from(t);
                    if ("Arguments" === i || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i))
                        return _arrayLikeToArray(t, r)
                }(t)) || r && t && "number" == typeof t.length) {
                    i && (t = i);
                    var a = 0
                      , o = function F() {};
                    return {
                        s: o,
                        n: function n() {
                            return a >= t.length ? {
                                done: !0
                            } : {
                                done: !1,
                                value: t[a++]
                            }
                        },
                        e: function e(t) {
                            throw t
                        },
                        f: o
                    }
                }
                throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
            }
            var l, u = !0, p = !1;
            return {
                s: function s() {
                    i = i.call(t)
                },
                n: function n() {
                    var t = i.next();
                    return u = t.done,
                    t
                },
                e: function e(t) {
                    p = !0,
                    l = t
                },
                f: function f() {
                    try {
                        u || null == i.return || i.return()
                    } finally {
                        if (p)
                            throw l
                    }
                }
            }
        }
        function _arrayLikeToArray(t, r) {
            (null == r || r > t.length) && (r = t.length);
            for (var i = 0, a = new Array(r); i < r; i++)
                a[i] = t[i];
            return a
        }
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function inherits(t, r) {
            if (!t || !r)
                return t;
            var i, l = _createForOfIteratorHelper(a.INHERIT_KEYS.optional);
            try {
                for (l.s(); !(i = l.n()).done; ) {
                    var u = i.value;
                    null == t[u] && (t[u] = r[u])
                }
            } catch (t) {
                l.e(t)
            } finally {
                l.f()
            }
            for (var p = 0, c = Object.keys(r); p < c.length; p++) {
                var d = c[p];
                "_" === d[0] && "__clone" !== d && (t[d] = r[d])
            }
            var y, h = _createForOfIteratorHelper(a.INHERIT_KEYS.force);
            try {
                for (h.s(); !(y = h.n()).done; ) {
                    var m = y.value;
                    t[m] = r[m]
                }
            } catch (t) {
                h.e(t)
            } finally {
                h.f()
            }
            return (0,
            o.default)(t, r),
            t
        }
        ;
        var a = i("M7ys")
          , o = i("0k9f")
    },
    "WP/u": function(t, r, i) {
        "use strict";
        function _createForOfIteratorHelper(t, r) {
            var i = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
            if (!i) {
                if (Array.isArray(t) || (i = function _unsupportedIterableToArray(t, r) {
                    if (!t)
                        return;
                    if ("string" == typeof t)
                        return _arrayLikeToArray(t, r);
                    var i = Object.prototype.toString.call(t).slice(8, -1);
                    "Object" === i && t.constructor && (i = t.constructor.name);
                    if ("Map" === i || "Set" === i)
                        return Array.from(t);
                    if ("Arguments" === i || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i))
                        return _arrayLikeToArray(t, r)
                }(t)) || r && t && "number" == typeof t.length) {
                    i && (t = i);
                    var a = 0
                      , o = function F() {};
                    return {
                        s: o,
                        n: function n() {
                            return a >= t.length ? {
                                done: !0
                            } : {
                                done: !1,
                                value: t[a++]
                            }
                        },
                        e: function e(t) {
                            throw t
                        },
                        f: o
                    }
                }
                throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
            }
            var l, u = !0, p = !1;
            return {
                s: function s() {
                    i = i.call(t)
                },
                n: function n() {
                    var t = i.next();
                    return u = t.done,
                    t
                },
                e: function e(t) {
                    p = !0,
                    l = t
                },
                f: function f() {
                    try {
                        u || null == i.return || i.return()
                    } finally {
                        if (p)
                            throw l
                    }
                }
            }
        }
        function _arrayLikeToArray(t, r) {
            (null == r || r > t.length) && (r = t.length);
            for (var i = 0, a = new Array(r); i < r; i++)
                a[i] = t[i];
            return a
        }
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.getTypeAnnotation = function getTypeAnnotation() {
            if (this.typeAnnotation)
                return this.typeAnnotation;
            var t = this._getTypeAnnotation() || o.anyTypeAnnotation();
            o.isTypeAnnotation(t) && (t = t.typeAnnotation);
            return this.typeAnnotation = t
        }
        ,
        r._getTypeAnnotation = function _getTypeAnnotation() {
            var t = this.node;
            if (!t) {
                if ("init" === this.key && this.parentPath.isVariableDeclarator()) {
                    var r = this.parentPath.parentPath
                      , i = r.parentPath;
                    return "left" === r.key && i.isForInStatement() ? o.stringTypeAnnotation() : "left" === r.key && i.isForOfStatement() ? o.anyTypeAnnotation() : o.voidTypeAnnotation()
                }
                return
            }
            if (t.typeAnnotation)
                return t.typeAnnotation;
            if (l.has(t))
                return;
            l.add(t);
            try {
                var u, p = a[t.type];
                if (p)
                    return p.call(this, t);
                if (p = a[this.parentPath.type],
                null != (u = p) && u.validParent)
                    return this.parentPath.getTypeAnnotation()
            } finally {
                l.delete(t)
            }
        }
        ,
        r.isBaseType = function isBaseType(t, r) {
            return _isBaseType(t, this.getTypeAnnotation(), r)
        }
        ,
        r.couldBeBaseType = function couldBeBaseType(t) {
            var r = this.getTypeAnnotation();
            if (o.isAnyTypeAnnotation(r))
                return !0;
            if (o.isUnionTypeAnnotation(r)) {
                var i, a = _createForOfIteratorHelper(r.types);
                try {
                    for (a.s(); !(i = a.n()).done; ) {
                        var l = i.value;
                        if (o.isAnyTypeAnnotation(l) || _isBaseType(t, l, !0))
                            return !0
                    }
                } catch (t) {
                    a.e(t)
                } finally {
                    a.f()
                }
                return !1
            }
            return _isBaseType(t, r, !0)
        }
        ,
        r.baseTypeStrictlyMatches = function baseTypeStrictlyMatches(t) {
            var r = this.getTypeAnnotation()
              , i = t.getTypeAnnotation();
            if (!o.isAnyTypeAnnotation(r) && o.isFlowBaseAnnotation(r))
                return i.type === r.type;
            return !1
        }
        ,
        r.isGenericType = function isGenericType(t) {
            var r = this.getTypeAnnotation();
            return o.isGenericTypeAnnotation(r) && o.isIdentifier(r.id, {
                name: t
            })
        }
        ;
        var a = i("yKLv")
          , o = i("ZtNB");
        var l = new WeakSet;
        function _isBaseType(t, r, i) {
            if ("string" === t)
                return o.isStringTypeAnnotation(r);
            if ("number" === t)
                return o.isNumberTypeAnnotation(r);
            if ("boolean" === t)
                return o.isBooleanTypeAnnotation(r);
            if ("any" === t)
                return o.isAnyTypeAnnotation(r);
            if ("mixed" === t)
                return o.isMixedTypeAnnotation(r);
            if ("empty" === t)
                return o.isEmptyTypeAnnotation(r);
            if ("void" === t)
                return o.isVoidTypeAnnotation(r);
            if (i)
                return !1;
            throw new Error("Unknown base type ".concat(t))
        }
    },
    WYNU: function(t, r, i) {},
    Wb6z: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.ClassBody = function ClassBody(t) {
            this.token("{"),
            this.printInnerComments(t),
            0 === t.body.length ? this.token("}") : (this.newline(),
            this.indent(),
            this.printSequence(t.body, t),
            this.dedent(),
            this.endsWith(10) || this.newline(),
            this.rightBrace())
        }
        ,
        r.ClassExpression = r.ClassDeclaration = function ClassDeclaration(t, r) {
            this.format.decoratorsBeforeExport && (o(r) || l(r)) || this.printJoin(t.decorators, t);
            t.declare && (this.word("declare"),
            this.space());
            t.abstract && (this.word("abstract"),
            this.space());
            this.word("class"),
            this.printInnerComments(t),
            t.id && (this.space(),
            this.print(t.id, t));
            this.print(t.typeParameters, t),
            t.superClass && (this.space(),
            this.word("extends"),
            this.space(),
            this.print(t.superClass, t),
            this.print(t.superTypeParameters, t));
            t.implements && (this.space(),
            this.word("implements"),
            this.space(),
            this.printList(t.implements, t));
            this.space(),
            this.print(t.body, t)
        }
        ,
        r.ClassMethod = function ClassMethod(t) {
            this._classMethodHead(t),
            this.space(),
            this.print(t.body, t)
        }
        ,
        r.ClassPrivateMethod = function ClassPrivateMethod(t) {
            this._classMethodHead(t),
            this.space(),
            this.print(t.body, t)
        }
        ,
        r.ClassPrivateProperty = function ClassPrivateProperty(t) {
            this.printJoin(t.decorators, t),
            t.static && (this.word("static"),
            this.space());
            this.print(t.key, t),
            this.print(t.typeAnnotation, t),
            t.value && (this.space(),
            this.token("="),
            this.space(),
            this.print(t.value, t));
            this.semicolon()
        }
        ,
        r.ClassProperty = function ClassProperty(t) {
            this.printJoin(t.decorators, t),
            this.source("end", t.key.loc),
            this.tsPrintClassMemberModifiers(t, !0),
            t.computed ? (this.token("["),
            this.print(t.key, t),
            this.token("]")) : (this._variance(t),
            this.print(t.key, t));
            t.optional && this.token("?");
            t.definite && this.token("!");
            this.print(t.typeAnnotation, t),
            t.value && (this.space(),
            this.token("="),
            this.space(),
            this.print(t.value, t));
            this.semicolon()
        }
        ,
        r.StaticBlock = function StaticBlock(t) {
            this.word("static"),
            this.space(),
            this.token("{"),
            0 === t.body.length ? this.token("}") : (this.newline(),
            this.printSequence(t.body, t, {
                indent: !0
            }),
            this.rightBrace())
        }
        ,
        r._classMethodHead = function _classMethodHead(t) {
            this.printJoin(t.decorators, t),
            this.source("end", t.key.loc),
            this.tsPrintClassMemberModifiers(t, !1),
            this._methodHead(t)
        }
        ;
        var a = i("JSq2");
        const {isExportDefaultDeclaration: o, isExportNamedDeclaration: l} = a
    },
    WlzW: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function toBindingIdentifierName(t) {
            "eval" !== (t = (0,
            a.default)(t)) && "arguments" !== t || (t = "_" + t);
            return t
        }
        ;
        var a = i("J/a/")
    },
    Wr9I: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = void 0;
        var a = i("pbIU")
          , o = function toExpression(t) {
            (0,
            a.isExpressionStatement)(t) && (t = t.expression);
            if ((0,
            a.isExpression)(t))
                return t;
            (0,
            a.isClass)(t) ? t.type = "ClassExpression" : (0,
            a.isFunction)(t) && (t.type = "FunctionExpression");
            if (!(0,
            a.isExpression)(t))
                throw new Error("cannot turn ".concat(t.type, " to an expression"));
            return t
        };
        r.default = o
    },
    X2aU: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function cleanJSXElementLiteralChild(t, r) {
            for (var i = t.value.split(/\r\n|\n|\r/), o = 0, l = 0; l < i.length; l++)
                i[l].match(/[^ \t]/) && (o = l);
            for (var u = "", p = 0; p < i.length; p++) {
                var c = i[p]
                  , d = 0 === p
                  , y = p === i.length - 1
                  , h = p === o
                  , m = c.replace(/\t/g, " ");
                d || (m = m.replace(/^[ ]+/, "")),
                y || (m = m.replace(/[ ]+$/, "")),
                m && (h || (m += " "),
                u += m)
            }
            u && r.push((0,
            a.stringLiteral)(u))
        }
        ;
        var a = i("57mi")
    },
    X6wd: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function removeProperties(t, r={}) {
            const i = r.preserveComments ? o : l;
            for (const r of i)
                null != t[r] && (t[r] = void 0);
            for (const r of Object.keys(t))
                "_" === r[0] && null != t[r] && (t[r] = void 0);
            const a = Object.getOwnPropertySymbols(t);
            for (const r of a)
                t[r] = null
        }
        ;
        var a = i("kEZX");
        const o = ["tokens", "start", "end", "loc", "raw", "rawValue"]
          , l = a.COMMENT_KEYS.concat(["comments"]).concat(o)
    },
    XJr0: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function isImmutable(t) {
            if ((0,
            a.default)(t.type, "Immutable"))
                return !0;
            if ((0,
            o.isIdentifier)(t))
                return "undefined" === t.name;
            return !1
        }
        ;
        var a = i("Mrar")
          , o = i("FUES")
    },
    "Xd/d": function(t, r, i) {
        "use strict";
        var a = i("41WB")
          , o = i("Eum2");
        t.exports = function(t, r, i) {
            return a(t, r).filter((function(t) {
                return "CommentLine" !== t.type && "CommentBlock" !== t.type
            }
            )).map((function(t) {
                return o(t, r, i)
            }
            ))
        }
    },
    XfNL: function(t, r, i) {
        "use strict";
        t.exports = i("n5Ud")
    },
    "Xz4/": function(t, r, i) {
        "use strict";
        function _createForOfIteratorHelper(t, r) {
            var i = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
            if (!i) {
                if (Array.isArray(t) || (i = function _unsupportedIterableToArray(t, r) {
                    if (!t)
                        return;
                    if ("string" == typeof t)
                        return _arrayLikeToArray(t, r);
                    var i = Object.prototype.toString.call(t).slice(8, -1);
                    "Object" === i && t.constructor && (i = t.constructor.name);
                    if ("Map" === i || "Set" === i)
                        return Array.from(t);
                    if ("Arguments" === i || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i))
                        return _arrayLikeToArray(t, r)
                }(t)) || r && t && "number" == typeof t.length) {
                    i && (t = i);
                    var a = 0
                      , o = function F() {};
                    return {
                        s: o,
                        n: function n() {
                            return a >= t.length ? {
                                done: !0
                            } : {
                                done: !1,
                                value: t[a++]
                            }
                        },
                        e: function e(t) {
                            throw t
                        },
                        f: o
                    }
                }
                throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
            }
            var l, u = !0, p = !1;
            return {
                s: function s() {
                    i = i.call(t)
                },
                n: function n() {
                    var t = i.next();
                    return u = t.done,
                    t
                },
                e: function e(t) {
                    p = !0,
                    l = t
                },
                f: function f() {
                    try {
                        u || null == i.return || i.return()
                    } finally {
                        if (p)
                            throw l
                    }
                }
            }
        }
        function _arrayLikeToArray(t, r) {
            (null == r || r > t.length) && (r = t.length);
            for (var i = 0, a = new Array(r); i < r; i++)
                a[i] = t[i];
            return a
        }
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function isPlaceholderType(t, r) {
            if (t === r)
                return !0;
            var i = a.PLACEHOLDERS_ALIAS[t];
            if (i) {
                var o, l = _createForOfIteratorHelper(i);
                try {
                    for (l.s(); !(o = l.n()).done; ) {
                        var u = o.value;
                        if (r === u)
                            return !0
                    }
                } catch (t) {
                    l.e(t)
                } finally {
                    l.f()
                }
            }
            return !1
        }
        ;
        var a = i("Resm")
    },
    Y0za: function(t, r, i) {
        "use strict";
        var a = i("PUqz")
          , o = i("IAoA");
        t.exports = function(t, r) {
            return o(r),
            a(t, r)
        }
    },
    Y7t6: function(t, r, i) {
        "use strict";
        var a = i("V97+")
          , o = i("8o0k")
          , l = i("F3vi");
        const u = (0,
        a.defineAliasedType)("TypeScript")
          , p = (0,
        a.assertValueType)("boolean")
          , c = {
            returnType: {
                validate: (0,
                a.assertNodeType)("TSTypeAnnotation", "Noop"),
                optional: !0
            },
            typeParameters: {
                validate: (0,
                a.assertNodeType)("TSTypeParameterDeclaration", "Noop"),
                optional: !0
            }
        };
        u("TSParameterProperty", {
            aliases: ["LVal"],
            visitor: ["parameter"],
            fields: {
                accessibility: {
                    validate: (0,
                    a.assertOneOf)("public", "private", "protected"),
                    optional: !0
                },
                readonly: {
                    validate: (0,
                    a.assertValueType)("boolean"),
                    optional: !0
                },
                parameter: {
                    validate: (0,
                    a.assertNodeType)("Identifier", "AssignmentPattern")
                },
                override: {
                    validate: (0,
                    a.assertValueType)("boolean"),
                    optional: !0
                },
                decorators: {
                    validate: (0,
                    a.chain)((0,
                    a.assertValueType)("array"), (0,
                    a.assertEach)((0,
                    a.assertNodeType)("Decorator"))),
                    optional: !0
                }
            }
        }),
        u("TSDeclareFunction", {
            aliases: ["Statement", "Declaration"],
            visitor: ["id", "typeParameters", "params", "returnType"],
            fields: Object.assign({}, o.functionDeclarationCommon, c)
        }),
        u("TSDeclareMethod", {
            visitor: ["decorators", "key", "typeParameters", "params", "returnType"],
            fields: Object.assign({}, o.classMethodOrDeclareMethodCommon, c)
        }),
        u("TSQualifiedName", {
            aliases: ["TSEntityName"],
            visitor: ["left", "right"],
            fields: {
                left: (0,
                a.validateType)("TSEntityName"),
                right: (0,
                a.validateType)("Identifier")
            }
        });
        const d = {
            typeParameters: (0,
            a.validateOptionalType)("TSTypeParameterDeclaration"),
            parameters: (0,
            a.validateArrayOfType)(["Identifier", "RestElement"]),
            typeAnnotation: (0,
            a.validateOptionalType)("TSTypeAnnotation")
        }
          , y = {
            aliases: ["TSTypeElement"],
            visitor: ["typeParameters", "parameters", "typeAnnotation"],
            fields: d
        };
        u("TSCallSignatureDeclaration", y),
        u("TSConstructSignatureDeclaration", y);
        const h = {
            key: (0,
            a.validateType)("Expression"),
            computed: (0,
            a.validate)(p),
            optional: (0,
            a.validateOptional)(p)
        };
        u("TSPropertySignature", {
            aliases: ["TSTypeElement"],
            visitor: ["key", "typeAnnotation", "initializer"],
            fields: Object.assign({}, h, {
                readonly: (0,
                a.validateOptional)(p),
                typeAnnotation: (0,
                a.validateOptionalType)("TSTypeAnnotation"),
                initializer: (0,
                a.validateOptionalType)("Expression"),
                kind: {
                    validate: (0,
                    a.assertOneOf)("get", "set")
                }
            })
        }),
        u("TSMethodSignature", {
            aliases: ["TSTypeElement"],
            visitor: ["key", "typeParameters", "parameters", "typeAnnotation"],
            fields: Object.assign({}, d, h, {
                kind: {
                    validate: (0,
                    a.assertOneOf)("method", "get", "set")
                }
            })
        }),
        u("TSIndexSignature", {
            aliases: ["TSTypeElement"],
            visitor: ["parameters", "typeAnnotation"],
            fields: {
                readonly: (0,
                a.validateOptional)(p),
                static: (0,
                a.validateOptional)(p),
                parameters: (0,
                a.validateArrayOfType)("Identifier"),
                typeAnnotation: (0,
                a.validateOptionalType)("TSTypeAnnotation")
            }
        });
        const m = ["TSAnyKeyword", "TSBooleanKeyword", "TSBigIntKeyword", "TSIntrinsicKeyword", "TSNeverKeyword", "TSNullKeyword", "TSNumberKeyword", "TSObjectKeyword", "TSStringKeyword", "TSSymbolKeyword", "TSUndefinedKeyword", "TSUnknownKeyword", "TSVoidKeyword"];
        for (const t of m)
            u(t, {
                aliases: ["TSType", "TSBaseType"],
                visitor: [],
                fields: {}
            });
        u("TSThisType", {
            aliases: ["TSType", "TSBaseType"],
            visitor: [],
            fields: {}
        });
        const T = {
            aliases: ["TSType"],
            visitor: ["typeParameters", "parameters", "typeAnnotation"]
        };
        u("TSFunctionType", Object.assign({}, T, {
            fields: d
        })),
        u("TSConstructorType", Object.assign({}, T, {
            fields: Object.assign({}, d, {
                abstract: (0,
                a.validateOptional)(p)
            })
        })),
        u("TSTypeReference", {
            aliases: ["TSType"],
            visitor: ["typeName", "typeParameters"],
            fields: {
                typeName: (0,
                a.validateType)("TSEntityName"),
                typeParameters: (0,
                a.validateOptionalType)("TSTypeParameterInstantiation")
            }
        }),
        u("TSTypePredicate", {
            aliases: ["TSType"],
            visitor: ["parameterName", "typeAnnotation"],
            builder: ["parameterName", "typeAnnotation", "asserts"],
            fields: {
                parameterName: (0,
                a.validateType)(["Identifier", "TSThisType"]),
                typeAnnotation: (0,
                a.validateOptionalType)("TSTypeAnnotation"),
                asserts: (0,
                a.validateOptional)(p)
            }
        }),
        u("TSTypeQuery", {
            aliases: ["TSType"],
            visitor: ["exprName"],
            fields: {
                exprName: (0,
                a.validateType)(["TSEntityName", "TSImportType"])
            }
        }),
        u("TSTypeLiteral", {
            aliases: ["TSType"],
            visitor: ["members"],
            fields: {
                members: (0,
                a.validateArrayOfType)("TSTypeElement")
            }
        }),
        u("TSArrayType", {
            aliases: ["TSType"],
            visitor: ["elementType"],
            fields: {
                elementType: (0,
                a.validateType)("TSType")
            }
        }),
        u("TSTupleType", {
            aliases: ["TSType"],
            visitor: ["elementTypes"],
            fields: {
                elementTypes: (0,
                a.validateArrayOfType)(["TSType", "TSNamedTupleMember"])
            }
        }),
        u("TSOptionalType", {
            aliases: ["TSType"],
            visitor: ["typeAnnotation"],
            fields: {
                typeAnnotation: (0,
                a.validateType)("TSType")
            }
        }),
        u("TSRestType", {
            aliases: ["TSType"],
            visitor: ["typeAnnotation"],
            fields: {
                typeAnnotation: (0,
                a.validateType)("TSType")
            }
        }),
        u("TSNamedTupleMember", {
            visitor: ["label", "elementType"],
            builder: ["label", "elementType", "optional"],
            fields: {
                label: (0,
                a.validateType)("Identifier"),
                optional: {
                    validate: p,
                    default: !1
                },
                elementType: (0,
                a.validateType)("TSType")
            }
        });
        const S = {
            aliases: ["TSType"],
            visitor: ["types"],
            fields: {
                types: (0,
                a.validateArrayOfType)("TSType")
            }
        };
        u("TSUnionType", S),
        u("TSIntersectionType", S),
        u("TSConditionalType", {
            aliases: ["TSType"],
            visitor: ["checkType", "extendsType", "trueType", "falseType"],
            fields: {
                checkType: (0,
                a.validateType)("TSType"),
                extendsType: (0,
                a.validateType)("TSType"),
                trueType: (0,
                a.validateType)("TSType"),
                falseType: (0,
                a.validateType)("TSType")
            }
        }),
        u("TSInferType", {
            aliases: ["TSType"],
            visitor: ["typeParameter"],
            fields: {
                typeParameter: (0,
                a.validateType)("TSTypeParameter")
            }
        }),
        u("TSParenthesizedType", {
            aliases: ["TSType"],
            visitor: ["typeAnnotation"],
            fields: {
                typeAnnotation: (0,
                a.validateType)("TSType")
            }
        }),
        u("TSTypeOperator", {
            aliases: ["TSType"],
            visitor: ["typeAnnotation"],
            fields: {
                operator: (0,
                a.validate)((0,
                a.assertValueType)("string")),
                typeAnnotation: (0,
                a.validateType)("TSType")
            }
        }),
        u("TSIndexedAccessType", {
            aliases: ["TSType"],
            visitor: ["objectType", "indexType"],
            fields: {
                objectType: (0,
                a.validateType)("TSType"),
                indexType: (0,
                a.validateType)("TSType")
            }
        }),
        u("TSMappedType", {
            aliases: ["TSType"],
            visitor: ["typeParameter", "typeAnnotation", "nameType"],
            fields: {
                readonly: (0,
                a.validateOptional)(p),
                typeParameter: (0,
                a.validateType)("TSTypeParameter"),
                optional: (0,
                a.validateOptional)(p),
                typeAnnotation: (0,
                a.validateOptionalType)("TSType"),
                nameType: (0,
                a.validateOptionalType)("TSType")
            }
        }),
        u("TSLiteralType", {
            aliases: ["TSType", "TSBaseType"],
            visitor: ["literal"],
            fields: {
                literal: {
                    validate: function() {
                        const t = (0,
                        a.assertNodeType)("NumericLiteral", "BigIntLiteral")
                          , r = (0,
                        a.assertOneOf)("-")
                          , i = (0,
                        a.assertNodeType)("NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral");
                        function validator(a, o, u) {
                            (0,
                            l.default)("UnaryExpression", u) ? (r(u, "operator", u.operator),
                            t(u, "argument", u.argument)) : i(a, o, u)
                        }
                        return validator.oneOfNodeTypes = ["NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral", "UnaryExpression"],
                        validator
                    }()
                }
            }
        }),
        u("TSExpressionWithTypeArguments", {
            aliases: ["TSType"],
            visitor: ["expression", "typeParameters"],
            fields: {
                expression: (0,
                a.validateType)("TSEntityName"),
                typeParameters: (0,
                a.validateOptionalType)("TSTypeParameterInstantiation")
            }
        }),
        u("TSInterfaceDeclaration", {
            aliases: ["Statement", "Declaration"],
            visitor: ["id", "typeParameters", "extends", "body"],
            fields: {
                declare: (0,
                a.validateOptional)(p),
                id: (0,
                a.validateType)("Identifier"),
                typeParameters: (0,
                a.validateOptionalType)("TSTypeParameterDeclaration"),
                extends: (0,
                a.validateOptional)((0,
                a.arrayOfType)("TSExpressionWithTypeArguments")),
                body: (0,
                a.validateType)("TSInterfaceBody")
            }
        }),
        u("TSInterfaceBody", {
            visitor: ["body"],
            fields: {
                body: (0,
                a.validateArrayOfType)("TSTypeElement")
            }
        }),
        u("TSTypeAliasDeclaration", {
            aliases: ["Statement", "Declaration"],
            visitor: ["id", "typeParameters", "typeAnnotation"],
            fields: {
                declare: (0,
                a.validateOptional)(p),
                id: (0,
                a.validateType)("Identifier"),
                typeParameters: (0,
                a.validateOptionalType)("TSTypeParameterDeclaration"),
                typeAnnotation: (0,
                a.validateType)("TSType")
            }
        }),
        u("TSAsExpression", {
            aliases: ["Expression"],
            visitor: ["expression", "typeAnnotation"],
            fields: {
                expression: (0,
                a.validateType)("Expression"),
                typeAnnotation: (0,
                a.validateType)("TSType")
            }
        }),
        u("TSTypeAssertion", {
            aliases: ["Expression"],
            visitor: ["typeAnnotation", "expression"],
            fields: {
                typeAnnotation: (0,
                a.validateType)("TSType"),
                expression: (0,
                a.validateType)("Expression")
            }
        }),
        u("TSEnumDeclaration", {
            aliases: ["Statement", "Declaration"],
            visitor: ["id", "members"],
            fields: {
                declare: (0,
                a.validateOptional)(p),
                const: (0,
                a.validateOptional)(p),
                id: (0,
                a.validateType)("Identifier"),
                members: (0,
                a.validateArrayOfType)("TSEnumMember"),
                initializer: (0,
                a.validateOptionalType)("Expression")
            }
        }),
        u("TSEnumMember", {
            visitor: ["id", "initializer"],
            fields: {
                id: (0,
                a.validateType)(["Identifier", "StringLiteral"]),
                initializer: (0,
                a.validateOptionalType)("Expression")
            }
        }),
        u("TSModuleDeclaration", {
            aliases: ["Statement", "Declaration"],
            visitor: ["id", "body"],
            fields: {
                declare: (0,
                a.validateOptional)(p),
                global: (0,
                a.validateOptional)(p),
                id: (0,
                a.validateType)(["Identifier", "StringLiteral"]),
                body: (0,
                a.validateType)(["TSModuleBlock", "TSModuleDeclaration"])
            }
        }),
        u("TSModuleBlock", {
            aliases: ["Scopable", "Block", "BlockParent"],
            visitor: ["body"],
            fields: {
                body: (0,
                a.validateArrayOfType)("Statement")
            }
        }),
        u("TSImportType", {
            aliases: ["TSType"],
            visitor: ["argument", "qualifier", "typeParameters"],
            fields: {
                argument: (0,
                a.validateType)("StringLiteral"),
                qualifier: (0,
                a.validateOptionalType)("TSEntityName"),
                typeParameters: (0,
                a.validateOptionalType)("TSTypeParameterInstantiation")
            }
        }),
        u("TSImportEqualsDeclaration", {
            aliases: ["Statement"],
            visitor: ["id", "moduleReference"],
            fields: {
                isExport: (0,
                a.validate)(p),
                id: (0,
                a.validateType)("Identifier"),
                moduleReference: (0,
                a.validateType)(["TSEntityName", "TSExternalModuleReference"]),
                importKind: {
                    validate: (0,
                    a.assertOneOf)("type", "value"),
                    optional: !0
                }
            }
        }),
        u("TSExternalModuleReference", {
            visitor: ["expression"],
            fields: {
                expression: (0,
                a.validateType)("StringLiteral")
            }
        }),
        u("TSNonNullExpression", {
            aliases: ["Expression"],
            visitor: ["expression"],
            fields: {
                expression: (0,
                a.validateType)("Expression")
            }
        }),
        u("TSExportAssignment", {
            aliases: ["Statement"],
            visitor: ["expression"],
            fields: {
                expression: (0,
                a.validateType)("Expression")
            }
        }),
        u("TSNamespaceExportDeclaration", {
            aliases: ["Statement"],
            visitor: ["id"],
            fields: {
                id: (0,
                a.validateType)("Identifier")
            }
        }),
        u("TSTypeAnnotation", {
            visitor: ["typeAnnotation"],
            fields: {
                typeAnnotation: {
                    validate: (0,
                    a.assertNodeType)("TSType")
                }
            }
        }),
        u("TSTypeParameterInstantiation", {
            visitor: ["params"],
            fields: {
                params: {
                    validate: (0,
                    a.chain)((0,
                    a.assertValueType)("array"), (0,
                    a.assertEach)((0,
                    a.assertNodeType)("TSType")))
                }
            }
        }),
        u("TSTypeParameterDeclaration", {
            visitor: ["params"],
            fields: {
                params: {
                    validate: (0,
                    a.chain)((0,
                    a.assertValueType)("array"), (0,
                    a.assertEach)((0,
                    a.assertNodeType)("TSTypeParameter")))
                }
            }
        }),
        u("TSTypeParameter", {
            builder: ["constraint", "default", "name"],
            visitor: ["constraint", "default"],
            fields: {
                name: {
                    validate: (0,
                    a.assertValueType)("string")
                },
                constraint: {
                    validate: (0,
                    a.assertNodeType)("TSType"),
                    optional: !0
                },
                default: {
                    validate: (0,
                    a.assertNodeType)("TSType"),
                    optional: !0
                }
            }
        })
    },
    YFjm: function(t, r, i) {
        "use strict";
        function _createForOfIteratorHelper(t, r) {
            var i = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
            if (!i) {
                if (Array.isArray(t) || (i = function _unsupportedIterableToArray(t, r) {
                    if (!t)
                        return;
                    if ("string" == typeof t)
                        return _arrayLikeToArray(t, r);
                    var i = Object.prototype.toString.call(t).slice(8, -1);
                    "Object" === i && t.constructor && (i = t.constructor.name);
                    if ("Map" === i || "Set" === i)
                        return Array.from(t);
                    if ("Arguments" === i || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i))
                        return _arrayLikeToArray(t, r)
                }(t)) || r && t && "number" == typeof t.length) {
                    i && (t = i);
                    var a = 0
                      , o = function F() {};
                    return {
                        s: o,
                        n: function n() {
                            return a >= t.length ? {
                                done: !0
                            } : {
                                done: !1,
                                value: t[a++]
                            }
                        },
                        e: function e(t) {
                            throw t
                        },
                        f: o
                    }
                }
                throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
            }
            var l, u = !0, p = !1;
            return {
                s: function s() {
                    i = i.call(t)
                },
                n: function n() {
                    var t = i.next();
                    return u = t.done,
                    t
                },
                e: function e(t) {
                    p = !0,
                    l = t
                },
                f: function f() {
                    try {
                        u || null == i.return || i.return()
                    } finally {
                        if (p)
                            throw l
                    }
                }
            }
        }
        function _arrayLikeToArray(t, r) {
            (null == r || r > t.length) && (r = t.length);
            for (var i = 0, a = new Array(r); i < r; i++)
                a[i] = t[i];
            return a
        }
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function removeProperties(t) {
            var r, i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, a = i.preserveComments ? o : l, u = _createForOfIteratorHelper(a);
            try {
                for (u.s(); !(r = u.n()).done; ) {
                    var p = r.value;
                    null != t[p] && (t[p] = void 0)
                }
            } catch (t) {
                u.e(t)
            } finally {
                u.f()
            }
            for (var c = 0, d = Object.keys(t); c < d.length; c++) {
                var y = d[c];
                "_" === y[0] && null != t[y] && (t[y] = void 0)
            }
            var h, m = Object.getOwnPropertySymbols(t), T = _createForOfIteratorHelper(m);
            try {
                for (T.s(); !(h = T.n()).done; ) {
                    var S = h.value;
                    t[S] = null
                }
            } catch (t) {
                T.e(t)
            } finally {
                T.f()
            }
        }
        ;
        var a = i("M7ys")
          , o = ["tokens", "start", "end", "loc", "raw", "rawValue"]
          , l = a.COMMENT_KEYS.concat(["comments"]).concat(o)
    },
    YIMe: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function traverse(t, r, i) {
            "function" == typeof r && (r = {
                enter: r
            });
            const {enter: o, exit: l} = r;
            !function traverseSimpleImpl(t, r, i, o, l) {
                const u = a.VISITOR_KEYS[t.type];
                if (!u)
                    return;
                r && r(t, l, o);
                for (const a of u) {
                    const u = t[a];
                    if (Array.isArray(u))
                        for (let p = 0; p < u.length; p++) {
                            const c = u[p];
                            c && (l.push({
                                node: t,
                                key: a,
                                index: p
                            }),
                            traverseSimpleImpl(c, r, i, o, l),
                            l.pop())
                        }
                    else
                        u && (l.push({
                            node: t,
                            key: a
                        }),
                        traverseSimpleImpl(u, r, i, o, l),
                        l.pop())
                }
                i && i(t, l, o)
            }(t, o, l, i, [])
        }
        ;
        var a = i("uXiX")
    },
    YQA8: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function addComment(t, r, i, o) {
            return (0,
            a.default)(t, r, [{
                type: o ? "CommentLine" : "CommentBlock",
                value: i
            }])
        }
        ;
        var a = i("RwJ3")
    },
    YSHT: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        });
        var a = {
            react: !0,
            assertNode: !0,
            createTypeAnnotationBasedOnTypeof: !0,
            createUnionTypeAnnotation: !0,
            createFlowUnionType: !0,
            createTSUnionType: !0,
            cloneNode: !0,
            clone: !0,
            cloneDeep: !0,
            cloneDeepWithoutLoc: !0,
            cloneWithoutLoc: !0,
            addComment: !0,
            addComments: !0,
            inheritInnerComments: !0,
            inheritLeadingComments: !0,
            inheritsComments: !0,
            inheritTrailingComments: !0,
            removeComments: !0,
            ensureBlock: !0,
            toBindingIdentifierName: !0,
            toBlock: !0,
            toComputedKey: !0,
            toExpression: !0,
            toIdentifier: !0,
            toKeyAlias: !0,
            toSequenceExpression: !0,
            toStatement: !0,
            valueToNode: !0,
            appendToMemberExpression: !0,
            inherits: !0,
            prependToMemberExpression: !0,
            removeProperties: !0,
            removePropertiesDeep: !0,
            removeTypeDuplicates: !0,
            getBindingIdentifiers: !0,
            getOuterBindingIdentifiers: !0,
            traverse: !0,
            traverseFast: !0,
            shallowEqual: !0,
            is: !0,
            isBinding: !0,
            isBlockScoped: !0,
            isImmutable: !0,
            isLet: !0,
            isNode: !0,
            isNodesEquivalent: !0,
            isPlaceholderType: !0,
            isReferenced: !0,
            isScope: !0,
            isSpecifierDefault: !0,
            isType: !0,
            isValidES3Identifier: !0,
            isValidIdentifier: !0,
            isVar: !0,
            matchesPattern: !0,
            validate: !0,
            buildMatchMemberExpression: !0
        };
        Object.defineProperty(r, "assertNode", {
            enumerable: !0,
            get: function get() {
                return p.default
            }
        }),
        Object.defineProperty(r, "createTypeAnnotationBasedOnTypeof", {
            enumerable: !0,
            get: function get() {
                return d.default
            }
        }),
        Object.defineProperty(r, "createUnionTypeAnnotation", {
            enumerable: !0,
            get: function get() {
                return y.default
            }
        }),
        Object.defineProperty(r, "createFlowUnionType", {
            enumerable: !0,
            get: function get() {
                return y.default
            }
        }),
        Object.defineProperty(r, "createTSUnionType", {
            enumerable: !0,
            get: function get() {
                return h.default
            }
        }),
        Object.defineProperty(r, "cloneNode", {
            enumerable: !0,
            get: function get() {
                return S.default
            }
        }),
        Object.defineProperty(r, "clone", {
            enumerable: !0,
            get: function get() {
                return g.default
            }
        }),
        Object.defineProperty(r, "cloneDeep", {
            enumerable: !0,
            get: function get() {
                return b.default
            }
        }),
        Object.defineProperty(r, "cloneDeepWithoutLoc", {
            enumerable: !0,
            get: function get() {
                return v.default
            }
        }),
        Object.defineProperty(r, "cloneWithoutLoc", {
            enumerable: !0,
            get: function get() {
                return E.default
            }
        }),
        Object.defineProperty(r, "addComment", {
            enumerable: !0,
            get: function get() {
                return P.default
            }
        }),
        Object.defineProperty(r, "addComments", {
            enumerable: !0,
            get: function get() {
                return x.default
            }
        }),
        Object.defineProperty(r, "inheritInnerComments", {
            enumerable: !0,
            get: function get() {
                return A.default
            }
        }),
        Object.defineProperty(r, "inheritLeadingComments", {
            enumerable: !0,
            get: function get() {
                return O.default
            }
        }),
        Object.defineProperty(r, "inheritsComments", {
            enumerable: !0,
            get: function get() {
                return I.default
            }
        }),
        Object.defineProperty(r, "inheritTrailingComments", {
            enumerable: !0,
            get: function get() {
                return w.default
            }
        }),
        Object.defineProperty(r, "removeComments", {
            enumerable: !0,
            get: function get() {
                return C.default
            }
        }),
        Object.defineProperty(r, "ensureBlock", {
            enumerable: !0,
            get: function get() {
                return _.default
            }
        }),
        Object.defineProperty(r, "toBindingIdentifierName", {
            enumerable: !0,
            get: function get() {
                return L.default
            }
        }),
        Object.defineProperty(r, "toBlock", {
            enumerable: !0,
            get: function get() {
                return k.default
            }
        }),
        Object.defineProperty(r, "toComputedKey", {
            enumerable: !0,
            get: function get() {
                return M.default
            }
        }),
        Object.defineProperty(r, "toExpression", {
            enumerable: !0,
            get: function get() {
                return j.default
            }
        }),
        Object.defineProperty(r, "toIdentifier", {
            enumerable: !0,
            get: function get() {
                return B.default
            }
        }),
        Object.defineProperty(r, "toKeyAlias", {
            enumerable: !0,
            get: function get() {
                return R.default
            }
        }),
        Object.defineProperty(r, "toSequenceExpression", {
            enumerable: !0,
            get: function get() {
                return K.default
            }
        }),
        Object.defineProperty(r, "toStatement", {
            enumerable: !0,
            get: function get() {
                return V.default
            }
        }),
        Object.defineProperty(r, "valueToNode", {
            enumerable: !0,
            get: function get() {
                return U.default
            }
        }),
        Object.defineProperty(r, "appendToMemberExpression", {
            enumerable: !0,
            get: function get() {
                return X.default
            }
        }),
        Object.defineProperty(r, "inherits", {
            enumerable: !0,
            get: function get() {
                return J.default
            }
        }),
        Object.defineProperty(r, "prependToMemberExpression", {
            enumerable: !0,
            get: function get() {
                return W.default
            }
        }),
        Object.defineProperty(r, "removeProperties", {
            enumerable: !0,
            get: function get() {
                return q.default
            }
        }),
        Object.defineProperty(r, "removePropertiesDeep", {
            enumerable: !0,
            get: function get() {
                return H.default
            }
        }),
        Object.defineProperty(r, "removeTypeDuplicates", {
            enumerable: !0,
            get: function get() {
                return G.default
            }
        }),
        Object.defineProperty(r, "getBindingIdentifiers", {
            enumerable: !0,
            get: function get() {
                return z.default
            }
        }),
        Object.defineProperty(r, "getOuterBindingIdentifiers", {
            enumerable: !0,
            get: function get() {
                return Q.default
            }
        }),
        Object.defineProperty(r, "traverse", {
            enumerable: !0,
            get: function get() {
                return $.default
            }
        }),
        Object.defineProperty(r, "traverseFast", {
            enumerable: !0,
            get: function get() {
                return Z.default
            }
        }),
        Object.defineProperty(r, "shallowEqual", {
            enumerable: !0,
            get: function get() {
                return ee.default
            }
        }),
        Object.defineProperty(r, "is", {
            enumerable: !0,
            get: function get() {
                return te.default
            }
        }),
        Object.defineProperty(r, "isBinding", {
            enumerable: !0,
            get: function get() {
                return re.default
            }
        }),
        Object.defineProperty(r, "isBlockScoped", {
            enumerable: !0,
            get: function get() {
                return ne.default
            }
        }),
        Object.defineProperty(r, "isImmutable", {
            enumerable: !0,
            get: function get() {
                return ie.default
            }
        }),
        Object.defineProperty(r, "isLet", {
            enumerable: !0,
            get: function get() {
                return ae.default
            }
        }),
        Object.defineProperty(r, "isNode", {
            enumerable: !0,
            get: function get() {
                return se.default
            }
        }),
        Object.defineProperty(r, "isNodesEquivalent", {
            enumerable: !0,
            get: function get() {
                return oe.default
            }
        }),
        Object.defineProperty(r, "isPlaceholderType", {
            enumerable: !0,
            get: function get() {
                return le.default
            }
        }),
        Object.defineProperty(r, "isReferenced", {
            enumerable: !0,
            get: function get() {
                return ue.default
            }
        }),
        Object.defineProperty(r, "isScope", {
            enumerable: !0,
            get: function get() {
                return pe.default
            }
        }),
        Object.defineProperty(r, "isSpecifierDefault", {
            enumerable: !0,
            get: function get() {
                return ce.default
            }
        }),
        Object.defineProperty(r, "isType", {
            enumerable: !0,
            get: function get() {
                return de.default
            }
        }),
        Object.defineProperty(r, "isValidES3Identifier", {
            enumerable: !0,
            get: function get() {
                return fe.default
            }
        }),
        Object.defineProperty(r, "isValidIdentifier", {
            enumerable: !0,
            get: function get() {
                return ye.default
            }
        }),
        Object.defineProperty(r, "isVar", {
            enumerable: !0,
            get: function get() {
                return he.default
            }
        }),
        Object.defineProperty(r, "matchesPattern", {
            enumerable: !0,
            get: function get() {
                return me.default
            }
        }),
        Object.defineProperty(r, "validate", {
            enumerable: !0,
            get: function get() {
                return Te.default
            }
        }),
        Object.defineProperty(r, "buildMatchMemberExpression", {
            enumerable: !0,
            get: function get() {
                return Se.default
            }
        }),
        r.react = void 0;
        var o = i("Iges")
          , l = i("U7Gz")
          , u = i("01Gy")
          , p = i("IQ/f")
          , c = i("nsxz");
        Object.keys(c).forEach((function(t) {
            "default" !== t && "__esModule" !== t && (Object.prototype.hasOwnProperty.call(a, t) || t in r && r[t] === c[t] || Object.defineProperty(r, t, {
                enumerable: !0,
                get: function get() {
                    return c[t]
                }
            }))
        }
        ));
        var d = i("AzTl")
          , y = i("0dgS")
          , h = i("LrfX")
          , m = i("57mi");
        Object.keys(m).forEach((function(t) {
            "default" !== t && "__esModule" !== t && (Object.prototype.hasOwnProperty.call(a, t) || t in r && r[t] === m[t] || Object.defineProperty(r, t, {
                enumerable: !0,
                get: function get() {
                    return m[t]
                }
            }))
        }
        ));
        var T = i("LtBJ");
        Object.keys(T).forEach((function(t) {
            "default" !== t && "__esModule" !== t && (Object.prototype.hasOwnProperty.call(a, t) || t in r && r[t] === T[t] || Object.defineProperty(r, t, {
                enumerable: !0,
                get: function get() {
                    return T[t]
                }
            }))
        }
        ));
        var S = i("sN7J")
          , g = i("ZxeC")
          , b = i("Qveh")
          , v = i("OzTh")
          , E = i("oBS/")
          , P = i("TrjT")
          , x = i("O4gS")
          , A = i("8iKV")
          , O = i("uDmM")
          , I = i("0JKf")
          , w = i("OLSu")
          , C = i("TR6X")
          , N = i("ylBm");
        Object.keys(N).forEach((function(t) {
            "default" !== t && "__esModule" !== t && (Object.prototype.hasOwnProperty.call(a, t) || t in r && r[t] === N[t] || Object.defineProperty(r, t, {
                enumerable: !0,
                get: function get() {
                    return N[t]
                }
            }))
        }
        ));
        var D = i("RS7Y");
        Object.keys(D).forEach((function(t) {
            "default" !== t && "__esModule" !== t && (Object.prototype.hasOwnProperty.call(a, t) || t in r && r[t] === D[t] || Object.defineProperty(r, t, {
                enumerable: !0,
                get: function get() {
                    return D[t]
                }
            }))
        }
        ));
        var _ = i("/erN")
          , L = i("Ax53")
          , k = i("dtFd")
          , M = i("AVna")
          , j = i("gL1R")
          , B = i("z1ss")
          , R = i("qtGH")
          , K = i("782H")
          , V = i("1kGC")
          , U = i("jr7T")
          , Y = i("Resm");
        Object.keys(Y).forEach((function(t) {
            "default" !== t && "__esModule" !== t && (Object.prototype.hasOwnProperty.call(a, t) || t in r && r[t] === Y[t] || Object.defineProperty(r, t, {
                enumerable: !0,
                get: function get() {
                    return Y[t]
                }
            }))
        }
        ));
        var X = i("xu3U")
          , J = i("anS6")
          , W = i("uqjE")
          , q = i("N2Vh")
          , H = i("dm8S")
          , G = i("EOii")
          , z = i("oUnQ")
          , Q = i("v+vk")
          , $ = i("iff2");
        Object.keys($).forEach((function(t) {
            "default" !== t && "__esModule" !== t && (Object.prototype.hasOwnProperty.call(a, t) || t in r && r[t] === $[t] || Object.defineProperty(r, t, {
                enumerable: !0,
                get: function get() {
                    return $[t]
                }
            }))
        }
        ));
        var Z = i("8YYJ")
          , ee = i("0Cqy")
          , te = i("0G7A")
          , re = i("lFjz")
          , ne = i("63rZ")
          , ie = i("XJr0")
          , ae = i("9gGh")
          , se = i("buHe")
          , oe = i("AaQr")
          , le = i("Xz4/")
          , ue = i("TkAf")
          , pe = i("b89f")
          , ce = i("z6FP")
          , de = i("Mrar")
          , fe = i("SDP1")
          , ye = i("yK+d")
          , he = i("4RZc")
          , me = i("z2IN")
          , Te = i("kmK0")
          , Se = i("OPXu")
          , ge = i("FUES");
        Object.keys(ge).forEach((function(t) {
            "default" !== t && "__esModule" !== t && (Object.prototype.hasOwnProperty.call(a, t) || t in r && r[t] === ge[t] || Object.defineProperty(r, t, {
                enumerable: !0,
                get: function get() {
                    return ge[t]
                }
            }))
        }
        ));
        var be = i("unU7");
        Object.keys(be).forEach((function(t) {
            "default" !== t && "__esModule" !== t && (Object.prototype.hasOwnProperty.call(a, t) || t in r && r[t] === be[t] || Object.defineProperty(r, t, {
                enumerable: !0,
                get: function get() {
                    return be[t]
                }
            }))
        }
        ));
        var ve = {
            isReactComponent: o.default,
            isCompatTag: l.default,
            buildChildren: u.default
        };
        r.react = ve
    },
    Yb52: function(t, r, i) {
        "use strict";
        var a = i("TqRt")(i("RIqP"));
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function removeTypeDuplicates(t) {
            for (var r = {}, i = {}, l = new Set, u = [], p = 0; p < t.length; p++) {
                var c = t[p];
                if (c && !(u.indexOf(c) >= 0)) {
                    if ((0,
                    o.isTSAnyKeyword)(c))
                        return [c];
                    (0,
                    o.isTSBaseType)(c) ? i[c.type] = c : (0,
                    o.isTSUnionType)(c) ? l.has(c.types) || (t.push.apply(t, (0,
                    a.default)(c.types)),
                    l.add(c.types)) : u.push(c)
                }
            }
            for (var d = 0, y = Object.keys(i); d < y.length; d++) {
                var h = y[d];
                u.push(i[h])
            }
            for (var m = 0, T = Object.keys(r); m < T.length; m++) {
                var S = T[m];
                u.push(r[S])
            }
            return u
        }
        ;
        var o = i("pbIU")
    },
    "Yp+L": function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function createFlowUnionType(t) {
            const r = (0,
            o.default)(t);
            return 1 === r.length ? r[0] : (0,
            a.unionTypeAnnotation)(r)
        }
        ;
        var a = i("61uC")
          , o = i("6tYi")
    },
    YqAK: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function createTSUnionType(t) {
            const r = t.map(t=>t.typeAnnotation)
              , i = (0,
            o.default)(r);
            return 1 === i.length ? i[0] : (0,
            a.tsUnionType)(i)
        }
        ;
        var a = i("61uC")
          , o = i("Gv8t")
    },
    YupJ: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function validate(t, r, i) {
            if (!t)
                return;
            const o = a.NODE_FIELDS[t.type];
            if (!o)
                return;
            const l = o[r];
            validateField(t, r, i, l),
            validateChild(t, r, i)
        }
        ,
        r.validateChild = validateChild,
        r.validateField = validateField;
        var a = i("uXiX");
        function validateField(t, r, i, a) {
            null != a && a.validate && (a.optional && null == i || a.validate(t, r, i))
        }
        function validateChild(t, r, i) {
            if (null == i)
                return;
            const o = a.NODE_PARENT_VALIDATIONS[i.type];
            o && o(t, r, i)
        }
    },
    Ywlc: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function isNodesEquivalent(t, r) {
            if ("object" != typeof t || "object" != typeof r || null == t || null == r)
                return t === r;
            if (t.type !== r.type)
                return !1;
            const i = Object.keys(a.NODE_FIELDS[t.type] || t.type)
              , o = a.VISITOR_KEYS[t.type];
            for (const a of i) {
                if (typeof t[a] != typeof r[a])
                    return !1;
                if (null != t[a] || null != r[a]) {
                    if (null == t[a] || null == r[a])
                        return !1;
                    if (Array.isArray(t[a])) {
                        if (!Array.isArray(r[a]))
                            return !1;
                        if (t[a].length !== r[a].length)
                            return !1;
                        for (let i = 0; i < t[a].length; i++)
                            if (!isNodesEquivalent(t[a][i], r[a][i]))
                                return !1
                    } else if ("object" != typeof t[a] || null != o && o.includes(a)) {
                        if (!isNodesEquivalent(t[a], r[a]))
                            return !1
                    } else
                        for (const i of Object.keys(t[a]))
                            if (t[a][i] !== r[a][i])
                                return !1
                }
            }
            return !0
        }
        ;
        var a = i("uXiX")
    },
    Z1lV: function(t, r) {
        r.GREATEST_LOWER_BOUND = 1,
        r.LEAST_UPPER_BOUND = 2,
        r.search = function search(t, i, a, o) {
            if (0 === i.length)
                return -1;
            var l = function recursiveSearch(t, i, a, o, l, u) {
                var p = Math.floor((i - t) / 2) + t
                  , c = l(a, o[p], !0);
                return 0 === c ? p : c > 0 ? i - p > 1 ? recursiveSearch(p, i, a, o, l, u) : u == r.LEAST_UPPER_BOUND ? i < o.length ? i : -1 : p : p - t > 1 ? recursiveSearch(t, p, a, o, l, u) : u == r.LEAST_UPPER_BOUND ? p : t < 0 ? -1 : t
            }(-1, i.length, t, i, a, o || r.GREATEST_LOWER_BOUND);
            if (l < 0)
                return -1;
            for (; l - 1 >= 0 && 0 === a(i[l], i[l - 1], !0); )
                --l;
            return l
        }
    },
    Z6Aa: function(t, r, i) {
        "use strict";
        function _createForOfIteratorHelper(t, r) {
            var i = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
            if (!i) {
                if (Array.isArray(t) || (i = function _unsupportedIterableToArray(t, r) {
                    if (!t)
                        return;
                    if ("string" == typeof t)
                        return _arrayLikeToArray(t, r);
                    var i = Object.prototype.toString.call(t).slice(8, -1);
                    "Object" === i && t.constructor && (i = t.constructor.name);
                    if ("Map" === i || "Set" === i)
                        return Array.from(t);
                    if ("Arguments" === i || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i))
                        return _arrayLikeToArray(t, r)
                }(t)) || r && t && "number" == typeof t.length) {
                    i && (t = i);
                    var a = 0
                      , o = function F() {};
                    return {
                        s: o,
                        n: function n() {
                            return a >= t.length ? {
                                done: !0
                            } : {
                                done: !1,
                                value: t[a++]
                            }
                        },
                        e: function e(t) {
                            throw t
                        },
                        f: o
                    }
                }
                throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
            }
            var l, u = !0, p = !1;
            return {
                s: function s() {
                    i = i.call(t)
                },
                n: function n() {
                    var t = i.next();
                    return u = t.done,
                    t
                },
                e: function e(t) {
                    p = !0,
                    l = t
                },
                f: function f() {
                    try {
                        u || null == i.return || i.return()
                    } finally {
                        if (p)
                            throw l
                    }
                }
            }
        }
        function _arrayLikeToArray(t, r) {
            (null == r || r > t.length) && (r = t.length);
            for (var i = 0, a = new Array(r); i < r; i++)
                a[i] = t[i];
            return a
        }
        var a, o = i("aMy0"), l = _createForOfIteratorHelper(Object.freeze(Object.keys(o)));
        try {
            for (l.s(); !(a = l.n()).done; ) {
                var u = a.value;
                Object.freeze(o[u])
            }
        } catch (t) {
            l.e(t)
        } finally {
            l.f()
        }
        Object.freeze(o);
        var p = new Set(["parent", "leadingComments", "trailingComments"]);
        function filterKey(t) {
            return !p.has(t) && "_" !== t[0]
        }
        t.exports = Object.freeze({
            KEYS: o,
            getKeys: function getKeys(t) {
                return Object.keys(t).filter(filterKey)
            },
            unionWith: function unionWith(t) {
                for (var r = Object.assign({}, o), i = 0, a = Object.keys(t); i < a.length; i++) {
                    var l = a[i];
                    if (r.hasOwnProperty(l)) {
                        var u, p = new Set(t[l]), c = _createForOfIteratorHelper(r[l]);
                        try {
                            for (c.s(); !(u = c.n()).done; ) {
                                var d = u.value;
                                p.add(d)
                            }
                        } catch (t) {
                            c.e(t)
                        } finally {
                            c.f()
                        }
                        r[l] = Object.freeze(Array.from(p))
                    } else
                        r[l] = Object.freeze(Array.from(t[l]))
                }
                return Object.freeze(r)
            }
        })
    },
    ZeCc: function(t, r, i) {
        "use strict";
        var a = i("7ePq");
        (0,
        a.default)("JSXAttribute", {
            visitor: ["name", "value"],
            aliases: ["JSX", "Immutable"],
            fields: {
                name: {
                    validate: (0,
                    a.assertNodeType)("JSXIdentifier", "JSXNamespacedName")
                },
                value: {
                    optional: !0,
                    validate: (0,
                    a.assertNodeType)("JSXElement", "JSXFragment", "StringLiteral", "JSXExpressionContainer")
                }
            }
        }),
        (0,
        a.default)("JSXClosingElement", {
            visitor: ["name"],
            aliases: ["JSX", "Immutable"],
            fields: {
                name: {
                    validate: (0,
                    a.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
                }
            }
        }),
        (0,
        a.default)("JSXElement", {
            builder: ["openingElement", "closingElement", "children", "selfClosing"],
            visitor: ["openingElement", "children", "closingElement"],
            aliases: ["JSX", "Immutable", "Expression"],
            fields: {
                openingElement: {
                    validate: (0,
                    a.assertNodeType)("JSXOpeningElement")
                },
                closingElement: {
                    optional: !0,
                    validate: (0,
                    a.assertNodeType)("JSXClosingElement")
                },
                children: {
                    validate: (0,
                    a.chain)((0,
                    a.assertValueType)("array"), (0,
                    a.assertEach)((0,
                    a.assertNodeType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")))
                },
                selfClosing: {
                    validate: (0,
                    a.assertValueType)("boolean"),
                    optional: !0
                }
            }
        }),
        (0,
        a.default)("JSXEmptyExpression", {
            aliases: ["JSX"]
        }),
        (0,
        a.default)("JSXExpressionContainer", {
            visitor: ["expression"],
            aliases: ["JSX", "Immutable"],
            fields: {
                expression: {
                    validate: (0,
                    a.assertNodeType)("Expression", "JSXEmptyExpression")
                }
            }
        }),
        (0,
        a.default)("JSXSpreadChild", {
            visitor: ["expression"],
            aliases: ["JSX", "Immutable"],
            fields: {
                expression: {
                    validate: (0,
                    a.assertNodeType)("Expression")
                }
            }
        }),
        (0,
        a.default)("JSXIdentifier", {
            builder: ["name"],
            aliases: ["JSX"],
            fields: {
                name: {
                    validate: (0,
                    a.assertValueType)("string")
                }
            }
        }),
        (0,
        a.default)("JSXMemberExpression", {
            visitor: ["object", "property"],
            aliases: ["JSX"],
            fields: {
                object: {
                    validate: (0,
                    a.assertNodeType)("JSXMemberExpression", "JSXIdentifier")
                },
                property: {
                    validate: (0,
                    a.assertNodeType)("JSXIdentifier")
                }
            }
        }),
        (0,
        a.default)("JSXNamespacedName", {
            visitor: ["namespace", "name"],
            aliases: ["JSX"],
            fields: {
                namespace: {
                    validate: (0,
                    a.assertNodeType)("JSXIdentifier")
                },
                name: {
                    validate: (0,
                    a.assertNodeType)("JSXIdentifier")
                }
            }
        }),
        (0,
        a.default)("JSXOpeningElement", {
            builder: ["name", "attributes", "selfClosing"],
            visitor: ["name", "attributes"],
            aliases: ["JSX", "Immutable"],
            fields: {
                name: {
                    validate: (0,
                    a.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
                },
                selfClosing: {
                    default: !1
                },
                attributes: {
                    validate: (0,
                    a.chain)((0,
                    a.assertValueType)("array"), (0,
                    a.assertEach)((0,
                    a.assertNodeType)("JSXAttribute", "JSXSpreadAttribute")))
                },
                typeParameters: {
                    validate: (0,
                    a.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
                    optional: !0
                }
            }
        }),
        (0,
        a.default)("JSXSpreadAttribute", {
            visitor: ["argument"],
            aliases: ["JSX"],
            fields: {
                argument: {
                    validate: (0,
                    a.assertNodeType)("Expression")
                }
            }
        }),
        (0,
        a.default)("JSXText", {
            aliases: ["JSX", "Immutable"],
            builder: ["value"],
            fields: {
                value: {
                    validate: (0,
                    a.assertValueType)("string")
                }
            }
        }),
        (0,
        a.default)("JSXFragment", {
            builder: ["openingFragment", "closingFragment", "children"],
            visitor: ["openingFragment", "children", "closingFragment"],
            aliases: ["JSX", "Immutable", "Expression"],
            fields: {
                openingFragment: {
                    validate: (0,
                    a.assertNodeType)("JSXOpeningFragment")
                },
                closingFragment: {
                    validate: (0,
                    a.assertNodeType)("JSXClosingFragment")
                },
                children: {
                    validate: (0,
                    a.chain)((0,
                    a.assertValueType)("array"), (0,
                    a.assertEach)((0,
                    a.assertNodeType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")))
                }
            }
        }),
        (0,
        a.default)("JSXOpeningFragment", {
            aliases: ["JSX", "Immutable"]
        }),
        (0,
        a.default)("JSXClosingFragment", {
            aliases: ["JSX", "Immutable"]
        })
    },
    ZtNB: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        });
        var a = {
            react: !0,
            assertNode: !0,
            createTypeAnnotationBasedOnTypeof: !0,
            createUnionTypeAnnotation: !0,
            createFlowUnionType: !0,
            createTSUnionType: !0,
            cloneNode: !0,
            clone: !0,
            cloneDeep: !0,
            cloneDeepWithoutLoc: !0,
            cloneWithoutLoc: !0,
            addComment: !0,
            addComments: !0,
            inheritInnerComments: !0,
            inheritLeadingComments: !0,
            inheritsComments: !0,
            inheritTrailingComments: !0,
            removeComments: !0,
            ensureBlock: !0,
            toBindingIdentifierName: !0,
            toBlock: !0,
            toComputedKey: !0,
            toExpression: !0,
            toIdentifier: !0,
            toKeyAlias: !0,
            toSequenceExpression: !0,
            toStatement: !0,
            valueToNode: !0,
            appendToMemberExpression: !0,
            inherits: !0,
            prependToMemberExpression: !0,
            removeProperties: !0,
            removePropertiesDeep: !0,
            removeTypeDuplicates: !0,
            getBindingIdentifiers: !0,
            getOuterBindingIdentifiers: !0,
            traverse: !0,
            traverseFast: !0,
            shallowEqual: !0,
            is: !0,
            isBinding: !0,
            isBlockScoped: !0,
            isImmutable: !0,
            isLet: !0,
            isNode: !0,
            isNodesEquivalent: !0,
            isPlaceholderType: !0,
            isReferenced: !0,
            isScope: !0,
            isSpecifierDefault: !0,
            isType: !0,
            isValidES3Identifier: !0,
            isValidIdentifier: !0,
            isVar: !0,
            matchesPattern: !0,
            validate: !0,
            buildMatchMemberExpression: !0
        };
        Object.defineProperty(r, "addComment", {
            enumerable: !0,
            get: function get() {
                return P.default
            }
        }),
        Object.defineProperty(r, "addComments", {
            enumerable: !0,
            get: function get() {
                return x.default
            }
        }),
        Object.defineProperty(r, "appendToMemberExpression", {
            enumerable: !0,
            get: function get() {
                return X.default
            }
        }),
        Object.defineProperty(r, "assertNode", {
            enumerable: !0,
            get: function get() {
                return p.default
            }
        }),
        Object.defineProperty(r, "buildMatchMemberExpression", {
            enumerable: !0,
            get: function get() {
                return Se.default
            }
        }),
        Object.defineProperty(r, "clone", {
            enumerable: !0,
            get: function get() {
                return g.default
            }
        }),
        Object.defineProperty(r, "cloneDeep", {
            enumerable: !0,
            get: function get() {
                return b.default
            }
        }),
        Object.defineProperty(r, "cloneDeepWithoutLoc", {
            enumerable: !0,
            get: function get() {
                return v.default
            }
        }),
        Object.defineProperty(r, "cloneNode", {
            enumerable: !0,
            get: function get() {
                return S.default
            }
        }),
        Object.defineProperty(r, "cloneWithoutLoc", {
            enumerable: !0,
            get: function get() {
                return E.default
            }
        }),
        Object.defineProperty(r, "createFlowUnionType", {
            enumerable: !0,
            get: function get() {
                return y.default
            }
        }),
        Object.defineProperty(r, "createTSUnionType", {
            enumerable: !0,
            get: function get() {
                return h.default
            }
        }),
        Object.defineProperty(r, "createTypeAnnotationBasedOnTypeof", {
            enumerable: !0,
            get: function get() {
                return d.default
            }
        }),
        Object.defineProperty(r, "createUnionTypeAnnotation", {
            enumerable: !0,
            get: function get() {
                return y.default
            }
        }),
        Object.defineProperty(r, "ensureBlock", {
            enumerable: !0,
            get: function get() {
                return _.default
            }
        }),
        Object.defineProperty(r, "getBindingIdentifiers", {
            enumerable: !0,
            get: function get() {
                return z.default
            }
        }),
        Object.defineProperty(r, "getOuterBindingIdentifiers", {
            enumerable: !0,
            get: function get() {
                return Q.default
            }
        }),
        Object.defineProperty(r, "inheritInnerComments", {
            enumerable: !0,
            get: function get() {
                return A.default
            }
        }),
        Object.defineProperty(r, "inheritLeadingComments", {
            enumerable: !0,
            get: function get() {
                return O.default
            }
        }),
        Object.defineProperty(r, "inheritTrailingComments", {
            enumerable: !0,
            get: function get() {
                return w.default
            }
        }),
        Object.defineProperty(r, "inherits", {
            enumerable: !0,
            get: function get() {
                return J.default
            }
        }),
        Object.defineProperty(r, "inheritsComments", {
            enumerable: !0,
            get: function get() {
                return I.default
            }
        }),
        Object.defineProperty(r, "is", {
            enumerable: !0,
            get: function get() {
                return te.default
            }
        }),
        Object.defineProperty(r, "isBinding", {
            enumerable: !0,
            get: function get() {
                return re.default
            }
        }),
        Object.defineProperty(r, "isBlockScoped", {
            enumerable: !0,
            get: function get() {
                return ne.default
            }
        }),
        Object.defineProperty(r, "isImmutable", {
            enumerable: !0,
            get: function get() {
                return ie.default
            }
        }),
        Object.defineProperty(r, "isLet", {
            enumerable: !0,
            get: function get() {
                return ae.default
            }
        }),
        Object.defineProperty(r, "isNode", {
            enumerable: !0,
            get: function get() {
                return se.default
            }
        }),
        Object.defineProperty(r, "isNodesEquivalent", {
            enumerable: !0,
            get: function get() {
                return oe.default
            }
        }),
        Object.defineProperty(r, "isPlaceholderType", {
            enumerable: !0,
            get: function get() {
                return le.default
            }
        }),
        Object.defineProperty(r, "isReferenced", {
            enumerable: !0,
            get: function get() {
                return ue.default
            }
        }),
        Object.defineProperty(r, "isScope", {
            enumerable: !0,
            get: function get() {
                return pe.default
            }
        }),
        Object.defineProperty(r, "isSpecifierDefault", {
            enumerable: !0,
            get: function get() {
                return ce.default
            }
        }),
        Object.defineProperty(r, "isType", {
            enumerable: !0,
            get: function get() {
                return de.default
            }
        }),
        Object.defineProperty(r, "isValidES3Identifier", {
            enumerable: !0,
            get: function get() {
                return fe.default
            }
        }),
        Object.defineProperty(r, "isValidIdentifier", {
            enumerable: !0,
            get: function get() {
                return ye.default
            }
        }),
        Object.defineProperty(r, "isVar", {
            enumerable: !0,
            get: function get() {
                return he.default
            }
        }),
        Object.defineProperty(r, "matchesPattern", {
            enumerable: !0,
            get: function get() {
                return me.default
            }
        }),
        Object.defineProperty(r, "prependToMemberExpression", {
            enumerable: !0,
            get: function get() {
                return W.default
            }
        }),
        r.react = void 0,
        Object.defineProperty(r, "removeComments", {
            enumerable: !0,
            get: function get() {
                return C.default
            }
        }),
        Object.defineProperty(r, "removeProperties", {
            enumerable: !0,
            get: function get() {
                return q.default
            }
        }),
        Object.defineProperty(r, "removePropertiesDeep", {
            enumerable: !0,
            get: function get() {
                return H.default
            }
        }),
        Object.defineProperty(r, "removeTypeDuplicates", {
            enumerable: !0,
            get: function get() {
                return G.default
            }
        }),
        Object.defineProperty(r, "shallowEqual", {
            enumerable: !0,
            get: function get() {
                return ee.default
            }
        }),
        Object.defineProperty(r, "toBindingIdentifierName", {
            enumerable: !0,
            get: function get() {
                return L.default
            }
        }),
        Object.defineProperty(r, "toBlock", {
            enumerable: !0,
            get: function get() {
                return k.default
            }
        }),
        Object.defineProperty(r, "toComputedKey", {
            enumerable: !0,
            get: function get() {
                return M.default
            }
        }),
        Object.defineProperty(r, "toExpression", {
            enumerable: !0,
            get: function get() {
                return j.default
            }
        }),
        Object.defineProperty(r, "toIdentifier", {
            enumerable: !0,
            get: function get() {
                return B.default
            }
        }),
        Object.defineProperty(r, "toKeyAlias", {
            enumerable: !0,
            get: function get() {
                return R.default
            }
        }),
        Object.defineProperty(r, "toSequenceExpression", {
            enumerable: !0,
            get: function get() {
                return K.default
            }
        }),
        Object.defineProperty(r, "toStatement", {
            enumerable: !0,
            get: function get() {
                return V.default
            }
        }),
        Object.defineProperty(r, "traverse", {
            enumerable: !0,
            get: function get() {
                return $.default
            }
        }),
        Object.defineProperty(r, "traverseFast", {
            enumerable: !0,
            get: function get() {
                return Z.default
            }
        }),
        Object.defineProperty(r, "validate", {
            enumerable: !0,
            get: function get() {
                return Te.default
            }
        }),
        Object.defineProperty(r, "valueToNode", {
            enumerable: !0,
            get: function get() {
                return U.default
            }
        });
        var o = i("9DXG")
          , l = i("RRSc")
          , u = i("/nHh")
          , p = i("dHLz")
          , c = i("Dku2");
        Object.keys(c).forEach((function(t) {
            "default" !== t && "__esModule" !== t && (Object.prototype.hasOwnProperty.call(a, t) || t in r && r[t] === c[t] || Object.defineProperty(r, t, {
                enumerable: !0,
                get: function get() {
                    return c[t]
                }
            }))
        }
        ));
        var d = i("KCd3")
          , y = i("wv7U")
          , h = i("skWS")
          , m = i("UuI8");
        Object.keys(m).forEach((function(t) {
            "default" !== t && "__esModule" !== t && (Object.prototype.hasOwnProperty.call(a, t) || t in r && r[t] === m[t] || Object.defineProperty(r, t, {
                enumerable: !0,
                get: function get() {
                    return m[t]
                }
            }))
        }
        ));
        var T = i("aOGm");
        Object.keys(T).forEach((function(t) {
            "default" !== t && "__esModule" !== t && (Object.prototype.hasOwnProperty.call(a, t) || t in r && r[t] === T[t] || Object.defineProperty(r, t, {
                enumerable: !0,
                get: function get() {
                    return T[t]
                }
            }))
        }
        ));
        var S = i("aHlp")
          , g = i("Aacy")
          , b = i("Pe1b")
          , v = i("9W4/")
          , E = i("a9MX")
          , P = i("n9cs")
          , x = i("mXTk")
          , A = i("NFYY")
          , O = i("IaKS")
          , I = i("0k9f")
          , w = i("Oz16")
          , C = i("VVhL")
          , N = i("8pGw");
        Object.keys(N).forEach((function(t) {
            "default" !== t && "__esModule" !== t && (Object.prototype.hasOwnProperty.call(a, t) || t in r && r[t] === N[t] || Object.defineProperty(r, t, {
                enumerable: !0,
                get: function get() {
                    return N[t]
                }
            }))
        }
        ));
        var D = i("M7ys");
        Object.keys(D).forEach((function(t) {
            "default" !== t && "__esModule" !== t && (Object.prototype.hasOwnProperty.call(a, t) || t in r && r[t] === D[t] || Object.defineProperty(r, t, {
                enumerable: !0,
                get: function get() {
                    return D[t]
                }
            }))
        }
        ));
        var _ = i("oMr5")
          , L = i("Rd5i")
          , k = i("0Awz")
          , M = i("230T")
          , j = i("Wr9I")
          , B = i("wv99")
          , R = i("EvNs")
          , K = i("qIut")
          , V = i("pTTH")
          , U = i("KDMj")
          , Y = i("UHlb");
        Object.keys(Y).forEach((function(t) {
            "default" !== t && "__esModule" !== t && (Object.prototype.hasOwnProperty.call(a, t) || t in r && r[t] === Y[t] || Object.defineProperty(r, t, {
                enumerable: !0,
                get: function get() {
                    return Y[t]
                }
            }))
        }
        ));
        var X = i("NRCf")
          , J = i("VxTX")
          , W = i("weqI")
          , q = i("YFjm")
          , H = i("lsUB")
          , G = i("4r8k")
          , z = i("V20z")
          , Q = i("MqCK")
          , $ = i("lQDi");
        Object.keys($).forEach((function(t) {
            "default" !== t && "__esModule" !== t && (Object.prototype.hasOwnProperty.call(a, t) || t in r && r[t] === $[t] || Object.defineProperty(r, t, {
                enumerable: !0,
                get: function get() {
                    return $[t]
                }
            }))
        }
        ));
        var Z = i("+FIw")
          , ee = i("v3TT")
          , te = i("ET4T")
          , re = i("nmjD")
          , ne = i("F/98")
          , ie = i("qjUn")
          , ae = i("K95w")
          , se = i("rHqr")
          , oe = i("q2+x")
          , le = i("AB3+")
          , ue = i("SLOx")
          , pe = i("dcRz")
          , ce = i("2Cc0")
          , de = i("ud6b")
          , fe = i("tAhW")
          , ye = i("Aniq")
          , he = i("AfzR")
          , me = i("s0R5")
          , Te = i("D+ka")
          , Se = i("qGI9")
          , ge = i("pbIU");
        Object.keys(ge).forEach((function(t) {
            "default" !== t && "__esModule" !== t && (Object.prototype.hasOwnProperty.call(a, t) || t in r && r[t] === ge[t] || Object.defineProperty(r, t, {
                enumerable: !0,
                get: function get() {
                    return ge[t]
                }
            }))
        }
        ));
        var be = i("WYNU");
        Object.keys(be).forEach((function(t) {
            "default" !== t && "__esModule" !== t && (Object.prototype.hasOwnProperty.call(a, t) || t in r && r[t] === be[t] || Object.defineProperty(r, t, {
                enumerable: !0,
                get: function get() {
                    return be[t]
                }
            }))
        }
        ));
        var ve = {
            isReactComponent: o.default,
            isCompatTag: l.default,
            buildChildren: u.default
        };
        r.react = ve
    },
    ZxeC: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function clone(t) {
            return (0,
            a.default)(t, !1)
        }
        ;
        var a = i("sN7J")
    },
    a9MX: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function cloneWithoutLoc(t) {
            return (0,
            a.default)(t, !1, !0)
        }
        ;
        var a = i("aHlp")
    },
    aHlp: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = cloneNode;
        var a = i("UHlb")
          , o = i("pbIU")
          , l = Function.call.bind(Object.prototype.hasOwnProperty);
        function cloneIfNode(t, r, i) {
            return t && "string" == typeof t.type ? cloneNode(t, r, i) : t
        }
        function cloneIfNodeOrArray(t, r, i) {
            return Array.isArray(t) ? t.map((function(t) {
                return cloneIfNode(t, r, i)
            }
            )) : cloneIfNode(t, r, i)
        }
        function cloneNode(t) {
            var r = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1]
              , i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
            if (!t)
                return t;
            var u = t.type
              , p = {
                type: t.type
            };
            if ((0,
            o.isIdentifier)(t))
                p.name = t.name,
                l(t, "optional") && "boolean" == typeof t.optional && (p.optional = t.optional),
                l(t, "typeAnnotation") && (p.typeAnnotation = r ? cloneIfNodeOrArray(t.typeAnnotation, !0, i) : t.typeAnnotation);
            else {
                if (!l(a.NODE_FIELDS, u))
                    throw new Error('Unknown node type: "'.concat(u, '"'));
                for (var c = 0, d = Object.keys(a.NODE_FIELDS[u]); c < d.length; c++) {
                    var y = d[c];
                    l(t, y) && (p[y] = r ? (0,
                    o.isFile)(t) && "comments" === y ? maybeCloneComments(t.comments, r, i) : cloneIfNodeOrArray(t[y], !0, i) : t[y])
                }
            }
            return l(t, "loc") && (p.loc = i ? null : t.loc),
            l(t, "leadingComments") && (p.leadingComments = maybeCloneComments(t.leadingComments, r, i)),
            l(t, "innerComments") && (p.innerComments = maybeCloneComments(t.innerComments, r, i)),
            l(t, "trailingComments") && (p.trailingComments = maybeCloneComments(t.trailingComments, r, i)),
            l(t, "extra") && (p.extra = Object.assign({}, t.extra)),
            p
        }
        function maybeCloneComments(t, r, i) {
            return t && r ? t.map((function(t) {
                var r = t.type
                  , a = t.value
                  , o = t.loc;
                return i ? {
                    type: r,
                    value: a,
                    loc: null
                } : {
                    type: r,
                    value: a,
                    loc: o
                }
            }
            )) : t
        }
    },
    aMy0: function(t) {
        t.exports = JSON.parse('{"AssignmentExpression":["left","right"],"AssignmentPattern":["left","right"],"ArrayExpression":["elements"],"ArrayPattern":["elements"],"ArrowFunctionExpression":["params","body"],"AwaitExpression":["argument"],"BlockStatement":["body"],"BinaryExpression":["left","right"],"BreakStatement":["label"],"CallExpression":["callee","arguments"],"CatchClause":["param","body"],"ChainExpression":["expression"],"ClassBody":["body"],"ClassDeclaration":["id","superClass","body"],"ClassExpression":["id","superClass","body"],"ConditionalExpression":["test","consequent","alternate"],"ContinueStatement":["label"],"DebuggerStatement":[],"DoWhileStatement":["body","test"],"EmptyStatement":[],"ExportAllDeclaration":["exported","source"],"ExportDefaultDeclaration":["declaration"],"ExportNamedDeclaration":["declaration","specifiers","source"],"ExportSpecifier":["exported","local"],"ExpressionStatement":["expression"],"ExperimentalRestProperty":["argument"],"ExperimentalSpreadProperty":["argument"],"ForStatement":["init","test","update","body"],"ForInStatement":["left","right","body"],"ForOfStatement":["left","right","body"],"FunctionDeclaration":["id","params","body"],"FunctionExpression":["id","params","body"],"Identifier":[],"IfStatement":["test","consequent","alternate"],"ImportDeclaration":["specifiers","source"],"ImportDefaultSpecifier":["local"],"ImportExpression":["source"],"ImportNamespaceSpecifier":["local"],"ImportSpecifier":["imported","local"],"JSXAttribute":["name","value"],"JSXClosingElement":["name"],"JSXElement":["openingElement","children","closingElement"],"JSXEmptyExpression":[],"JSXExpressionContainer":["expression"],"JSXIdentifier":[],"JSXMemberExpression":["object","property"],"JSXNamespacedName":["namespace","name"],"JSXOpeningElement":["name","attributes"],"JSXSpreadAttribute":["argument"],"JSXText":[],"JSXFragment":["openingFragment","children","closingFragment"],"Literal":[],"LabeledStatement":["label","body"],"LogicalExpression":["left","right"],"MemberExpression":["object","property"],"MetaProperty":["meta","property"],"MethodDefinition":["key","value"],"NewExpression":["callee","arguments"],"ObjectExpression":["properties"],"ObjectPattern":["properties"],"Program":["body"],"Property":["key","value"],"RestElement":["argument"],"ReturnStatement":["argument"],"SequenceExpression":["expressions"],"SpreadElement":["argument"],"Super":[],"SwitchStatement":["discriminant","cases"],"SwitchCase":["test","consequent"],"TaggedTemplateExpression":["tag","quasi"],"TemplateElement":[],"TemplateLiteral":["quasis","expressions"],"ThisExpression":[],"ThrowStatement":["argument"],"TryStatement":["block","handler","finalizer"],"UnaryExpression":["argument"],"UpdateExpression":["argument"],"VariableDeclaration":["declarations"],"VariableDeclarator":["id","init"],"WhileStatement":["test","body"],"WithStatement":["object","body"],"YieldExpression":["argument"]}')
    },
    aOGm: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        Object.defineProperty(r, "AnyTypeAnnotation", {
            enumerable: !0,
            get: function get() {
                return a.anyTypeAnnotation
            }
        }),
        Object.defineProperty(r, "ArgumentPlaceholder", {
            enumerable: !0,
            get: function get() {
                return a.argumentPlaceholder
            }
        }),
        Object.defineProperty(r, "ArrayExpression", {
            enumerable: !0,
            get: function get() {
                return a.arrayExpression
            }
        }),
        Object.defineProperty(r, "ArrayPattern", {
            enumerable: !0,
            get: function get() {
                return a.arrayPattern
            }
        }),
        Object.defineProperty(r, "ArrayTypeAnnotation", {
            enumerable: !0,
            get: function get() {
                return a.arrayTypeAnnotation
            }
        }),
        Object.defineProperty(r, "ArrowFunctionExpression", {
            enumerable: !0,
            get: function get() {
                return a.arrowFunctionExpression
            }
        }),
        Object.defineProperty(r, "AssignmentExpression", {
            enumerable: !0,
            get: function get() {
                return a.assignmentExpression
            }
        }),
        Object.defineProperty(r, "AssignmentPattern", {
            enumerable: !0,
            get: function get() {
                return a.assignmentPattern
            }
        }),
        Object.defineProperty(r, "AwaitExpression", {
            enumerable: !0,
            get: function get() {
                return a.awaitExpression
            }
        }),
        Object.defineProperty(r, "BigIntLiteral", {
            enumerable: !0,
            get: function get() {
                return a.bigIntLiteral
            }
        }),
        Object.defineProperty(r, "BinaryExpression", {
            enumerable: !0,
            get: function get() {
                return a.binaryExpression
            }
        }),
        Object.defineProperty(r, "BindExpression", {
            enumerable: !0,
            get: function get() {
                return a.bindExpression
            }
        }),
        Object.defineProperty(r, "BlockStatement", {
            enumerable: !0,
            get: function get() {
                return a.blockStatement
            }
        }),
        Object.defineProperty(r, "BooleanLiteral", {
            enumerable: !0,
            get: function get() {
                return a.booleanLiteral
            }
        }),
        Object.defineProperty(r, "BooleanLiteralTypeAnnotation", {
            enumerable: !0,
            get: function get() {
                return a.booleanLiteralTypeAnnotation
            }
        }),
        Object.defineProperty(r, "BooleanTypeAnnotation", {
            enumerable: !0,
            get: function get() {
                return a.booleanTypeAnnotation
            }
        }),
        Object.defineProperty(r, "BreakStatement", {
            enumerable: !0,
            get: function get() {
                return a.breakStatement
            }
        }),
        Object.defineProperty(r, "CallExpression", {
            enumerable: !0,
            get: function get() {
                return a.callExpression
            }
        }),
        Object.defineProperty(r, "CatchClause", {
            enumerable: !0,
            get: function get() {
                return a.catchClause
            }
        }),
        Object.defineProperty(r, "ClassBody", {
            enumerable: !0,
            get: function get() {
                return a.classBody
            }
        }),
        Object.defineProperty(r, "ClassDeclaration", {
            enumerable: !0,
            get: function get() {
                return a.classDeclaration
            }
        }),
        Object.defineProperty(r, "ClassExpression", {
            enumerable: !0,
            get: function get() {
                return a.classExpression
            }
        }),
        Object.defineProperty(r, "ClassImplements", {
            enumerable: !0,
            get: function get() {
                return a.classImplements
            }
        }),
        Object.defineProperty(r, "ClassMethod", {
            enumerable: !0,
            get: function get() {
                return a.classMethod
            }
        }),
        Object.defineProperty(r, "ClassPrivateMethod", {
            enumerable: !0,
            get: function get() {
                return a.classPrivateMethod
            }
        }),
        Object.defineProperty(r, "ClassPrivateProperty", {
            enumerable: !0,
            get: function get() {
                return a.classPrivateProperty
            }
        }),
        Object.defineProperty(r, "ClassProperty", {
            enumerable: !0,
            get: function get() {
                return a.classProperty
            }
        }),
        Object.defineProperty(r, "ConditionalExpression", {
            enumerable: !0,
            get: function get() {
                return a.conditionalExpression
            }
        }),
        Object.defineProperty(r, "ContinueStatement", {
            enumerable: !0,
            get: function get() {
                return a.continueStatement
            }
        }),
        Object.defineProperty(r, "DebuggerStatement", {
            enumerable: !0,
            get: function get() {
                return a.debuggerStatement
            }
        }),
        Object.defineProperty(r, "DecimalLiteral", {
            enumerable: !0,
            get: function get() {
                return a.decimalLiteral
            }
        }),
        Object.defineProperty(r, "DeclareClass", {
            enumerable: !0,
            get: function get() {
                return a.declareClass
            }
        }),
        Object.defineProperty(r, "DeclareExportAllDeclaration", {
            enumerable: !0,
            get: function get() {
                return a.declareExportAllDeclaration
            }
        }),
        Object.defineProperty(r, "DeclareExportDeclaration", {
            enumerable: !0,
            get: function get() {
                return a.declareExportDeclaration
            }
        }),
        Object.defineProperty(r, "DeclareFunction", {
            enumerable: !0,
            get: function get() {
                return a.declareFunction
            }
        }),
        Object.defineProperty(r, "DeclareInterface", {
            enumerable: !0,
            get: function get() {
                return a.declareInterface
            }
        }),
        Object.defineProperty(r, "DeclareModule", {
            enumerable: !0,
            get: function get() {
                return a.declareModule
            }
        }),
        Object.defineProperty(r, "DeclareModuleExports", {
            enumerable: !0,
            get: function get() {
                return a.declareModuleExports
            }
        }),
        Object.defineProperty(r, "DeclareOpaqueType", {
            enumerable: !0,
            get: function get() {
                return a.declareOpaqueType
            }
        }),
        Object.defineProperty(r, "DeclareTypeAlias", {
            enumerable: !0,
            get: function get() {
                return a.declareTypeAlias
            }
        }),
        Object.defineProperty(r, "DeclareVariable", {
            enumerable: !0,
            get: function get() {
                return a.declareVariable
            }
        }),
        Object.defineProperty(r, "DeclaredPredicate", {
            enumerable: !0,
            get: function get() {
                return a.declaredPredicate
            }
        }),
        Object.defineProperty(r, "Decorator", {
            enumerable: !0,
            get: function get() {
                return a.decorator
            }
        }),
        Object.defineProperty(r, "Directive", {
            enumerable: !0,
            get: function get() {
                return a.directive
            }
        }),
        Object.defineProperty(r, "DirectiveLiteral", {
            enumerable: !0,
            get: function get() {
                return a.directiveLiteral
            }
        }),
        Object.defineProperty(r, "DoExpression", {
            enumerable: !0,
            get: function get() {
                return a.doExpression
            }
        }),
        Object.defineProperty(r, "DoWhileStatement", {
            enumerable: !0,
            get: function get() {
                return a.doWhileStatement
            }
        }),
        Object.defineProperty(r, "EmptyStatement", {
            enumerable: !0,
            get: function get() {
                return a.emptyStatement
            }
        }),
        Object.defineProperty(r, "EmptyTypeAnnotation", {
            enumerable: !0,
            get: function get() {
                return a.emptyTypeAnnotation
            }
        }),
        Object.defineProperty(r, "EnumBooleanBody", {
            enumerable: !0,
            get: function get() {
                return a.enumBooleanBody
            }
        }),
        Object.defineProperty(r, "EnumBooleanMember", {
            enumerable: !0,
            get: function get() {
                return a.enumBooleanMember
            }
        }),
        Object.defineProperty(r, "EnumDeclaration", {
            enumerable: !0,
            get: function get() {
                return a.enumDeclaration
            }
        }),
        Object.defineProperty(r, "EnumDefaultedMember", {
            enumerable: !0,
            get: function get() {
                return a.enumDefaultedMember
            }
        }),
        Object.defineProperty(r, "EnumNumberBody", {
            enumerable: !0,
            get: function get() {
                return a.enumNumberBody
            }
        }),
        Object.defineProperty(r, "EnumNumberMember", {
            enumerable: !0,
            get: function get() {
                return a.enumNumberMember
            }
        }),
        Object.defineProperty(r, "EnumStringBody", {
            enumerable: !0,
            get: function get() {
                return a.enumStringBody
            }
        }),
        Object.defineProperty(r, "EnumStringMember", {
            enumerable: !0,
            get: function get() {
                return a.enumStringMember
            }
        }),
        Object.defineProperty(r, "EnumSymbolBody", {
            enumerable: !0,
            get: function get() {
                return a.enumSymbolBody
            }
        }),
        Object.defineProperty(r, "ExistsTypeAnnotation", {
            enumerable: !0,
            get: function get() {
                return a.existsTypeAnnotation
            }
        }),
        Object.defineProperty(r, "ExportAllDeclaration", {
            enumerable: !0,
            get: function get() {
                return a.exportAllDeclaration
            }
        }),
        Object.defineProperty(r, "ExportDefaultDeclaration", {
            enumerable: !0,
            get: function get() {
                return a.exportDefaultDeclaration
            }
        }),
        Object.defineProperty(r, "ExportDefaultSpecifier", {
            enumerable: !0,
            get: function get() {
                return a.exportDefaultSpecifier
            }
        }),
        Object.defineProperty(r, "ExportNamedDeclaration", {
            enumerable: !0,
            get: function get() {
                return a.exportNamedDeclaration
            }
        }),
        Object.defineProperty(r, "ExportNamespaceSpecifier", {
            enumerable: !0,
            get: function get() {
                return a.exportNamespaceSpecifier
            }
        }),
        Object.defineProperty(r, "ExportSpecifier", {
            enumerable: !0,
            get: function get() {
                return a.exportSpecifier
            }
        }),
        Object.defineProperty(r, "ExpressionStatement", {
            enumerable: !0,
            get: function get() {
                return a.expressionStatement
            }
        }),
        Object.defineProperty(r, "File", {
            enumerable: !0,
            get: function get() {
                return a.file
            }
        }),
        Object.defineProperty(r, "ForInStatement", {
            enumerable: !0,
            get: function get() {
                return a.forInStatement
            }
        }),
        Object.defineProperty(r, "ForOfStatement", {
            enumerable: !0,
            get: function get() {
                return a.forOfStatement
            }
        }),
        Object.defineProperty(r, "ForStatement", {
            enumerable: !0,
            get: function get() {
                return a.forStatement
            }
        }),
        Object.defineProperty(r, "FunctionDeclaration", {
            enumerable: !0,
            get: function get() {
                return a.functionDeclaration
            }
        }),
        Object.defineProperty(r, "FunctionExpression", {
            enumerable: !0,
            get: function get() {
                return a.functionExpression
            }
        }),
        Object.defineProperty(r, "FunctionTypeAnnotation", {
            enumerable: !0,
            get: function get() {
                return a.functionTypeAnnotation
            }
        }),
        Object.defineProperty(r, "FunctionTypeParam", {
            enumerable: !0,
            get: function get() {
                return a.functionTypeParam
            }
        }),
        Object.defineProperty(r, "GenericTypeAnnotation", {
            enumerable: !0,
            get: function get() {
                return a.genericTypeAnnotation
            }
        }),
        Object.defineProperty(r, "Identifier", {
            enumerable: !0,
            get: function get() {
                return a.identifier
            }
        }),
        Object.defineProperty(r, "IfStatement", {
            enumerable: !0,
            get: function get() {
                return a.ifStatement
            }
        }),
        Object.defineProperty(r, "Import", {
            enumerable: !0,
            get: function get() {
                return a.import
            }
        }),
        Object.defineProperty(r, "ImportAttribute", {
            enumerable: !0,
            get: function get() {
                return a.importAttribute
            }
        }),
        Object.defineProperty(r, "ImportDeclaration", {
            enumerable: !0,
            get: function get() {
                return a.importDeclaration
            }
        }),
        Object.defineProperty(r, "ImportDefaultSpecifier", {
            enumerable: !0,
            get: function get() {
                return a.importDefaultSpecifier
            }
        }),
        Object.defineProperty(r, "ImportNamespaceSpecifier", {
            enumerable: !0,
            get: function get() {
                return a.importNamespaceSpecifier
            }
        }),
        Object.defineProperty(r, "ImportSpecifier", {
            enumerable: !0,
            get: function get() {
                return a.importSpecifier
            }
        }),
        Object.defineProperty(r, "IndexedAccessType", {
            enumerable: !0,
            get: function get() {
                return a.indexedAccessType
            }
        }),
        Object.defineProperty(r, "InferredPredicate", {
            enumerable: !0,
            get: function get() {
                return a.inferredPredicate
            }
        }),
        Object.defineProperty(r, "InterfaceDeclaration", {
            enumerable: !0,
            get: function get() {
                return a.interfaceDeclaration
            }
        }),
        Object.defineProperty(r, "InterfaceExtends", {
            enumerable: !0,
            get: function get() {
                return a.interfaceExtends
            }
        }),
        Object.defineProperty(r, "InterfaceTypeAnnotation", {
            enumerable: !0,
            get: function get() {
                return a.interfaceTypeAnnotation
            }
        }),
        Object.defineProperty(r, "InterpreterDirective", {
            enumerable: !0,
            get: function get() {
                return a.interpreterDirective
            }
        }),
        Object.defineProperty(r, "IntersectionTypeAnnotation", {
            enumerable: !0,
            get: function get() {
                return a.intersectionTypeAnnotation
            }
        }),
        Object.defineProperty(r, "JSXAttribute", {
            enumerable: !0,
            get: function get() {
                return a.jsxAttribute
            }
        }),
        Object.defineProperty(r, "JSXClosingElement", {
            enumerable: !0,
            get: function get() {
                return a.jsxClosingElement
            }
        }),
        Object.defineProperty(r, "JSXClosingFragment", {
            enumerable: !0,
            get: function get() {
                return a.jsxClosingFragment
            }
        }),
        Object.defineProperty(r, "JSXElement", {
            enumerable: !0,
            get: function get() {
                return a.jsxElement
            }
        }),
        Object.defineProperty(r, "JSXEmptyExpression", {
            enumerable: !0,
            get: function get() {
                return a.jsxEmptyExpression
            }
        }),
        Object.defineProperty(r, "JSXExpressionContainer", {
            enumerable: !0,
            get: function get() {
                return a.jsxExpressionContainer
            }
        }),
        Object.defineProperty(r, "JSXFragment", {
            enumerable: !0,
            get: function get() {
                return a.jsxFragment
            }
        }),
        Object.defineProperty(r, "JSXIdentifier", {
            enumerable: !0,
            get: function get() {
                return a.jsxIdentifier
            }
        }),
        Object.defineProperty(r, "JSXMemberExpression", {
            enumerable: !0,
            get: function get() {
                return a.jsxMemberExpression
            }
        }),
        Object.defineProperty(r, "JSXNamespacedName", {
            enumerable: !0,
            get: function get() {
                return a.jsxNamespacedName
            }
        }),
        Object.defineProperty(r, "JSXOpeningElement", {
            enumerable: !0,
            get: function get() {
                return a.jsxOpeningElement
            }
        }),
        Object.defineProperty(r, "JSXOpeningFragment", {
            enumerable: !0,
            get: function get() {
                return a.jsxOpeningFragment
            }
        }),
        Object.defineProperty(r, "JSXSpreadAttribute", {
            enumerable: !0,
            get: function get() {
                return a.jsxSpreadAttribute
            }
        }),
        Object.defineProperty(r, "JSXSpreadChild", {
            enumerable: !0,
            get: function get() {
                return a.jsxSpreadChild
            }
        }),
        Object.defineProperty(r, "JSXText", {
            enumerable: !0,
            get: function get() {
                return a.jsxText
            }
        }),
        Object.defineProperty(r, "LabeledStatement", {
            enumerable: !0,
            get: function get() {
                return a.labeledStatement
            }
        }),
        Object.defineProperty(r, "LogicalExpression", {
            enumerable: !0,
            get: function get() {
                return a.logicalExpression
            }
        }),
        Object.defineProperty(r, "MemberExpression", {
            enumerable: !0,
            get: function get() {
                return a.memberExpression
            }
        }),
        Object.defineProperty(r, "MetaProperty", {
            enumerable: !0,
            get: function get() {
                return a.metaProperty
            }
        }),
        Object.defineProperty(r, "MixedTypeAnnotation", {
            enumerable: !0,
            get: function get() {
                return a.mixedTypeAnnotation
            }
        }),
        Object.defineProperty(r, "ModuleExpression", {
            enumerable: !0,
            get: function get() {
                return a.moduleExpression
            }
        }),
        Object.defineProperty(r, "NewExpression", {
            enumerable: !0,
            get: function get() {
                return a.newExpression
            }
        }),
        Object.defineProperty(r, "Noop", {
            enumerable: !0,
            get: function get() {
                return a.noop
            }
        }),
        Object.defineProperty(r, "NullLiteral", {
            enumerable: !0,
            get: function get() {
                return a.nullLiteral
            }
        }),
        Object.defineProperty(r, "NullLiteralTypeAnnotation", {
            enumerable: !0,
            get: function get() {
                return a.nullLiteralTypeAnnotation
            }
        }),
        Object.defineProperty(r, "NullableTypeAnnotation", {
            enumerable: !0,
            get: function get() {
                return a.nullableTypeAnnotation
            }
        }),
        Object.defineProperty(r, "NumberLiteral", {
            enumerable: !0,
            get: function get() {
                return a.numberLiteral
            }
        }),
        Object.defineProperty(r, "NumberLiteralTypeAnnotation", {
            enumerable: !0,
            get: function get() {
                return a.numberLiteralTypeAnnotation
            }
        }),
        Object.defineProperty(r, "NumberTypeAnnotation", {
            enumerable: !0,
            get: function get() {
                return a.numberTypeAnnotation
            }
        }),
        Object.defineProperty(r, "NumericLiteral", {
            enumerable: !0,
            get: function get() {
                return a.numericLiteral
            }
        }),
        Object.defineProperty(r, "ObjectExpression", {
            enumerable: !0,
            get: function get() {
                return a.objectExpression
            }
        }),
        Object.defineProperty(r, "ObjectMethod", {
            enumerable: !0,
            get: function get() {
                return a.objectMethod
            }
        }),
        Object.defineProperty(r, "ObjectPattern", {
            enumerable: !0,
            get: function get() {
                return a.objectPattern
            }
        }),
        Object.defineProperty(r, "ObjectProperty", {
            enumerable: !0,
            get: function get() {
                return a.objectProperty
            }
        }),
        Object.defineProperty(r, "ObjectTypeAnnotation", {
            enumerable: !0,
            get: function get() {
                return a.objectTypeAnnotation
            }
        }),
        Object.defineProperty(r, "ObjectTypeCallProperty", {
            enumerable: !0,
            get: function get() {
                return a.objectTypeCallProperty
            }
        }),
        Object.defineProperty(r, "ObjectTypeIndexer", {
            enumerable: !0,
            get: function get() {
                return a.objectTypeIndexer
            }
        }),
        Object.defineProperty(r, "ObjectTypeInternalSlot", {
            enumerable: !0,
            get: function get() {
                return a.objectTypeInternalSlot
            }
        }),
        Object.defineProperty(r, "ObjectTypeProperty", {
            enumerable: !0,
            get: function get() {
                return a.objectTypeProperty
            }
        }),
        Object.defineProperty(r, "ObjectTypeSpreadProperty", {
            enumerable: !0,
            get: function get() {
                return a.objectTypeSpreadProperty
            }
        }),
        Object.defineProperty(r, "OpaqueType", {
            enumerable: !0,
            get: function get() {
                return a.opaqueType
            }
        }),
        Object.defineProperty(r, "OptionalCallExpression", {
            enumerable: !0,
            get: function get() {
                return a.optionalCallExpression
            }
        }),
        Object.defineProperty(r, "OptionalIndexedAccessType", {
            enumerable: !0,
            get: function get() {
                return a.optionalIndexedAccessType
            }
        }),
        Object.defineProperty(r, "OptionalMemberExpression", {
            enumerable: !0,
            get: function get() {
                return a.optionalMemberExpression
            }
        }),
        Object.defineProperty(r, "ParenthesizedExpression", {
            enumerable: !0,
            get: function get() {
                return a.parenthesizedExpression
            }
        }),
        Object.defineProperty(r, "PipelineBareFunction", {
            enumerable: !0,
            get: function get() {
                return a.pipelineBareFunction
            }
        }),
        Object.defineProperty(r, "PipelinePrimaryTopicReference", {
            enumerable: !0,
            get: function get() {
                return a.pipelinePrimaryTopicReference
            }
        }),
        Object.defineProperty(r, "PipelineTopicExpression", {
            enumerable: !0,
            get: function get() {
                return a.pipelineTopicExpression
            }
        }),
        Object.defineProperty(r, "Placeholder", {
            enumerable: !0,
            get: function get() {
                return a.placeholder
            }
        }),
        Object.defineProperty(r, "PrivateName", {
            enumerable: !0,
            get: function get() {
                return a.privateName
            }
        }),
        Object.defineProperty(r, "Program", {
            enumerable: !0,
            get: function get() {
                return a.program
            }
        }),
        Object.defineProperty(r, "QualifiedTypeIdentifier", {
            enumerable: !0,
            get: function get() {
                return a.qualifiedTypeIdentifier
            }
        }),
        Object.defineProperty(r, "RecordExpression", {
            enumerable: !0,
            get: function get() {
                return a.recordExpression
            }
        }),
        Object.defineProperty(r, "RegExpLiteral", {
            enumerable: !0,
            get: function get() {
                return a.regExpLiteral
            }
        }),
        Object.defineProperty(r, "RegexLiteral", {
            enumerable: !0,
            get: function get() {
                return a.regexLiteral
            }
        }),
        Object.defineProperty(r, "RestElement", {
            enumerable: !0,
            get: function get() {
                return a.restElement
            }
        }),
        Object.defineProperty(r, "RestProperty", {
            enumerable: !0,
            get: function get() {
                return a.restProperty
            }
        }),
        Object.defineProperty(r, "ReturnStatement", {
            enumerable: !0,
            get: function get() {
                return a.returnStatement
            }
        }),
        Object.defineProperty(r, "SequenceExpression", {
            enumerable: !0,
            get: function get() {
                return a.sequenceExpression
            }
        }),
        Object.defineProperty(r, "SpreadElement", {
            enumerable: !0,
            get: function get() {
                return a.spreadElement
            }
        }),
        Object.defineProperty(r, "SpreadProperty", {
            enumerable: !0,
            get: function get() {
                return a.spreadProperty
            }
        }),
        Object.defineProperty(r, "StaticBlock", {
            enumerable: !0,
            get: function get() {
                return a.staticBlock
            }
        }),
        Object.defineProperty(r, "StringLiteral", {
            enumerable: !0,
            get: function get() {
                return a.stringLiteral
            }
        }),
        Object.defineProperty(r, "StringLiteralTypeAnnotation", {
            enumerable: !0,
            get: function get() {
                return a.stringLiteralTypeAnnotation
            }
        }),
        Object.defineProperty(r, "StringTypeAnnotation", {
            enumerable: !0,
            get: function get() {
                return a.stringTypeAnnotation
            }
        }),
        Object.defineProperty(r, "Super", {
            enumerable: !0,
            get: function get() {
                return a.super
            }
        }),
        Object.defineProperty(r, "SwitchCase", {
            enumerable: !0,
            get: function get() {
                return a.switchCase
            }
        }),
        Object.defineProperty(r, "SwitchStatement", {
            enumerable: !0,
            get: function get() {
                return a.switchStatement
            }
        }),
        Object.defineProperty(r, "SymbolTypeAnnotation", {
            enumerable: !0,
            get: function get() {
                return a.symbolTypeAnnotation
            }
        }),
        Object.defineProperty(r, "TSAnyKeyword", {
            enumerable: !0,
            get: function get() {
                return a.tsAnyKeyword
            }
        }),
        Object.defineProperty(r, "TSArrayType", {
            enumerable: !0,
            get: function get() {
                return a.tsArrayType
            }
        }),
        Object.defineProperty(r, "TSAsExpression", {
            enumerable: !0,
            get: function get() {
                return a.tsAsExpression
            }
        }),
        Object.defineProperty(r, "TSBigIntKeyword", {
            enumerable: !0,
            get: function get() {
                return a.tsBigIntKeyword
            }
        }),
        Object.defineProperty(r, "TSBooleanKeyword", {
            enumerable: !0,
            get: function get() {
                return a.tsBooleanKeyword
            }
        }),
        Object.defineProperty(r, "TSCallSignatureDeclaration", {
            enumerable: !0,
            get: function get() {
                return a.tsCallSignatureDeclaration
            }
        }),
        Object.defineProperty(r, "TSConditionalType", {
            enumerable: !0,
            get: function get() {
                return a.tsConditionalType
            }
        }),
        Object.defineProperty(r, "TSConstructSignatureDeclaration", {
            enumerable: !0,
            get: function get() {
                return a.tsConstructSignatureDeclaration
            }
        }),
        Object.defineProperty(r, "TSConstructorType", {
            enumerable: !0,
            get: function get() {
                return a.tsConstructorType
            }
        }),
        Object.defineProperty(r, "TSDeclareFunction", {
            enumerable: !0,
            get: function get() {
                return a.tsDeclareFunction
            }
        }),
        Object.defineProperty(r, "TSDeclareMethod", {
            enumerable: !0,
            get: function get() {
                return a.tsDeclareMethod
            }
        }),
        Object.defineProperty(r, "TSEnumDeclaration", {
            enumerable: !0,
            get: function get() {
                return a.tsEnumDeclaration
            }
        }),
        Object.defineProperty(r, "TSEnumMember", {
            enumerable: !0,
            get: function get() {
                return a.tsEnumMember
            }
        }),
        Object.defineProperty(r, "TSExportAssignment", {
            enumerable: !0,
            get: function get() {
                return a.tsExportAssignment
            }
        }),
        Object.defineProperty(r, "TSExpressionWithTypeArguments", {
            enumerable: !0,
            get: function get() {
                return a.tsExpressionWithTypeArguments
            }
        }),
        Object.defineProperty(r, "TSExternalModuleReference", {
            enumerable: !0,
            get: function get() {
                return a.tsExternalModuleReference
            }
        }),
        Object.defineProperty(r, "TSFunctionType", {
            enumerable: !0,
            get: function get() {
                return a.tsFunctionType
            }
        }),
        Object.defineProperty(r, "TSImportEqualsDeclaration", {
            enumerable: !0,
            get: function get() {
                return a.tsImportEqualsDeclaration
            }
        }),
        Object.defineProperty(r, "TSImportType", {
            enumerable: !0,
            get: function get() {
                return a.tsImportType
            }
        }),
        Object.defineProperty(r, "TSIndexSignature", {
            enumerable: !0,
            get: function get() {
                return a.tsIndexSignature
            }
        }),
        Object.defineProperty(r, "TSIndexedAccessType", {
            enumerable: !0,
            get: function get() {
                return a.tsIndexedAccessType
            }
        }),
        Object.defineProperty(r, "TSInferType", {
            enumerable: !0,
            get: function get() {
                return a.tsInferType
            }
        }),
        Object.defineProperty(r, "TSInterfaceBody", {
            enumerable: !0,
            get: function get() {
                return a.tsInterfaceBody
            }
        }),
        Object.defineProperty(r, "TSInterfaceDeclaration", {
            enumerable: !0,
            get: function get() {
                return a.tsInterfaceDeclaration
            }
        }),
        Object.defineProperty(r, "TSIntersectionType", {
            enumerable: !0,
            get: function get() {
                return a.tsIntersectionType
            }
        }),
        Object.defineProperty(r, "TSIntrinsicKeyword", {
            enumerable: !0,
            get: function get() {
                return a.tsIntrinsicKeyword
            }
        }),
        Object.defineProperty(r, "TSLiteralType", {
            enumerable: !0,
            get: function get() {
                return a.tsLiteralType
            }
        }),
        Object.defineProperty(r, "TSMappedType", {
            enumerable: !0,
            get: function get() {
                return a.tsMappedType
            }
        }),
        Object.defineProperty(r, "TSMethodSignature", {
            enumerable: !0,
            get: function get() {
                return a.tsMethodSignature
            }
        }),
        Object.defineProperty(r, "TSModuleBlock", {
            enumerable: !0,
            get: function get() {
                return a.tsModuleBlock
            }
        }),
        Object.defineProperty(r, "TSModuleDeclaration", {
            enumerable: !0,
            get: function get() {
                return a.tsModuleDeclaration
            }
        }),
        Object.defineProperty(r, "TSNamedTupleMember", {
            enumerable: !0,
            get: function get() {
                return a.tsNamedTupleMember
            }
        }),
        Object.defineProperty(r, "TSNamespaceExportDeclaration", {
            enumerable: !0,
            get: function get() {
                return a.tsNamespaceExportDeclaration
            }
        }),
        Object.defineProperty(r, "TSNeverKeyword", {
            enumerable: !0,
            get: function get() {
                return a.tsNeverKeyword
            }
        }),
        Object.defineProperty(r, "TSNonNullExpression", {
            enumerable: !0,
            get: function get() {
                return a.tsNonNullExpression
            }
        }),
        Object.defineProperty(r, "TSNullKeyword", {
            enumerable: !0,
            get: function get() {
                return a.tsNullKeyword
            }
        }),
        Object.defineProperty(r, "TSNumberKeyword", {
            enumerable: !0,
            get: function get() {
                return a.tsNumberKeyword
            }
        }),
        Object.defineProperty(r, "TSObjectKeyword", {
            enumerable: !0,
            get: function get() {
                return a.tsObjectKeyword
            }
        }),
        Object.defineProperty(r, "TSOptionalType", {
            enumerable: !0,
            get: function get() {
                return a.tsOptionalType
            }
        }),
        Object.defineProperty(r, "TSParameterProperty", {
            enumerable: !0,
            get: function get() {
                return a.tsParameterProperty
            }
        }),
        Object.defineProperty(r, "TSParenthesizedType", {
            enumerable: !0,
            get: function get() {
                return a.tsParenthesizedType
            }
        }),
        Object.defineProperty(r, "TSPropertySignature", {
            enumerable: !0,
            get: function get() {
                return a.tsPropertySignature
            }
        }),
        Object.defineProperty(r, "TSQualifiedName", {
            enumerable: !0,
            get: function get() {
                return a.tsQualifiedName
            }
        }),
        Object.defineProperty(r, "TSRestType", {
            enumerable: !0,
            get: function get() {
                return a.tsRestType
            }
        }),
        Object.defineProperty(r, "TSStringKeyword", {
            enumerable: !0,
            get: function get() {
                return a.tsStringKeyword
            }
        }),
        Object.defineProperty(r, "TSSymbolKeyword", {
            enumerable: !0,
            get: function get() {
                return a.tsSymbolKeyword
            }
        }),
        Object.defineProperty(r, "TSThisType", {
            enumerable: !0,
            get: function get() {
                return a.tsThisType
            }
        }),
        Object.defineProperty(r, "TSTupleType", {
            enumerable: !0,
            get: function get() {
                return a.tsTupleType
            }
        }),
        Object.defineProperty(r, "TSTypeAliasDeclaration", {
            enumerable: !0,
            get: function get() {
                return a.tsTypeAliasDeclaration
            }
        }),
        Object.defineProperty(r, "TSTypeAnnotation", {
            enumerable: !0,
            get: function get() {
                return a.tsTypeAnnotation
            }
        }),
        Object.defineProperty(r, "TSTypeAssertion", {
            enumerable: !0,
            get: function get() {
                return a.tsTypeAssertion
            }
        }),
        Object.defineProperty(r, "TSTypeLiteral", {
            enumerable: !0,
            get: function get() {
                return a.tsTypeLiteral
            }
        }),
        Object.defineProperty(r, "TSTypeOperator", {
            enumerable: !0,
            get: function get() {
                return a.tsTypeOperator
            }
        }),
        Object.defineProperty(r, "TSTypeParameter", {
            enumerable: !0,
            get: function get() {
                return a.tsTypeParameter
            }
        }),
        Object.defineProperty(r, "TSTypeParameterDeclaration", {
            enumerable: !0,
            get: function get() {
                return a.tsTypeParameterDeclaration
            }
        }),
        Object.defineProperty(r, "TSTypeParameterInstantiation", {
            enumerable: !0,
            get: function get() {
                return a.tsTypeParameterInstantiation
            }
        }),
        Object.defineProperty(r, "TSTypePredicate", {
            enumerable: !0,
            get: function get() {
                return a.tsTypePredicate
            }
        }),
        Object.defineProperty(r, "TSTypeQuery", {
            enumerable: !0,
            get: function get() {
                return a.tsTypeQuery
            }
        }),
        Object.defineProperty(r, "TSTypeReference", {
            enumerable: !0,
            get: function get() {
                return a.tsTypeReference
            }
        }),
        Object.defineProperty(r, "TSUndefinedKeyword", {
            enumerable: !0,
            get: function get() {
                return a.tsUndefinedKeyword
            }
        }),
        Object.defineProperty(r, "TSUnionType", {
            enumerable: !0,
            get: function get() {
                return a.tsUnionType
            }
        }),
        Object.defineProperty(r, "TSUnknownKeyword", {
            enumerable: !0,
            get: function get() {
                return a.tsUnknownKeyword
            }
        }),
        Object.defineProperty(r, "TSVoidKeyword", {
            enumerable: !0,
            get: function get() {
                return a.tsVoidKeyword
            }
        }),
        Object.defineProperty(r, "TaggedTemplateExpression", {
            enumerable: !0,
            get: function get() {
                return a.taggedTemplateExpression
            }
        }),
        Object.defineProperty(r, "TemplateElement", {
            enumerable: !0,
            get: function get() {
                return a.templateElement
            }
        }),
        Object.defineProperty(r, "TemplateLiteral", {
            enumerable: !0,
            get: function get() {
                return a.templateLiteral
            }
        }),
        Object.defineProperty(r, "ThisExpression", {
            enumerable: !0,
            get: function get() {
                return a.thisExpression
            }
        }),
        Object.defineProperty(r, "ThisTypeAnnotation", {
            enumerable: !0,
            get: function get() {
                return a.thisTypeAnnotation
            }
        }),
        Object.defineProperty(r, "ThrowStatement", {
            enumerable: !0,
            get: function get() {
                return a.throwStatement
            }
        }),
        Object.defineProperty(r, "TopicReference", {
            enumerable: !0,
            get: function get() {
                return a.topicReference
            }
        }),
        Object.defineProperty(r, "TryStatement", {
            enumerable: !0,
            get: function get() {
                return a.tryStatement
            }
        }),
        Object.defineProperty(r, "TupleExpression", {
            enumerable: !0,
            get: function get() {
                return a.tupleExpression
            }
        }),
        Object.defineProperty(r, "TupleTypeAnnotation", {
            enumerable: !0,
            get: function get() {
                return a.tupleTypeAnnotation
            }
        }),
        Object.defineProperty(r, "TypeAlias", {
            enumerable: !0,
            get: function get() {
                return a.typeAlias
            }
        }),
        Object.defineProperty(r, "TypeAnnotation", {
            enumerable: !0,
            get: function get() {
                return a.typeAnnotation
            }
        }),
        Object.defineProperty(r, "TypeCastExpression", {
            enumerable: !0,
            get: function get() {
                return a.typeCastExpression
            }
        }),
        Object.defineProperty(r, "TypeParameter", {
            enumerable: !0,
            get: function get() {
                return a.typeParameter
            }
        }),
        Object.defineProperty(r, "TypeParameterDeclaration", {
            enumerable: !0,
            get: function get() {
                return a.typeParameterDeclaration
            }
        }),
        Object.defineProperty(r, "TypeParameterInstantiation", {
            enumerable: !0,
            get: function get() {
                return a.typeParameterInstantiation
            }
        }),
        Object.defineProperty(r, "TypeofTypeAnnotation", {
            enumerable: !0,
            get: function get() {
                return a.typeofTypeAnnotation
            }
        }),
        Object.defineProperty(r, "UnaryExpression", {
            enumerable: !0,
            get: function get() {
                return a.unaryExpression
            }
        }),
        Object.defineProperty(r, "UnionTypeAnnotation", {
            enumerable: !0,
            get: function get() {
                return a.unionTypeAnnotation
            }
        }),
        Object.defineProperty(r, "UpdateExpression", {
            enumerable: !0,
            get: function get() {
                return a.updateExpression
            }
        }),
        Object.defineProperty(r, "V8IntrinsicIdentifier", {
            enumerable: !0,
            get: function get() {
                return a.v8IntrinsicIdentifier
            }
        }),
        Object.defineProperty(r, "VariableDeclaration", {
            enumerable: !0,
            get: function get() {
                return a.variableDeclaration
            }
        }),
        Object.defineProperty(r, "VariableDeclarator", {
            enumerable: !0,
            get: function get() {
                return a.variableDeclarator
            }
        }),
        Object.defineProperty(r, "Variance", {
            enumerable: !0,
            get: function get() {
                return a.variance
            }
        }),
        Object.defineProperty(r, "VoidTypeAnnotation", {
            enumerable: !0,
            get: function get() {
                return a.voidTypeAnnotation
            }
        }),
        Object.defineProperty(r, "WhileStatement", {
            enumerable: !0,
            get: function get() {
                return a.whileStatement
            }
        }),
        Object.defineProperty(r, "WithStatement", {
            enumerable: !0,
            get: function get() {
                return a.withStatement
            }
        }),
        Object.defineProperty(r, "YieldExpression", {
            enumerable: !0,
            get: function get() {
                return a.yieldExpression
            }
        });
        var a = i("UuI8")
    },
    aaMo: function(t, r, i) {
        "use strict";
        (function(t) {
            var a = i("TqRt")
              , o = a(i("RIqP"))
              , l = a(i("cDf5"));
            function _createForOfIteratorHelper(t, r) {
                var i = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
                if (!i) {
                    if (Array.isArray(t) || (i = function _unsupportedIterableToArray(t, r) {
                        if (!t)
                            return;
                        if ("string" == typeof t)
                            return _arrayLikeToArray(t, r);
                        var i = Object.prototype.toString.call(t).slice(8, -1);
                        "Object" === i && t.constructor && (i = t.constructor.name);
                        if ("Map" === i || "Set" === i)
                            return Array.from(t);
                        if ("Arguments" === i || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i))
                            return _arrayLikeToArray(t, r)
                    }(t)) || r && t && "number" == typeof t.length) {
                        i && (t = i);
                        var a = 0
                          , o = function F() {};
                        return {
                            s: o,
                            n: function n() {
                                return a >= t.length ? {
                                    done: !0
                                } : {
                                    done: !1,
                                    value: t[a++]
                                }
                            },
                            e: function e(t) {
                                throw t
                            },
                            f: o
                        }
                    }
                    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                }
                var l, u = !0, p = !1;
                return {
                    s: function s() {
                        i = i.call(t)
                    },
                    n: function n() {
                        var t = i.next();
                        return u = t.done,
                        t
                    },
                    e: function e(t) {
                        p = !0,
                        l = t
                    },
                    f: function f() {
                        try {
                            u || null == i.return || i.return()
                        } finally {
                            if (p)
                                throw l
                        }
                    }
                }
            }
            function _arrayLikeToArray(t, r) {
                (null == r || r > t.length) && (r = t.length);
                for (var i = 0, a = new Array(r); i < r; i++)
                    a[i] = t[i];
                return a
            }
            Object.defineProperty(r, "__esModule", {
                value: !0
            }),
            r.VISITOR_KEYS = r.NODE_PARENT_VALIDATIONS = r.NODE_FIELDS = r.FLIPPED_ALIAS_KEYS = r.DEPRECATED_KEYS = r.BUILDER_KEYS = r.ALIAS_KEYS = void 0,
            r.arrayOf = arrayOf,
            r.arrayOfType = arrayOfType,
            r.assertEach = assertEach,
            r.assertNodeOrValueType = function assertNodeOrValueType() {
                for (var t = arguments.length, r = new Array(t), i = 0; i < t; i++)
                    r[i] = arguments[i];
                function validate(t, i, a) {
                    var o, l = _createForOfIteratorHelper(r);
                    try {
                        for (l.s(); !(o = l.n()).done; ) {
                            var c = o.value;
                            if (getType(a) === c || (0,
                            u.default)(c, a))
                                return void (0,
                                p.validateChild)(t, i, a)
                        }
                    } catch (t) {
                        l.e(t)
                    } finally {
                        l.f()
                    }
                    throw new TypeError("Property ".concat(i, " of ").concat(t.type, " expected node to be of a type ").concat(JSON.stringify(r), " but instead got ").concat(JSON.stringify(null == a ? void 0 : a.type)))
                }
                return validate.oneOfNodeOrValueTypes = r,
                validate
            }
            ,
            r.assertNodeType = assertNodeType,
            r.assertOneOf = function assertOneOf() {
                for (var t = arguments.length, r = new Array(t), i = 0; i < t; i++)
                    r[i] = arguments[i];
                function validate(t, i, a) {
                    if (r.indexOf(a) < 0)
                        throw new TypeError("Property ".concat(i, " expected value to be one of ").concat(JSON.stringify(r), " but got ").concat(JSON.stringify(a)))
                }
                return validate.oneOf = r,
                validate
            }
            ,
            r.assertOptionalChainStart = function assertOptionalChainStart() {
                return function validate(t) {
                    for (var r, i = t; t; ) {
                        var a = i.type;
                        if ("OptionalCallExpression" !== a) {
                            if ("OptionalMemberExpression" !== a)
                                break;
                            if (i.optional)
                                return;
                            i = i.object
                        } else {
                            if (i.optional)
                                return;
                            i = i.callee
                        }
                    }
                    throw new TypeError("Non-optional ".concat(t.type, " must chain from an optional OptionalMemberExpression or OptionalCallExpression. Found chain from ").concat(null == (r = i) ? void 0 : r.type))
                }
            }
            ,
            r.assertShape = function assertShape(t) {
                function validate(r, i, a) {
                    for (var o = [], l = 0, u = Object.keys(t); l < u.length; l++) {
                        var c = u[l];
                        try {
                            (0,
                            p.validateField)(r, c, a[c], t[c])
                        } catch (t) {
                            if (t instanceof TypeError) {
                                o.push(t.message);
                                continue
                            }
                            throw t
                        }
                    }
                    if (o.length)
                        throw new TypeError("Property ".concat(i, " of ").concat(r.type, " expected to have the following:\n").concat(o.join("\n")))
                }
                return validate.shapeOf = t,
                validate
            }
            ,
            r.assertValueType = assertValueType,
            r.chain = chain,
            r.default = defineType,
            r.defineAliasedType = function defineAliasedType() {
                for (var t = arguments.length, r = new Array(t), i = 0; i < t; i++)
                    r[i] = arguments[i];
                return function(t) {
                    var i, a, l = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, u = l.aliases;
                    u || (l.inherits && (u = null == (a = v[l.inherits].aliases) ? void 0 : a.slice()),
                    null != u || (u = []),
                    l.aliases = u);
                    var p = r.filter((function(t) {
                        return !u.includes(t)
                    }
                    ));
                    return (i = u).unshift.apply(i, (0,
                    o.default)(p)),
                    defineType(t, l)
                }
            }
            ,
            r.typeIs = typeIs,
            r.validate = validate,
            r.validateArrayOfType = function validateArrayOfType(t) {
                return validate(arrayOfType(t))
            }
            ,
            r.validateOptional = function validateOptional(t) {
                return {
                    validate: t,
                    optional: !0
                }
            }
            ,
            r.validateOptionalType = function validateOptionalType(t) {
                return {
                    validate: typeIs(t),
                    optional: !0
                }
            }
            ,
            r.validateType = function validateType(t) {
                return validate(typeIs(t))
            }
            ;
            var u = i("ET4T")
              , p = i("D+ka")
              , c = {};
            r.VISITOR_KEYS = c;
            var d = {};
            r.ALIAS_KEYS = d;
            var y = {};
            r.FLIPPED_ALIAS_KEYS = y;
            var h = {};
            r.NODE_FIELDS = h;
            var m = {};
            r.BUILDER_KEYS = m;
            var T = {};
            r.DEPRECATED_KEYS = T;
            var S = {};
            function getType(t) {
                return Array.isArray(t) ? "array" : null === t ? "null" : (0,
                l.default)(t)
            }
            function validate(t) {
                return {
                    validate: t
                }
            }
            function typeIs(t) {
                return "string" == typeof t ? assertNodeType(t) : assertNodeType.apply(void 0, (0,
                o.default)(t))
            }
            function arrayOf(t) {
                return chain(assertValueType("array"), assertEach(t))
            }
            function arrayOfType(t) {
                return arrayOf(typeIs(t))
            }
            function assertEach(r) {
                function validator(i, a, o) {
                    if (Array.isArray(o))
                        for (var l = 0; l < o.length; l++) {
                            var u = "".concat(a, "[").concat(l, "]")
                              , c = o[l];
                            r(i, u, c),
                            t.env.BABEL_TYPES_8_BREAKING && (0,
                            p.validateChild)(i, u, c)
                        }
                }
                return validator.each = r,
                validator
            }
            function assertNodeType() {
                for (var t = arguments.length, r = new Array(t), i = 0; i < t; i++)
                    r[i] = arguments[i];
                function validate(t, i, a) {
                    var o, l = _createForOfIteratorHelper(r);
                    try {
                        for (l.s(); !(o = l.n()).done; ) {
                            var c = o.value;
                            if ((0,
                            u.default)(c, a))
                                return void (0,
                                p.validateChild)(t, i, a)
                        }
                    } catch (t) {
                        l.e(t)
                    } finally {
                        l.f()
                    }
                    throw new TypeError("Property ".concat(i, " of ").concat(t.type, " expected node to be of a type ").concat(JSON.stringify(r), " but instead got ").concat(JSON.stringify(null == a ? void 0 : a.type)))
                }
                return validate.oneOfNodeTypes = r,
                validate
            }
            function assertValueType(t) {
                function validate(r, i, a) {
                    if (!(getType(a) === t))
                        throw new TypeError("Property ".concat(i, " expected type of ").concat(t, " but got ").concat(getType(a)))
                }
                return validate.type = t,
                validate
            }
            function chain() {
                for (var t = arguments.length, r = new Array(t), i = 0; i < t; i++)
                    r[i] = arguments[i];
                function validate() {
                    var t, i = _createForOfIteratorHelper(r);
                    try {
                        for (i.s(); !(t = i.n()).done; ) {
                            var a = t.value;
                            a.apply(void 0, arguments)
                        }
                    } catch (t) {
                        i.e(t)
                    } finally {
                        i.f()
                    }
                }
                if (validate.chainOf = r,
                r.length >= 2 && "type"in r[0] && "array" === r[0].type && !("each"in r[1]))
                    throw new Error('An assertValueType("array") validator can only be followed by an assertEach(...) validator.');
                return validate
            }
            r.NODE_PARENT_VALIDATIONS = S;
            var g = ["aliases", "builder", "deprecatedAlias", "fields", "inherits", "visitor", "validate"]
              , b = ["default", "optional", "validate"];
            function defineType(t) {
                var r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}
                  , i = r.inherits && v[r.inherits] || {}
                  , a = r.fields;
                if (!a && (a = {},
                i.fields)) {
                    var o, u = Object.getOwnPropertyNames(i.fields), p = _createForOfIteratorHelper(u);
                    try {
                        for (p.s(); !(o = p.n()).done; ) {
                            var E = o.value
                              , P = i.fields[E]
                              , x = P.default;
                            if (Array.isArray(x) ? x.length > 0 : x && "object" === (0,
                            l.default)(x))
                                throw new Error("field defaults can only be primitives or empty arrays currently");
                            a[E] = {
                                default: Array.isArray(x) ? [] : x,
                                optional: P.optional,
                                validate: P.validate
                            }
                        }
                    } catch (t) {
                        p.e(t)
                    } finally {
                        p.f()
                    }
                }
                for (var A = r.visitor || i.visitor || [], O = r.aliases || i.aliases || [], I = r.builder || i.builder || r.visitor || [], w = 0, C = Object.keys(r); w < C.length; w++) {
                    var N = C[w];
                    if (-1 === g.indexOf(N))
                        throw new Error('Unknown type option "'.concat(N, '" on ').concat(t))
                }
                r.deprecatedAlias && (T[r.deprecatedAlias] = t);
                var D, _ = _createForOfIteratorHelper(A.concat(I));
                try {
                    for (_.s(); !(D = _.n()).done; ) {
                        var L = D.value;
                        a[L] = a[L] || {}
                    }
                } catch (t) {
                    _.e(t)
                } finally {
                    _.f()
                }
                for (var k = 0, M = Object.keys(a); k < M.length; k++) {
                    var j = M[k]
                      , B = a[j];
                    void 0 !== B.default && -1 === I.indexOf(j) && (B.optional = !0),
                    void 0 === B.default ? B.default = null : B.validate || null == B.default || (B.validate = assertValueType(getType(B.default)));
                    for (var R = 0, K = Object.keys(B); R < K.length; R++) {
                        var V = K[R];
                        if (-1 === b.indexOf(V))
                            throw new Error('Unknown field key "'.concat(V, '" on ').concat(t, ".").concat(j))
                    }
                }
                c[t] = r.visitor = A,
                m[t] = r.builder = I,
                h[t] = r.fields = a,
                d[t] = r.aliases = O,
                O.forEach((function(r) {
                    y[r] = y[r] || [],
                    y[r].push(t)
                }
                )),
                r.validate && (S[t] = r.validate),
                v[t] = r
            }
            var v = {}
        }
        ).call(this, i("8oxB"))
    },
    aeMg: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function removeTypeDuplicates(t) {
            for (var r = {}, i = {}, o = [], l = [], u = 0; u < t.length; u++) {
                var p = t[u];
                if (p && !(l.indexOf(p) >= 0)) {
                    if ((0,
                    a.isTSAnyKeyword)(p))
                        return [p];
                    (0,
                    a.isTSBaseType)(p) ? i[p.type] = p : (0,
                    a.isTSUnionType)(p) ? o.indexOf(p.types) < 0 && (t = t.concat(p.types),
                    o.push(p.types)) : l.push(p)
                }
            }
            for (var c = 0, d = Object.keys(i); c < d.length; c++) {
                var y = d[c];
                l.push(i[y])
            }
            for (var h = 0, m = Object.keys(r); h < m.length; h++) {
                var T = m[h];
                l.push(r[T])
            }
            return l
        }
        ;
        var a = i("FUES")
    },
    ag9y: function(t, r, i) {
        "use strict";
        var a = i("TqRt")(i("RIqP"))
          , o = i("7ePq")
          , l = i("5Y2g");
        (0,
        o.default)("Noop", {
            visitor: []
        }),
        (0,
        o.default)("Placeholder", {
            visitor: [],
            builder: ["expectedNode", "name"],
            fields: {
                name: {
                    validate: (0,
                    o.assertNodeType)("Identifier")
                },
                expectedNode: {
                    validate: o.assertOneOf.apply(void 0, (0,
                    a.default)(l.PLACEHOLDERS))
                }
            }
        }),
        (0,
        o.default)("V8IntrinsicIdentifier", {
            builder: ["name"],
            fields: {
                name: {
                    validate: (0,
                    o.assertValueType)("string")
                }
            }
        })
    },
    alMP: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.toComputedKey = function toComputedKey() {
            var t;
            if (this.isMemberExpression())
                t = this.node.property;
            else {
                if (!this.isProperty() && !this.isMethod())
                    throw new ReferenceError("todo");
                t = this.node.key
            }
            this.node.computed || a.isIdentifier(t) && (t = a.stringLiteral(t.name));
            return t
        }
        ,
        r.ensureBlock = function ensureBlock() {
            var t = this.get("body")
              , r = t.node;
            if (Array.isArray(t))
                throw new Error("Can't convert array path to a block statement");
            if (!r)
                throw new Error("Can't convert node without a body");
            if (t.isBlockStatement())
                return r;
            var i, o, l = [], u = "body";
            t.isStatement() ? (o = "body",
            i = 0,
            l.push(t.node)) : (u += ".body.0",
            this.isFunction() ? (i = "argument",
            l.push(a.returnStatement(t.node))) : (i = "expression",
            l.push(a.expressionStatement(t.node))));
            this.node.body = a.blockStatement(l);
            var p = this.get(u);
            return t.setup(p, o ? p.node[o] : p.node, o, i),
            this.node
        }
        ,
        r.arrowFunctionToShadowed = function arrowFunctionToShadowed() {
            if (!this.isArrowFunctionExpression())
                return;
            this.arrowFunctionToExpression()
        }
        ,
        r.unwrapFunctionEnvironment = function unwrapFunctionEnvironment() {
            if (!this.isArrowFunctionExpression() && !this.isFunctionExpression() && !this.isFunctionDeclaration())
                throw this.buildCodeFrameError("Can only unwrap the environment of a function.");
            hoistFunctionEnvironment(this)
        }
        ,
        r.arrowFunctionToExpression = function arrowFunctionToExpression() {
            var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}
              , r = t.allowInsertArrow
              , i = void 0 === r || r
              , l = t.specCompliant
              , u = void 0 !== l && l
              , p = t.noNewArrows
              , c = void 0 === p ? !u : p;
            if (!this.isArrowFunctionExpression())
                throw this.buildCodeFrameError("Cannot convert non-arrow function to a function expression.");
            var d = hoistFunctionEnvironment(this, c, i);
            if (this.ensureBlock(),
            this.node.type = "FunctionExpression",
            !c) {
                var y = d ? null : this.parentPath.scope.generateUidIdentifier("arrowCheckId");
                y && this.parentPath.scope.push({
                    id: y,
                    init: a.objectExpression([])
                }),
                this.get("body").unshiftContainer("body", a.expressionStatement(a.callExpression(this.hub.addHelper("newArrowCheck"), [a.thisExpression(), y ? a.identifier(y.name) : a.identifier(d)]))),
                this.replaceWith(a.callExpression(a.memberExpression((0,
                o.default)(this, !0) || this.node, a.identifier("bind")), [y ? a.identifier(y.name) : a.thisExpression()]))
            }
        }
        ;
        var a = i("ZtNB")
          , o = i("whFr");
        function hoistFunctionEnvironment(t) {
            var r = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1]
              , i = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2]
              , o = t.findParent((function(t) {
                return t.isFunction() && !t.isArrowFunctionExpression() || t.isProgram() || t.isClassProperty({
                    static: !1
                })
            }
            ))
              , l = "constructor" === (null == o ? void 0 : o.node.kind);
            if (o.isClassProperty())
                throw t.buildCodeFrameError("Unable to transform arrow inside class property");
            var u, p = getScopeInformation(t), c = p.thisPaths, d = p.argumentsPaths, y = p.newTargetPaths, h = p.superProps, m = p.superCalls;
            if (l && m.length > 0) {
                if (!i)
                    throw m[0].buildCodeFrameError("Unable to handle nested super() usage in arrow");
                var T = [];
                o.traverse({
                    Function: function Function(t) {
                        t.isArrowFunctionExpression() || t.skip()
                    },
                    ClassProperty: function ClassProperty(t) {
                        t.skip()
                    },
                    CallExpression: function CallExpression(t) {
                        t.get("callee").isSuper() && T.push(t)
                    }
                });
                var S = getSuperBinding(o);
                T.forEach((function(t) {
                    var r = a.identifier(S);
                    r.loc = t.node.callee.loc,
                    t.get("callee").replaceWith(r)
                }
                ))
            }
            if (d.length > 0) {
                var g = getBinding(o, "arguments", (function() {
                    var t = function args() {
                        return a.identifier("arguments")
                    };
                    return o.scope.path.isProgram() ? a.conditionalExpression(a.binaryExpression("===", a.unaryExpression("typeof", t()), a.stringLiteral("undefined")), o.scope.buildUndefinedNode(), t()) : t()
                }
                ));
                d.forEach((function(t) {
                    var r = a.identifier(g);
                    r.loc = t.node.loc,
                    t.replaceWith(r)
                }
                ))
            }
            if (y.length > 0) {
                var b = getBinding(o, "newtarget", (function() {
                    return a.metaProperty(a.identifier("new"), a.identifier("target"))
                }
                ));
                y.forEach((function(t) {
                    var r = a.identifier(b);
                    r.loc = t.node.loc,
                    t.replaceWith(r)
                }
                ))
            }
            if (h.length > 0) {
                if (!i)
                    throw h[0].buildCodeFrameError("Unable to handle nested super.prop usage");
                var v = h.reduce((function(t, r) {
                    return t.concat(standardizeSuperProperty(r))
                }
                ), []);
                v.forEach((function(t) {
                    var r = t.node.computed ? "" : t.get("property").node.name
                      , i = t.parentPath.isAssignmentExpression({
                        left: t.node
                    })
                      , l = t.parentPath.isCallExpression({
                        callee: t.node
                    })
                      , u = getSuperPropBinding(o, i, r)
                      , p = [];
                    if (t.node.computed && p.push(t.get("property").node),
                    i) {
                        var d = t.parentPath.node.right;
                        p.push(d)
                    }
                    var y = a.callExpression(a.identifier(u), p);
                    l ? (t.parentPath.unshiftContainer("arguments", a.thisExpression()),
                    t.replaceWith(a.memberExpression(y, a.identifier("call"))),
                    c.push(t.parentPath.get("arguments.0"))) : i ? t.parentPath.replaceWith(y) : t.replaceWith(y)
                }
                ))
            }
            return (c.length > 0 || !r) && (u = getThisBinding(o, l),
            (r || l && hasSuperClass(o)) && (c.forEach((function(t) {
                var r = t.isJSX() ? a.jsxIdentifier(u) : a.identifier(u);
                r.loc = t.node.loc,
                t.replaceWith(r)
            }
            )),
            r || (u = null))),
            u
        }
        function standardizeSuperProperty(t) {
            if (t.parentPath.isAssignmentExpression() && "=" !== t.parentPath.node.operator) {
                var r = t.parentPath
                  , i = r.node.operator.slice(0, -1)
                  , o = r.node.right;
                if (r.node.operator = "=",
                t.node.computed) {
                    var l = t.scope.generateDeclaredUidIdentifier("tmp");
                    r.get("left").replaceWith(a.memberExpression(t.node.object, a.assignmentExpression("=", l, t.node.property), !0)),
                    r.get("right").replaceWith(a.binaryExpression(i, a.memberExpression(t.node.object, a.identifier(l.name), !0), o))
                } else
                    r.get("left").replaceWith(a.memberExpression(t.node.object, t.node.property)),
                    r.get("right").replaceWith(a.binaryExpression(i, a.memberExpression(t.node.object, a.identifier(t.node.property.name)), o));
                return [r.get("left"), r.get("right").get("left")]
            }
            if (t.parentPath.isUpdateExpression()) {
                var u = t.parentPath
                  , p = t.scope.generateDeclaredUidIdentifier("tmp")
                  , c = t.node.computed ? t.scope.generateDeclaredUidIdentifier("prop") : null
                  , d = [a.assignmentExpression("=", p, a.memberExpression(t.node.object, c ? a.assignmentExpression("=", c, t.node.property) : t.node.property, t.node.computed)), a.assignmentExpression("=", a.memberExpression(t.node.object, c ? a.identifier(c.name) : t.node.property, t.node.computed), a.binaryExpression("+", a.identifier(p.name), a.numericLiteral(1)))];
                return t.parentPath.node.prefix || d.push(a.identifier(p.name)),
                u.replaceWith(a.sequenceExpression(d)),
                [u.get("expressions.0.right"), u.get("expressions.1.left")]
            }
            return [t]
        }
        function hasSuperClass(t) {
            return t.isClassMethod() && !!t.parentPath.parentPath.node.superClass
        }
        function getThisBinding(t, r) {
            return getBinding(t, "this", (function(i) {
                if (!r || !hasSuperClass(t))
                    return a.thisExpression();
                var o = new WeakSet;
                t.traverse({
                    Function: function Function(t) {
                        t.isArrowFunctionExpression() || t.skip()
                    },
                    ClassProperty: function ClassProperty(t) {
                        t.skip()
                    },
                    CallExpression: function CallExpression(t) {
                        t.get("callee").isSuper() && (o.has(t.node) || (o.add(t.node),
                        t.replaceWithMultiple([t.node, a.assignmentExpression("=", a.identifier(i), a.identifier("this"))])))
                    }
                })
            }
            ))
        }
        function getSuperBinding(t) {
            return getBinding(t, "supercall", (function() {
                var r = t.scope.generateUidIdentifier("args");
                return a.arrowFunctionExpression([a.restElement(r)], a.callExpression(a.super(), [a.spreadElement(a.identifier(r.name))]))
            }
            ))
        }
        function getSuperPropBinding(t, r, i) {
            return getBinding(t, "superprop_".concat(r ? "set" : "get", ":").concat(i || ""), (function() {
                var o, l = [];
                if (i)
                    o = a.memberExpression(a.super(), a.identifier(i));
                else {
                    var u = t.scope.generateUidIdentifier("prop");
                    l.unshift(u),
                    o = a.memberExpression(a.super(), a.identifier(u.name), !0)
                }
                if (r) {
                    var p = t.scope.generateUidIdentifier("value");
                    l.push(p),
                    o = a.assignmentExpression("=", o, a.identifier(p.name))
                }
                return a.arrowFunctionExpression(l, o)
            }
            ))
        }
        function getBinding(t, r, i) {
            var a = "binding:" + r
              , o = t.getData(a);
            if (!o) {
                var l = t.scope.generateUidIdentifier(r);
                o = l.name,
                t.setData(a, o),
                t.scope.push({
                    id: l,
                    init: i(o)
                })
            }
            return o
        }
        function getScopeInformation(t) {
            var r = []
              , i = []
              , a = []
              , o = []
              , l = [];
            return t.traverse({
                ClassProperty: function ClassProperty(t) {
                    t.skip()
                },
                Function: function Function(t) {
                    t.isArrowFunctionExpression() || t.skip()
                },
                ThisExpression: function ThisExpression(t) {
                    r.push(t)
                },
                JSXIdentifier: function JSXIdentifier(t) {
                    "this" === t.node.name && (t.parentPath.isJSXMemberExpression({
                        object: t.node
                    }) || t.parentPath.isJSXOpeningElement({
                        name: t.node
                    })) && r.push(t)
                },
                CallExpression: function CallExpression(t) {
                    t.get("callee").isSuper() && l.push(t)
                },
                MemberExpression: function MemberExpression(t) {
                    t.get("object").isSuper() && o.push(t)
                },
                ReferencedIdentifier: function ReferencedIdentifier(t) {
                    if ("arguments" === t.node.name) {
                        var r = t.scope;
                        do {
                            if (r.hasOwnBinding("arguments"))
                                return void r.rename("arguments");
                            if (r.path.isFunction() && !r.path.isArrowFunctionExpression())
                                break
                        } while (r = r.parent);
                        i.push(t)
                    }
                },
                MetaProperty: function MetaProperty(t) {
                    t.get("meta").isIdentifier({
                        name: "new"
                    }) && t.get("property").isIdentifier({
                        name: "target"
                    }) && a.push(t)
                }
            }),
            {
                thisPaths: r,
                argumentsPaths: i,
                newTargetPaths: a,
                superProps: o,
                superCalls: l
            }
        }
    },
    anS6: function(t, r, i) {
        "use strict";
        function _createForOfIteratorHelper(t, r) {
            var i = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
            if (!i) {
                if (Array.isArray(t) || (i = function _unsupportedIterableToArray(t, r) {
                    if (!t)
                        return;
                    if ("string" == typeof t)
                        return _arrayLikeToArray(t, r);
                    var i = Object.prototype.toString.call(t).slice(8, -1);
                    "Object" === i && t.constructor && (i = t.constructor.name);
                    if ("Map" === i || "Set" === i)
                        return Array.from(t);
                    if ("Arguments" === i || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i))
                        return _arrayLikeToArray(t, r)
                }(t)) || r && t && "number" == typeof t.length) {
                    i && (t = i);
                    var a = 0
                      , o = function F() {};
                    return {
                        s: o,
                        n: function n() {
                            return a >= t.length ? {
                                done: !0
                            } : {
                                done: !1,
                                value: t[a++]
                            }
                        },
                        e: function e(t) {
                            throw t
                        },
                        f: o
                    }
                }
                throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
            }
            var l, u = !0, p = !1;
            return {
                s: function s() {
                    i = i.call(t)
                },
                n: function n() {
                    var t = i.next();
                    return u = t.done,
                    t
                },
                e: function e(t) {
                    p = !0,
                    l = t
                },
                f: function f() {
                    try {
                        u || null == i.return || i.return()
                    } finally {
                        if (p)
                            throw l
                    }
                }
            }
        }
        function _arrayLikeToArray(t, r) {
            (null == r || r > t.length) && (r = t.length);
            for (var i = 0, a = new Array(r); i < r; i++)
                a[i] = t[i];
            return a
        }
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function inherits(t, r) {
            if (!t || !r)
                return t;
            var i, l = _createForOfIteratorHelper(a.INHERIT_KEYS.optional);
            try {
                for (l.s(); !(i = l.n()).done; ) {
                    var u = i.value;
                    null == t[u] && (t[u] = r[u])
                }
            } catch (t) {
                l.e(t)
            } finally {
                l.f()
            }
            for (var p = 0, c = Object.keys(r); p < c.length; p++) {
                var d = c[p];
                "_" === d[0] && "__clone" !== d && (t[d] = r[d])
            }
            var y, h = _createForOfIteratorHelper(a.INHERIT_KEYS.force);
            try {
                for (h.s(); !(y = h.n()).done; ) {
                    var m = y.value;
                    t[m] = r[m]
                }
            } catch (t) {
                h.e(t)
            } finally {
                h.f()
            }
            return (0,
            o.default)(t, r),
            t
        }
        ;
        var a = i("RS7Y")
          , o = i("0JKf")
    },
    ap7b: function(t, r) {
        function swap(t, r, i) {
            var a = t[r];
            t[r] = t[i],
            t[i] = a
        }
        function doQuickSort(t, r, i, a) {
            if (i < a) {
                var o = i - 1;
                swap(t, function randomIntInRange(t, r) {
                    return Math.round(t + Math.random() * (r - t))
                }(i, a), a);
                for (var l = t[a], u = i; u < a; u++)
                    r(t[u], l) <= 0 && swap(t, o += 1, u);
                swap(t, o + 1, u);
                var p = o + 1;
                doQuickSort(t, r, i, p - 1),
                doQuickSort(t, r, p + 1, a)
            }
        }
        r.quickSort = function(t, r) {
            doQuickSort(t, r, 0, t.length - 1)
        }
    },
    ar3U: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.BreakStatement = void 0,
        r.CatchClause = function CatchClause(t) {
            this.word("catch"),
            this.space(),
            t.param && (this.token("("),
            this.print(t.param, t),
            this.print(t.param.typeAnnotation, t),
            this.token(")"),
            this.space());
            this.print(t.body, t)
        }
        ,
        r.ContinueStatement = void 0,
        r.DebuggerStatement = function DebuggerStatement() {
            this.word("debugger"),
            this.semicolon()
        }
        ,
        r.DoWhileStatement = function DoWhileStatement(t) {
            this.word("do"),
            this.space(),
            this.print(t.body, t),
            this.space(),
            this.word("while"),
            this.space(),
            this.token("("),
            this.print(t.test, t),
            this.token(")"),
            this.semicolon()
        }
        ,
        r.ForOfStatement = r.ForInStatement = void 0,
        r.ForStatement = function ForStatement(t) {
            this.word("for"),
            this.space(),
            this.token("("),
            this.inForStatementInitCounter++,
            this.print(t.init, t),
            this.inForStatementInitCounter--,
            this.token(";"),
            t.test && (this.space(),
            this.print(t.test, t));
            this.token(";"),
            t.update && (this.space(),
            this.print(t.update, t));
            this.token(")"),
            this.printBlock(t)
        }
        ,
        r.IfStatement = function IfStatement(t) {
            this.word("if"),
            this.space(),
            this.token("("),
            this.print(t.test, t),
            this.token(")"),
            this.space();
            const r = t.alternate && u(function getLastStatement(t) {
                return p(t.body) ? getLastStatement(t.body) : t
            }(t.consequent));
            r && (this.token("{"),
            this.newline(),
            this.indent());
            this.printAndIndentOnComments(t.consequent, t),
            r && (this.dedent(),
            this.newline(),
            this.token("}"));
            t.alternate && (this.endsWith(125) && this.space(),
            this.word("else"),
            this.space(),
            this.printAndIndentOnComments(t.alternate, t))
        }
        ,
        r.LabeledStatement = function LabeledStatement(t) {
            this.print(t.label, t),
            this.token(":"),
            this.space(),
            this.print(t.body, t)
        }
        ,
        r.ReturnStatement = void 0,
        r.SwitchCase = function SwitchCase(t) {
            t.test ? (this.word("case"),
            this.space(),
            this.print(t.test, t),
            this.token(":")) : (this.word("default"),
            this.token(":"));
            t.consequent.length && (this.newline(),
            this.printSequence(t.consequent, t, {
                indent: !0
            }))
        }
        ,
        r.SwitchStatement = function SwitchStatement(t) {
            this.word("switch"),
            this.space(),
            this.token("("),
            this.print(t.discriminant, t),
            this.token(")"),
            this.space(),
            this.token("{"),
            this.printSequence(t.cases, t, {
                indent: !0,
                addNewlines(r, i) {
                    if (!r && t.cases[t.cases.length - 1] === i)
                        return -1
                }
            }),
            this.token("}")
        }
        ,
        r.ThrowStatement = void 0,
        r.TryStatement = function TryStatement(t) {
            this.word("try"),
            this.space(),
            this.print(t.block, t),
            this.space(),
            t.handlers ? this.print(t.handlers[0], t) : this.print(t.handler, t);
            t.finalizer && (this.space(),
            this.word("finally"),
            this.space(),
            this.print(t.finalizer, t))
        }
        ,
        r.VariableDeclaration = function VariableDeclaration(t, r) {
            t.declare && (this.word("declare"),
            this.space());
            this.word(t.kind),
            this.space();
            let i, a = !1;
            if (!o(r))
                for (const r of t.declarations)
                    r.init && (a = !0);
            a && (i = "const" === t.kind ? constDeclarationIndent : variableDeclarationIndent);
            if (this.printList(t.declarations, t, {
                separator: i
            }),
            o(r))
                if (l(r)) {
                    if (r.init === t)
                        return
                } else if (r.left === t)
                    return;
            this.semicolon()
        }
        ,
        r.VariableDeclarator = function VariableDeclarator(t) {
            this.print(t.id, t),
            t.definite && this.token("!");
            this.print(t.id.typeAnnotation, t),
            t.init && (this.space(),
            this.token("="),
            this.space(),
            this.print(t.init, t))
        }
        ,
        r.WhileStatement = function WhileStatement(t) {
            this.word("while"),
            this.space(),
            this.token("("),
            this.print(t.test, t),
            this.token(")"),
            this.printBlock(t)
        }
        ,
        r.WithStatement = function WithStatement(t) {
            this.word("with"),
            this.space(),
            this.token("("),
            this.print(t.object, t),
            this.token(")"),
            this.printBlock(t)
        }
        ;
        var a = i("JSq2");
        const {isFor: o, isForStatement: l, isIfStatement: u, isStatement: p} = a;
        const buildForXStatement = function(t) {
            return function(r) {
                this.word("for"),
                this.space(),
                "of" === t && r.await && (this.word("await"),
                this.space()),
                this.token("("),
                this.print(r.left, r),
                this.space(),
                this.word(t),
                this.space(),
                this.print(r.right, r),
                this.token(")"),
                this.printBlock(r)
            }
        }
          , c = buildForXStatement("in");
        r.ForInStatement = c;
        const d = buildForXStatement("of");
        function buildLabelStatement(t, r="label") {
            return function(i) {
                this.word(t);
                const a = i[r];
                if (a) {
                    this.space();
                    const t = "label" == r
                      , o = this.startTerminatorless(t);
                    this.print(a, i),
                    this.endTerminatorless(o)
                }
                this.semicolon()
            }
        }
        r.ForOfStatement = d;
        const y = buildLabelStatement("continue");
        r.ContinueStatement = y;
        const h = buildLabelStatement("return", "argument");
        r.ReturnStatement = h;
        const m = buildLabelStatement("break");
        r.BreakStatement = m;
        const T = buildLabelStatement("throw", "argument");
        function variableDeclarationIndent() {
            if (this.token(","),
            this.newline(),
            this.endsWith(10))
                for (let t = 0; t < 4; t++)
                    this.space(!0)
        }
        function constDeclarationIndent() {
            if (this.token(","),
            this.newline(),
            this.endsWith(10))
                for (let t = 0; t < 6; t++)
                    this.space(!0)
        }
        r.ThrowStatement = T
    },
    b25T: function(t, r, i) {
        "use strict";
        (function(t) {
            var r = i("V97+");
            (0,
            r.default)("ArgumentPlaceholder", {}),
            (0,
            r.default)("BindExpression", {
                visitor: ["object", "callee"],
                aliases: ["Expression"],
                fields: t.env.BABEL_TYPES_8_BREAKING ? {
                    object: {
                        validate: (0,
                        r.assertNodeType)("Expression")
                    },
                    callee: {
                        validate: (0,
                        r.assertNodeType)("Expression")
                    }
                } : {
                    object: {
                        validate: Object.assign(()=>{}
                        , {
                            oneOfNodeTypes: ["Expression"]
                        })
                    },
                    callee: {
                        validate: Object.assign(()=>{}
                        , {
                            oneOfNodeTypes: ["Expression"]
                        })
                    }
                }
            }),
            (0,
            r.default)("ImportAttribute", {
                visitor: ["key", "value"],
                fields: {
                    key: {
                        validate: (0,
                        r.assertNodeType)("Identifier", "StringLiteral")
                    },
                    value: {
                        validate: (0,
                        r.assertNodeType)("StringLiteral")
                    }
                }
            }),
            (0,
            r.default)("Decorator", {
                visitor: ["expression"],
                fields: {
                    expression: {
                        validate: (0,
                        r.assertNodeType)("Expression")
                    }
                }
            }),
            (0,
            r.default)("DoExpression", {
                visitor: ["body"],
                builder: ["body", "async"],
                aliases: ["Expression"],
                fields: {
                    body: {
                        validate: (0,
                        r.assertNodeType)("BlockStatement")
                    },
                    async: {
                        validate: (0,
                        r.assertValueType)("boolean"),
                        default: !1
                    }
                }
            }),
            (0,
            r.default)("ExportDefaultSpecifier", {
                visitor: ["exported"],
                aliases: ["ModuleSpecifier"],
                fields: {
                    exported: {
                        validate: (0,
                        r.assertNodeType)("Identifier")
                    }
                }
            }),
            (0,
            r.default)("RecordExpression", {
                visitor: ["properties"],
                aliases: ["Expression"],
                fields: {
                    properties: {
                        validate: (0,
                        r.chain)((0,
                        r.assertValueType)("array"), (0,
                        r.assertEach)((0,
                        r.assertNodeType)("ObjectProperty", "SpreadElement")))
                    }
                }
            }),
            (0,
            r.default)("TupleExpression", {
                fields: {
                    elements: {
                        validate: (0,
                        r.chain)((0,
                        r.assertValueType)("array"), (0,
                        r.assertEach)((0,
                        r.assertNodeType)("Expression", "SpreadElement"))),
                        default: []
                    }
                },
                visitor: ["elements"],
                aliases: ["Expression"]
            }),
            (0,
            r.default)("DecimalLiteral", {
                builder: ["value"],
                fields: {
                    value: {
                        validate: (0,
                        r.assertValueType)("string")
                    }
                },
                aliases: ["Expression", "Pureish", "Literal", "Immutable"]
            }),
            (0,
            r.default)("ModuleExpression", {
                visitor: ["body"],
                fields: {
                    body: {
                        validate: (0,
                        r.assertNodeType)("Program")
                    }
                },
                aliases: ["Expression"]
            }),
            (0,
            r.default)("TopicReference", {
                aliases: ["Expression"]
            }),
            (0,
            r.default)("PipelineTopicExpression", {
                builder: ["expression"],
                visitor: ["expression"],
                fields: {
                    expression: {
                        validate: (0,
                        r.assertNodeType)("Expression")
                    }
                },
                aliases: ["Expression"]
            }),
            (0,
            r.default)("PipelineBareFunction", {
                builder: ["callee"],
                visitor: ["callee"],
                fields: {
                    callee: {
                        validate: (0,
                        r.assertNodeType)("Expression")
                    }
                },
                aliases: ["Expression"]
            }),
            (0,
            r.default)("PipelinePrimaryTopicReference", {
                aliases: ["Expression"]
            })
        }
        ).call(this, i("8oxB"))
    },
    b89f: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function isScope(t, r) {
            if ((0,
            a.isBlockStatement)(t) && ((0,
            a.isFunction)(r) || (0,
            a.isCatchClause)(r)))
                return !1;
            if ((0,
            a.isPattern)(t) && ((0,
            a.isFunction)(r) || (0,
            a.isCatchClause)(r)))
                return !0;
            return (0,
            a.isScopable)(t)
        }
        ;
        var a = i("FUES")
    },
    bEOD: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function builder(t) {
            for (var r = arguments.length, i = new Array(r > 1 ? r - 1 : 0), l = 1; l < r; l++)
                i[l - 1] = arguments[l];
            var u = a.BUILDER_KEYS[t]
              , p = i.length;
            if (p > u.length)
                throw new Error("".concat(t, ": Too many arguments passed. Received ").concat(p, " but can receive no more than ").concat(u.length));
            var c = {
                type: t
            }
              , d = 0;
            u.forEach((function(r) {
                var o, l = a.NODE_FIELDS[t][r];
                d < p && (o = i[d]),
                void 0 === o && (o = Array.isArray(l.default) ? [] : l.default),
                c[r] = o,
                d++
            }
            ));
            for (var y = 0, h = Object.keys(c); y < h.length; y++) {
                var m = h[y];
                (0,
                o.default)(c, m, c[m])
            }
            return c
        }
        ;
        var a = i("Resm")
          , o = i("kmK0")
    },
    baCj: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = void 0;
        const a = /^[ \t]+$/;
        r.default = class Buffer {
            constructor(t) {
                this._map = null,
                this._buf = "",
                this._last = 0,
                this._queue = [],
                this._position = {
                    line: 1,
                    column: 0
                },
                this._sourcePosition = {
                    identifierName: null,
                    line: null,
                    column: null,
                    filename: null
                },
                this._disallowedPop = null,
                this._map = t
            }
            get() {
                this._flush();
                const t = this._map
                  , r = {
                    code: this._buf.trimRight(),
                    map: null,
                    rawMappings: null == t ? void 0 : t.getRawMappings()
                };
                return t && Object.defineProperty(r, "map", {
                    configurable: !0,
                    enumerable: !0,
                    get() {
                        return this.map = t.get()
                    },
                    set(t) {
                        Object.defineProperty(this, "map", {
                            value: t,
                            writable: !0
                        })
                    }
                }),
                r
            }
            append(t) {
                this._flush();
                const {line: r, column: i, filename: a, identifierName: o, force: l} = this._sourcePosition;
                this._append(t, r, i, o, a, l)
            }
            queue(t) {
                if ("\n" === t)
                    for (; this._queue.length > 0 && a.test(this._queue[0][0]); )
                        this._queue.shift();
                const {line: r, column: i, filename: o, identifierName: l, force: u} = this._sourcePosition;
                this._queue.unshift([t, r, i, l, o, u])
            }
            _flush() {
                let t;
                for (; t = this._queue.pop(); )
                    this._append(...t)
            }
            _append(t, r, i, a, o, l) {
                this._buf += t,
                this._last = t.charCodeAt(t.length - 1);
                let u = t.indexOf("\n")
                  , p = 0;
                for (0 !== u && this._mark(r, i, a, o, l); -1 !== u; )
                    this._position.line++,
                    this._position.column = 0,
                    p = u + 1,
                    p < t.length && this._mark(++r, 0, a, o, l),
                    u = t.indexOf("\n", p);
                this._position.column += t.length - p
            }
            _mark(t, r, i, a, o) {
                var l;
                null == (l = this._map) || l.mark(this._position.line, this._position.column, t, r, i, a, o)
            }
            removeTrailingNewline() {
                this._queue.length > 0 && "\n" === this._queue[0][0] && this._queue.shift()
            }
            removeLastSemicolon() {
                this._queue.length > 0 && ";" === this._queue[0][0] && this._queue.shift()
            }
            getLastChar() {
                let t;
                if (this._queue.length > 0) {
                    t = this._queue[0][0].charCodeAt(0)
                } else
                    t = this._last;
                return t
            }
            endsWithCharAndNewline() {
                const t = this._queue;
                if (t.length > 0) {
                    if (10 !== t[0][0].charCodeAt(0))
                        return;
                    if (t.length > 1) {
                        return t[1][0].charCodeAt(0)
                    }
                    return this._last
                }
            }
            hasContent() {
                return this._queue.length > 0 || !!this._last
            }
            exactSource(t, r) {
                this.source("start", t, !0),
                r(),
                this.source("end", t),
                this._disallowPop("start", t)
            }
            source(t, r, i) {
                t && !r || this._normalizePosition(t, r, this._sourcePosition, i)
            }
            withSource(t, r, i) {
                if (!this._map)
                    return i();
                const a = this._sourcePosition.line
                  , o = this._sourcePosition.column
                  , l = this._sourcePosition.filename
                  , u = this._sourcePosition.identifierName;
                this.source(t, r),
                i(),
                this._sourcePosition.force && this._sourcePosition.line === a && this._sourcePosition.column === o && this._sourcePosition.filename === l || this._disallowedPop && this._disallowedPop.line === a && this._disallowedPop.column === o && this._disallowedPop.filename === l || (this._sourcePosition.line = a,
                this._sourcePosition.column = o,
                this._sourcePosition.filename = l,
                this._sourcePosition.identifierName = u,
                this._sourcePosition.force = !1,
                this._disallowedPop = null)
            }
            _disallowPop(t, r) {
                t && !r || (this._disallowedPop = this._normalizePosition(t, r))
            }
            _normalizePosition(t, r, i, a) {
                const o = r ? r[t] : null;
                void 0 === i && (i = {
                    identifierName: null,
                    line: null,
                    column: null,
                    filename: null,
                    force: !1
                });
                const l = i.line
                  , u = i.column
                  , p = i.filename;
                return i.identifierName = "start" === t && (null == r ? void 0 : r.identifierName) || null,
                i.line = null == o ? void 0 : o.line,
                i.column = null == o ? void 0 : o.column,
                i.filename = null == r ? void 0 : r.filename,
                (a || i.line !== l || i.column !== u || i.filename !== p) && (i.force = a),
                i
            }
            getCurrentColumn() {
                const t = this._queue.reduce((t,r)=>r[0] + t, "")
                  , r = t.lastIndexOf("\n");
                return -1 === r ? this._position.column + t.length : t.length - 1 - r
            }
            getCurrentLine() {
                const t = this._queue.reduce((t,r)=>r[0] + t, "");
                let r = 0;
                for (let i = 0; i < t.length; i++)
                    "\n" === t[i] && r++;
                return this._position.line + r
            }
        }
    },
    buHe: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function isNode(t) {
            return !(!t || !a.VISITOR_KEYS[t.type])
        }
        ;
        var a = i("Resm")
    },
    c700: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function gatherSequenceExpressions(t, r, i) {
            const p = [];
            let c = !0;
            for (const d of t)
                if ((0,
                o.isEmptyStatement)(d) || (c = !1),
                (0,
                o.isExpression)(d))
                    p.push(d);
                else if ((0,
                o.isExpressionStatement)(d))
                    p.push(d.expression);
                else if ((0,
                o.isVariableDeclaration)(d)) {
                    if ("var" !== d.kind)
                        return;
                    for (const t of d.declarations) {
                        const r = (0,
                        a.default)(t);
                        for (const t of Object.keys(r))
                            i.push({
                                kind: d.kind,
                                id: (0,
                                u.default)(r[t])
                            });
                        t.init && p.push((0,
                        l.assignmentExpression)("=", t.id, t.init))
                    }
                    c = !0
                } else if ((0,
                o.isIfStatement)(d)) {
                    const t = d.consequent ? gatherSequenceExpressions([d.consequent], r, i) : r.buildUndefinedNode()
                      , a = d.alternate ? gatherSequenceExpressions([d.alternate], r, i) : r.buildUndefinedNode();
                    if (!t || !a)
                        return;
                    p.push((0,
                    l.conditionalExpression)(d.test, t, a))
                } else if ((0,
                o.isBlockStatement)(d)) {
                    const t = gatherSequenceExpressions(d.body, r, i);
                    if (!t)
                        return;
                    p.push(t)
                } else {
                    if (!(0,
                    o.isEmptyStatement)(d))
                        return;
                    0 === t.indexOf(d) && (c = !0)
                }
            c && p.push(r.buildUndefinedNode());
            return 1 === p.length ? p[0] : (0,
            l.sequenceExpression)(p)
        }
        ;
        var a = i("wffa")
          , o = i("xIU+")
          , l = i("61uC")
          , u = i("v3g0")
    },
    cb78: function(t, r) {
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = /((['"])(?:(?!\2|\\).|\\(?:\r\n|[\s\S]))*(\2)?|`(?:[^`\\$]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{[^}]*\}?)*\}?)*(`)?)|(\/\/.*)|(\/\*(?:[^*]|\*(?!\/))*(\*\/)?)|(\/(?!\*)(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\]\\]).|\\.)+\/(?:(?!\s*(?:\b|[\u0080-\uFFFF$\\'"~({]|[+\-!](?!=)|\.?\d))|[gmiyus]{1,6}\b(?![\u0080-\uFFFF$\\]|\s*(?:[+\-*%&|^<>!=?({]|\/(?![\/*])))))|(0[xX][\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?)|((?!\d)(?:(?!\s)[$\w\u0080-\uFFFF]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+)|(--|\+\+|&&|\|\||=>|\.{3}|(?:[+\-\/%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\](){}])|(\s+)|(^$|[\s\S])/g,
        r.matchToToken = function(t) {
            var r = {
                type: "invalid",
                value: t[0],
                closed: void 0
            };
            return t[1] ? (r.type = "string",
            r.closed = !(!t[3] && !t[4])) : t[5] ? r.type = "comment" : t[6] ? (r.type = "comment",
            r.closed = !!t[7]) : t[8] ? r.type = "regex" : t[9] ? r.type = "number" : t[10] ? r.type = "name" : t[11] ? r.type = "punctuator" : t[12] && (r.type = "whitespace"),
            r
        }
    },
    cuf3: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function buildChildren(t) {
            const r = [];
            for (let i = 0; i < t.children.length; i++) {
                let l = t.children[i];
                (0,
                a.isJSXText)(l) ? (0,
                o.default)(l, r) : ((0,
                a.isJSXExpressionContainer)(l) && (l = l.expression),
                (0,
                a.isJSXEmptyExpression)(l) || r.push(l))
            }
            return r
        }
        ;
        var a = i("xIU+")
          , o = i("FjNa")
    },
    dHLz: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function assertNode(t) {
            if (!(0,
            a.default)(t)) {
                var r, i = null != (r = null == t ? void 0 : t.type) ? r : JSON.stringify(t);
                throw new TypeError('Not a valid node of type "'.concat(i, '"'))
            }
        }
        ;
        var a = i("rHqr")
    },
    dYsE: function(t, r, i) {
        "use strict";
        var a = i("TqRt")
          , o = a(i("W8MJ"))
          , l = a(i("lwsE"))
          , u = (0,
        o.default)((function Variable(t, r) {
            (0,
            l.default)(this, Variable),
            this.name = t,
            this.identifiers = [],
            this.references = [],
            this.defs = [],
            this.tainted = !1,
            this.stack = !0,
            this.scope = r
        }
        ));
        u.CatchClause = "CatchClause",
        u.Parameter = "Parameter",
        u.FunctionName = "FunctionName",
        u.ClassName = "ClassName",
        u.Variable = "Variable",
        u.ImportBinding = "ImportBinding",
        u.TDZ = "TDZ",
        u.ImplicitGlobalVariable = "ImplicitGlobalVariable",
        t.exports = u
    },
    dcRz: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function isScope(t, r) {
            if ((0,
            a.isBlockStatement)(t) && ((0,
            a.isFunction)(r) || (0,
            a.isCatchClause)(r)))
                return !1;
            if ((0,
            a.isPattern)(t) && ((0,
            a.isFunction)(r) || (0,
            a.isCatchClause)(r)))
                return !0;
            return (0,
            a.isScopable)(t)
        }
        ;
        var a = i("pbIU")
    },
    dm8S: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function removePropertiesDeep(t, r) {
            return (0,
            a.default)(t, o.default, r),
            t
        }
        ;
        var a = i("8YYJ")
          , o = i("N2Vh")
    },
    dr59: function(t, r, i) {
        "use strict";
        var a = i("aaMo")
          , o = (0,
        a.defineAliasedType)("Flow")
          , l = function defineInterfaceishType(t) {
            var r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "TypeParameterDeclaration";
            o(t, {
                builder: ["id", "typeParameters", "extends", "body"],
                visitor: ["id", "typeParameters", "extends", "mixins", "implements", "body"],
                aliases: ["FlowDeclaration", "Statement", "Declaration"],
                fields: {
                    id: (0,
                    a.validateType)("Identifier"),
                    typeParameters: (0,
                    a.validateOptionalType)(r),
                    extends: (0,
                    a.validateOptional)((0,
                    a.arrayOfType)("InterfaceExtends")),
                    mixins: (0,
                    a.validateOptional)((0,
                    a.arrayOfType)("InterfaceExtends")),
                    implements: (0,
                    a.validateOptional)((0,
                    a.arrayOfType)("ClassImplements")),
                    body: (0,
                    a.validateType)("ObjectTypeAnnotation")
                }
            })
        };
        o("AnyTypeAnnotation", {
            aliases: ["FlowType", "FlowBaseAnnotation"]
        }),
        o("ArrayTypeAnnotation", {
            visitor: ["elementType"],
            aliases: ["FlowType"],
            fields: {
                elementType: (0,
                a.validateType)("FlowType")
            }
        }),
        o("BooleanTypeAnnotation", {
            aliases: ["FlowType", "FlowBaseAnnotation"]
        }),
        o("BooleanLiteralTypeAnnotation", {
            builder: ["value"],
            aliases: ["FlowType"],
            fields: {
                value: (0,
                a.validate)((0,
                a.assertValueType)("boolean"))
            }
        }),
        o("NullLiteralTypeAnnotation", {
            aliases: ["FlowType", "FlowBaseAnnotation"]
        }),
        o("ClassImplements", {
            visitor: ["id", "typeParameters"],
            fields: {
                id: (0,
                a.validateType)("Identifier"),
                typeParameters: (0,
                a.validateOptionalType)("TypeParameterInstantiation")
            }
        }),
        l("DeclareClass"),
        o("DeclareFunction", {
            visitor: ["id"],
            aliases: ["FlowDeclaration", "Statement", "Declaration"],
            fields: {
                id: (0,
                a.validateType)("Identifier"),
                predicate: (0,
                a.validateOptionalType)("DeclaredPredicate")
            }
        }),
        l("DeclareInterface"),
        o("DeclareModule", {
            builder: ["id", "body", "kind"],
            visitor: ["id", "body"],
            aliases: ["FlowDeclaration", "Statement", "Declaration"],
            fields: {
                id: (0,
                a.validateType)(["Identifier", "StringLiteral"]),
                body: (0,
                a.validateType)("BlockStatement"),
                kind: (0,
                a.validateOptional)((0,
                a.assertOneOf)("CommonJS", "ES"))
            }
        }),
        o("DeclareModuleExports", {
            visitor: ["typeAnnotation"],
            aliases: ["FlowDeclaration", "Statement", "Declaration"],
            fields: {
                typeAnnotation: (0,
                a.validateType)("TypeAnnotation")
            }
        }),
        o("DeclareTypeAlias", {
            visitor: ["id", "typeParameters", "right"],
            aliases: ["FlowDeclaration", "Statement", "Declaration"],
            fields: {
                id: (0,
                a.validateType)("Identifier"),
                typeParameters: (0,
                a.validateOptionalType)("TypeParameterDeclaration"),
                right: (0,
                a.validateType)("FlowType")
            }
        }),
        o("DeclareOpaqueType", {
            visitor: ["id", "typeParameters", "supertype"],
            aliases: ["FlowDeclaration", "Statement", "Declaration"],
            fields: {
                id: (0,
                a.validateType)("Identifier"),
                typeParameters: (0,
                a.validateOptionalType)("TypeParameterDeclaration"),
                supertype: (0,
                a.validateOptionalType)("FlowType"),
                impltype: (0,
                a.validateOptionalType)("FlowType")
            }
        }),
        o("DeclareVariable", {
            visitor: ["id"],
            aliases: ["FlowDeclaration", "Statement", "Declaration"],
            fields: {
                id: (0,
                a.validateType)("Identifier")
            }
        }),
        o("DeclareExportDeclaration", {
            visitor: ["declaration", "specifiers", "source"],
            aliases: ["FlowDeclaration", "Statement", "Declaration"],
            fields: {
                declaration: (0,
                a.validateOptionalType)("Flow"),
                specifiers: (0,
                a.validateOptional)((0,
                a.arrayOfType)(["ExportSpecifier", "ExportNamespaceSpecifier"])),
                source: (0,
                a.validateOptionalType)("StringLiteral"),
                default: (0,
                a.validateOptional)((0,
                a.assertValueType)("boolean"))
            }
        }),
        o("DeclareExportAllDeclaration", {
            visitor: ["source"],
            aliases: ["FlowDeclaration", "Statement", "Declaration"],
            fields: {
                source: (0,
                a.validateType)("StringLiteral"),
                exportKind: (0,
                a.validateOptional)((0,
                a.assertOneOf)("type", "value"))
            }
        }),
        o("DeclaredPredicate", {
            visitor: ["value"],
            aliases: ["FlowPredicate"],
            fields: {
                value: (0,
                a.validateType)("Flow")
            }
        }),
        o("ExistsTypeAnnotation", {
            aliases: ["FlowType"]
        }),
        o("FunctionTypeAnnotation", {
            visitor: ["typeParameters", "params", "rest", "returnType"],
            aliases: ["FlowType"],
            fields: {
                typeParameters: (0,
                a.validateOptionalType)("TypeParameterDeclaration"),
                params: (0,
                a.validate)((0,
                a.arrayOfType)("FunctionTypeParam")),
                rest: (0,
                a.validateOptionalType)("FunctionTypeParam"),
                this: (0,
                a.validateOptionalType)("FunctionTypeParam"),
                returnType: (0,
                a.validateType)("FlowType")
            }
        }),
        o("FunctionTypeParam", {
            visitor: ["name", "typeAnnotation"],
            fields: {
                name: (0,
                a.validateOptionalType)("Identifier"),
                typeAnnotation: (0,
                a.validateType)("FlowType"),
                optional: (0,
                a.validateOptional)((0,
                a.assertValueType)("boolean"))
            }
        }),
        o("GenericTypeAnnotation", {
            visitor: ["id", "typeParameters"],
            aliases: ["FlowType"],
            fields: {
                id: (0,
                a.validateType)(["Identifier", "QualifiedTypeIdentifier"]),
                typeParameters: (0,
                a.validateOptionalType)("TypeParameterInstantiation")
            }
        }),
        o("InferredPredicate", {
            aliases: ["FlowPredicate"]
        }),
        o("InterfaceExtends", {
            visitor: ["id", "typeParameters"],
            fields: {
                id: (0,
                a.validateType)(["Identifier", "QualifiedTypeIdentifier"]),
                typeParameters: (0,
                a.validateOptionalType)("TypeParameterInstantiation")
            }
        }),
        l("InterfaceDeclaration"),
        o("InterfaceTypeAnnotation", {
            visitor: ["extends", "body"],
            aliases: ["FlowType"],
            fields: {
                extends: (0,
                a.validateOptional)((0,
                a.arrayOfType)("InterfaceExtends")),
                body: (0,
                a.validateType)("ObjectTypeAnnotation")
            }
        }),
        o("IntersectionTypeAnnotation", {
            visitor: ["types"],
            aliases: ["FlowType"],
            fields: {
                types: (0,
                a.validate)((0,
                a.arrayOfType)("FlowType"))
            }
        }),
        o("MixedTypeAnnotation", {
            aliases: ["FlowType", "FlowBaseAnnotation"]
        }),
        o("EmptyTypeAnnotation", {
            aliases: ["FlowType", "FlowBaseAnnotation"]
        }),
        o("NullableTypeAnnotation", {
            visitor: ["typeAnnotation"],
            aliases: ["FlowType"],
            fields: {
                typeAnnotation: (0,
                a.validateType)("FlowType")
            }
        }),
        o("NumberLiteralTypeAnnotation", {
            builder: ["value"],
            aliases: ["FlowType"],
            fields: {
                value: (0,
                a.validate)((0,
                a.assertValueType)("number"))
            }
        }),
        o("NumberTypeAnnotation", {
            aliases: ["FlowType", "FlowBaseAnnotation"]
        }),
        o("ObjectTypeAnnotation", {
            visitor: ["properties", "indexers", "callProperties", "internalSlots"],
            aliases: ["FlowType"],
            builder: ["properties", "indexers", "callProperties", "internalSlots", "exact"],
            fields: {
                properties: (0,
                a.validate)((0,
                a.arrayOfType)(["ObjectTypeProperty", "ObjectTypeSpreadProperty"])),
                indexers: (0,
                a.validateOptional)((0,
                a.arrayOfType)("ObjectTypeIndexer")),
                callProperties: (0,
                a.validateOptional)((0,
                a.arrayOfType)("ObjectTypeCallProperty")),
                internalSlots: (0,
                a.validateOptional)((0,
                a.arrayOfType)("ObjectTypeInternalSlot")),
                exact: {
                    validate: (0,
                    a.assertValueType)("boolean"),
                    default: !1
                },
                inexact: (0,
                a.validateOptional)((0,
                a.assertValueType)("boolean"))
            }
        }),
        o("ObjectTypeInternalSlot", {
            visitor: ["id", "value", "optional", "static", "method"],
            aliases: ["UserWhitespacable"],
            fields: {
                id: (0,
                a.validateType)("Identifier"),
                value: (0,
                a.validateType)("FlowType"),
                optional: (0,
                a.validate)((0,
                a.assertValueType)("boolean")),
                static: (0,
                a.validate)((0,
                a.assertValueType)("boolean")),
                method: (0,
                a.validate)((0,
                a.assertValueType)("boolean"))
            }
        }),
        o("ObjectTypeCallProperty", {
            visitor: ["value"],
            aliases: ["UserWhitespacable"],
            fields: {
                value: (0,
                a.validateType)("FlowType"),
                static: (0,
                a.validate)((0,
                a.assertValueType)("boolean"))
            }
        }),
        o("ObjectTypeIndexer", {
            visitor: ["id", "key", "value", "variance"],
            aliases: ["UserWhitespacable"],
            fields: {
                id: (0,
                a.validateOptionalType)("Identifier"),
                key: (0,
                a.validateType)("FlowType"),
                value: (0,
                a.validateType)("FlowType"),
                static: (0,
                a.validate)((0,
                a.assertValueType)("boolean")),
                variance: (0,
                a.validateOptionalType)("Variance")
            }
        }),
        o("ObjectTypeProperty", {
            visitor: ["key", "value", "variance"],
            aliases: ["UserWhitespacable"],
            fields: {
                key: (0,
                a.validateType)(["Identifier", "StringLiteral"]),
                value: (0,
                a.validateType)("FlowType"),
                kind: (0,
                a.validate)((0,
                a.assertOneOf)("init", "get", "set")),
                static: (0,
                a.validate)((0,
                a.assertValueType)("boolean")),
                proto: (0,
                a.validate)((0,
                a.assertValueType)("boolean")),
                optional: (0,
                a.validate)((0,
                a.assertValueType)("boolean")),
                variance: (0,
                a.validateOptionalType)("Variance"),
                method: (0,
                a.validate)((0,
                a.assertValueType)("boolean"))
            }
        }),
        o("ObjectTypeSpreadProperty", {
            visitor: ["argument"],
            aliases: ["UserWhitespacable"],
            fields: {
                argument: (0,
                a.validateType)("FlowType")
            }
        }),
        o("OpaqueType", {
            visitor: ["id", "typeParameters", "supertype", "impltype"],
            aliases: ["FlowDeclaration", "Statement", "Declaration"],
            fields: {
                id: (0,
                a.validateType)("Identifier"),
                typeParameters: (0,
                a.validateOptionalType)("TypeParameterDeclaration"),
                supertype: (0,
                a.validateOptionalType)("FlowType"),
                impltype: (0,
                a.validateType)("FlowType")
            }
        }),
        o("QualifiedTypeIdentifier", {
            visitor: ["id", "qualification"],
            fields: {
                id: (0,
                a.validateType)("Identifier"),
                qualification: (0,
                a.validateType)(["Identifier", "QualifiedTypeIdentifier"])
            }
        }),
        o("StringLiteralTypeAnnotation", {
            builder: ["value"],
            aliases: ["FlowType"],
            fields: {
                value: (0,
                a.validate)((0,
                a.assertValueType)("string"))
            }
        }),
        o("StringTypeAnnotation", {
            aliases: ["FlowType", "FlowBaseAnnotation"]
        }),
        o("SymbolTypeAnnotation", {
            aliases: ["FlowType", "FlowBaseAnnotation"]
        }),
        o("ThisTypeAnnotation", {
            aliases: ["FlowType", "FlowBaseAnnotation"]
        }),
        o("TupleTypeAnnotation", {
            visitor: ["types"],
            aliases: ["FlowType"],
            fields: {
                types: (0,
                a.validate)((0,
                a.arrayOfType)("FlowType"))
            }
        }),
        o("TypeofTypeAnnotation", {
            visitor: ["argument"],
            aliases: ["FlowType"],
            fields: {
                argument: (0,
                a.validateType)("FlowType")
            }
        }),
        o("TypeAlias", {
            visitor: ["id", "typeParameters", "right"],
            aliases: ["FlowDeclaration", "Statement", "Declaration"],
            fields: {
                id: (0,
                a.validateType)("Identifier"),
                typeParameters: (0,
                a.validateOptionalType)("TypeParameterDeclaration"),
                right: (0,
                a.validateType)("FlowType")
            }
        }),
        o("TypeAnnotation", {
            visitor: ["typeAnnotation"],
            fields: {
                typeAnnotation: (0,
                a.validateType)("FlowType")
            }
        }),
        o("TypeCastExpression", {
            visitor: ["expression", "typeAnnotation"],
            aliases: ["ExpressionWrapper", "Expression"],
            fields: {
                expression: (0,
                a.validateType)("Expression"),
                typeAnnotation: (0,
                a.validateType)("TypeAnnotation")
            }
        }),
        o("TypeParameter", {
            visitor: ["bound", "default", "variance"],
            fields: {
                name: (0,
                a.validate)((0,
                a.assertValueType)("string")),
                bound: (0,
                a.validateOptionalType)("TypeAnnotation"),
                default: (0,
                a.validateOptionalType)("FlowType"),
                variance: (0,
                a.validateOptionalType)("Variance")
            }
        }),
        o("TypeParameterDeclaration", {
            visitor: ["params"],
            fields: {
                params: (0,
                a.validate)((0,
                a.arrayOfType)("TypeParameter"))
            }
        }),
        o("TypeParameterInstantiation", {
            visitor: ["params"],
            fields: {
                params: (0,
                a.validate)((0,
                a.arrayOfType)("FlowType"))
            }
        }),
        o("UnionTypeAnnotation", {
            visitor: ["types"],
            aliases: ["FlowType"],
            fields: {
                types: (0,
                a.validate)((0,
                a.arrayOfType)("FlowType"))
            }
        }),
        o("Variance", {
            builder: ["kind"],
            fields: {
                kind: (0,
                a.validate)((0,
                a.assertOneOf)("minus", "plus"))
            }
        }),
        o("VoidTypeAnnotation", {
            aliases: ["FlowType", "FlowBaseAnnotation"]
        }),
        o("EnumDeclaration", {
            aliases: ["Statement", "Declaration"],
            visitor: ["id", "body"],
            fields: {
                id: (0,
                a.validateType)("Identifier"),
                body: (0,
                a.validateType)(["EnumBooleanBody", "EnumNumberBody", "EnumStringBody", "EnumSymbolBody"])
            }
        }),
        o("EnumBooleanBody", {
            aliases: ["EnumBody"],
            visitor: ["members"],
            fields: {
                explicitType: (0,
                a.validate)((0,
                a.assertValueType)("boolean")),
                members: (0,
                a.validateArrayOfType)("EnumBooleanMember"),
                hasUnknownMembers: (0,
                a.validate)((0,
                a.assertValueType)("boolean"))
            }
        }),
        o("EnumNumberBody", {
            aliases: ["EnumBody"],
            visitor: ["members"],
            fields: {
                explicitType: (0,
                a.validate)((0,
                a.assertValueType)("boolean")),
                members: (0,
                a.validateArrayOfType)("EnumNumberMember"),
                hasUnknownMembers: (0,
                a.validate)((0,
                a.assertValueType)("boolean"))
            }
        }),
        o("EnumStringBody", {
            aliases: ["EnumBody"],
            visitor: ["members"],
            fields: {
                explicitType: (0,
                a.validate)((0,
                a.assertValueType)("boolean")),
                members: (0,
                a.validateArrayOfType)(["EnumStringMember", "EnumDefaultedMember"]),
                hasUnknownMembers: (0,
                a.validate)((0,
                a.assertValueType)("boolean"))
            }
        }),
        o("EnumSymbolBody", {
            aliases: ["EnumBody"],
            visitor: ["members"],
            fields: {
                members: (0,
                a.validateArrayOfType)("EnumDefaultedMember"),
                hasUnknownMembers: (0,
                a.validate)((0,
                a.assertValueType)("boolean"))
            }
        }),
        o("EnumBooleanMember", {
            aliases: ["EnumMember"],
            visitor: ["id"],
            fields: {
                id: (0,
                a.validateType)("Identifier"),
                init: (0,
                a.validateType)("BooleanLiteral")
            }
        }),
        o("EnumNumberMember", {
            aliases: ["EnumMember"],
            visitor: ["id", "init"],
            fields: {
                id: (0,
                a.validateType)("Identifier"),
                init: (0,
                a.validateType)("NumericLiteral")
            }
        }),
        o("EnumStringMember", {
            aliases: ["EnumMember"],
            visitor: ["id", "init"],
            fields: {
                id: (0,
                a.validateType)("Identifier"),
                init: (0,
                a.validateType)("StringLiteral")
            }
        }),
        o("EnumDefaultedMember", {
            aliases: ["EnumMember"],
            visitor: ["id"],
            fields: {
                id: (0,
                a.validateType)("Identifier")
            }
        }),
        o("IndexedAccessType", {
            visitor: ["objectType", "indexType"],
            aliases: ["FlowType"],
            fields: {
                objectType: (0,
                a.validateType)("FlowType"),
                indexType: (0,
                a.validateType)("FlowType")
            }
        }),
        o("OptionalIndexedAccessType", {
            visitor: ["objectType", "indexType"],
            aliases: ["FlowType"],
            fields: {
                objectType: (0,
                a.validateType)("FlowType"),
                indexType: (0,
                a.validateType)("FlowType"),
                optional: (0,
                a.validate)((0,
                a.assertValueType)("boolean"))
            }
        })
    },
    dtFd: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function toBlock(t, r) {
            if ((0,
            a.isBlockStatement)(t))
                return t;
            var i = [];
            (0,
            a.isEmptyStatement)(t) ? i = [] : ((0,
            a.isStatement)(t) || (t = (0,
            a.isFunction)(r) ? (0,
            o.returnStatement)(t) : (0,
            o.expressionStatement)(t)),
            i = [t]);
            return (0,
            o.blockStatement)(i)
        }
        ;
        var a = i("FUES")
          , o = i("57mi")
    },
    e5Hd: function(t, r, i) {
        "use strict";
        t.exports = function(t, r, i) {
            if (r.length) {
                var a = r[0]
                  , o = r[r.length - 1];
                if (i.length) {
                    if (a.start < i[0].start) {
                        var l = i[0];
                        if (t.body.length) {
                            var u = t.body[0];
                            u.leadingComments = [];
                            for (var p = l.start, c = r.length, d = 0; d < c && r[d].start < p; d++)
                                u.leadingComments.push(r[d])
                        }
                    }
                } else
                    t.start = o.end,
                    t.loc.start.line = o.loc.end.line,
                    t.loc.start.column = o.loc.end.column,
                    null === t.leadingComments && t.innerComments.length && (t.leadingComments = t.innerComments);
                if (i.length) {
                    var y = i[i.length - 1];
                    o.end > y.end && (t.range[1] = y.end,
                    t.loc.end.line = y.loc.end.line,
                    t.loc.end.column = y.loc.end.column)
                }
            } else
                i.length || (t.loc.start.line = 1,
                t.loc.end.line = 1);
            t.body && t.body.length > 0 && (t.loc.start.line = t.body[0].loc.start.line,
            t.range[0] = t.body[0].start)
        }
    },
    "e9y/": function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.CodeGenerator = void 0,
        r.default = function generate(t, r, i) {
            return new Generator(t,r,i).generate()
        }
        ;
        var a = i("m+63")
          , o = i("TuKl");
        class Generator extends o.default {
            constructor(t, r={}, i) {
                super(function normalizeOptions(t, r) {
                    const i = {
                        auxiliaryCommentBefore: r.auxiliaryCommentBefore,
                        auxiliaryCommentAfter: r.auxiliaryCommentAfter,
                        shouldPrintComment: r.shouldPrintComment,
                        retainLines: r.retainLines,
                        retainFunctionParens: r.retainFunctionParens,
                        comments: null == r.comments || r.comments,
                        compact: r.compact,
                        minified: r.minified,
                        concise: r.concise,
                        indent: {
                            adjustMultilineComment: !0,
                            style: "  ",
                            base: 0
                        },
                        decoratorsBeforeExport: !!r.decoratorsBeforeExport,
                        jsescOption: Object.assign({
                            quotes: "double",
                            wrap: !0,
                            minimal: !1
                        }, r.jsescOption),
                        recordAndTupleSyntaxType: r.recordAndTupleSyntaxType,
                        topicToken: r.topicToken
                    };
                    i.jsonCompatibleStrings = r.jsonCompatibleStrings,
                    i.minified ? (i.compact = !0,
                    i.shouldPrintComment = i.shouldPrintComment || (()=>i.comments)) : i.shouldPrintComment = i.shouldPrintComment || (t=>i.comments || t.indexOf("@license") >= 0 || t.indexOf("@preserve") >= 0);
                    "auto" === i.compact && (i.compact = t.length > 5e5,
                    i.compact && console.error("[BABEL] Note: The code generator has deoptimised the styling of " + r.filename + " as it exceeds the max of 500KB."));
                    i.compact && (i.indent.adjustMultilineComment = !1);
                    return i
                }(i, r), r.sourceMaps ? new a.default(r,i) : null),
                this.ast = void 0,
                this.ast = t
            }
            generate() {
                return super.generate(this.ast)
            }
        }
        r.CodeGenerator = class CodeGenerator {
            constructor(t, r, i) {
                this._generator = void 0,
                this._generator = new Generator(t,r,i)
            }
            generate() {
                return this._generator.generate()
            }
        }
    },
    f0nW: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.hooks = void 0;
        r.hooks = [function(t, r) {
            if ("test" === t.key && (r.isWhile() || r.isSwitchCase()) || "declaration" === t.key && r.isExportDeclaration() || "body" === t.key && r.isLabeledStatement() || "declarations" === t.listKey && r.isVariableDeclaration() && 1 === r.node.declarations.length || "expression" === t.key && r.isExpressionStatement())
                return r.remove(),
                !0
        }
        , function(t, r) {
            if (r.isSequenceExpression() && 1 === r.node.expressions.length)
                return r.replaceWith(r.node.expressions[0]),
                !0
        }
        , function(t, r) {
            if (r.isBinary())
                return "left" === t.key ? r.replaceWith(r.node.right) : r.replaceWith(r.node.left),
                !0
        }
        , function(t, r) {
            if (r.isIfStatement() && ("consequent" === t.key || "alternate" === t.key) || "body" === t.key && (r.isLoop() || r.isArrowFunctionExpression()))
                return t.replaceWith({
                    type: "BlockStatement",
                    body: []
                }),
                !0
        }
        ]
    },
    fJha: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function literalTemplate(t, r, i) {
            const {metadata: u, names: p} = function buildLiteralData(t, r, i) {
                let a, l, u, p = "";
                do {
                    p += "$";
                    const c = buildTemplateCode(r, p);
                    a = c.names,
                    l = new Set(a),
                    u = (0,
                    o.default)(t, t.code(c.code), {
                        parser: i.parser,
                        placeholderWhitelist: new Set(c.names.concat(i.placeholderWhitelist ? Array.from(i.placeholderWhitelist) : [])),
                        placeholderPattern: i.placeholderPattern,
                        preserveComments: i.preserveComments,
                        syntacticPlaceholders: i.syntacticPlaceholders
                    })
                } while (u.placeholders.some(t=>t.isDuplicate && l.has(t.name)));
                return {
                    metadata: u,
                    names: a
                }
            }(t, r, i);
            return r=>{
                const i = {};
                return r.forEach((t,r)=>{
                    i[p[r]] = t
                }
                ),
                r=>{
                    const o = (0,
                    a.normalizeReplacements)(r);
                    return o && Object.keys(o).forEach(t=>{
                        if (Object.prototype.hasOwnProperty.call(i, t))
                            throw new Error("Unexpected replacement overlap.")
                    }
                    ),
                    t.unwrap((0,
                    l.default)(u, o ? Object.assign(o, i) : i))
                }
            }
        }
        ;
        var a = i("+zpO")
          , o = i("kSM9")
          , l = i("wOpn");
        function buildTemplateCode(t, r) {
            const i = [];
            let a = t[0];
            for (let o = 1; o < t.length; o++) {
                const l = `${r}${o - 1}`;
                i.push(l),
                a += l + t[o]
            }
            return {
                names: i,
                code: a
            }
        }
    },
    fivu: function(t, r, i) {
        "use strict";
        (function(t) {
            var r = i("aaMo");
            (0,
            r.default)("ArgumentPlaceholder", {}),
            (0,
            r.default)("BindExpression", {
                visitor: ["object", "callee"],
                aliases: ["Expression"],
                fields: t.env.BABEL_TYPES_8_BREAKING ? {
                    object: {
                        validate: (0,
                        r.assertNodeType)("Expression")
                    },
                    callee: {
                        validate: (0,
                        r.assertNodeType)("Expression")
                    }
                } : {
                    object: {
                        validate: Object.assign((function() {}
                        ), {
                            oneOfNodeTypes: ["Expression"]
                        })
                    },
                    callee: {
                        validate: Object.assign((function() {}
                        ), {
                            oneOfNodeTypes: ["Expression"]
                        })
                    }
                }
            }),
            (0,
            r.default)("ImportAttribute", {
                visitor: ["key", "value"],
                fields: {
                    key: {
                        validate: (0,
                        r.assertNodeType)("Identifier", "StringLiteral")
                    },
                    value: {
                        validate: (0,
                        r.assertNodeType)("StringLiteral")
                    }
                }
            }),
            (0,
            r.default)("Decorator", {
                visitor: ["expression"],
                fields: {
                    expression: {
                        validate: (0,
                        r.assertNodeType)("Expression")
                    }
                }
            }),
            (0,
            r.default)("DoExpression", {
                visitor: ["body"],
                builder: ["body", "async"],
                aliases: ["Expression"],
                fields: {
                    body: {
                        validate: (0,
                        r.assertNodeType)("BlockStatement")
                    },
                    async: {
                        validate: (0,
                        r.assertValueType)("boolean"),
                        default: !1
                    }
                }
            }),
            (0,
            r.default)("ExportDefaultSpecifier", {
                visitor: ["exported"],
                aliases: ["ModuleSpecifier"],
                fields: {
                    exported: {
                        validate: (0,
                        r.assertNodeType)("Identifier")
                    }
                }
            }),
            (0,
            r.default)("RecordExpression", {
                visitor: ["properties"],
                aliases: ["Expression"],
                fields: {
                    properties: {
                        validate: (0,
                        r.chain)((0,
                        r.assertValueType)("array"), (0,
                        r.assertEach)((0,
                        r.assertNodeType)("ObjectProperty", "SpreadElement")))
                    }
                }
            }),
            (0,
            r.default)("TupleExpression", {
                fields: {
                    elements: {
                        validate: (0,
                        r.chain)((0,
                        r.assertValueType)("array"), (0,
                        r.assertEach)((0,
                        r.assertNodeType)("Expression", "SpreadElement"))),
                        default: []
                    }
                },
                visitor: ["elements"],
                aliases: ["Expression"]
            }),
            (0,
            r.default)("DecimalLiteral", {
                builder: ["value"],
                fields: {
                    value: {
                        validate: (0,
                        r.assertValueType)("string")
                    }
                },
                aliases: ["Expression", "Pureish", "Literal", "Immutable"]
            }),
            (0,
            r.default)("ModuleExpression", {
                visitor: ["body"],
                fields: {
                    body: {
                        validate: (0,
                        r.assertNodeType)("Program")
                    }
                },
                aliases: ["Expression"]
            }),
            (0,
            r.default)("TopicReference", {
                aliases: ["Expression"]
            }),
            (0,
            r.default)("PipelineTopicExpression", {
                builder: ["expression"],
                visitor: ["expression"],
                fields: {
                    expression: {
                        validate: (0,
                        r.assertNodeType)("Expression")
                    }
                },
                aliases: ["Expression"]
            }),
            (0,
            r.default)("PipelineBareFunction", {
                builder: ["callee"],
                visitor: ["callee"],
                fields: {
                    callee: {
                        validate: (0,
                        r.assertNodeType)("Expression")
                    }
                },
                aliases: ["Expression"]
            }),
            (0,
            r.default)("PipelinePrimaryTopicReference", {
                aliases: ["Expression"]
            })
        }
        ).call(this, i("8oxB"))
    },
    fkdI: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function inheritInnerComments(t, r) {
            (0,
            a.default)("innerComments", t, r)
        }
        ;
        var a = i("ExWc")
    },
    fwxm: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function toBlock(t, r) {
            if ((0,
            a.isBlockStatement)(t))
                return t;
            let i = [];
            (0,
            a.isEmptyStatement)(t) ? i = [] : ((0,
            a.isStatement)(t) || (t = (0,
            a.isFunction)(r) ? (0,
            o.returnStatement)(t) : (0,
            o.expressionStatement)(t)),
            i = [t]);
            return (0,
            o.blockStatement)(i)
        }
        ;
        var a = i("xIU+")
          , o = i("61uC")
    },
    gEKJ: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function appendToMemberExpression(t, r, i=!1) {
            return t.object = (0,
            a.memberExpression)(t.object, t.property, t.computed),
            t.property = r,
            t.computed = !!i,
            t
        }
        ;
        var a = i("61uC")
    },
    gL1R: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = void 0;
        var a = i("FUES")
          , o = function toExpression(t) {
            (0,
            a.isExpressionStatement)(t) && (t = t.expression);
            if ((0,
            a.isExpression)(t))
                return t;
            (0,
            a.isClass)(t) ? t.type = "ClassExpression" : (0,
            a.isFunction)(t) && (t.type = "FunctionExpression");
            if (!(0,
            a.isExpression)(t))
                throw new Error("cannot turn ".concat(t.type, " to an expression"));
            return t
        };
        r.default = o
    },
    hsUc: function(t, r, i) {
        "use strict";
        var a = i("TqRt")(i("cDf5"))
          , o = i("9lTW")
          , l = i("jf/V")
          , u = i("V+V6")
          , p = i("SCtg")
          , c = i("dYsE")
          , d = i("GlVh").Scope
          , y = i("HG/J").version;
        t.exports = {
            version: y,
            Reference: p,
            Variable: c,
            Scope: d,
            ScopeManager: l,
            analyze: function analyze(t, r) {
                var i = function updateDeeply(t, r) {
                    function isHashObject(t) {
                        return "object" === (0,
                        a.default)(t) && t instanceof Object && !(t instanceof Array) && !(t instanceof RegExp)
                    }
                    for (var i in r)
                        if (r.hasOwnProperty(i)) {
                            var o = r[i];
                            isHashObject(o) ? isHashObject(t[i]) ? updateDeeply(t[i], o) : t[i] = updateDeeply({}, o) : t[i] = o
                        }
                    return t
                }({
                    optimistic: !1,
                    directive: !1,
                    nodejsScope: !1,
                    impliedStrict: !1,
                    sourceType: "script",
                    ecmaVersion: 5,
                    childVisitorKeys: null,
                    fallback: "iteration"
                }, r)
                  , p = new l(i);
                return new u(i,p).visit(t),
                o(null === p.__currentScope, "currentScope should be null."),
                p
            }
        }
    },
    "i+xC": function(t) {
        t.exports = JSON.parse('{"name":"esrecurse","description":"ECMAScript AST recursive visitor","homepage":"https://github.com/estools/esrecurse","main":"esrecurse.js","version":"4.3.0","engines":{"node":">=4.0"},"maintainers":[{"name":"Yusuke Suzuki","email":"utatane.tea@gmail.com","web":"https://github.com/Constellation"}],"repository":{"type":"git","url":"https://github.com/estools/esrecurse.git"},"dependencies":{"estraverse":"^5.2.0"},"devDependencies":{"babel-cli":"^6.24.1","babel-eslint":"^7.2.3","babel-preset-es2015":"^6.24.1","babel-register":"^6.24.1","chai":"^4.0.2","esprima":"^4.0.0","gulp":"^3.9.0","gulp-bump":"^2.7.0","gulp-eslint":"^4.0.0","gulp-filter":"^5.0.0","gulp-git":"^2.4.1","gulp-mocha":"^4.3.1","gulp-tag-version":"^1.2.1","jsdoc":"^3.3.0-alpha10","minimist":"^1.1.0"},"license":"BSD-2-Clause","scripts":{"test":"gulp travis","unit-test":"gulp test","lint":"gulp lint"},"babel":{"presets":["es2015"]}}')
    },
    "i0Q+": function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function isScope(t, r) {
            if ((0,
            a.isBlockStatement)(t) && ((0,
            a.isFunction)(r) || (0,
            a.isCatchClause)(r)))
                return !1;
            if ((0,
            a.isPattern)(t) && ((0,
            a.isFunction)(r) || (0,
            a.isCatchClause)(r)))
                return !0;
            return (0,
            a.isScopable)(t)
        }
        ;
        var a = i("xIU+")
    },
    i2G0: function(t, r, i) {
        "use strict";
        var a = i("V97+");
        const o = (0,
        a.defineAliasedType)("Flow")
          , defineInterfaceishType = (t,r="TypeParameterDeclaration")=>{
            o(t, {
                builder: ["id", "typeParameters", "extends", "body"],
                visitor: ["id", "typeParameters", "extends", "mixins", "implements", "body"],
                aliases: ["FlowDeclaration", "Statement", "Declaration"],
                fields: {
                    id: (0,
                    a.validateType)("Identifier"),
                    typeParameters: (0,
                    a.validateOptionalType)(r),
                    extends: (0,
                    a.validateOptional)((0,
                    a.arrayOfType)("InterfaceExtends")),
                    mixins: (0,
                    a.validateOptional)((0,
                    a.arrayOfType)("InterfaceExtends")),
                    implements: (0,
                    a.validateOptional)((0,
                    a.arrayOfType)("ClassImplements")),
                    body: (0,
                    a.validateType)("ObjectTypeAnnotation")
                }
            })
        }
        ;
        o("AnyTypeAnnotation", {
            aliases: ["FlowType", "FlowBaseAnnotation"]
        }),
        o("ArrayTypeAnnotation", {
            visitor: ["elementType"],
            aliases: ["FlowType"],
            fields: {
                elementType: (0,
                a.validateType)("FlowType")
            }
        }),
        o("BooleanTypeAnnotation", {
            aliases: ["FlowType", "FlowBaseAnnotation"]
        }),
        o("BooleanLiteralTypeAnnotation", {
            builder: ["value"],
            aliases: ["FlowType"],
            fields: {
                value: (0,
                a.validate)((0,
                a.assertValueType)("boolean"))
            }
        }),
        o("NullLiteralTypeAnnotation", {
            aliases: ["FlowType", "FlowBaseAnnotation"]
        }),
        o("ClassImplements", {
            visitor: ["id", "typeParameters"],
            fields: {
                id: (0,
                a.validateType)("Identifier"),
                typeParameters: (0,
                a.validateOptionalType)("TypeParameterInstantiation")
            }
        }),
        defineInterfaceishType("DeclareClass"),
        o("DeclareFunction", {
            visitor: ["id"],
            aliases: ["FlowDeclaration", "Statement", "Declaration"],
            fields: {
                id: (0,
                a.validateType)("Identifier"),
                predicate: (0,
                a.validateOptionalType)("DeclaredPredicate")
            }
        }),
        defineInterfaceishType("DeclareInterface"),
        o("DeclareModule", {
            builder: ["id", "body", "kind"],
            visitor: ["id", "body"],
            aliases: ["FlowDeclaration", "Statement", "Declaration"],
            fields: {
                id: (0,
                a.validateType)(["Identifier", "StringLiteral"]),
                body: (0,
                a.validateType)("BlockStatement"),
                kind: (0,
                a.validateOptional)((0,
                a.assertOneOf)("CommonJS", "ES"))
            }
        }),
        o("DeclareModuleExports", {
            visitor: ["typeAnnotation"],
            aliases: ["FlowDeclaration", "Statement", "Declaration"],
            fields: {
                typeAnnotation: (0,
                a.validateType)("TypeAnnotation")
            }
        }),
        o("DeclareTypeAlias", {
            visitor: ["id", "typeParameters", "right"],
            aliases: ["FlowDeclaration", "Statement", "Declaration"],
            fields: {
                id: (0,
                a.validateType)("Identifier"),
                typeParameters: (0,
                a.validateOptionalType)("TypeParameterDeclaration"),
                right: (0,
                a.validateType)("FlowType")
            }
        }),
        o("DeclareOpaqueType", {
            visitor: ["id", "typeParameters", "supertype"],
            aliases: ["FlowDeclaration", "Statement", "Declaration"],
            fields: {
                id: (0,
                a.validateType)("Identifier"),
                typeParameters: (0,
                a.validateOptionalType)("TypeParameterDeclaration"),
                supertype: (0,
                a.validateOptionalType)("FlowType"),
                impltype: (0,
                a.validateOptionalType)("FlowType")
            }
        }),
        o("DeclareVariable", {
            visitor: ["id"],
            aliases: ["FlowDeclaration", "Statement", "Declaration"],
            fields: {
                id: (0,
                a.validateType)("Identifier")
            }
        }),
        o("DeclareExportDeclaration", {
            visitor: ["declaration", "specifiers", "source"],
            aliases: ["FlowDeclaration", "Statement", "Declaration"],
            fields: {
                declaration: (0,
                a.validateOptionalType)("Flow"),
                specifiers: (0,
                a.validateOptional)((0,
                a.arrayOfType)(["ExportSpecifier", "ExportNamespaceSpecifier"])),
                source: (0,
                a.validateOptionalType)("StringLiteral"),
                default: (0,
                a.validateOptional)((0,
                a.assertValueType)("boolean"))
            }
        }),
        o("DeclareExportAllDeclaration", {
            visitor: ["source"],
            aliases: ["FlowDeclaration", "Statement", "Declaration"],
            fields: {
                source: (0,
                a.validateType)("StringLiteral"),
                exportKind: (0,
                a.validateOptional)((0,
                a.assertOneOf)("type", "value"))
            }
        }),
        o("DeclaredPredicate", {
            visitor: ["value"],
            aliases: ["FlowPredicate"],
            fields: {
                value: (0,
                a.validateType)("Flow")
            }
        }),
        o("ExistsTypeAnnotation", {
            aliases: ["FlowType"]
        }),
        o("FunctionTypeAnnotation", {
            visitor: ["typeParameters", "params", "rest", "returnType"],
            aliases: ["FlowType"],
            fields: {
                typeParameters: (0,
                a.validateOptionalType)("TypeParameterDeclaration"),
                params: (0,
                a.validate)((0,
                a.arrayOfType)("FunctionTypeParam")),
                rest: (0,
                a.validateOptionalType)("FunctionTypeParam"),
                this: (0,
                a.validateOptionalType)("FunctionTypeParam"),
                returnType: (0,
                a.validateType)("FlowType")
            }
        }),
        o("FunctionTypeParam", {
            visitor: ["name", "typeAnnotation"],
            fields: {
                name: (0,
                a.validateOptionalType)("Identifier"),
                typeAnnotation: (0,
                a.validateType)("FlowType"),
                optional: (0,
                a.validateOptional)((0,
                a.assertValueType)("boolean"))
            }
        }),
        o("GenericTypeAnnotation", {
            visitor: ["id", "typeParameters"],
            aliases: ["FlowType"],
            fields: {
                id: (0,
                a.validateType)(["Identifier", "QualifiedTypeIdentifier"]),
                typeParameters: (0,
                a.validateOptionalType)("TypeParameterInstantiation")
            }
        }),
        o("InferredPredicate", {
            aliases: ["FlowPredicate"]
        }),
        o("InterfaceExtends", {
            visitor: ["id", "typeParameters"],
            fields: {
                id: (0,
                a.validateType)(["Identifier", "QualifiedTypeIdentifier"]),
                typeParameters: (0,
                a.validateOptionalType)("TypeParameterInstantiation")
            }
        }),
        defineInterfaceishType("InterfaceDeclaration"),
        o("InterfaceTypeAnnotation", {
            visitor: ["extends", "body"],
            aliases: ["FlowType"],
            fields: {
                extends: (0,
                a.validateOptional)((0,
                a.arrayOfType)("InterfaceExtends")),
                body: (0,
                a.validateType)("ObjectTypeAnnotation")
            }
        }),
        o("IntersectionTypeAnnotation", {
            visitor: ["types"],
            aliases: ["FlowType"],
            fields: {
                types: (0,
                a.validate)((0,
                a.arrayOfType)("FlowType"))
            }
        }),
        o("MixedTypeAnnotation", {
            aliases: ["FlowType", "FlowBaseAnnotation"]
        }),
        o("EmptyTypeAnnotation", {
            aliases: ["FlowType", "FlowBaseAnnotation"]
        }),
        o("NullableTypeAnnotation", {
            visitor: ["typeAnnotation"],
            aliases: ["FlowType"],
            fields: {
                typeAnnotation: (0,
                a.validateType)("FlowType")
            }
        }),
        o("NumberLiteralTypeAnnotation", {
            builder: ["value"],
            aliases: ["FlowType"],
            fields: {
                value: (0,
                a.validate)((0,
                a.assertValueType)("number"))
            }
        }),
        o("NumberTypeAnnotation", {
            aliases: ["FlowType", "FlowBaseAnnotation"]
        }),
        o("ObjectTypeAnnotation", {
            visitor: ["properties", "indexers", "callProperties", "internalSlots"],
            aliases: ["FlowType"],
            builder: ["properties", "indexers", "callProperties", "internalSlots", "exact"],
            fields: {
                properties: (0,
                a.validate)((0,
                a.arrayOfType)(["ObjectTypeProperty", "ObjectTypeSpreadProperty"])),
                indexers: (0,
                a.validateOptional)((0,
                a.arrayOfType)("ObjectTypeIndexer")),
                callProperties: (0,
                a.validateOptional)((0,
                a.arrayOfType)("ObjectTypeCallProperty")),
                internalSlots: (0,
                a.validateOptional)((0,
                a.arrayOfType)("ObjectTypeInternalSlot")),
                exact: {
                    validate: (0,
                    a.assertValueType)("boolean"),
                    default: !1
                },
                inexact: (0,
                a.validateOptional)((0,
                a.assertValueType)("boolean"))
            }
        }),
        o("ObjectTypeInternalSlot", {
            visitor: ["id", "value", "optional", "static", "method"],
            aliases: ["UserWhitespacable"],
            fields: {
                id: (0,
                a.validateType)("Identifier"),
                value: (0,
                a.validateType)("FlowType"),
                optional: (0,
                a.validate)((0,
                a.assertValueType)("boolean")),
                static: (0,
                a.validate)((0,
                a.assertValueType)("boolean")),
                method: (0,
                a.validate)((0,
                a.assertValueType)("boolean"))
            }
        }),
        o("ObjectTypeCallProperty", {
            visitor: ["value"],
            aliases: ["UserWhitespacable"],
            fields: {
                value: (0,
                a.validateType)("FlowType"),
                static: (0,
                a.validate)((0,
                a.assertValueType)("boolean"))
            }
        }),
        o("ObjectTypeIndexer", {
            visitor: ["id", "key", "value", "variance"],
            aliases: ["UserWhitespacable"],
            fields: {
                id: (0,
                a.validateOptionalType)("Identifier"),
                key: (0,
                a.validateType)("FlowType"),
                value: (0,
                a.validateType)("FlowType"),
                static: (0,
                a.validate)((0,
                a.assertValueType)("boolean")),
                variance: (0,
                a.validateOptionalType)("Variance")
            }
        }),
        o("ObjectTypeProperty", {
            visitor: ["key", "value", "variance"],
            aliases: ["UserWhitespacable"],
            fields: {
                key: (0,
                a.validateType)(["Identifier", "StringLiteral"]),
                value: (0,
                a.validateType)("FlowType"),
                kind: (0,
                a.validate)((0,
                a.assertOneOf)("init", "get", "set")),
                static: (0,
                a.validate)((0,
                a.assertValueType)("boolean")),
                proto: (0,
                a.validate)((0,
                a.assertValueType)("boolean")),
                optional: (0,
                a.validate)((0,
                a.assertValueType)("boolean")),
                variance: (0,
                a.validateOptionalType)("Variance"),
                method: (0,
                a.validate)((0,
                a.assertValueType)("boolean"))
            }
        }),
        o("ObjectTypeSpreadProperty", {
            visitor: ["argument"],
            aliases: ["UserWhitespacable"],
            fields: {
                argument: (0,
                a.validateType)("FlowType")
            }
        }),
        o("OpaqueType", {
            visitor: ["id", "typeParameters", "supertype", "impltype"],
            aliases: ["FlowDeclaration", "Statement", "Declaration"],
            fields: {
                id: (0,
                a.validateType)("Identifier"),
                typeParameters: (0,
                a.validateOptionalType)("TypeParameterDeclaration"),
                supertype: (0,
                a.validateOptionalType)("FlowType"),
                impltype: (0,
                a.validateType)("FlowType")
            }
        }),
        o("QualifiedTypeIdentifier", {
            visitor: ["id", "qualification"],
            fields: {
                id: (0,
                a.validateType)("Identifier"),
                qualification: (0,
                a.validateType)(["Identifier", "QualifiedTypeIdentifier"])
            }
        }),
        o("StringLiteralTypeAnnotation", {
            builder: ["value"],
            aliases: ["FlowType"],
            fields: {
                value: (0,
                a.validate)((0,
                a.assertValueType)("string"))
            }
        }),
        o("StringTypeAnnotation", {
            aliases: ["FlowType", "FlowBaseAnnotation"]
        }),
        o("SymbolTypeAnnotation", {
            aliases: ["FlowType", "FlowBaseAnnotation"]
        }),
        o("ThisTypeAnnotation", {
            aliases: ["FlowType", "FlowBaseAnnotation"]
        }),
        o("TupleTypeAnnotation", {
            visitor: ["types"],
            aliases: ["FlowType"],
            fields: {
                types: (0,
                a.validate)((0,
                a.arrayOfType)("FlowType"))
            }
        }),
        o("TypeofTypeAnnotation", {
            visitor: ["argument"],
            aliases: ["FlowType"],
            fields: {
                argument: (0,
                a.validateType)("FlowType")
            }
        }),
        o("TypeAlias", {
            visitor: ["id", "typeParameters", "right"],
            aliases: ["FlowDeclaration", "Statement", "Declaration"],
            fields: {
                id: (0,
                a.validateType)("Identifier"),
                typeParameters: (0,
                a.validateOptionalType)("TypeParameterDeclaration"),
                right: (0,
                a.validateType)("FlowType")
            }
        }),
        o("TypeAnnotation", {
            visitor: ["typeAnnotation"],
            fields: {
                typeAnnotation: (0,
                a.validateType)("FlowType")
            }
        }),
        o("TypeCastExpression", {
            visitor: ["expression", "typeAnnotation"],
            aliases: ["ExpressionWrapper", "Expression"],
            fields: {
                expression: (0,
                a.validateType)("Expression"),
                typeAnnotation: (0,
                a.validateType)("TypeAnnotation")
            }
        }),
        o("TypeParameter", {
            visitor: ["bound", "default", "variance"],
            fields: {
                name: (0,
                a.validate)((0,
                a.assertValueType)("string")),
                bound: (0,
                a.validateOptionalType)("TypeAnnotation"),
                default: (0,
                a.validateOptionalType)("FlowType"),
                variance: (0,
                a.validateOptionalType)("Variance")
            }
        }),
        o("TypeParameterDeclaration", {
            visitor: ["params"],
            fields: {
                params: (0,
                a.validate)((0,
                a.arrayOfType)("TypeParameter"))
            }
        }),
        o("TypeParameterInstantiation", {
            visitor: ["params"],
            fields: {
                params: (0,
                a.validate)((0,
                a.arrayOfType)("FlowType"))
            }
        }),
        o("UnionTypeAnnotation", {
            visitor: ["types"],
            aliases: ["FlowType"],
            fields: {
                types: (0,
                a.validate)((0,
                a.arrayOfType)("FlowType"))
            }
        }),
        o("Variance", {
            builder: ["kind"],
            fields: {
                kind: (0,
                a.validate)((0,
                a.assertOneOf)("minus", "plus"))
            }
        }),
        o("VoidTypeAnnotation", {
            aliases: ["FlowType", "FlowBaseAnnotation"]
        }),
        o("EnumDeclaration", {
            aliases: ["Statement", "Declaration"],
            visitor: ["id", "body"],
            fields: {
                id: (0,
                a.validateType)("Identifier"),
                body: (0,
                a.validateType)(["EnumBooleanBody", "EnumNumberBody", "EnumStringBody", "EnumSymbolBody"])
            }
        }),
        o("EnumBooleanBody", {
            aliases: ["EnumBody"],
            visitor: ["members"],
            fields: {
                explicitType: (0,
                a.validate)((0,
                a.assertValueType)("boolean")),
                members: (0,
                a.validateArrayOfType)("EnumBooleanMember"),
                hasUnknownMembers: (0,
                a.validate)((0,
                a.assertValueType)("boolean"))
            }
        }),
        o("EnumNumberBody", {
            aliases: ["EnumBody"],
            visitor: ["members"],
            fields: {
                explicitType: (0,
                a.validate)((0,
                a.assertValueType)("boolean")),
                members: (0,
                a.validateArrayOfType)("EnumNumberMember"),
                hasUnknownMembers: (0,
                a.validate)((0,
                a.assertValueType)("boolean"))
            }
        }),
        o("EnumStringBody", {
            aliases: ["EnumBody"],
            visitor: ["members"],
            fields: {
                explicitType: (0,
                a.validate)((0,
                a.assertValueType)("boolean")),
                members: (0,
                a.validateArrayOfType)(["EnumStringMember", "EnumDefaultedMember"]),
                hasUnknownMembers: (0,
                a.validate)((0,
                a.assertValueType)("boolean"))
            }
        }),
        o("EnumSymbolBody", {
            aliases: ["EnumBody"],
            visitor: ["members"],
            fields: {
                members: (0,
                a.validateArrayOfType)("EnumDefaultedMember"),
                hasUnknownMembers: (0,
                a.validate)((0,
                a.assertValueType)("boolean"))
            }
        }),
        o("EnumBooleanMember", {
            aliases: ["EnumMember"],
            visitor: ["id"],
            fields: {
                id: (0,
                a.validateType)("Identifier"),
                init: (0,
                a.validateType)("BooleanLiteral")
            }
        }),
        o("EnumNumberMember", {
            aliases: ["EnumMember"],
            visitor: ["id", "init"],
            fields: {
                id: (0,
                a.validateType)("Identifier"),
                init: (0,
                a.validateType)("NumericLiteral")
            }
        }),
        o("EnumStringMember", {
            aliases: ["EnumMember"],
            visitor: ["id", "init"],
            fields: {
                id: (0,
                a.validateType)("Identifier"),
                init: (0,
                a.validateType)("StringLiteral")
            }
        }),
        o("EnumDefaultedMember", {
            aliases: ["EnumMember"],
            visitor: ["id"],
            fields: {
                id: (0,
                a.validateType)("Identifier")
            }
        }),
        o("IndexedAccessType", {
            visitor: ["objectType", "indexType"],
            aliases: ["FlowType"],
            fields: {
                objectType: (0,
                a.validateType)("FlowType"),
                indexType: (0,
                a.validateType)("FlowType")
            }
        }),
        o("OptionalIndexedAccessType", {
            visitor: ["objectType", "indexType"],
            aliases: ["FlowType"],
            fields: {
                objectType: (0,
                a.validateType)("FlowType"),
                indexType: (0,
                a.validateType)("FlowType"),
                optional: (0,
                a.validate)((0,
                a.assertValueType)("boolean"))
            }
        })
    },
    iBAI: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function isBlockScoped(t) {
            return (0,
            a.isFunctionDeclaration)(t) || (0,
            a.isClassDeclaration)(t) || (0,
            o.default)(t)
        }
        ;
        var a = i("xIU+")
          , o = i("wQ14")
    },
    iff2: function(t, r, i) {
        "use strict";
        function _createForOfIteratorHelper(t, r) {
            var i = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
            if (!i) {
                if (Array.isArray(t) || (i = function _unsupportedIterableToArray(t, r) {
                    if (!t)
                        return;
                    if ("string" == typeof t)
                        return _arrayLikeToArray(t, r);
                    var i = Object.prototype.toString.call(t).slice(8, -1);
                    "Object" === i && t.constructor && (i = t.constructor.name);
                    if ("Map" === i || "Set" === i)
                        return Array.from(t);
                    if ("Arguments" === i || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i))
                        return _arrayLikeToArray(t, r)
                }(t)) || r && t && "number" == typeof t.length) {
                    i && (t = i);
                    var a = 0
                      , o = function F() {};
                    return {
                        s: o,
                        n: function n() {
                            return a >= t.length ? {
                                done: !0
                            } : {
                                done: !1,
                                value: t[a++]
                            }
                        },
                        e: function e(t) {
                            throw t
                        },
                        f: o
                    }
                }
                throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
            }
            var l, u = !0, p = !1;
            return {
                s: function s() {
                    i = i.call(t)
                },
                n: function n() {
                    var t = i.next();
                    return u = t.done,
                    t
                },
                e: function e(t) {
                    p = !0,
                    l = t
                },
                f: function f() {
                    try {
                        u || null == i.return || i.return()
                    } finally {
                        if (p)
                            throw l
                    }
                }
            }
        }
        function _arrayLikeToArray(t, r) {
            (null == r || r > t.length) && (r = t.length);
            for (var i = 0, a = new Array(r); i < r; i++)
                a[i] = t[i];
            return a
        }
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function traverse(t, r, i) {
            "function" == typeof r && (r = {
                enter: r
            });
            var o = r
              , l = o.enter
              , u = o.exit;
            !function traverseSimpleImpl(t, r, i, o, l) {
                var u = a.VISITOR_KEYS[t.type];
                if (!u)
                    return;
                r && r(t, l, o);
                var p, c = _createForOfIteratorHelper(u);
                try {
                    for (c.s(); !(p = c.n()).done; ) {
                        var d = p.value
                          , y = t[d];
                        if (Array.isArray(y))
                            for (var h = 0; h < y.length; h++) {
                                var m = y[h];
                                m && (l.push({
                                    node: t,
                                    key: d,
                                    index: h
                                }),
                                traverseSimpleImpl(m, r, i, o, l),
                                l.pop())
                            }
                        else
                            y && (l.push({
                                node: t,
                                key: d
                            }),
                            traverseSimpleImpl(y, r, i, o, l),
                            l.pop())
                    }
                } catch (t) {
                    c.e(t)
                } finally {
                    c.f()
                }
                i && i(t, l, o)
            }(t, l, u, i, [])
        }
        ;
        var a = i("Resm")
    },
    ijAY: function(t, r, i) {
        "use strict";
        (function(t) {
            const r = i("B3XP")
              , wrapAnsi16 = (t,i)=>function() {
                const a = t.apply(r, arguments);
                return `[${a + i}m`
            }
              , wrapAnsi256 = (t,i)=>function() {
                const a = t.apply(r, arguments);
                return `[${38 + i};5;${a}m`
            }
              , wrapAnsi16m = (t,i)=>function() {
                const a = t.apply(r, arguments);
                return `[${38 + i};2;${a[0]};${a[1]};${a[2]}m`
            }
            ;
            Object.defineProperty(t, "exports", {
                enumerable: !0,
                get: function assembleStyles() {
                    const t = new Map
                      , i = {
                        modifier: {
                            reset: [0, 0],
                            bold: [1, 22],
                            dim: [2, 22],
                            italic: [3, 23],
                            underline: [4, 24],
                            inverse: [7, 27],
                            hidden: [8, 28],
                            strikethrough: [9, 29]
                        },
                        color: {
                            black: [30, 39],
                            red: [31, 39],
                            green: [32, 39],
                            yellow: [33, 39],
                            blue: [34, 39],
                            magenta: [35, 39],
                            cyan: [36, 39],
                            white: [37, 39],
                            gray: [90, 39],
                            redBright: [91, 39],
                            greenBright: [92, 39],
                            yellowBright: [93, 39],
                            blueBright: [94, 39],
                            magentaBright: [95, 39],
                            cyanBright: [96, 39],
                            whiteBright: [97, 39]
                        },
                        bgColor: {
                            bgBlack: [40, 49],
                            bgRed: [41, 49],
                            bgGreen: [42, 49],
                            bgYellow: [43, 49],
                            bgBlue: [44, 49],
                            bgMagenta: [45, 49],
                            bgCyan: [46, 49],
                            bgWhite: [47, 49],
                            bgBlackBright: [100, 49],
                            bgRedBright: [101, 49],
                            bgGreenBright: [102, 49],
                            bgYellowBright: [103, 49],
                            bgBlueBright: [104, 49],
                            bgMagentaBright: [105, 49],
                            bgCyanBright: [106, 49],
                            bgWhiteBright: [107, 49]
                        }
                    };
                    i.color.grey = i.color.gray;
                    for (const r of Object.keys(i)) {
                        const a = i[r];
                        for (const r of Object.keys(a)) {
                            const o = a[r];
                            i[r] = {
                                open: `[${o[0]}m`,
                                close: `[${o[1]}m`
                            },
                            a[r] = i[r],
                            t.set(o[0], o[1])
                        }
                        Object.defineProperty(i, r, {
                            value: a,
                            enumerable: !1
                        }),
                        Object.defineProperty(i, "codes", {
                            value: t,
                            enumerable: !1
                        })
                    }
                    const ansi2ansi = t=>t
                      , rgb2rgb = (t,r,i)=>[t, r, i];
                    i.color.close = "[39m",
                    i.bgColor.close = "[49m",
                    i.color.ansi = {
                        ansi: wrapAnsi16(ansi2ansi, 0)
                    },
                    i.color.ansi256 = {
                        ansi256: wrapAnsi256(ansi2ansi, 0)
                    },
                    i.color.ansi16m = {
                        rgb: wrapAnsi16m(rgb2rgb, 0)
                    },
                    i.bgColor.ansi = {
                        ansi: wrapAnsi16(ansi2ansi, 10)
                    },
                    i.bgColor.ansi256 = {
                        ansi256: wrapAnsi256(ansi2ansi, 10)
                    },
                    i.bgColor.ansi16m = {
                        rgb: wrapAnsi16m(rgb2rgb, 10)
                    };
                    for (let t of Object.keys(r)) {
                        if ("object" != typeof r[t])
                            continue;
                        const a = r[t];
                        "ansi16" === t && (t = "ansi"),
                        "ansi16"in a && (i.color.ansi[t] = wrapAnsi16(a.ansi16, 0),
                        i.bgColor.ansi[t] = wrapAnsi16(a.ansi16, 10)),
                        "ansi256"in a && (i.color.ansi256[t] = wrapAnsi256(a.ansi256, 0),
                        i.bgColor.ansi256[t] = wrapAnsi256(a.ansi256, 10)),
                        "rgb"in a && (i.color.ansi16m[t] = wrapAnsi16m(a.rgb, 0),
                        i.bgColor.ansi16m[t] = wrapAnsi16m(a.rgb, 10))
                    }
                    return i
                }
            })
        }
        ).call(this, i("YuTi")(t))
    },
    iyG3: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function builder() {
            var t = this
              , r = a.BUILDER_KEYS[t]
              , i = arguments.length;
            if (i > r.length)
                throw new Error("".concat(t, ": Too many arguments passed. Received ").concat(i, " but can receive no more than ").concat(r.length));
            for (var l = {
                type: t
            }, u = 0; u < r.length; ++u) {
                var p = r[u]
                  , c = a.NODE_FIELDS[t][p]
                  , d = void 0;
                u < i && (d = arguments[u]),
                void 0 === d && (d = Array.isArray(c.default) ? [] : c.default),
                l[p] = d
            }
            for (var y in l)
                (0,
                o.default)(l, y, l[y]);
            return l
        }
        ;
        var a = i("UHlb")
          , o = i("D+ka")
    },
    jXap: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function splitExportDeclaration(t) {
            if (!t.isExportDeclaration())
                throw new Error("Only export declarations can be split.");
            const r = t.isExportDefaultDeclaration()
              , i = t.get("declaration")
              , a = i.isClassDeclaration();
            if (r) {
                const r = i.isFunctionDeclaration() || a
                  , y = i.isScope() ? i.scope.parent : i.scope;
                let h = i.node.id
                  , m = !1;
                h || (m = !0,
                h = y.generateUidIdentifier("default"),
                (r || i.isFunctionExpression() || i.isClassExpression()) && (i.node.id = o(h)));
                const T = r ? i : c("var", [d(o(h), i.node)])
                  , S = l(null, [u(o(h), p("default"))]);
                return t.insertAfter(S),
                t.replaceWith(T),
                m && y.registerDeclaration(t),
                t
            }
            if (t.get("specifiers").length > 0)
                throw new Error("It doesn't make sense to split exported specifiers.");
            const y = i.getOuterBindingIdentifiers()
              , h = Object.keys(y).map(t=>u(p(t), p(t)))
              , m = l(null, h);
            return t.insertAfter(m),
            t.replaceWith(i.node),
            t
        }
        ;
        var a = i("JSq2");
        const {cloneNode: o, exportNamedDeclaration: l, exportSpecifier: u, identifier: p, variableDeclaration: c, variableDeclarator: d} = a
    },
    "jf/V": function(t, r, i) {
        "use strict";
        var a = i("TqRt")
          , o = a(i("lwsE"))
          , l = a(i("W8MJ"))
          , u = i("GlVh")
          , p = i("9lTW")
          , c = u.GlobalScope
          , d = u.CatchScope
          , y = u.WithScope
          , h = u.ModuleScope
          , m = u.ClassScope
          , T = u.SwitchScope
          , S = u.FunctionScope
          , g = u.ForScope
          , b = u.TDZScope
          , v = u.FunctionExpressionNameScope
          , E = u.BlockScope
          , P = function() {
            function ScopeManager(t) {
                (0,
                o.default)(this, ScopeManager),
                this.scopes = [],
                this.globalScope = null,
                this.__nodeToScope = new WeakMap,
                this.__currentScope = null,
                this.__options = t,
                this.__declaredVariables = new WeakMap
            }
            return (0,
            l.default)(ScopeManager, [{
                key: "__useDirective",
                value: function __useDirective() {
                    return this.__options.directive
                }
            }, {
                key: "__isOptimistic",
                value: function __isOptimistic() {
                    return this.__options.optimistic
                }
            }, {
                key: "__ignoreEval",
                value: function __ignoreEval() {
                    return this.__options.ignoreEval
                }
            }, {
                key: "__isNodejsScope",
                value: function __isNodejsScope() {
                    return this.__options.nodejsScope
                }
            }, {
                key: "isModule",
                value: function isModule() {
                    return "module" === this.__options.sourceType
                }
            }, {
                key: "isImpliedStrict",
                value: function isImpliedStrict() {
                    return this.__options.impliedStrict
                }
            }, {
                key: "isStrictModeSupported",
                value: function isStrictModeSupported() {
                    return this.__options.ecmaVersion >= 5
                }
            }, {
                key: "__get",
                value: function __get(t) {
                    return this.__nodeToScope.get(t)
                }
            }, {
                key: "getDeclaredVariables",
                value: function getDeclaredVariables(t) {
                    return this.__declaredVariables.get(t) || []
                }
            }, {
                key: "acquire",
                value: function acquire(t, r) {
                    function predicate(t) {
                        return ("function" !== t.type || !t.functionExpressionScope) && "TDZ" !== t.type
                    }
                    var i = this.__get(t);
                    if (!i || 0 === i.length)
                        return null;
                    if (1 === i.length)
                        return i[0];
                    if (r)
                        for (var a = i.length - 1; a >= 0; --a) {
                            var o = i[a];
                            if (predicate(o))
                                return o
                        }
                    else
                        for (var l = 0, u = i.length; l < u; ++l) {
                            var p = i[l];
                            if (predicate(p))
                                return p
                        }
                    return null
                }
            }, {
                key: "acquireAll",
                value: function acquireAll(t) {
                    return this.__get(t)
                }
            }, {
                key: "release",
                value: function release(t, r) {
                    var i = this.__get(t);
                    if (i && i.length) {
                        var a = i[0].upper;
                        return a ? this.acquire(a.block, r) : null
                    }
                    return null
                }
            }, {
                key: "attach",
                value: function attach() {}
            }, {
                key: "detach",
                value: function detach() {}
            }, {
                key: "__nestScope",
                value: function __nestScope(t) {
                    return t instanceof c && (p(null === this.__currentScope),
                    this.globalScope = t),
                    this.__currentScope = t,
                    t
                }
            }, {
                key: "__nestGlobalScope",
                value: function __nestGlobalScope(t) {
                    return this.__nestScope(new c(this,t))
                }
            }, {
                key: "__nestBlockScope",
                value: function __nestBlockScope(t) {
                    return this.__nestScope(new E(this,this.__currentScope,t))
                }
            }, {
                key: "__nestFunctionScope",
                value: function __nestFunctionScope(t, r) {
                    return this.__nestScope(new S(this,this.__currentScope,t,r))
                }
            }, {
                key: "__nestForScope",
                value: function __nestForScope(t) {
                    return this.__nestScope(new g(this,this.__currentScope,t))
                }
            }, {
                key: "__nestCatchScope",
                value: function __nestCatchScope(t) {
                    return this.__nestScope(new d(this,this.__currentScope,t))
                }
            }, {
                key: "__nestWithScope",
                value: function __nestWithScope(t) {
                    return this.__nestScope(new y(this,this.__currentScope,t))
                }
            }, {
                key: "__nestClassScope",
                value: function __nestClassScope(t) {
                    return this.__nestScope(new m(this,this.__currentScope,t))
                }
            }, {
                key: "__nestSwitchScope",
                value: function __nestSwitchScope(t) {
                    return this.__nestScope(new T(this,this.__currentScope,t))
                }
            }, {
                key: "__nestModuleScope",
                value: function __nestModuleScope(t) {
                    return this.__nestScope(new h(this,this.__currentScope,t))
                }
            }, {
                key: "__nestTDZScope",
                value: function __nestTDZScope(t) {
                    return this.__nestScope(new b(this,this.__currentScope,t))
                }
            }, {
                key: "__nestFunctionExpressionNameScope",
                value: function __nestFunctionExpressionNameScope(t) {
                    return this.__nestScope(new v(this,this.__currentScope,t))
                }
            }, {
                key: "__isES6",
                value: function __isES6() {
                    return this.__options.ecmaVersion >= 6
                }
            }]),
            ScopeManager
        }();
        t.exports = P
    },
    jr7T: function(t, r, i) {
        "use strict";
        var a = i("TqRt")(i("cDf5"));
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = void 0;
        var o = i("yK+d")
          , l = i("57mi")
          , u = function valueToNode(t) {
            if (void 0 === t)
                return (0,
                l.identifier)("undefined");
            if (!0 === t || !1 === t)
                return (0,
                l.booleanLiteral)(t);
            if (null === t)
                return (0,
                l.nullLiteral)();
            if ("string" == typeof t)
                return (0,
                l.stringLiteral)(t);
            if ("number" == typeof t) {
                var r, i;
                if (Number.isFinite(t))
                    r = (0,
                    l.numericLiteral)(Math.abs(t));
                else
                    i = Number.isNaN(t) ? (0,
                    l.numericLiteral)(0) : (0,
                    l.numericLiteral)(1),
                    r = (0,
                    l.binaryExpression)("/", i, (0,
                    l.numericLiteral)(0));
                return (t < 0 || Object.is(t, -0)) && (r = (0,
                l.unaryExpression)("-", r)),
                r
            }
            if (function isRegExp(t) {
                return "[object RegExp]" === p(t)
            }(t)) {
                var u = t.source
                  , c = t.toString().match(/\/([a-z]+|)$/)[1];
                return (0,
                l.regExpLiteral)(u, c)
            }
            if (Array.isArray(t))
                return (0,
                l.arrayExpression)(t.map(valueToNode));
            if (function isPlainObject(t) {
                if ("object" !== (0,
                a.default)(t) || null === t || "[object Object]" !== Object.prototype.toString.call(t))
                    return !1;
                var r = Object.getPrototypeOf(t);
                return null === r || null === Object.getPrototypeOf(r)
            }(t)) {
                for (var d = [], y = 0, h = Object.keys(t); y < h.length; y++) {
                    var m = h[y]
                      , T = void 0;
                    T = (0,
                    o.default)(m) ? (0,
                    l.identifier)(m) : (0,
                    l.stringLiteral)(m),
                    d.push((0,
                    l.objectProperty)(T, valueToNode(t[m])))
                }
                return (0,
                l.objectExpression)(d)
            }
            throw new Error("don't know how to turn this value into a node")
        };
        r.default = u;
        var p = Function.call.bind(Object.prototype.toString)
    },
    jwsk: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function createTemplateBuilder(t, r) {
            const i = new WeakMap
              , p = new WeakMap
              , c = r || (0,
            a.validate)(null);
            return Object.assign((r,...u)=>{
                if ("string" == typeof r) {
                    if (u.length > 1)
                        throw new Error("Unexpected extra params.");
                    return extendedTrace((0,
                    o.default)(t, r, (0,
                    a.merge)(c, (0,
                    a.validate)(u[0]))))
                }
                if (Array.isArray(r)) {
                    let a = i.get(r);
                    return a || (a = (0,
                    l.default)(t, r, c),
                    i.set(r, a)),
                    extendedTrace(a(u))
                }
                if ("object" == typeof r && r) {
                    if (u.length > 0)
                        throw new Error("Unexpected extra params.");
                    return createTemplateBuilder(t, (0,
                    a.merge)(c, (0,
                    a.validate)(r)))
                }
                throw new Error("Unexpected template param " + typeof r)
            }
            , {
                ast: (r,...i)=>{
                    if ("string" == typeof r) {
                        if (i.length > 1)
                            throw new Error("Unexpected extra params.");
                        return (0,
                        o.default)(t, r, (0,
                        a.merge)((0,
                        a.merge)(c, (0,
                        a.validate)(i[0])), u))()
                    }
                    if (Array.isArray(r)) {
                        let o = p.get(r);
                        return o || (o = (0,
                        l.default)(t, r, (0,
                        a.merge)(c, u)),
                        p.set(r, o)),
                        o(i)()
                    }
                    throw new Error("Unexpected template param " + typeof r)
                }
            })
        }
        ;
        var a = i("+zpO")
          , o = i("LluO")
          , l = i("fJha");
        const u = (0,
        a.validate)({
            placeholderPattern: !1
        });
        function extendedTrace(t) {
            let r = "";
            try {
                throw new Error
            } catch (t) {
                t.stack && (r = t.stack.split("\n").slice(3).join("\n"))
            }
            return i=>{
                try {
                    return t(i)
                } catch (t) {
                    throw t.stack += "\n    =============\n" + r,
                    t
                }
            }
        }
    },
    k4iN: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = void 0;
        var a = i("ucPi")
          , o = i("61uC")
          , l = function valueToNode(t) {
            if (void 0 === t)
                return (0,
                o.identifier)("undefined");
            if (!0 === t || !1 === t)
                return (0,
                o.booleanLiteral)(t);
            if (null === t)
                return (0,
                o.nullLiteral)();
            if ("string" == typeof t)
                return (0,
                o.stringLiteral)(t);
            if ("number" == typeof t) {
                let r;
                if (Number.isFinite(t))
                    r = (0,
                    o.numericLiteral)(Math.abs(t));
                else {
                    let i;
                    i = Number.isNaN(t) ? (0,
                    o.numericLiteral)(0) : (0,
                    o.numericLiteral)(1),
                    r = (0,
                    o.binaryExpression)("/", i, (0,
                    o.numericLiteral)(0))
                }
                return (t < 0 || Object.is(t, -0)) && (r = (0,
                o.unaryExpression)("-", r)),
                r
            }
            if (function isRegExp(t) {
                return "[object RegExp]" === u(t)
            }(t)) {
                const r = t.source
                  , i = t.toString().match(/\/([a-z]+|)$/)[1];
                return (0,
                o.regExpLiteral)(r, i)
            }
            if (Array.isArray(t))
                return (0,
                o.arrayExpression)(t.map(valueToNode));
            if (function isPlainObject(t) {
                if ("object" != typeof t || null === t || "[object Object]" !== Object.prototype.toString.call(t))
                    return !1;
                const r = Object.getPrototypeOf(t);
                return null === r || null === Object.getPrototypeOf(r)
            }(t)) {
                const r = [];
                for (const i of Object.keys(t)) {
                    let l;
                    l = (0,
                    a.default)(i) ? (0,
                    o.identifier)(i) : (0,
                    o.stringLiteral)(i),
                    r.push((0,
                    o.objectProperty)(l, valueToNode(t[i])))
                }
                return (0,
                o.objectExpression)(r)
            }
            throw new Error("don't know how to turn this value into a node")
        };
        r.default = l;
        const u = Function.call.bind(Object.prototype.toString)
    },
    kEZX: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.UPDATE_OPERATORS = r.UNARY_OPERATORS = r.STRING_UNARY_OPERATORS = r.STATEMENT_OR_BLOCK_KEYS = r.NUMBER_UNARY_OPERATORS = r.NUMBER_BINARY_OPERATORS = r.NOT_LOCAL_BINDING = r.LOGICAL_OPERATORS = r.INHERIT_KEYS = r.FOR_INIT_KEYS = r.FLATTENABLE_KEYS = r.EQUALITY_BINARY_OPERATORS = r.COMPARISON_BINARY_OPERATORS = r.COMMENT_KEYS = r.BOOLEAN_UNARY_OPERATORS = r.BOOLEAN_NUMBER_BINARY_OPERATORS = r.BOOLEAN_BINARY_OPERATORS = r.BLOCK_SCOPED_SYMBOL = r.BINARY_OPERATORS = r.ASSIGNMENT_OPERATORS = void 0;
        r.STATEMENT_OR_BLOCK_KEYS = ["consequent", "body", "alternate"];
        r.FLATTENABLE_KEYS = ["body", "expressions"];
        r.FOR_INIT_KEYS = ["left", "init"];
        r.COMMENT_KEYS = ["leadingComments", "trailingComments", "innerComments"];
        const a = ["||", "&&", "??"];
        r.LOGICAL_OPERATORS = a;
        r.UPDATE_OPERATORS = ["++", "--"];
        const o = [">", "<", ">=", "<="];
        r.BOOLEAN_NUMBER_BINARY_OPERATORS = o;
        const l = ["==", "===", "!=", "!=="];
        r.EQUALITY_BINARY_OPERATORS = l;
        const u = [...l, "in", "instanceof"];
        r.COMPARISON_BINARY_OPERATORS = u;
        const p = [...u, ...o];
        r.BOOLEAN_BINARY_OPERATORS = p;
        const c = ["-", "/", "%", "*", "**", "&", "|", ">>", ">>>", "<<", "^"];
        r.NUMBER_BINARY_OPERATORS = c;
        const d = ["+", ...c, ...p];
        r.BINARY_OPERATORS = d;
        const y = ["=", "+=", ...c.map(t=>t + "="), ...a.map(t=>t + "=")];
        r.ASSIGNMENT_OPERATORS = y;
        const h = ["delete", "!"];
        r.BOOLEAN_UNARY_OPERATORS = h;
        const m = ["+", "-", "~"];
        r.NUMBER_UNARY_OPERATORS = m;
        const T = ["typeof"];
        r.STRING_UNARY_OPERATORS = T;
        const S = ["void", "throw", ...h, ...m, ...T];
        r.UNARY_OPERATORS = S;
        r.INHERIT_KEYS = {
            optional: ["typeAnnotation", "typeParameters", "returnType"],
            force: ["start", "loc", "end"]
        };
        const g = Symbol.for("var used to be block scoped");
        r.BLOCK_SCOPED_SYMBOL = g;
        const b = Symbol.for("should not be considered a local binding");
        r.NOT_LOCAL_BINDING = b
    },
    kSM9: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function parseAndBuildMetadata(t, r, i) {
            const {placeholderWhitelist: a, placeholderPattern: u, preserveComments: p, syntacticPlaceholders: c} = i
              , d = function parseWithCodeFrame(t, r, i) {
                const a = (r.plugins || []).slice();
                !1 !== i && a.push("placeholders");
                r = Object.assign({
                    allowReturnOutsideFunction: !0,
                    allowSuperOutsideMethod: !0,
                    sourceType: "module"
                }, r, {
                    plugins: a
                });
                try {
                    return (0,
                    o.parse)(t, r)
                } catch (r) {
                    const i = r.loc;
                    throw i && (r.message += "\n" + (0,
                    l.codeFrameColumns)(t, {
                        start: i
                    }),
                    r.code = "BABEL_TEMPLATE_PARSE_ERROR"),
                    r
                }
            }(r, i.parser, c);
            g(d, {
                preserveComments: p
            }),
            t.validate(d);
            const y = {
                placeholders: [],
                placeholderNames: new Set
            }
              , h = {
                placeholders: [],
                placeholderNames: new Set
            }
              , m = {
                value: void 0
            };
            return b(d, placeholderVisitorHandler, {
                syntactic: y,
                legacy: h,
                isLegacyRef: m,
                placeholderWhitelist: a,
                placeholderPattern: u,
                syntacticPlaceholders: c
            }),
            Object.assign({
                ast: d
            }, m.value ? h : y)
        }
        ;
        var a = i("JSq2")
          , o = i("GGH7")
          , l = i("IXBh");
        const {isCallExpression: u, isExpressionStatement: p, isFunction: c, isIdentifier: d, isJSXIdentifier: y, isNewExpression: h, isPlaceholder: m, isStatement: T, isStringLiteral: S, removePropertiesDeep: g, traverse: b} = a
          , v = /^[_$A-Z0-9]+$/;
        function placeholderVisitorHandler(t, r, i) {
            var a;
            let o;
            if (m(t)) {
                if (!1 === i.syntacticPlaceholders)
                    throw new Error("%%foo%%-style placeholders can't be used when '.syntacticPlaceholders' is false.");
                o = t.name.name,
                i.isLegacyRef.value = !1
            } else {
                if (!1 === i.isLegacyRef.value || i.syntacticPlaceholders)
                    return;
                if (d(t) || y(t))
                    o = t.name,
                    i.isLegacyRef.value = !0;
                else {
                    if (!S(t))
                        return;
                    o = t.value,
                    i.isLegacyRef.value = !0
                }
            }
            if (!i.isLegacyRef.value && (null != i.placeholderPattern || null != i.placeholderWhitelist))
                throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible with '.syntacticPlaceholders: true'");
            if (i.isLegacyRef.value && (!1 === i.placeholderPattern || !(i.placeholderPattern || v).test(o)) && (null == (a = i.placeholderWhitelist) || !a.has(o)))
                return;
            r = r.slice();
            const {node: l, key: g} = r[r.length - 1];
            let b;
            S(t) || m(t, {
                expectedNode: "StringLiteral"
            }) ? b = "string" : h(l) && "arguments" === g || u(l) && "arguments" === g || c(l) && "params" === g ? b = "param" : p(l) && !m(t) ? (b = "statement",
            r = r.slice(0, -1)) : b = T(t) && m(t) ? "statement" : "other";
            const {placeholders: E, placeholderNames: P} = i.isLegacyRef.value ? i.legacy : i.syntactic;
            E.push({
                name: o,
                type: b,
                resolve: t=>function resolveAncestors(t, r) {
                    let i = t;
                    for (let t = 0; t < r.length - 1; t++) {
                        const {key: a, index: o} = r[t];
                        i = void 0 === o ? i[a] : i[a][o]
                    }
                    const {key: a, index: o} = r[r.length - 1];
                    return {
                        parent: i,
                        key: a,
                        index: o
                    }
                }(t, r),
                isDuplicate: P.has(o)
            }),
            P.add(o)
        }
    },
    kUnP: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = void 0;
        var a = i("xIU+")
          , o = i("61uC")
          , l = function toStatement(t, r) {
            if ((0,
            a.isStatement)(t))
                return t;
            let i, l = !1;
            if ((0,
            a.isClass)(t))
                l = !0,
                i = "ClassDeclaration";
            else if ((0,
            a.isFunction)(t))
                l = !0,
                i = "FunctionDeclaration";
            else if ((0,
            a.isAssignmentExpression)(t))
                return (0,
                o.expressionStatement)(t);
            l && !t.id && (i = !1);
            if (!i) {
                if (r)
                    return !1;
                throw new Error(`cannot turn ${t.type} to a statement`)
            }
            return t.type = i,
            t
        };
        r.default = l
    },
    "kVK+": function(t, r) {
        r.read = function(t, r, i, a, o) {
            var l, u, p = 8 * o - a - 1, c = (1 << p) - 1, d = c >> 1, y = -7, h = i ? o - 1 : 0, m = i ? -1 : 1, T = t[r + h];
            for (h += m,
            l = T & (1 << -y) - 1,
            T >>= -y,
            y += p; y > 0; l = 256 * l + t[r + h],
            h += m,
            y -= 8)
                ;
            for (u = l & (1 << -y) - 1,
            l >>= -y,
            y += a; y > 0; u = 256 * u + t[r + h],
            h += m,
            y -= 8)
                ;
            if (0 === l)
                l = 1 - d;
            else {
                if (l === c)
                    return u ? NaN : 1 / 0 * (T ? -1 : 1);
                u += Math.pow(2, a),
                l -= d
            }
            return (T ? -1 : 1) * u * Math.pow(2, l - a)
        }
        ,
        r.write = function(t, r, i, a, o, l) {
            var u, p, c, d = 8 * l - o - 1, y = (1 << d) - 1, h = y >> 1, m = 23 === o ? Math.pow(2, -24) - Math.pow(2, -77) : 0, T = a ? 0 : l - 1, S = a ? 1 : -1, g = r < 0 || 0 === r && 1 / r < 0 ? 1 : 0;
            for (r = Math.abs(r),
            isNaN(r) || r === 1 / 0 ? (p = isNaN(r) ? 1 : 0,
            u = y) : (u = Math.floor(Math.log(r) / Math.LN2),
            r * (c = Math.pow(2, -u)) < 1 && (u--,
            c *= 2),
            (r += u + h >= 1 ? m / c : m * Math.pow(2, 1 - h)) * c >= 2 && (u++,
            c /= 2),
            u + h >= y ? (p = 0,
            u = y) : u + h >= 1 ? (p = (r * c - 1) * Math.pow(2, o),
            u += h) : (p = r * Math.pow(2, h - 1) * Math.pow(2, o),
            u = 0)); o >= 8; t[i + T] = 255 & p,
            T += S,
            p /= 256,
            o -= 8)
                ;
            for (u = u << o | p,
            d += o; d > 0; t[i + T] = 255 & u,
            T += S,
            u /= 256,
            d -= 8)
                ;
            t[i + T - S] |= 128 * g
        }
    },
    kkH2: function(t, r, i) {
        var a = i("ub0H")
          , o = Object.prototype.hasOwnProperty
          , l = "undefined" != typeof Map;
        function ArraySet() {
            this._array = [],
            this._set = l ? new Map : Object.create(null)
        }
        ArraySet.fromArray = function ArraySet_fromArray(t, r) {
            for (var i = new ArraySet, a = 0, o = t.length; a < o; a++)
                i.add(t[a], r);
            return i
        }
        ,
        ArraySet.prototype.size = function ArraySet_size() {
            return l ? this._set.size : Object.getOwnPropertyNames(this._set).length
        }
        ,
        ArraySet.prototype.add = function ArraySet_add(t, r) {
            var i = l ? t : a.toSetString(t)
              , u = l ? this.has(t) : o.call(this._set, i)
              , p = this._array.length;
            u && !r || this._array.push(t),
            u || (l ? this._set.set(t, p) : this._set[i] = p)
        }
        ,
        ArraySet.prototype.has = function ArraySet_has(t) {
            if (l)
                return this._set.has(t);
            var r = a.toSetString(t);
            return o.call(this._set, r)
        }
        ,
        ArraySet.prototype.indexOf = function ArraySet_indexOf(t) {
            if (l) {
                var r = this._set.get(t);
                if (r >= 0)
                    return r
            } else {
                var i = a.toSetString(t);
                if (o.call(this._set, i))
                    return this._set[i]
            }
            throw new Error('"' + t + '" is not in the set.')
        }
        ,
        ArraySet.prototype.at = function ArraySet_at(t) {
            if (t >= 0 && t < this._array.length)
                return this._array[t];
            throw new Error("No element indexed by " + t)
        }
        ,
        ArraySet.prototype.toArray = function ArraySet_toArray() {
            return this._array.slice()
        }
        ,
        r.ArraySet = ArraySet
    },
    kmK0: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function validate(t, r, i) {
            if (!t)
                return;
            var o = a.NODE_FIELDS[t.type];
            if (!o)
                return;
            var l = o[r];
            validateField(t, r, i, l),
            validateChild(t, r, i)
        }
        ,
        r.validateField = validateField,
        r.validateChild = validateChild;
        var a = i("Resm");
        function validateField(t, r, i, a) {
            null != a && a.validate && (a.optional && null == i || a.validate(t, r, i))
        }
        function validateChild(t, r, i) {
            if (null != i) {
                var o = a.NODE_PARENT_VALIDATIONS[i.type];
                o && o(t, r, i)
            }
        }
    },
    lFjz: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function isBinding(t, r, i) {
            if (i && "Identifier" === t.type && "ObjectProperty" === r.type && "ObjectExpression" === i.type)
                return !1;
            var o = a.default.keys[r.type];
            if (o)
                for (var l = 0; l < o.length; l++) {
                    var u = o[l]
                      , p = r[u];
                    if (Array.isArray(p)) {
                        if (p.indexOf(t) >= 0)
                            return !0
                    } else if (p === t)
                        return !0
                }
            return !1
        }
        ;
        var a = i("oUnQ")
    },
    lQDi: function(t, r, i) {
        "use strict";
        function _createForOfIteratorHelper(t, r) {
            var i = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
            if (!i) {
                if (Array.isArray(t) || (i = function _unsupportedIterableToArray(t, r) {
                    if (!t)
                        return;
                    if ("string" == typeof t)
                        return _arrayLikeToArray(t, r);
                    var i = Object.prototype.toString.call(t).slice(8, -1);
                    "Object" === i && t.constructor && (i = t.constructor.name);
                    if ("Map" === i || "Set" === i)
                        return Array.from(t);
                    if ("Arguments" === i || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i))
                        return _arrayLikeToArray(t, r)
                }(t)) || r && t && "number" == typeof t.length) {
                    i && (t = i);
                    var a = 0
                      , o = function F() {};
                    return {
                        s: o,
                        n: function n() {
                            return a >= t.length ? {
                                done: !0
                            } : {
                                done: !1,
                                value: t[a++]
                            }
                        },
                        e: function e(t) {
                            throw t
                        },
                        f: o
                    }
                }
                throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
            }
            var l, u = !0, p = !1;
            return {
                s: function s() {
                    i = i.call(t)
                },
                n: function n() {
                    var t = i.next();
                    return u = t.done,
                    t
                },
                e: function e(t) {
                    p = !0,
                    l = t
                },
                f: function f() {
                    try {
                        u || null == i.return || i.return()
                    } finally {
                        if (p)
                            throw l
                    }
                }
            }
        }
        function _arrayLikeToArray(t, r) {
            (null == r || r > t.length) && (r = t.length);
            for (var i = 0, a = new Array(r); i < r; i++)
                a[i] = t[i];
            return a
        }
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function traverse(t, r, i) {
            "function" == typeof r && (r = {
                enter: r
            });
            var o = r
              , l = o.enter
              , u = o.exit;
            !function traverseSimpleImpl(t, r, i, o, l) {
                var u = a.VISITOR_KEYS[t.type];
                if (!u)
                    return;
                r && r(t, l, o);
                var p, c = _createForOfIteratorHelper(u);
                try {
                    for (c.s(); !(p = c.n()).done; ) {
                        var d = p.value
                          , y = t[d];
                        if (Array.isArray(y))
                            for (var h = 0; h < y.length; h++) {
                                var m = y[h];
                                m && (l.push({
                                    node: t,
                                    key: d,
                                    index: h
                                }),
                                traverseSimpleImpl(m, r, i, o, l),
                                l.pop())
                            }
                        else
                            y && (l.push({
                                node: t,
                                key: d
                            }),
                            traverseSimpleImpl(y, r, i, o, l),
                            l.pop())
                    }
                } catch (t) {
                    c.e(t)
                } finally {
                    c.f()
                }
                i && i(t, l, o)
            }(t, l, u, i, [])
        }
        ;
        var a = i("UHlb")
    },
    lTU0: function(t, r, i) {
        "use strict";
        var a = i("TqRt")
          , o = a(i("lwsE"))
          , l = a(i("W8MJ"))
          , u = a(i("7W2i"))
          , p = a(i("a1gu"))
          , c = a(i("Nsbk"));
        function _createSuper(t) {
            var r = function _isNativeReflectConstruct() {
                if ("undefined" == typeof Reflect || !Reflect.construct)
                    return !1;
                if (Reflect.construct.sham)
                    return !1;
                if ("function" == typeof Proxy)
                    return !0;
                try {
                    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}
                    ))),
                    !0
                } catch (t) {
                    return !1
                }
            }();
            return function _createSuperInternal() {
                var i, a = (0,
                c.default)(t);
                if (r) {
                    var o = (0,
                    c.default)(this).constructor;
                    i = Reflect.construct(a, arguments, o)
                } else
                    i = a.apply(this, arguments);
                return (0,
                p.default)(this, i)
            }
        }
        var d = i("sR6L").Syntax;
        var y = function(t) {
            (0,
            u.default)(PatternVisitor, t);
            var r = _createSuper(PatternVisitor);
            function PatternVisitor(t, i, a) {
                var l;
                return (0,
                o.default)(this, PatternVisitor),
                (l = r.call(this, null, t)).rootPattern = i,
                l.callback = a,
                l.assignments = [],
                l.rightHandNodes = [],
                l.restElements = [],
                l
            }
            return (0,
            l.default)(PatternVisitor, [{
                key: "Identifier",
                value: function Identifier(t) {
                    var r = function getLast(t) {
                        return t[t.length - 1] || null
                    }(this.restElements);
                    this.callback(t, {
                        topLevel: t === this.rootPattern,
                        rest: null != r && r.argument === t,
                        assignments: this.assignments
                    })
                }
            }, {
                key: "Property",
                value: function Property(t) {
                    t.computed && this.rightHandNodes.push(t.key),
                    this.visit(t.value)
                }
            }, {
                key: "ArrayPattern",
                value: function ArrayPattern(t) {
                    for (var r = 0, i = t.elements.length; r < i; ++r) {
                        var a = t.elements[r];
                        this.visit(a)
                    }
                }
            }, {
                key: "AssignmentPattern",
                value: function AssignmentPattern(t) {
                    this.assignments.push(t),
                    this.visit(t.left),
                    this.rightHandNodes.push(t.right),
                    this.assignments.pop()
                }
            }, {
                key: "RestElement",
                value: function RestElement(t) {
                    this.restElements.push(t),
                    this.visit(t.argument),
                    this.restElements.pop()
                }
            }, {
                key: "MemberExpression",
                value: function MemberExpression(t) {
                    t.computed && this.rightHandNodes.push(t.property),
                    this.rightHandNodes.push(t.object)
                }
            }, {
                key: "SpreadElement",
                value: function SpreadElement(t) {
                    this.visit(t.argument)
                }
            }, {
                key: "ArrayExpression",
                value: function ArrayExpression(t) {
                    t.elements.forEach(this.visit, this)
                }
            }, {
                key: "AssignmentExpression",
                value: function AssignmentExpression(t) {
                    this.assignments.push(t),
                    this.visit(t.left),
                    this.rightHandNodes.push(t.right),
                    this.assignments.pop()
                }
            }, {
                key: "CallExpression",
                value: function CallExpression(t) {
                    var r = this;
                    t.arguments.forEach((function(t) {
                        r.rightHandNodes.push(t)
                    }
                    )),
                    this.visit(t.callee)
                }
            }], [{
                key: "isPattern",
                value: function isPattern(t) {
                    var r = t.type;
                    return r === d.Identifier || r === d.ObjectPattern || r === d.ArrayPattern || r === d.SpreadElement || r === d.RestElement || r === d.AssignmentPattern
                }
            }]),
            PatternVisitor
        }(i("KZm0").Visitor);
        t.exports = y
    },
    lTly: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function isImmutable(t) {
            if ((0,
            a.default)(t.type, "Immutable"))
                return !0;
            if ((0,
            o.isIdentifier)(t))
                return "undefined" === t.name;
            return !1
        }
        ;
        var a = i("EJNx")
          , o = i("xIU+")
    },
    lllF: function(t, r, i) {
        "use strict";
        var a = i("TqRt")(i("cDf5"));
        function _createForOfIteratorHelper(t, r) {
            var i = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
            if (!i) {
                if (Array.isArray(t) || (i = function _unsupportedIterableToArray(t, r) {
                    if (!t)
                        return;
                    if ("string" == typeof t)
                        return _arrayLikeToArray(t, r);
                    var i = Object.prototype.toString.call(t).slice(8, -1);
                    "Object" === i && t.constructor && (i = t.constructor.name);
                    if ("Map" === i || "Set" === i)
                        return Array.from(t);
                    if ("Arguments" === i || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i))
                        return _arrayLikeToArray(t, r)
                }(t)) || r && t && "number" == typeof t.length) {
                    i && (t = i);
                    var a = 0
                      , o = function F() {};
                    return {
                        s: o,
                        n: function n() {
                            return a >= t.length ? {
                                done: !0
                            } : {
                                done: !1,
                                value: t[a++]
                            }
                        },
                        e: function e(t) {
                            throw t
                        },
                        f: o
                    }
                }
                throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
            }
            var l, u = !0, p = !1;
            return {
                s: function s() {
                    i = i.call(t)
                },
                n: function n() {
                    var t = i.next();
                    return u = t.done,
                    t
                },
                e: function e(t) {
                    p = !0,
                    l = t
                },
                f: function f() {
                    try {
                        u || null == i.return || i.return()
                    } finally {
                        if (p)
                            throw l
                    }
                }
            }
        }
        function _arrayLikeToArray(t, r) {
            (null == r || r > t.length) && (r = t.length);
            for (var i = 0, a = new Array(r); i < r; i++)
                a[i] = t[i];
            return a
        }
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.call = function call(t) {
            var r = this.opts;
            if (this.debug(t),
            this.node && this._call(r[t]))
                return !0;
            if (this.node)
                return this._call(r[this.node.type] && r[this.node.type][t]);
            return !1
        }
        ,
        r._call = function _call(t) {
            if (!t)
                return !1;
            var r, i = _createForOfIteratorHelper(t);
            try {
                for (i.s(); !(r = i.n()).done; ) {
                    var o = r.value;
                    if (o) {
                        var l = this.node;
                        if (!l)
                            return !0;
                        var u = o.call(this.state, this, this.state);
                        if (u && "object" === (0,
                        a.default)(u) && "function" == typeof u.then)
                            throw new Error("You appear to be using a plugin with an async traversal visitor, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version.");
                        if (u)
                            throw new Error("Unexpected return value from visitor method ".concat(o));
                        if (this.node !== l)
                            return !0;
                        if (this._traverseFlags > 0)
                            return !0
                    }
                }
            } catch (t) {
                i.e(t)
            } finally {
                i.f()
            }
            return !1
        }
        ,
        r.isBlacklisted = r.isDenylisted = function isDenylisted() {
            var t, r = null != (t = this.opts.denylist) ? t : this.opts.blacklist;
            return r && r.indexOf(this.node.type) > -1
        }
        ,
        r.visit = function visit() {
            if (!this.node)
                return !1;
            if (this.isDenylisted())
                return !1;
            if (this.opts.shouldSkip && this.opts.shouldSkip(this))
                return !1;
            if (this.shouldSkip || this.call("enter") || this.shouldSkip)
                return this.debug("Skip..."),
                this.shouldStop;
            return this.debug("Recursing into..."),
            o.default.node(this.node, this.opts, this.scope, this.state, this, this.skipKeys),
            this.call("exit"),
            this.shouldStop
        }
        ,
        r.skip = function skip() {
            this.shouldSkip = !0
        }
        ,
        r.skipKey = function skipKey(t) {
            null == this.skipKeys && (this.skipKeys = {});
            this.skipKeys[t] = !0
        }
        ,
        r.stop = function stop() {
            this._traverseFlags |= l.SHOULD_SKIP | l.SHOULD_STOP
        }
        ,
        r.setScope = function setScope() {
            if (this.opts && this.opts.noScope)
                return;
            var t, r = this.parentPath;
            "key" === this.key && r.isMethod() && (r = r.parentPath);
            for (; r && !t; ) {
                if (r.opts && r.opts.noScope)
                    return;
                t = r.scope,
                r = r.parentPath
            }
            this.scope = this.getScope(t),
            this.scope && this.scope.init()
        }
        ,
        r.setContext = function setContext(t) {
            null != this.skipKeys && (this.skipKeys = {});
            this._traverseFlags = 0,
            t && (this.context = t,
            this.state = t.state,
            this.opts = t.opts);
            return this.setScope(),
            this
        }
        ,
        r.resync = function resync() {
            if (this.removed)
                return;
            this._resyncParent(),
            this._resyncList(),
            this._resyncKey()
        }
        ,
        r._resyncParent = function _resyncParent() {
            this.parentPath && (this.parent = this.parentPath.node)
        }
        ,
        r._resyncKey = function _resyncKey() {
            if (!this.container)
                return;
            if (this.node === this.container[this.key])
                return;
            if (Array.isArray(this.container)) {
                for (var t = 0; t < this.container.length; t++)
                    if (this.container[t] === this.node)
                        return this.setKey(t)
            } else
                for (var r = 0, i = Object.keys(this.container); r < i.length; r++) {
                    var a = i[r];
                    if (this.container[a] === this.node)
                        return this.setKey(a)
                }
            this.key = null
        }
        ,
        r._resyncList = function _resyncList() {
            if (!this.parent || !this.inList)
                return;
            var t = this.parent[this.listKey];
            if (this.container === t)
                return;
            this.container = t || null
        }
        ,
        r._resyncRemoved = function _resyncRemoved() {
            null != this.key && this.container && this.container[this.key] === this.node || this._markRemoved()
        }
        ,
        r.popContext = function popContext() {
            this.contexts.pop(),
            this.contexts.length > 0 ? this.setContext(this.contexts[this.contexts.length - 1]) : this.setContext(void 0)
        }
        ,
        r.pushContext = function pushContext(t) {
            this.contexts.push(t),
            this.setContext(t)
        }
        ,
        r.setup = function setup(t, r, i, a) {
            this.listKey = i,
            this.container = r,
            this.parentPath = t || this.parentPath,
            this.setKey(a)
        }
        ,
        r.setKey = function setKey(t) {
            var r;
            this.key = t,
            this.node = this.container[this.key],
            this.type = null == (r = this.node) ? void 0 : r.type
        }
        ,
        r.requeue = function requeue() {
            var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this;
            if (t.removed)
                return;
            var r, i = this.contexts, a = _createForOfIteratorHelper(i);
            try {
                for (a.s(); !(r = a.n()).done; ) {
                    var o = r.value;
                    o.maybeQueue(t)
                }
            } catch (t) {
                a.e(t)
            } finally {
                a.f()
            }
        }
        ,
        r._getQueueContexts = function _getQueueContexts() {
            var t = this
              , r = this.contexts;
            for (; !r.length && (t = t.parentPath); )
                r = t.contexts;
            return r
        }
        ;
        var o = i("LR/y")
          , l = i("MBGo")
    },
    lrmr: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        Object.defineProperty(r, "AnyTypeAnnotation", {
            enumerable: !0,
            get: function() {
                return a.anyTypeAnnotation
            }
        }),
        Object.defineProperty(r, "ArgumentPlaceholder", {
            enumerable: !0,
            get: function() {
                return a.argumentPlaceholder
            }
        }),
        Object.defineProperty(r, "ArrayExpression", {
            enumerable: !0,
            get: function() {
                return a.arrayExpression
            }
        }),
        Object.defineProperty(r, "ArrayPattern", {
            enumerable: !0,
            get: function() {
                return a.arrayPattern
            }
        }),
        Object.defineProperty(r, "ArrayTypeAnnotation", {
            enumerable: !0,
            get: function() {
                return a.arrayTypeAnnotation
            }
        }),
        Object.defineProperty(r, "ArrowFunctionExpression", {
            enumerable: !0,
            get: function() {
                return a.arrowFunctionExpression
            }
        }),
        Object.defineProperty(r, "AssignmentExpression", {
            enumerable: !0,
            get: function() {
                return a.assignmentExpression
            }
        }),
        Object.defineProperty(r, "AssignmentPattern", {
            enumerable: !0,
            get: function() {
                return a.assignmentPattern
            }
        }),
        Object.defineProperty(r, "AwaitExpression", {
            enumerable: !0,
            get: function() {
                return a.awaitExpression
            }
        }),
        Object.defineProperty(r, "BigIntLiteral", {
            enumerable: !0,
            get: function() {
                return a.bigIntLiteral
            }
        }),
        Object.defineProperty(r, "BinaryExpression", {
            enumerable: !0,
            get: function() {
                return a.binaryExpression
            }
        }),
        Object.defineProperty(r, "BindExpression", {
            enumerable: !0,
            get: function() {
                return a.bindExpression
            }
        }),
        Object.defineProperty(r, "BlockStatement", {
            enumerable: !0,
            get: function() {
                return a.blockStatement
            }
        }),
        Object.defineProperty(r, "BooleanLiteral", {
            enumerable: !0,
            get: function() {
                return a.booleanLiteral
            }
        }),
        Object.defineProperty(r, "BooleanLiteralTypeAnnotation", {
            enumerable: !0,
            get: function() {
                return a.booleanLiteralTypeAnnotation
            }
        }),
        Object.defineProperty(r, "BooleanTypeAnnotation", {
            enumerable: !0,
            get: function() {
                return a.booleanTypeAnnotation
            }
        }),
        Object.defineProperty(r, "BreakStatement", {
            enumerable: !0,
            get: function() {
                return a.breakStatement
            }
        }),
        Object.defineProperty(r, "CallExpression", {
            enumerable: !0,
            get: function() {
                return a.callExpression
            }
        }),
        Object.defineProperty(r, "CatchClause", {
            enumerable: !0,
            get: function() {
                return a.catchClause
            }
        }),
        Object.defineProperty(r, "ClassBody", {
            enumerable: !0,
            get: function() {
                return a.classBody
            }
        }),
        Object.defineProperty(r, "ClassDeclaration", {
            enumerable: !0,
            get: function() {
                return a.classDeclaration
            }
        }),
        Object.defineProperty(r, "ClassExpression", {
            enumerable: !0,
            get: function() {
                return a.classExpression
            }
        }),
        Object.defineProperty(r, "ClassImplements", {
            enumerable: !0,
            get: function() {
                return a.classImplements
            }
        }),
        Object.defineProperty(r, "ClassMethod", {
            enumerable: !0,
            get: function() {
                return a.classMethod
            }
        }),
        Object.defineProperty(r, "ClassPrivateMethod", {
            enumerable: !0,
            get: function() {
                return a.classPrivateMethod
            }
        }),
        Object.defineProperty(r, "ClassPrivateProperty", {
            enumerable: !0,
            get: function() {
                return a.classPrivateProperty
            }
        }),
        Object.defineProperty(r, "ClassProperty", {
            enumerable: !0,
            get: function() {
                return a.classProperty
            }
        }),
        Object.defineProperty(r, "ConditionalExpression", {
            enumerable: !0,
            get: function() {
                return a.conditionalExpression
            }
        }),
        Object.defineProperty(r, "ContinueStatement", {
            enumerable: !0,
            get: function() {
                return a.continueStatement
            }
        }),
        Object.defineProperty(r, "DebuggerStatement", {
            enumerable: !0,
            get: function() {
                return a.debuggerStatement
            }
        }),
        Object.defineProperty(r, "DecimalLiteral", {
            enumerable: !0,
            get: function() {
                return a.decimalLiteral
            }
        }),
        Object.defineProperty(r, "DeclareClass", {
            enumerable: !0,
            get: function() {
                return a.declareClass
            }
        }),
        Object.defineProperty(r, "DeclareExportAllDeclaration", {
            enumerable: !0,
            get: function() {
                return a.declareExportAllDeclaration
            }
        }),
        Object.defineProperty(r, "DeclareExportDeclaration", {
            enumerable: !0,
            get: function() {
                return a.declareExportDeclaration
            }
        }),
        Object.defineProperty(r, "DeclareFunction", {
            enumerable: !0,
            get: function() {
                return a.declareFunction
            }
        }),
        Object.defineProperty(r, "DeclareInterface", {
            enumerable: !0,
            get: function() {
                return a.declareInterface
            }
        }),
        Object.defineProperty(r, "DeclareModule", {
            enumerable: !0,
            get: function() {
                return a.declareModule
            }
        }),
        Object.defineProperty(r, "DeclareModuleExports", {
            enumerable: !0,
            get: function() {
                return a.declareModuleExports
            }
        }),
        Object.defineProperty(r, "DeclareOpaqueType", {
            enumerable: !0,
            get: function() {
                return a.declareOpaqueType
            }
        }),
        Object.defineProperty(r, "DeclareTypeAlias", {
            enumerable: !0,
            get: function() {
                return a.declareTypeAlias
            }
        }),
        Object.defineProperty(r, "DeclareVariable", {
            enumerable: !0,
            get: function() {
                return a.declareVariable
            }
        }),
        Object.defineProperty(r, "DeclaredPredicate", {
            enumerable: !0,
            get: function() {
                return a.declaredPredicate
            }
        }),
        Object.defineProperty(r, "Decorator", {
            enumerable: !0,
            get: function() {
                return a.decorator
            }
        }),
        Object.defineProperty(r, "Directive", {
            enumerable: !0,
            get: function() {
                return a.directive
            }
        }),
        Object.defineProperty(r, "DirectiveLiteral", {
            enumerable: !0,
            get: function() {
                return a.directiveLiteral
            }
        }),
        Object.defineProperty(r, "DoExpression", {
            enumerable: !0,
            get: function() {
                return a.doExpression
            }
        }),
        Object.defineProperty(r, "DoWhileStatement", {
            enumerable: !0,
            get: function() {
                return a.doWhileStatement
            }
        }),
        Object.defineProperty(r, "EmptyStatement", {
            enumerable: !0,
            get: function() {
                return a.emptyStatement
            }
        }),
        Object.defineProperty(r, "EmptyTypeAnnotation", {
            enumerable: !0,
            get: function() {
                return a.emptyTypeAnnotation
            }
        }),
        Object.defineProperty(r, "EnumBooleanBody", {
            enumerable: !0,
            get: function() {
                return a.enumBooleanBody
            }
        }),
        Object.defineProperty(r, "EnumBooleanMember", {
            enumerable: !0,
            get: function() {
                return a.enumBooleanMember
            }
        }),
        Object.defineProperty(r, "EnumDeclaration", {
            enumerable: !0,
            get: function() {
                return a.enumDeclaration
            }
        }),
        Object.defineProperty(r, "EnumDefaultedMember", {
            enumerable: !0,
            get: function() {
                return a.enumDefaultedMember
            }
        }),
        Object.defineProperty(r, "EnumNumberBody", {
            enumerable: !0,
            get: function() {
                return a.enumNumberBody
            }
        }),
        Object.defineProperty(r, "EnumNumberMember", {
            enumerable: !0,
            get: function() {
                return a.enumNumberMember
            }
        }),
        Object.defineProperty(r, "EnumStringBody", {
            enumerable: !0,
            get: function() {
                return a.enumStringBody
            }
        }),
        Object.defineProperty(r, "EnumStringMember", {
            enumerable: !0,
            get: function() {
                return a.enumStringMember
            }
        }),
        Object.defineProperty(r, "EnumSymbolBody", {
            enumerable: !0,
            get: function() {
                return a.enumSymbolBody
            }
        }),
        Object.defineProperty(r, "ExistsTypeAnnotation", {
            enumerable: !0,
            get: function() {
                return a.existsTypeAnnotation
            }
        }),
        Object.defineProperty(r, "ExportAllDeclaration", {
            enumerable: !0,
            get: function() {
                return a.exportAllDeclaration
            }
        }),
        Object.defineProperty(r, "ExportDefaultDeclaration", {
            enumerable: !0,
            get: function() {
                return a.exportDefaultDeclaration
            }
        }),
        Object.defineProperty(r, "ExportDefaultSpecifier", {
            enumerable: !0,
            get: function() {
                return a.exportDefaultSpecifier
            }
        }),
        Object.defineProperty(r, "ExportNamedDeclaration", {
            enumerable: !0,
            get: function() {
                return a.exportNamedDeclaration
            }
        }),
        Object.defineProperty(r, "ExportNamespaceSpecifier", {
            enumerable: !0,
            get: function() {
                return a.exportNamespaceSpecifier
            }
        }),
        Object.defineProperty(r, "ExportSpecifier", {
            enumerable: !0,
            get: function() {
                return a.exportSpecifier
            }
        }),
        Object.defineProperty(r, "ExpressionStatement", {
            enumerable: !0,
            get: function() {
                return a.expressionStatement
            }
        }),
        Object.defineProperty(r, "File", {
            enumerable: !0,
            get: function() {
                return a.file
            }
        }),
        Object.defineProperty(r, "ForInStatement", {
            enumerable: !0,
            get: function() {
                return a.forInStatement
            }
        }),
        Object.defineProperty(r, "ForOfStatement", {
            enumerable: !0,
            get: function() {
                return a.forOfStatement
            }
        }),
        Object.defineProperty(r, "ForStatement", {
            enumerable: !0,
            get: function() {
                return a.forStatement
            }
        }),
        Object.defineProperty(r, "FunctionDeclaration", {
            enumerable: !0,
            get: function() {
                return a.functionDeclaration
            }
        }),
        Object.defineProperty(r, "FunctionExpression", {
            enumerable: !0,
            get: function() {
                return a.functionExpression
            }
        }),
        Object.defineProperty(r, "FunctionTypeAnnotation", {
            enumerable: !0,
            get: function() {
                return a.functionTypeAnnotation
            }
        }),
        Object.defineProperty(r, "FunctionTypeParam", {
            enumerable: !0,
            get: function() {
                return a.functionTypeParam
            }
        }),
        Object.defineProperty(r, "GenericTypeAnnotation", {
            enumerable: !0,
            get: function() {
                return a.genericTypeAnnotation
            }
        }),
        Object.defineProperty(r, "Identifier", {
            enumerable: !0,
            get: function() {
                return a.identifier
            }
        }),
        Object.defineProperty(r, "IfStatement", {
            enumerable: !0,
            get: function() {
                return a.ifStatement
            }
        }),
        Object.defineProperty(r, "Import", {
            enumerable: !0,
            get: function() {
                return a.import
            }
        }),
        Object.defineProperty(r, "ImportAttribute", {
            enumerable: !0,
            get: function() {
                return a.importAttribute
            }
        }),
        Object.defineProperty(r, "ImportDeclaration", {
            enumerable: !0,
            get: function() {
                return a.importDeclaration
            }
        }),
        Object.defineProperty(r, "ImportDefaultSpecifier", {
            enumerable: !0,
            get: function() {
                return a.importDefaultSpecifier
            }
        }),
        Object.defineProperty(r, "ImportNamespaceSpecifier", {
            enumerable: !0,
            get: function() {
                return a.importNamespaceSpecifier
            }
        }),
        Object.defineProperty(r, "ImportSpecifier", {
            enumerable: !0,
            get: function() {
                return a.importSpecifier
            }
        }),
        Object.defineProperty(r, "IndexedAccessType", {
            enumerable: !0,
            get: function() {
                return a.indexedAccessType
            }
        }),
        Object.defineProperty(r, "InferredPredicate", {
            enumerable: !0,
            get: function() {
                return a.inferredPredicate
            }
        }),
        Object.defineProperty(r, "InterfaceDeclaration", {
            enumerable: !0,
            get: function() {
                return a.interfaceDeclaration
            }
        }),
        Object.defineProperty(r, "InterfaceExtends", {
            enumerable: !0,
            get: function() {
                return a.interfaceExtends
            }
        }),
        Object.defineProperty(r, "InterfaceTypeAnnotation", {
            enumerable: !0,
            get: function() {
                return a.interfaceTypeAnnotation
            }
        }),
        Object.defineProperty(r, "InterpreterDirective", {
            enumerable: !0,
            get: function() {
                return a.interpreterDirective
            }
        }),
        Object.defineProperty(r, "IntersectionTypeAnnotation", {
            enumerable: !0,
            get: function() {
                return a.intersectionTypeAnnotation
            }
        }),
        Object.defineProperty(r, "JSXAttribute", {
            enumerable: !0,
            get: function() {
                return a.jsxAttribute
            }
        }),
        Object.defineProperty(r, "JSXClosingElement", {
            enumerable: !0,
            get: function() {
                return a.jsxClosingElement
            }
        }),
        Object.defineProperty(r, "JSXClosingFragment", {
            enumerable: !0,
            get: function() {
                return a.jsxClosingFragment
            }
        }),
        Object.defineProperty(r, "JSXElement", {
            enumerable: !0,
            get: function() {
                return a.jsxElement
            }
        }),
        Object.defineProperty(r, "JSXEmptyExpression", {
            enumerable: !0,
            get: function() {
                return a.jsxEmptyExpression
            }
        }),
        Object.defineProperty(r, "JSXExpressionContainer", {
            enumerable: !0,
            get: function() {
                return a.jsxExpressionContainer
            }
        }),
        Object.defineProperty(r, "JSXFragment", {
            enumerable: !0,
            get: function() {
                return a.jsxFragment
            }
        }),
        Object.defineProperty(r, "JSXIdentifier", {
            enumerable: !0,
            get: function() {
                return a.jsxIdentifier
            }
        }),
        Object.defineProperty(r, "JSXMemberExpression", {
            enumerable: !0,
            get: function() {
                return a.jsxMemberExpression
            }
        }),
        Object.defineProperty(r, "JSXNamespacedName", {
            enumerable: !0,
            get: function() {
                return a.jsxNamespacedName
            }
        }),
        Object.defineProperty(r, "JSXOpeningElement", {
            enumerable: !0,
            get: function() {
                return a.jsxOpeningElement
            }
        }),
        Object.defineProperty(r, "JSXOpeningFragment", {
            enumerable: !0,
            get: function() {
                return a.jsxOpeningFragment
            }
        }),
        Object.defineProperty(r, "JSXSpreadAttribute", {
            enumerable: !0,
            get: function() {
                return a.jsxSpreadAttribute
            }
        }),
        Object.defineProperty(r, "JSXSpreadChild", {
            enumerable: !0,
            get: function() {
                return a.jsxSpreadChild
            }
        }),
        Object.defineProperty(r, "JSXText", {
            enumerable: !0,
            get: function() {
                return a.jsxText
            }
        }),
        Object.defineProperty(r, "LabeledStatement", {
            enumerable: !0,
            get: function() {
                return a.labeledStatement
            }
        }),
        Object.defineProperty(r, "LogicalExpression", {
            enumerable: !0,
            get: function() {
                return a.logicalExpression
            }
        }),
        Object.defineProperty(r, "MemberExpression", {
            enumerable: !0,
            get: function() {
                return a.memberExpression
            }
        }),
        Object.defineProperty(r, "MetaProperty", {
            enumerable: !0,
            get: function() {
                return a.metaProperty
            }
        }),
        Object.defineProperty(r, "MixedTypeAnnotation", {
            enumerable: !0,
            get: function() {
                return a.mixedTypeAnnotation
            }
        }),
        Object.defineProperty(r, "ModuleExpression", {
            enumerable: !0,
            get: function() {
                return a.moduleExpression
            }
        }),
        Object.defineProperty(r, "NewExpression", {
            enumerable: !0,
            get: function() {
                return a.newExpression
            }
        }),
        Object.defineProperty(r, "Noop", {
            enumerable: !0,
            get: function() {
                return a.noop
            }
        }),
        Object.defineProperty(r, "NullLiteral", {
            enumerable: !0,
            get: function() {
                return a.nullLiteral
            }
        }),
        Object.defineProperty(r, "NullLiteralTypeAnnotation", {
            enumerable: !0,
            get: function() {
                return a.nullLiteralTypeAnnotation
            }
        }),
        Object.defineProperty(r, "NullableTypeAnnotation", {
            enumerable: !0,
            get: function() {
                return a.nullableTypeAnnotation
            }
        }),
        Object.defineProperty(r, "NumberLiteral", {
            enumerable: !0,
            get: function() {
                return a.numberLiteral
            }
        }),
        Object.defineProperty(r, "NumberLiteralTypeAnnotation", {
            enumerable: !0,
            get: function() {
                return a.numberLiteralTypeAnnotation
            }
        }),
        Object.defineProperty(r, "NumberTypeAnnotation", {
            enumerable: !0,
            get: function() {
                return a.numberTypeAnnotation
            }
        }),
        Object.defineProperty(r, "NumericLiteral", {
            enumerable: !0,
            get: function() {
                return a.numericLiteral
            }
        }),
        Object.defineProperty(r, "ObjectExpression", {
            enumerable: !0,
            get: function() {
                return a.objectExpression
            }
        }),
        Object.defineProperty(r, "ObjectMethod", {
            enumerable: !0,
            get: function() {
                return a.objectMethod
            }
        }),
        Object.defineProperty(r, "ObjectPattern", {
            enumerable: !0,
            get: function() {
                return a.objectPattern
            }
        }),
        Object.defineProperty(r, "ObjectProperty", {
            enumerable: !0,
            get: function() {
                return a.objectProperty
            }
        }),
        Object.defineProperty(r, "ObjectTypeAnnotation", {
            enumerable: !0,
            get: function() {
                return a.objectTypeAnnotation
            }
        }),
        Object.defineProperty(r, "ObjectTypeCallProperty", {
            enumerable: !0,
            get: function() {
                return a.objectTypeCallProperty
            }
        }),
        Object.defineProperty(r, "ObjectTypeIndexer", {
            enumerable: !0,
            get: function() {
                return a.objectTypeIndexer
            }
        }),
        Object.defineProperty(r, "ObjectTypeInternalSlot", {
            enumerable: !0,
            get: function() {
                return a.objectTypeInternalSlot
            }
        }),
        Object.defineProperty(r, "ObjectTypeProperty", {
            enumerable: !0,
            get: function() {
                return a.objectTypeProperty
            }
        }),
        Object.defineProperty(r, "ObjectTypeSpreadProperty", {
            enumerable: !0,
            get: function() {
                return a.objectTypeSpreadProperty
            }
        }),
        Object.defineProperty(r, "OpaqueType", {
            enumerable: !0,
            get: function() {
                return a.opaqueType
            }
        }),
        Object.defineProperty(r, "OptionalCallExpression", {
            enumerable: !0,
            get: function() {
                return a.optionalCallExpression
            }
        }),
        Object.defineProperty(r, "OptionalIndexedAccessType", {
            enumerable: !0,
            get: function() {
                return a.optionalIndexedAccessType
            }
        }),
        Object.defineProperty(r, "OptionalMemberExpression", {
            enumerable: !0,
            get: function() {
                return a.optionalMemberExpression
            }
        }),
        Object.defineProperty(r, "ParenthesizedExpression", {
            enumerable: !0,
            get: function() {
                return a.parenthesizedExpression
            }
        }),
        Object.defineProperty(r, "PipelineBareFunction", {
            enumerable: !0,
            get: function() {
                return a.pipelineBareFunction
            }
        }),
        Object.defineProperty(r, "PipelinePrimaryTopicReference", {
            enumerable: !0,
            get: function() {
                return a.pipelinePrimaryTopicReference
            }
        }),
        Object.defineProperty(r, "PipelineTopicExpression", {
            enumerable: !0,
            get: function() {
                return a.pipelineTopicExpression
            }
        }),
        Object.defineProperty(r, "Placeholder", {
            enumerable: !0,
            get: function() {
                return a.placeholder
            }
        }),
        Object.defineProperty(r, "PrivateName", {
            enumerable: !0,
            get: function() {
                return a.privateName
            }
        }),
        Object.defineProperty(r, "Program", {
            enumerable: !0,
            get: function() {
                return a.program
            }
        }),
        Object.defineProperty(r, "QualifiedTypeIdentifier", {
            enumerable: !0,
            get: function() {
                return a.qualifiedTypeIdentifier
            }
        }),
        Object.defineProperty(r, "RecordExpression", {
            enumerable: !0,
            get: function() {
                return a.recordExpression
            }
        }),
        Object.defineProperty(r, "RegExpLiteral", {
            enumerable: !0,
            get: function() {
                return a.regExpLiteral
            }
        }),
        Object.defineProperty(r, "RegexLiteral", {
            enumerable: !0,
            get: function() {
                return a.regexLiteral
            }
        }),
        Object.defineProperty(r, "RestElement", {
            enumerable: !0,
            get: function() {
                return a.restElement
            }
        }),
        Object.defineProperty(r, "RestProperty", {
            enumerable: !0,
            get: function() {
                return a.restProperty
            }
        }),
        Object.defineProperty(r, "ReturnStatement", {
            enumerable: !0,
            get: function() {
                return a.returnStatement
            }
        }),
        Object.defineProperty(r, "SequenceExpression", {
            enumerable: !0,
            get: function() {
                return a.sequenceExpression
            }
        }),
        Object.defineProperty(r, "SpreadElement", {
            enumerable: !0,
            get: function() {
                return a.spreadElement
            }
        }),
        Object.defineProperty(r, "SpreadProperty", {
            enumerable: !0,
            get: function() {
                return a.spreadProperty
            }
        }),
        Object.defineProperty(r, "StaticBlock", {
            enumerable: !0,
            get: function() {
                return a.staticBlock
            }
        }),
        Object.defineProperty(r, "StringLiteral", {
            enumerable: !0,
            get: function() {
                return a.stringLiteral
            }
        }),
        Object.defineProperty(r, "StringLiteralTypeAnnotation", {
            enumerable: !0,
            get: function() {
                return a.stringLiteralTypeAnnotation
            }
        }),
        Object.defineProperty(r, "StringTypeAnnotation", {
            enumerable: !0,
            get: function() {
                return a.stringTypeAnnotation
            }
        }),
        Object.defineProperty(r, "Super", {
            enumerable: !0,
            get: function() {
                return a.super
            }
        }),
        Object.defineProperty(r, "SwitchCase", {
            enumerable: !0,
            get: function() {
                return a.switchCase
            }
        }),
        Object.defineProperty(r, "SwitchStatement", {
            enumerable: !0,
            get: function() {
                return a.switchStatement
            }
        }),
        Object.defineProperty(r, "SymbolTypeAnnotation", {
            enumerable: !0,
            get: function() {
                return a.symbolTypeAnnotation
            }
        }),
        Object.defineProperty(r, "TSAnyKeyword", {
            enumerable: !0,
            get: function() {
                return a.tsAnyKeyword
            }
        }),
        Object.defineProperty(r, "TSArrayType", {
            enumerable: !0,
            get: function() {
                return a.tsArrayType
            }
        }),
        Object.defineProperty(r, "TSAsExpression", {
            enumerable: !0,
            get: function() {
                return a.tsAsExpression
            }
        }),
        Object.defineProperty(r, "TSBigIntKeyword", {
            enumerable: !0,
            get: function() {
                return a.tsBigIntKeyword
            }
        }),
        Object.defineProperty(r, "TSBooleanKeyword", {
            enumerable: !0,
            get: function() {
                return a.tsBooleanKeyword
            }
        }),
        Object.defineProperty(r, "TSCallSignatureDeclaration", {
            enumerable: !0,
            get: function() {
                return a.tsCallSignatureDeclaration
            }
        }),
        Object.defineProperty(r, "TSConditionalType", {
            enumerable: !0,
            get: function() {
                return a.tsConditionalType
            }
        }),
        Object.defineProperty(r, "TSConstructSignatureDeclaration", {
            enumerable: !0,
            get: function() {
                return a.tsConstructSignatureDeclaration
            }
        }),
        Object.defineProperty(r, "TSConstructorType", {
            enumerable: !0,
            get: function() {
                return a.tsConstructorType
            }
        }),
        Object.defineProperty(r, "TSDeclareFunction", {
            enumerable: !0,
            get: function() {
                return a.tsDeclareFunction
            }
        }),
        Object.defineProperty(r, "TSDeclareMethod", {
            enumerable: !0,
            get: function() {
                return a.tsDeclareMethod
            }
        }),
        Object.defineProperty(r, "TSEnumDeclaration", {
            enumerable: !0,
            get: function() {
                return a.tsEnumDeclaration
            }
        }),
        Object.defineProperty(r, "TSEnumMember", {
            enumerable: !0,
            get: function() {
                return a.tsEnumMember
            }
        }),
        Object.defineProperty(r, "TSExportAssignment", {
            enumerable: !0,
            get: function() {
                return a.tsExportAssignment
            }
        }),
        Object.defineProperty(r, "TSExpressionWithTypeArguments", {
            enumerable: !0,
            get: function() {
                return a.tsExpressionWithTypeArguments
            }
        }),
        Object.defineProperty(r, "TSExternalModuleReference", {
            enumerable: !0,
            get: function() {
                return a.tsExternalModuleReference
            }
        }),
        Object.defineProperty(r, "TSFunctionType", {
            enumerable: !0,
            get: function() {
                return a.tsFunctionType
            }
        }),
        Object.defineProperty(r, "TSImportEqualsDeclaration", {
            enumerable: !0,
            get: function() {
                return a.tsImportEqualsDeclaration
            }
        }),
        Object.defineProperty(r, "TSImportType", {
            enumerable: !0,
            get: function() {
                return a.tsImportType
            }
        }),
        Object.defineProperty(r, "TSIndexSignature", {
            enumerable: !0,
            get: function() {
                return a.tsIndexSignature
            }
        }),
        Object.defineProperty(r, "TSIndexedAccessType", {
            enumerable: !0,
            get: function() {
                return a.tsIndexedAccessType
            }
        }),
        Object.defineProperty(r, "TSInferType", {
            enumerable: !0,
            get: function() {
                return a.tsInferType
            }
        }),
        Object.defineProperty(r, "TSInterfaceBody", {
            enumerable: !0,
            get: function() {
                return a.tsInterfaceBody
            }
        }),
        Object.defineProperty(r, "TSInterfaceDeclaration", {
            enumerable: !0,
            get: function() {
                return a.tsInterfaceDeclaration
            }
        }),
        Object.defineProperty(r, "TSIntersectionType", {
            enumerable: !0,
            get: function() {
                return a.tsIntersectionType
            }
        }),
        Object.defineProperty(r, "TSIntrinsicKeyword", {
            enumerable: !0,
            get: function() {
                return a.tsIntrinsicKeyword
            }
        }),
        Object.defineProperty(r, "TSLiteralType", {
            enumerable: !0,
            get: function() {
                return a.tsLiteralType
            }
        }),
        Object.defineProperty(r, "TSMappedType", {
            enumerable: !0,
            get: function() {
                return a.tsMappedType
            }
        }),
        Object.defineProperty(r, "TSMethodSignature", {
            enumerable: !0,
            get: function() {
                return a.tsMethodSignature
            }
        }),
        Object.defineProperty(r, "TSModuleBlock", {
            enumerable: !0,
            get: function() {
                return a.tsModuleBlock
            }
        }),
        Object.defineProperty(r, "TSModuleDeclaration", {
            enumerable: !0,
            get: function() {
                return a.tsModuleDeclaration
            }
        }),
        Object.defineProperty(r, "TSNamedTupleMember", {
            enumerable: !0,
            get: function() {
                return a.tsNamedTupleMember
            }
        }),
        Object.defineProperty(r, "TSNamespaceExportDeclaration", {
            enumerable: !0,
            get: function() {
                return a.tsNamespaceExportDeclaration
            }
        }),
        Object.defineProperty(r, "TSNeverKeyword", {
            enumerable: !0,
            get: function() {
                return a.tsNeverKeyword
            }
        }),
        Object.defineProperty(r, "TSNonNullExpression", {
            enumerable: !0,
            get: function() {
                return a.tsNonNullExpression
            }
        }),
        Object.defineProperty(r, "TSNullKeyword", {
            enumerable: !0,
            get: function() {
                return a.tsNullKeyword
            }
        }),
        Object.defineProperty(r, "TSNumberKeyword", {
            enumerable: !0,
            get: function() {
                return a.tsNumberKeyword
            }
        }),
        Object.defineProperty(r, "TSObjectKeyword", {
            enumerable: !0,
            get: function() {
                return a.tsObjectKeyword
            }
        }),
        Object.defineProperty(r, "TSOptionalType", {
            enumerable: !0,
            get: function() {
                return a.tsOptionalType
            }
        }),
        Object.defineProperty(r, "TSParameterProperty", {
            enumerable: !0,
            get: function() {
                return a.tsParameterProperty
            }
        }),
        Object.defineProperty(r, "TSParenthesizedType", {
            enumerable: !0,
            get: function() {
                return a.tsParenthesizedType
            }
        }),
        Object.defineProperty(r, "TSPropertySignature", {
            enumerable: !0,
            get: function() {
                return a.tsPropertySignature
            }
        }),
        Object.defineProperty(r, "TSQualifiedName", {
            enumerable: !0,
            get: function() {
                return a.tsQualifiedName
            }
        }),
        Object.defineProperty(r, "TSRestType", {
            enumerable: !0,
            get: function() {
                return a.tsRestType
            }
        }),
        Object.defineProperty(r, "TSStringKeyword", {
            enumerable: !0,
            get: function() {
                return a.tsStringKeyword
            }
        }),
        Object.defineProperty(r, "TSSymbolKeyword", {
            enumerable: !0,
            get: function() {
                return a.tsSymbolKeyword
            }
        }),
        Object.defineProperty(r, "TSThisType", {
            enumerable: !0,
            get: function() {
                return a.tsThisType
            }
        }),
        Object.defineProperty(r, "TSTupleType", {
            enumerable: !0,
            get: function() {
                return a.tsTupleType
            }
        }),
        Object.defineProperty(r, "TSTypeAliasDeclaration", {
            enumerable: !0,
            get: function() {
                return a.tsTypeAliasDeclaration
            }
        }),
        Object.defineProperty(r, "TSTypeAnnotation", {
            enumerable: !0,
            get: function() {
                return a.tsTypeAnnotation
            }
        }),
        Object.defineProperty(r, "TSTypeAssertion", {
            enumerable: !0,
            get: function() {
                return a.tsTypeAssertion
            }
        }),
        Object.defineProperty(r, "TSTypeLiteral", {
            enumerable: !0,
            get: function() {
                return a.tsTypeLiteral
            }
        }),
        Object.defineProperty(r, "TSTypeOperator", {
            enumerable: !0,
            get: function() {
                return a.tsTypeOperator
            }
        }),
        Object.defineProperty(r, "TSTypeParameter", {
            enumerable: !0,
            get: function() {
                return a.tsTypeParameter
            }
        }),
        Object.defineProperty(r, "TSTypeParameterDeclaration", {
            enumerable: !0,
            get: function() {
                return a.tsTypeParameterDeclaration
            }
        }),
        Object.defineProperty(r, "TSTypeParameterInstantiation", {
            enumerable: !0,
            get: function() {
                return a.tsTypeParameterInstantiation
            }
        }),
        Object.defineProperty(r, "TSTypePredicate", {
            enumerable: !0,
            get: function() {
                return a.tsTypePredicate
            }
        }),
        Object.defineProperty(r, "TSTypeQuery", {
            enumerable: !0,
            get: function() {
                return a.tsTypeQuery
            }
        }),
        Object.defineProperty(r, "TSTypeReference", {
            enumerable: !0,
            get: function() {
                return a.tsTypeReference
            }
        }),
        Object.defineProperty(r, "TSUndefinedKeyword", {
            enumerable: !0,
            get: function() {
                return a.tsUndefinedKeyword
            }
        }),
        Object.defineProperty(r, "TSUnionType", {
            enumerable: !0,
            get: function() {
                return a.tsUnionType
            }
        }),
        Object.defineProperty(r, "TSUnknownKeyword", {
            enumerable: !0,
            get: function() {
                return a.tsUnknownKeyword
            }
        }),
        Object.defineProperty(r, "TSVoidKeyword", {
            enumerable: !0,
            get: function() {
                return a.tsVoidKeyword
            }
        }),
        Object.defineProperty(r, "TaggedTemplateExpression", {
            enumerable: !0,
            get: function() {
                return a.taggedTemplateExpression
            }
        }),
        Object.defineProperty(r, "TemplateElement", {
            enumerable: !0,
            get: function() {
                return a.templateElement
            }
        }),
        Object.defineProperty(r, "TemplateLiteral", {
            enumerable: !0,
            get: function() {
                return a.templateLiteral
            }
        }),
        Object.defineProperty(r, "ThisExpression", {
            enumerable: !0,
            get: function() {
                return a.thisExpression
            }
        }),
        Object.defineProperty(r, "ThisTypeAnnotation", {
            enumerable: !0,
            get: function() {
                return a.thisTypeAnnotation
            }
        }),
        Object.defineProperty(r, "ThrowStatement", {
            enumerable: !0,
            get: function() {
                return a.throwStatement
            }
        }),
        Object.defineProperty(r, "TopicReference", {
            enumerable: !0,
            get: function() {
                return a.topicReference
            }
        }),
        Object.defineProperty(r, "TryStatement", {
            enumerable: !0,
            get: function() {
                return a.tryStatement
            }
        }),
        Object.defineProperty(r, "TupleExpression", {
            enumerable: !0,
            get: function() {
                return a.tupleExpression
            }
        }),
        Object.defineProperty(r, "TupleTypeAnnotation", {
            enumerable: !0,
            get: function() {
                return a.tupleTypeAnnotation
            }
        }),
        Object.defineProperty(r, "TypeAlias", {
            enumerable: !0,
            get: function() {
                return a.typeAlias
            }
        }),
        Object.defineProperty(r, "TypeAnnotation", {
            enumerable: !0,
            get: function() {
                return a.typeAnnotation
            }
        }),
        Object.defineProperty(r, "TypeCastExpression", {
            enumerable: !0,
            get: function() {
                return a.typeCastExpression
            }
        }),
        Object.defineProperty(r, "TypeParameter", {
            enumerable: !0,
            get: function() {
                return a.typeParameter
            }
        }),
        Object.defineProperty(r, "TypeParameterDeclaration", {
            enumerable: !0,
            get: function() {
                return a.typeParameterDeclaration
            }
        }),
        Object.defineProperty(r, "TypeParameterInstantiation", {
            enumerable: !0,
            get: function() {
                return a.typeParameterInstantiation
            }
        }),
        Object.defineProperty(r, "TypeofTypeAnnotation", {
            enumerable: !0,
            get: function() {
                return a.typeofTypeAnnotation
            }
        }),
        Object.defineProperty(r, "UnaryExpression", {
            enumerable: !0,
            get: function() {
                return a.unaryExpression
            }
        }),
        Object.defineProperty(r, "UnionTypeAnnotation", {
            enumerable: !0,
            get: function() {
                return a.unionTypeAnnotation
            }
        }),
        Object.defineProperty(r, "UpdateExpression", {
            enumerable: !0,
            get: function() {
                return a.updateExpression
            }
        }),
        Object.defineProperty(r, "V8IntrinsicIdentifier", {
            enumerable: !0,
            get: function() {
                return a.v8IntrinsicIdentifier
            }
        }),
        Object.defineProperty(r, "VariableDeclaration", {
            enumerable: !0,
            get: function() {
                return a.variableDeclaration
            }
        }),
        Object.defineProperty(r, "VariableDeclarator", {
            enumerable: !0,
            get: function() {
                return a.variableDeclarator
            }
        }),
        Object.defineProperty(r, "Variance", {
            enumerable: !0,
            get: function() {
                return a.variance
            }
        }),
        Object.defineProperty(r, "VoidTypeAnnotation", {
            enumerable: !0,
            get: function() {
                return a.voidTypeAnnotation
            }
        }),
        Object.defineProperty(r, "WhileStatement", {
            enumerable: !0,
            get: function() {
                return a.whileStatement
            }
        }),
        Object.defineProperty(r, "WithStatement", {
            enumerable: !0,
            get: function() {
                return a.withStatement
            }
        }),
        Object.defineProperty(r, "YieldExpression", {
            enumerable: !0,
            get: function() {
                return a.yieldExpression
            }
        });
        var a = i("61uC")
    },
    lsUB: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function removePropertiesDeep(t, r) {
            return (0,
            a.default)(t, o.default, r),
            t
        }
        ;
        var a = i("+FIw")
          , o = i("YFjm")
    },
    lxMW: function(t, r, i) {
        "use strict";
        var a = i("7ePq")
          , o = i("DrtQ")
          , l = i("0G7A")
          , u = (0,
        a.assertValueType)("boolean")
          , p = {
            returnType: {
                validate: (0,
                a.assertNodeType)("TSTypeAnnotation", "Noop"),
                optional: !0
            },
            typeParameters: {
                validate: (0,
                a.assertNodeType)("TSTypeParameterDeclaration", "Noop"),
                optional: !0
            }
        };
        (0,
        a.default)("TSParameterProperty", {
            aliases: ["LVal"],
            visitor: ["parameter"],
            fields: {
                accessibility: {
                    validate: (0,
                    a.assertOneOf)("public", "private", "protected"),
                    optional: !0
                },
                readonly: {
                    validate: (0,
                    a.assertValueType)("boolean"),
                    optional: !0
                },
                parameter: {
                    validate: (0,
                    a.assertNodeType)("Identifier", "AssignmentPattern")
                },
                override: {
                    validate: (0,
                    a.assertValueType)("boolean"),
                    optional: !0
                },
                decorators: {
                    validate: (0,
                    a.chain)((0,
                    a.assertValueType)("array"), (0,
                    a.assertEach)((0,
                    a.assertNodeType)("Decorator"))),
                    optional: !0
                }
            }
        }),
        (0,
        a.default)("TSDeclareFunction", {
            aliases: ["Statement", "Declaration"],
            visitor: ["id", "typeParameters", "params", "returnType"],
            fields: Object.assign({}, o.functionDeclarationCommon, p)
        }),
        (0,
        a.default)("TSDeclareMethod", {
            visitor: ["decorators", "key", "typeParameters", "params", "returnType"],
            fields: Object.assign({}, o.classMethodOrDeclareMethodCommon, p)
        }),
        (0,
        a.default)("TSQualifiedName", {
            aliases: ["TSEntityName"],
            visitor: ["left", "right"],
            fields: {
                left: (0,
                a.validateType)("TSEntityName"),
                right: (0,
                a.validateType)("Identifier")
            }
        });
        var c = {
            typeParameters: (0,
            a.validateOptionalType)("TSTypeParameterDeclaration"),
            parameters: (0,
            a.validateArrayOfType)(["Identifier", "RestElement"]),
            typeAnnotation: (0,
            a.validateOptionalType)("TSTypeAnnotation")
        }
          , d = {
            aliases: ["TSTypeElement"],
            visitor: ["typeParameters", "parameters", "typeAnnotation"],
            fields: c
        };
        (0,
        a.default)("TSCallSignatureDeclaration", d),
        (0,
        a.default)("TSConstructSignatureDeclaration", d);
        var y = {
            key: (0,
            a.validateType)("Expression"),
            computed: (0,
            a.validate)(u),
            optional: (0,
            a.validateOptional)(u)
        };
        (0,
        a.default)("TSPropertySignature", {
            aliases: ["TSTypeElement"],
            visitor: ["key", "typeAnnotation", "initializer"],
            fields: Object.assign({}, y, {
                readonly: (0,
                a.validateOptional)(u),
                typeAnnotation: (0,
                a.validateOptionalType)("TSTypeAnnotation"),
                initializer: (0,
                a.validateOptionalType)("Expression"),
                kind: {
                    validate: (0,
                    a.assertOneOf)("get", "set")
                }
            })
        }),
        (0,
        a.default)("TSMethodSignature", {
            aliases: ["TSTypeElement"],
            visitor: ["key", "typeParameters", "parameters", "typeAnnotation"],
            fields: Object.assign({}, c, y, {
                kind: {
                    validate: (0,
                    a.assertOneOf)("method", "get", "set")
                }
            })
        }),
        (0,
        a.default)("TSIndexSignature", {
            aliases: ["TSTypeElement"],
            visitor: ["parameters", "typeAnnotation"],
            fields: {
                readonly: (0,
                a.validateOptional)(u),
                static: (0,
                a.validateOptional)(u),
                parameters: (0,
                a.validateArrayOfType)("Identifier"),
                typeAnnotation: (0,
                a.validateOptionalType)("TSTypeAnnotation")
            }
        });
        for (var h = 0, m = ["TSAnyKeyword", "TSBooleanKeyword", "TSBigIntKeyword", "TSIntrinsicKeyword", "TSNeverKeyword", "TSNullKeyword", "TSNumberKeyword", "TSObjectKeyword", "TSStringKeyword", "TSSymbolKeyword", "TSUndefinedKeyword", "TSUnknownKeyword", "TSVoidKeyword"]; h < m.length; h++) {
            var T = m[h];
            (0,
            a.default)(T, {
                aliases: ["TSType", "TSBaseType"],
                visitor: [],
                fields: {}
            })
        }
        (0,
        a.default)("TSThisType", {
            aliases: ["TSType", "TSBaseType"],
            visitor: [],
            fields: {}
        });
        var S = {
            aliases: ["TSType"],
            visitor: ["typeParameters", "parameters", "typeAnnotation"]
        };
        (0,
        a.default)("TSFunctionType", Object.assign({}, S, {
            fields: c
        })),
        (0,
        a.default)("TSConstructorType", Object.assign({}, S, {
            fields: Object.assign({}, c, {
                abstract: (0,
                a.validateOptional)(u)
            })
        })),
        (0,
        a.default)("TSTypeReference", {
            aliases: ["TSType"],
            visitor: ["typeName", "typeParameters"],
            fields: {
                typeName: (0,
                a.validateType)("TSEntityName"),
                typeParameters: (0,
                a.validateOptionalType)("TSTypeParameterInstantiation")
            }
        }),
        (0,
        a.default)("TSTypePredicate", {
            aliases: ["TSType"],
            visitor: ["parameterName", "typeAnnotation"],
            builder: ["parameterName", "typeAnnotation", "asserts"],
            fields: {
                parameterName: (0,
                a.validateType)(["Identifier", "TSThisType"]),
                typeAnnotation: (0,
                a.validateOptionalType)("TSTypeAnnotation"),
                asserts: (0,
                a.validateOptional)(u)
            }
        }),
        (0,
        a.default)("TSTypeQuery", {
            aliases: ["TSType"],
            visitor: ["exprName"],
            fields: {
                exprName: (0,
                a.validateType)(["TSEntityName", "TSImportType"])
            }
        }),
        (0,
        a.default)("TSTypeLiteral", {
            aliases: ["TSType"],
            visitor: ["members"],
            fields: {
                members: (0,
                a.validateArrayOfType)("TSTypeElement")
            }
        }),
        (0,
        a.default)("TSArrayType", {
            aliases: ["TSType"],
            visitor: ["elementType"],
            fields: {
                elementType: (0,
                a.validateType)("TSType")
            }
        }),
        (0,
        a.default)("TSTupleType", {
            aliases: ["TSType"],
            visitor: ["elementTypes"],
            fields: {
                elementTypes: (0,
                a.validateArrayOfType)(["TSType", "TSNamedTupleMember"])
            }
        }),
        (0,
        a.default)("TSOptionalType", {
            aliases: ["TSType"],
            visitor: ["typeAnnotation"],
            fields: {
                typeAnnotation: (0,
                a.validateType)("TSType")
            }
        }),
        (0,
        a.default)("TSRestType", {
            aliases: ["TSType"],
            visitor: ["typeAnnotation"],
            fields: {
                typeAnnotation: (0,
                a.validateType)("TSType")
            }
        }),
        (0,
        a.default)("TSNamedTupleMember", {
            visitor: ["label", "elementType"],
            builder: ["label", "elementType", "optional"],
            fields: {
                label: (0,
                a.validateType)("Identifier"),
                optional: {
                    validate: u,
                    default: !1
                },
                elementType: (0,
                a.validateType)("TSType")
            }
        });
        var g = {
            aliases: ["TSType"],
            visitor: ["types"],
            fields: {
                types: (0,
                a.validateArrayOfType)("TSType")
            }
        };
        (0,
        a.default)("TSUnionType", g),
        (0,
        a.default)("TSIntersectionType", g),
        (0,
        a.default)("TSConditionalType", {
            aliases: ["TSType"],
            visitor: ["checkType", "extendsType", "trueType", "falseType"],
            fields: {
                checkType: (0,
                a.validateType)("TSType"),
                extendsType: (0,
                a.validateType)("TSType"),
                trueType: (0,
                a.validateType)("TSType"),
                falseType: (0,
                a.validateType)("TSType")
            }
        }),
        (0,
        a.default)("TSInferType", {
            aliases: ["TSType"],
            visitor: ["typeParameter"],
            fields: {
                typeParameter: (0,
                a.validateType)("TSTypeParameter")
            }
        }),
        (0,
        a.default)("TSParenthesizedType", {
            aliases: ["TSType"],
            visitor: ["typeAnnotation"],
            fields: {
                typeAnnotation: (0,
                a.validateType)("TSType")
            }
        }),
        (0,
        a.default)("TSTypeOperator", {
            aliases: ["TSType"],
            visitor: ["typeAnnotation"],
            fields: {
                operator: (0,
                a.validate)((0,
                a.assertValueType)("string")),
                typeAnnotation: (0,
                a.validateType)("TSType")
            }
        }),
        (0,
        a.default)("TSIndexedAccessType", {
            aliases: ["TSType"],
            visitor: ["objectType", "indexType"],
            fields: {
                objectType: (0,
                a.validateType)("TSType"),
                indexType: (0,
                a.validateType)("TSType")
            }
        }),
        (0,
        a.default)("TSMappedType", {
            aliases: ["TSType"],
            visitor: ["typeParameter", "typeAnnotation", "nameType"],
            fields: {
                readonly: (0,
                a.validateOptional)(u),
                typeParameter: (0,
                a.validateType)("TSTypeParameter"),
                optional: (0,
                a.validateOptional)(u),
                typeAnnotation: (0,
                a.validateOptionalType)("TSType"),
                nameType: (0,
                a.validateOptionalType)("TSType")
            }
        }),
        (0,
        a.default)("TSLiteralType", {
            aliases: ["TSType", "TSBaseType"],
            visitor: ["literal"],
            fields: {
                literal: {
                    validate: function() {
                        var t = (0,
                        a.assertNodeType)("NumericLiteral", "BigIntLiteral")
                          , r = (0,
                        a.assertOneOf)("-")
                          , i = (0,
                        a.assertNodeType)("NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral");
                        function validator(a, o, u) {
                            (0,
                            l.default)("UnaryExpression", u) ? (r(u, "operator", u.operator),
                            t(u, "argument", u.argument)) : i(a, o, u)
                        }
                        return validator.oneOfNodeTypes = ["NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral", "UnaryExpression"],
                        validator
                    }()
                }
            }
        }),
        (0,
        a.default)("TSExpressionWithTypeArguments", {
            aliases: ["TSType"],
            visitor: ["expression", "typeParameters"],
            fields: {
                expression: (0,
                a.validateType)("TSEntityName"),
                typeParameters: (0,
                a.validateOptionalType)("TSTypeParameterInstantiation")
            }
        }),
        (0,
        a.default)("TSInterfaceDeclaration", {
            aliases: ["Statement", "Declaration"],
            visitor: ["id", "typeParameters", "extends", "body"],
            fields: {
                declare: (0,
                a.validateOptional)(u),
                id: (0,
                a.validateType)("Identifier"),
                typeParameters: (0,
                a.validateOptionalType)("TSTypeParameterDeclaration"),
                extends: (0,
                a.validateOptional)((0,
                a.arrayOfType)("TSExpressionWithTypeArguments")),
                body: (0,
                a.validateType)("TSInterfaceBody")
            }
        }),
        (0,
        a.default)("TSInterfaceBody", {
            visitor: ["body"],
            fields: {
                body: (0,
                a.validateArrayOfType)("TSTypeElement")
            }
        }),
        (0,
        a.default)("TSTypeAliasDeclaration", {
            aliases: ["Statement", "Declaration"],
            visitor: ["id", "typeParameters", "typeAnnotation"],
            fields: {
                declare: (0,
                a.validateOptional)(u),
                id: (0,
                a.validateType)("Identifier"),
                typeParameters: (0,
                a.validateOptionalType)("TSTypeParameterDeclaration"),
                typeAnnotation: (0,
                a.validateType)("TSType")
            }
        }),
        (0,
        a.default)("TSAsExpression", {
            aliases: ["Expression"],
            visitor: ["expression", "typeAnnotation"],
            fields: {
                expression: (0,
                a.validateType)("Expression"),
                typeAnnotation: (0,
                a.validateType)("TSType")
            }
        }),
        (0,
        a.default)("TSTypeAssertion", {
            aliases: ["Expression"],
            visitor: ["typeAnnotation", "expression"],
            fields: {
                typeAnnotation: (0,
                a.validateType)("TSType"),
                expression: (0,
                a.validateType)("Expression")
            }
        }),
        (0,
        a.default)("TSEnumDeclaration", {
            aliases: ["Statement", "Declaration"],
            visitor: ["id", "members"],
            fields: {
                declare: (0,
                a.validateOptional)(u),
                const: (0,
                a.validateOptional)(u),
                id: (0,
                a.validateType)("Identifier"),
                members: (0,
                a.validateArrayOfType)("TSEnumMember"),
                initializer: (0,
                a.validateOptionalType)("Expression")
            }
        }),
        (0,
        a.default)("TSEnumMember", {
            visitor: ["id", "initializer"],
            fields: {
                id: (0,
                a.validateType)(["Identifier", "StringLiteral"]),
                initializer: (0,
                a.validateOptionalType)("Expression")
            }
        }),
        (0,
        a.default)("TSModuleDeclaration", {
            aliases: ["Statement", "Declaration"],
            visitor: ["id", "body"],
            fields: {
                declare: (0,
                a.validateOptional)(u),
                global: (0,
                a.validateOptional)(u),
                id: (0,
                a.validateType)(["Identifier", "StringLiteral"]),
                body: (0,
                a.validateType)(["TSModuleBlock", "TSModuleDeclaration"])
            }
        }),
        (0,
        a.default)("TSModuleBlock", {
            aliases: ["Scopable", "Block", "BlockParent"],
            visitor: ["body"],
            fields: {
                body: (0,
                a.validateArrayOfType)("Statement")
            }
        }),
        (0,
        a.default)("TSImportType", {
            aliases: ["TSType"],
            visitor: ["argument", "qualifier", "typeParameters"],
            fields: {
                argument: (0,
                a.validateType)("StringLiteral"),
                qualifier: (0,
                a.validateOptionalType)("TSEntityName"),
                typeParameters: (0,
                a.validateOptionalType)("TSTypeParameterInstantiation")
            }
        }),
        (0,
        a.default)("TSImportEqualsDeclaration", {
            aliases: ["Statement"],
            visitor: ["id", "moduleReference"],
            fields: {
                isExport: (0,
                a.validate)(u),
                id: (0,
                a.validateType)("Identifier"),
                moduleReference: (0,
                a.validateType)(["TSEntityName", "TSExternalModuleReference"]),
                importKind: {
                    validate: (0,
                    a.assertOneOf)("type", "value"),
                    optional: !0
                }
            }
        }),
        (0,
        a.default)("TSExternalModuleReference", {
            visitor: ["expression"],
            fields: {
                expression: (0,
                a.validateType)("StringLiteral")
            }
        }),
        (0,
        a.default)("TSNonNullExpression", {
            aliases: ["Expression"],
            visitor: ["expression"],
            fields: {
                expression: (0,
                a.validateType)("Expression")
            }
        }),
        (0,
        a.default)("TSExportAssignment", {
            aliases: ["Statement"],
            visitor: ["expression"],
            fields: {
                expression: (0,
                a.validateType)("Expression")
            }
        }),
        (0,
        a.default)("TSNamespaceExportDeclaration", {
            aliases: ["Statement"],
            visitor: ["id"],
            fields: {
                id: (0,
                a.validateType)("Identifier")
            }
        }),
        (0,
        a.default)("TSTypeAnnotation", {
            visitor: ["typeAnnotation"],
            fields: {
                typeAnnotation: {
                    validate: (0,
                    a.assertNodeType)("TSType")
                }
            }
        }),
        (0,
        a.default)("TSTypeParameterInstantiation", {
            visitor: ["params"],
            fields: {
                params: {
                    validate: (0,
                    a.chain)((0,
                    a.assertValueType)("array"), (0,
                    a.assertEach)((0,
                    a.assertNodeType)("TSType")))
                }
            }
        }),
        (0,
        a.default)("TSTypeParameterDeclaration", {
            visitor: ["params"],
            fields: {
                params: {
                    validate: (0,
                    a.chain)((0,
                    a.assertValueType)("array"), (0,
                    a.assertEach)((0,
                    a.assertNodeType)("TSTypeParameter")))
                }
            }
        }),
        (0,
        a.default)("TSTypeParameter", {
            builder: ["constraint", "default", "name"],
            visitor: ["constraint", "default"],
            fields: {
                name: {
                    validate: (0,
                    a.assertValueType)("string")
                },
                constraint: {
                    validate: (0,
                    a.assertNodeType)("TSType"),
                    optional: !0
                },
                default: {
                    validate: (0,
                    a.assertNodeType)("TSType"),
                    optional: !0
                }
            }
        })
    },
    "m+63": function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = void 0;
        var a = i("AMU3");
        r.default = class SourceMap {
            constructor(t, r) {
                this._cachedMap = void 0,
                this._code = void 0,
                this._opts = void 0,
                this._rawMappings = void 0,
                this._lastGenLine = void 0,
                this._lastSourceLine = void 0,
                this._lastSourceColumn = void 0,
                this._cachedMap = null,
                this._code = r,
                this._opts = t,
                this._rawMappings = []
            }
            get() {
                if (!this._cachedMap) {
                    const t = this._cachedMap = new a.SourceMapGenerator({
                        sourceRoot: this._opts.sourceRoot
                    })
                      , r = this._code;
                    "string" == typeof r ? t.setSourceContent(this._opts.sourceFileName.replace(/\\/g, "/"), r) : "object" == typeof r && Object.keys(r).forEach(i=>{
                        t.setSourceContent(i.replace(/\\/g, "/"), r[i])
                    }
                    ),
                    this._rawMappings.forEach(r=>t.addMapping(r), t)
                }
                return this._cachedMap.toJSON()
            }
            getRawMappings() {
                return this._rawMappings.slice()
            }
            mark(t, r, i, a, o, l, u) {
                this._lastGenLine !== t && null === i || (u || this._lastGenLine !== t || this._lastSourceLine !== i || this._lastSourceColumn !== a) && (this._cachedMap = null,
                this._lastGenLine = t,
                this._lastSourceLine = i,
                this._lastSourceColumn = a,
                this._rawMappings.push({
                    name: o || void 0,
                    generated: {
                        line: t,
                        column: r
                    },
                    source: null == i ? void 0 : (l || this._opts.sourceFileName).replace(/\\/g, "/"),
                    original: null == i ? void 0 : {
                        line: i,
                        column: a
                    }
                }))
            }
        }
    },
    m5M9: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function assertNode(t) {
            if (!(0,
            a.default)(t)) {
                var r;
                const i = null != (r = null == t ? void 0 : t.type) ? r : JSON.stringify(t);
                throw new TypeError(`Not a valid node of type "${i}"`)
            }
        }
        ;
        var a = i("L4Kc")
    },
    mObf: function(t, r) {
        var i = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
        r.encode = function(t) {
            if (0 <= t && t < i.length)
                return i[t];
            throw new TypeError("Must be between 0 and 63: " + t)
        }
        ,
        r.decode = function(t) {
            return 65 <= t && t <= 90 ? t - 65 : 97 <= t && t <= 122 ? t - 97 + 26 : 48 <= t && t <= 57 ? t - 48 + 52 : 43 == t ? 62 : 47 == t ? 63 : -1
        }
    },
    mXO1: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function removePropertiesDeep(t, r) {
            return (0,
            a.default)(t, o.default, r),
            t
        }
        ;
        var a = i("+v0W")
          , o = i("X6wd")
    },
    mXTk: function(t, r, i) {
        "use strict";
        var a = i("TqRt")(i("RIqP"));
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function addComments(t, r, i) {
            if (!i || !t)
                return t;
            var o = "".concat(r, "Comments");
            if (t[o]) {
                var l;
                if ("leading" === r)
                    t[o] = i.concat(t[o]);
                else
                    (l = t[o]).push.apply(l, (0,
                    a.default)(i))
            } else
                t[o] = i;
            return t
        }
    },
    mgDx: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function isValidES3Identifier(t) {
            return (0,
            a.default)(t) && !o.has(t)
        }
        ;
        var a = i("ucPi");
        const o = new Set(["abstract", "boolean", "byte", "char", "double", "enum", "final", "float", "goto", "implements", "int", "interface", "long", "native", "package", "private", "protected", "public", "short", "static", "synchronized", "throws", "transient", "volatile"])
    },
    mj3m: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function isSpecifierDefault(t) {
            return (0,
            a.isImportDefaultSpecifier)(t) || (0,
            a.isIdentifier)(t.imported || t.exported, {
                name: "default"
            })
        }
        ;
        var a = i("xIU+")
    },
    n5Ud: function(t) {
        t.exports = JSON.parse('{"builtin":{"Array":false,"ArrayBuffer":false,"Atomics":false,"BigInt":false,"BigInt64Array":false,"BigUint64Array":false,"Boolean":false,"constructor":false,"DataView":false,"Date":false,"decodeURI":false,"decodeURIComponent":false,"encodeURI":false,"encodeURIComponent":false,"Error":false,"escape":false,"eval":false,"EvalError":false,"Float32Array":false,"Float64Array":false,"Function":false,"globalThis":false,"hasOwnProperty":false,"Infinity":false,"Int16Array":false,"Int32Array":false,"Int8Array":false,"isFinite":false,"isNaN":false,"isPrototypeOf":false,"JSON":false,"Map":false,"Math":false,"NaN":false,"Number":false,"Object":false,"parseFloat":false,"parseInt":false,"Promise":false,"propertyIsEnumerable":false,"Proxy":false,"RangeError":false,"ReferenceError":false,"Reflect":false,"RegExp":false,"Set":false,"SharedArrayBuffer":false,"String":false,"Symbol":false,"SyntaxError":false,"toLocaleString":false,"toString":false,"TypeError":false,"Uint16Array":false,"Uint32Array":false,"Uint8Array":false,"Uint8ClampedArray":false,"undefined":false,"unescape":false,"URIError":false,"valueOf":false,"WeakMap":false,"WeakSet":false},"es5":{"Array":false,"Boolean":false,"constructor":false,"Date":false,"decodeURI":false,"decodeURIComponent":false,"encodeURI":false,"encodeURIComponent":false,"Error":false,"escape":false,"eval":false,"EvalError":false,"Function":false,"hasOwnProperty":false,"Infinity":false,"isFinite":false,"isNaN":false,"isPrototypeOf":false,"JSON":false,"Math":false,"NaN":false,"Number":false,"Object":false,"parseFloat":false,"parseInt":false,"propertyIsEnumerable":false,"RangeError":false,"ReferenceError":false,"RegExp":false,"String":false,"SyntaxError":false,"toLocaleString":false,"toString":false,"TypeError":false,"undefined":false,"unescape":false,"URIError":false,"valueOf":false},"es2015":{"Array":false,"ArrayBuffer":false,"Boolean":false,"constructor":false,"DataView":false,"Date":false,"decodeURI":false,"decodeURIComponent":false,"encodeURI":false,"encodeURIComponent":false,"Error":false,"escape":false,"eval":false,"EvalError":false,"Float32Array":false,"Float64Array":false,"Function":false,"hasOwnProperty":false,"Infinity":false,"Int16Array":false,"Int32Array":false,"Int8Array":false,"isFinite":false,"isNaN":false,"isPrototypeOf":false,"JSON":false,"Map":false,"Math":false,"NaN":false,"Number":false,"Object":false,"parseFloat":false,"parseInt":false,"Promise":false,"propertyIsEnumerable":false,"Proxy":false,"RangeError":false,"ReferenceError":false,"Reflect":false,"RegExp":false,"Set":false,"String":false,"Symbol":false,"SyntaxError":false,"toLocaleString":false,"toString":false,"TypeError":false,"Uint16Array":false,"Uint32Array":false,"Uint8Array":false,"Uint8ClampedArray":false,"undefined":false,"unescape":false,"URIError":false,"valueOf":false,"WeakMap":false,"WeakSet":false},"es2017":{"Array":false,"ArrayBuffer":false,"Atomics":false,"Boolean":false,"constructor":false,"DataView":false,"Date":false,"decodeURI":false,"decodeURIComponent":false,"encodeURI":false,"encodeURIComponent":false,"Error":false,"escape":false,"eval":false,"EvalError":false,"Float32Array":false,"Float64Array":false,"Function":false,"hasOwnProperty":false,"Infinity":false,"Int16Array":false,"Int32Array":false,"Int8Array":false,"isFinite":false,"isNaN":false,"isPrototypeOf":false,"JSON":false,"Map":false,"Math":false,"NaN":false,"Number":false,"Object":false,"parseFloat":false,"parseInt":false,"Promise":false,"propertyIsEnumerable":false,"Proxy":false,"RangeError":false,"ReferenceError":false,"Reflect":false,"RegExp":false,"Set":false,"SharedArrayBuffer":false,"String":false,"Symbol":false,"SyntaxError":false,"toLocaleString":false,"toString":false,"TypeError":false,"Uint16Array":false,"Uint32Array":false,"Uint8Array":false,"Uint8ClampedArray":false,"undefined":false,"unescape":false,"URIError":false,"valueOf":false,"WeakMap":false,"WeakSet":false},"browser":{"AbortController":false,"AbortSignal":false,"addEventListener":false,"alert":false,"AnalyserNode":false,"Animation":false,"AnimationEffectReadOnly":false,"AnimationEffectTiming":false,"AnimationEffectTimingReadOnly":false,"AnimationEvent":false,"AnimationPlaybackEvent":false,"AnimationTimeline":false,"applicationCache":false,"ApplicationCache":false,"ApplicationCacheErrorEvent":false,"atob":false,"Attr":false,"Audio":false,"AudioBuffer":false,"AudioBufferSourceNode":false,"AudioContext":false,"AudioDestinationNode":false,"AudioListener":false,"AudioNode":false,"AudioParam":false,"AudioProcessingEvent":false,"AudioScheduledSourceNode":false,"AudioWorkletGlobalScope ":false,"AudioWorkletNode":false,"AudioWorkletProcessor":false,"BarProp":false,"BaseAudioContext":false,"BatteryManager":false,"BeforeUnloadEvent":false,"BiquadFilterNode":false,"Blob":false,"BlobEvent":false,"blur":false,"BroadcastChannel":false,"btoa":false,"BudgetService":false,"ByteLengthQueuingStrategy":false,"Cache":false,"caches":false,"CacheStorage":false,"cancelAnimationFrame":false,"cancelIdleCallback":false,"CanvasCaptureMediaStreamTrack":false,"CanvasGradient":false,"CanvasPattern":false,"CanvasRenderingContext2D":false,"ChannelMergerNode":false,"ChannelSplitterNode":false,"CharacterData":false,"clearInterval":false,"clearTimeout":false,"clientInformation":false,"ClipboardEvent":false,"close":false,"closed":false,"CloseEvent":false,"Comment":false,"CompositionEvent":false,"confirm":false,"console":false,"ConstantSourceNode":false,"ConvolverNode":false,"CountQueuingStrategy":false,"createImageBitmap":false,"Credential":false,"CredentialsContainer":false,"crypto":false,"Crypto":false,"CryptoKey":false,"CSS":false,"CSSConditionRule":false,"CSSFontFaceRule":false,"CSSGroupingRule":false,"CSSImportRule":false,"CSSKeyframeRule":false,"CSSKeyframesRule":false,"CSSMediaRule":false,"CSSNamespaceRule":false,"CSSPageRule":false,"CSSRule":false,"CSSRuleList":false,"CSSStyleDeclaration":false,"CSSStyleRule":false,"CSSStyleSheet":false,"CSSSupportsRule":false,"CustomElementRegistry":false,"customElements":false,"CustomEvent":false,"DataTransfer":false,"DataTransferItem":false,"DataTransferItemList":false,"defaultstatus":false,"defaultStatus":false,"DelayNode":false,"DeviceMotionEvent":false,"DeviceOrientationEvent":false,"devicePixelRatio":false,"dispatchEvent":false,"document":false,"Document":false,"DocumentFragment":false,"DocumentType":false,"DOMError":false,"DOMException":false,"DOMImplementation":false,"DOMMatrix":false,"DOMMatrixReadOnly":false,"DOMParser":false,"DOMPoint":false,"DOMPointReadOnly":false,"DOMQuad":false,"DOMRect":false,"DOMRectReadOnly":false,"DOMStringList":false,"DOMStringMap":false,"DOMTokenList":false,"DragEvent":false,"DynamicsCompressorNode":false,"Element":false,"ErrorEvent":false,"event":false,"Event":false,"EventSource":false,"EventTarget":false,"external":false,"fetch":false,"File":false,"FileList":false,"FileReader":false,"find":false,"focus":false,"FocusEvent":false,"FontFace":false,"FontFaceSetLoadEvent":false,"FormData":false,"frameElement":false,"frames":false,"GainNode":false,"Gamepad":false,"GamepadButton":false,"GamepadEvent":false,"getComputedStyle":false,"getSelection":false,"HashChangeEvent":false,"Headers":false,"history":false,"History":false,"HTMLAllCollection":false,"HTMLAnchorElement":false,"HTMLAreaElement":false,"HTMLAudioElement":false,"HTMLBaseElement":false,"HTMLBodyElement":false,"HTMLBRElement":false,"HTMLButtonElement":false,"HTMLCanvasElement":false,"HTMLCollection":false,"HTMLContentElement":false,"HTMLDataElement":false,"HTMLDataListElement":false,"HTMLDetailsElement":false,"HTMLDialogElement":false,"HTMLDirectoryElement":false,"HTMLDivElement":false,"HTMLDListElement":false,"HTMLDocument":false,"HTMLElement":false,"HTMLEmbedElement":false,"HTMLFieldSetElement":false,"HTMLFontElement":false,"HTMLFormControlsCollection":false,"HTMLFormElement":false,"HTMLFrameElement":false,"HTMLFrameSetElement":false,"HTMLHeadElement":false,"HTMLHeadingElement":false,"HTMLHRElement":false,"HTMLHtmlElement":false,"HTMLIFrameElement":false,"HTMLImageElement":false,"HTMLInputElement":false,"HTMLLabelElement":false,"HTMLLegendElement":false,"HTMLLIElement":false,"HTMLLinkElement":false,"HTMLMapElement":false,"HTMLMarqueeElement":false,"HTMLMediaElement":false,"HTMLMenuElement":false,"HTMLMetaElement":false,"HTMLMeterElement":false,"HTMLModElement":false,"HTMLObjectElement":false,"HTMLOListElement":false,"HTMLOptGroupElement":false,"HTMLOptionElement":false,"HTMLOptionsCollection":false,"HTMLOutputElement":false,"HTMLParagraphElement":false,"HTMLParamElement":false,"HTMLPictureElement":false,"HTMLPreElement":false,"HTMLProgressElement":false,"HTMLQuoteElement":false,"HTMLScriptElement":false,"HTMLSelectElement":false,"HTMLShadowElement":false,"HTMLSlotElement":false,"HTMLSourceElement":false,"HTMLSpanElement":false,"HTMLStyleElement":false,"HTMLTableCaptionElement":false,"HTMLTableCellElement":false,"HTMLTableColElement":false,"HTMLTableElement":false,"HTMLTableRowElement":false,"HTMLTableSectionElement":false,"HTMLTemplateElement":false,"HTMLTextAreaElement":false,"HTMLTimeElement":false,"HTMLTitleElement":false,"HTMLTrackElement":false,"HTMLUListElement":false,"HTMLUnknownElement":false,"HTMLVideoElement":false,"IDBCursor":false,"IDBCursorWithValue":false,"IDBDatabase":false,"IDBFactory":false,"IDBIndex":false,"IDBKeyRange":false,"IDBObjectStore":false,"IDBOpenDBRequest":false,"IDBRequest":false,"IDBTransaction":false,"IDBVersionChangeEvent":false,"IdleDeadline":false,"IIRFilterNode":false,"Image":false,"ImageBitmap":false,"ImageBitmapRenderingContext":false,"ImageCapture":false,"ImageData":false,"indexedDB":false,"innerHeight":false,"innerWidth":false,"InputEvent":false,"IntersectionObserver":false,"IntersectionObserverEntry":false,"Intl":false,"isSecureContext":false,"KeyboardEvent":false,"KeyframeEffect":false,"KeyframeEffectReadOnly":false,"length":false,"localStorage":false,"location":true,"Location":false,"locationbar":false,"matchMedia":false,"MediaDeviceInfo":false,"MediaDevices":false,"MediaElementAudioSourceNode":false,"MediaEncryptedEvent":false,"MediaError":false,"MediaKeyMessageEvent":false,"MediaKeySession":false,"MediaKeyStatusMap":false,"MediaKeySystemAccess":false,"MediaList":false,"MediaQueryList":false,"MediaQueryListEvent":false,"MediaRecorder":false,"MediaSettingsRange":false,"MediaSource":false,"MediaStream":false,"MediaStreamAudioDestinationNode":false,"MediaStreamAudioSourceNode":false,"MediaStreamEvent":false,"MediaStreamTrack":false,"MediaStreamTrackEvent":false,"menubar":false,"MessageChannel":false,"MessageEvent":false,"MessagePort":false,"MIDIAccess":false,"MIDIConnectionEvent":false,"MIDIInput":false,"MIDIInputMap":false,"MIDIMessageEvent":false,"MIDIOutput":false,"MIDIOutputMap":false,"MIDIPort":false,"MimeType":false,"MimeTypeArray":false,"MouseEvent":false,"moveBy":false,"moveTo":false,"MutationEvent":false,"MutationObserver":false,"MutationRecord":false,"name":false,"NamedNodeMap":false,"NavigationPreloadManager":false,"navigator":false,"Navigator":false,"NetworkInformation":false,"Node":false,"NodeFilter":false,"NodeIterator":false,"NodeList":false,"Notification":false,"OfflineAudioCompletionEvent":false,"OfflineAudioContext":false,"offscreenBuffering":false,"OffscreenCanvas":true,"onabort":true,"onafterprint":true,"onanimationend":true,"onanimationiteration":true,"onanimationstart":true,"onappinstalled":true,"onauxclick":true,"onbeforeinstallprompt":true,"onbeforeprint":true,"onbeforeunload":true,"onblur":true,"oncancel":true,"oncanplay":true,"oncanplaythrough":true,"onchange":true,"onclick":true,"onclose":true,"oncontextmenu":true,"oncuechange":true,"ondblclick":true,"ondevicemotion":true,"ondeviceorientation":true,"ondeviceorientationabsolute":true,"ondrag":true,"ondragend":true,"ondragenter":true,"ondragleave":true,"ondragover":true,"ondragstart":true,"ondrop":true,"ondurationchange":true,"onemptied":true,"onended":true,"onerror":true,"onfocus":true,"ongotpointercapture":true,"onhashchange":true,"oninput":true,"oninvalid":true,"onkeydown":true,"onkeypress":true,"onkeyup":true,"onlanguagechange":true,"onload":true,"onloadeddata":true,"onloadedmetadata":true,"onloadstart":true,"onlostpointercapture":true,"onmessage":true,"onmessageerror":true,"onmousedown":true,"onmouseenter":true,"onmouseleave":true,"onmousemove":true,"onmouseout":true,"onmouseover":true,"onmouseup":true,"onmousewheel":true,"onoffline":true,"ononline":true,"onpagehide":true,"onpageshow":true,"onpause":true,"onplay":true,"onplaying":true,"onpointercancel":true,"onpointerdown":true,"onpointerenter":true,"onpointerleave":true,"onpointermove":true,"onpointerout":true,"onpointerover":true,"onpointerup":true,"onpopstate":true,"onprogress":true,"onratechange":true,"onrejectionhandled":true,"onreset":true,"onresize":true,"onscroll":true,"onsearch":true,"onseeked":true,"onseeking":true,"onselect":true,"onstalled":true,"onstorage":true,"onsubmit":true,"onsuspend":true,"ontimeupdate":true,"ontoggle":true,"ontransitionend":true,"onunhandledrejection":true,"onunload":true,"onvolumechange":true,"onwaiting":true,"onwheel":true,"open":false,"openDatabase":false,"opener":false,"Option":false,"origin":false,"OscillatorNode":false,"outerHeight":false,"outerWidth":false,"PageTransitionEvent":false,"pageXOffset":false,"pageYOffset":false,"PannerNode":false,"parent":false,"Path2D":false,"PaymentAddress":false,"PaymentRequest":false,"PaymentRequestUpdateEvent":false,"PaymentResponse":false,"performance":false,"Performance":false,"PerformanceEntry":false,"PerformanceLongTaskTiming":false,"PerformanceMark":false,"PerformanceMeasure":false,"PerformanceNavigation":false,"PerformanceNavigationTiming":false,"PerformanceObserver":false,"PerformanceObserverEntryList":false,"PerformancePaintTiming":false,"PerformanceResourceTiming":false,"PerformanceTiming":false,"PeriodicWave":false,"Permissions":false,"PermissionStatus":false,"personalbar":false,"PhotoCapabilities":false,"Plugin":false,"PluginArray":false,"PointerEvent":false,"PopStateEvent":false,"postMessage":false,"Presentation":false,"PresentationAvailability":false,"PresentationConnection":false,"PresentationConnectionAvailableEvent":false,"PresentationConnectionCloseEvent":false,"PresentationConnectionList":false,"PresentationReceiver":false,"PresentationRequest":false,"print":false,"ProcessingInstruction":false,"ProgressEvent":false,"PromiseRejectionEvent":false,"prompt":false,"PushManager":false,"PushSubscription":false,"PushSubscriptionOptions":false,"queueMicrotask":false,"RadioNodeList":false,"Range":false,"ReadableStream":false,"registerProcessor":false,"RemotePlayback":false,"removeEventListener":false,"Request":false,"requestAnimationFrame":false,"requestIdleCallback":false,"resizeBy":false,"ResizeObserver":false,"ResizeObserverEntry":false,"resizeTo":false,"Response":false,"RTCCertificate":false,"RTCDataChannel":false,"RTCDataChannelEvent":false,"RTCDtlsTransport":false,"RTCIceCandidate":false,"RTCIceGatherer":false,"RTCIceTransport":false,"RTCPeerConnection":false,"RTCPeerConnectionIceEvent":false,"RTCRtpContributingSource":false,"RTCRtpReceiver":false,"RTCRtpSender":false,"RTCSctpTransport":false,"RTCSessionDescription":false,"RTCStatsReport":false,"RTCTrackEvent":false,"screen":false,"Screen":false,"screenLeft":false,"ScreenOrientation":false,"screenTop":false,"screenX":false,"screenY":false,"ScriptProcessorNode":false,"scroll":false,"scrollbars":false,"scrollBy":false,"scrollTo":false,"scrollX":false,"scrollY":false,"SecurityPolicyViolationEvent":false,"Selection":false,"self":false,"ServiceWorker":false,"ServiceWorkerContainer":false,"ServiceWorkerRegistration":false,"sessionStorage":false,"setInterval":false,"setTimeout":false,"ShadowRoot":false,"SharedWorker":false,"SourceBuffer":false,"SourceBufferList":false,"speechSynthesis":false,"SpeechSynthesisEvent":false,"SpeechSynthesisUtterance":false,"StaticRange":false,"status":false,"statusbar":false,"StereoPannerNode":false,"stop":false,"Storage":false,"StorageEvent":false,"StorageManager":false,"styleMedia":false,"StyleSheet":false,"StyleSheetList":false,"SubtleCrypto":false,"SVGAElement":false,"SVGAngle":false,"SVGAnimatedAngle":false,"SVGAnimatedBoolean":false,"SVGAnimatedEnumeration":false,"SVGAnimatedInteger":false,"SVGAnimatedLength":false,"SVGAnimatedLengthList":false,"SVGAnimatedNumber":false,"SVGAnimatedNumberList":false,"SVGAnimatedPreserveAspectRatio":false,"SVGAnimatedRect":false,"SVGAnimatedString":false,"SVGAnimatedTransformList":false,"SVGAnimateElement":false,"SVGAnimateMotionElement":false,"SVGAnimateTransformElement":false,"SVGAnimationElement":false,"SVGCircleElement":false,"SVGClipPathElement":false,"SVGComponentTransferFunctionElement":false,"SVGDefsElement":false,"SVGDescElement":false,"SVGDiscardElement":false,"SVGElement":false,"SVGEllipseElement":false,"SVGFEBlendElement":false,"SVGFEColorMatrixElement":false,"SVGFEComponentTransferElement":false,"SVGFECompositeElement":false,"SVGFEConvolveMatrixElement":false,"SVGFEDiffuseLightingElement":false,"SVGFEDisplacementMapElement":false,"SVGFEDistantLightElement":false,"SVGFEDropShadowElement":false,"SVGFEFloodElement":false,"SVGFEFuncAElement":false,"SVGFEFuncBElement":false,"SVGFEFuncGElement":false,"SVGFEFuncRElement":false,"SVGFEGaussianBlurElement":false,"SVGFEImageElement":false,"SVGFEMergeElement":false,"SVGFEMergeNodeElement":false,"SVGFEMorphologyElement":false,"SVGFEOffsetElement":false,"SVGFEPointLightElement":false,"SVGFESpecularLightingElement":false,"SVGFESpotLightElement":false,"SVGFETileElement":false,"SVGFETurbulenceElement":false,"SVGFilterElement":false,"SVGForeignObjectElement":false,"SVGGElement":false,"SVGGeometryElement":false,"SVGGradientElement":false,"SVGGraphicsElement":false,"SVGImageElement":false,"SVGLength":false,"SVGLengthList":false,"SVGLinearGradientElement":false,"SVGLineElement":false,"SVGMarkerElement":false,"SVGMaskElement":false,"SVGMatrix":false,"SVGMetadataElement":false,"SVGMPathElement":false,"SVGNumber":false,"SVGNumberList":false,"SVGPathElement":false,"SVGPatternElement":false,"SVGPoint":false,"SVGPointList":false,"SVGPolygonElement":false,"SVGPolylineElement":false,"SVGPreserveAspectRatio":false,"SVGRadialGradientElement":false,"SVGRect":false,"SVGRectElement":false,"SVGScriptElement":false,"SVGSetElement":false,"SVGStopElement":false,"SVGStringList":false,"SVGStyleElement":false,"SVGSVGElement":false,"SVGSwitchElement":false,"SVGSymbolElement":false,"SVGTextContentElement":false,"SVGTextElement":false,"SVGTextPathElement":false,"SVGTextPositioningElement":false,"SVGTitleElement":false,"SVGTransform":false,"SVGTransformList":false,"SVGTSpanElement":false,"SVGUnitTypes":false,"SVGUseElement":false,"SVGViewElement":false,"TaskAttributionTiming":false,"Text":false,"TextDecoder":false,"TextEncoder":false,"TextEvent":false,"TextMetrics":false,"TextTrack":false,"TextTrackCue":false,"TextTrackCueList":false,"TextTrackList":false,"TimeRanges":false,"toolbar":false,"top":false,"Touch":false,"TouchEvent":false,"TouchList":false,"TrackEvent":false,"TransitionEvent":false,"TreeWalker":false,"UIEvent":false,"URL":false,"URLSearchParams":false,"ValidityState":false,"visualViewport":false,"VisualViewport":false,"VTTCue":false,"WaveShaperNode":false,"WebAssembly":false,"WebGL2RenderingContext":false,"WebGLActiveInfo":false,"WebGLBuffer":false,"WebGLContextEvent":false,"WebGLFramebuffer":false,"WebGLProgram":false,"WebGLQuery":false,"WebGLRenderbuffer":false,"WebGLRenderingContext":false,"WebGLSampler":false,"WebGLShader":false,"WebGLShaderPrecisionFormat":false,"WebGLSync":false,"WebGLTexture":false,"WebGLTransformFeedback":false,"WebGLUniformLocation":false,"WebGLVertexArrayObject":false,"WebSocket":false,"WheelEvent":false,"window":false,"Window":false,"Worker":false,"WritableStream":false,"XMLDocument":false,"XMLHttpRequest":false,"XMLHttpRequestEventTarget":false,"XMLHttpRequestUpload":false,"XMLSerializer":false,"XPathEvaluator":false,"XPathExpression":false,"XPathResult":false,"XSLTProcessor":false},"worker":{"addEventListener":false,"applicationCache":false,"atob":false,"Blob":false,"BroadcastChannel":false,"btoa":false,"Cache":false,"caches":false,"clearInterval":false,"clearTimeout":false,"close":true,"console":false,"fetch":false,"FileReaderSync":false,"FormData":false,"Headers":false,"IDBCursor":false,"IDBCursorWithValue":false,"IDBDatabase":false,"IDBFactory":false,"IDBIndex":false,"IDBKeyRange":false,"IDBObjectStore":false,"IDBOpenDBRequest":false,"IDBRequest":false,"IDBTransaction":false,"IDBVersionChangeEvent":false,"ImageData":false,"importScripts":true,"indexedDB":false,"location":false,"MessageChannel":false,"MessagePort":false,"name":false,"navigator":false,"Notification":false,"onclose":true,"onconnect":true,"onerror":true,"onlanguagechange":true,"onmessage":true,"onoffline":true,"ononline":true,"onrejectionhandled":true,"onunhandledrejection":true,"performance":false,"Performance":false,"PerformanceEntry":false,"PerformanceMark":false,"PerformanceMeasure":false,"PerformanceNavigation":false,"PerformanceResourceTiming":false,"PerformanceTiming":false,"postMessage":true,"Promise":false,"queueMicrotask":false,"removeEventListener":false,"Request":false,"Response":false,"self":true,"ServiceWorkerRegistration":false,"setInterval":false,"setTimeout":false,"TextDecoder":false,"TextEncoder":false,"URL":false,"URLSearchParams":false,"WebSocket":false,"Worker":false,"WorkerGlobalScope":false,"XMLHttpRequest":false},"node":{"__dirname":false,"__filename":false,"Buffer":false,"clearImmediate":false,"clearInterval":false,"clearTimeout":false,"console":false,"exports":true,"global":false,"Intl":false,"module":false,"process":false,"queueMicrotask":false,"require":false,"setImmediate":false,"setInterval":false,"setTimeout":false,"TextDecoder":false,"TextEncoder":false,"URL":false,"URLSearchParams":false},"commonjs":{"exports":true,"global":false,"module":false,"require":false},"amd":{"define":false,"require":false},"mocha":{"after":false,"afterEach":false,"before":false,"beforeEach":false,"context":false,"describe":false,"it":false,"mocha":false,"run":false,"setup":false,"specify":false,"suite":false,"suiteSetup":false,"suiteTeardown":false,"teardown":false,"test":false,"xcontext":false,"xdescribe":false,"xit":false,"xspecify":false},"jasmine":{"afterAll":false,"afterEach":false,"beforeAll":false,"beforeEach":false,"describe":false,"expect":false,"fail":false,"fdescribe":false,"fit":false,"it":false,"jasmine":false,"pending":false,"runs":false,"spyOn":false,"spyOnProperty":false,"waits":false,"waitsFor":false,"xdescribe":false,"xit":false},"jest":{"afterAll":false,"afterEach":false,"beforeAll":false,"beforeEach":false,"describe":false,"expect":false,"fdescribe":false,"fit":false,"it":false,"jest":false,"pit":false,"require":false,"test":false,"xdescribe":false,"xit":false,"xtest":false},"qunit":{"asyncTest":false,"deepEqual":false,"equal":false,"expect":false,"module":false,"notDeepEqual":false,"notEqual":false,"notOk":false,"notPropEqual":false,"notStrictEqual":false,"ok":false,"propEqual":false,"QUnit":false,"raises":false,"start":false,"stop":false,"strictEqual":false,"test":false,"throws":false},"phantomjs":{"console":true,"exports":true,"phantom":true,"require":true,"WebPage":true},"couch":{"emit":false,"exports":false,"getRow":false,"log":false,"module":false,"provides":false,"require":false,"respond":false,"send":false,"start":false,"sum":false},"rhino":{"defineClass":false,"deserialize":false,"gc":false,"help":false,"importClass":false,"importPackage":false,"java":false,"load":false,"loadClass":false,"Packages":false,"print":false,"quit":false,"readFile":false,"readUrl":false,"runCommand":false,"seal":false,"serialize":false,"spawn":false,"sync":false,"toint32":false,"version":false},"nashorn":{"__DIR__":false,"__FILE__":false,"__LINE__":false,"com":false,"edu":false,"exit":false,"java":false,"Java":false,"javafx":false,"JavaImporter":false,"javax":false,"JSAdapter":false,"load":false,"loadWithNewGlobal":false,"org":false,"Packages":false,"print":false,"quit":false},"wsh":{"ActiveXObject":true,"Enumerator":true,"GetObject":true,"ScriptEngine":true,"ScriptEngineBuildVersion":true,"ScriptEngineMajorVersion":true,"ScriptEngineMinorVersion":true,"VBArray":true,"WScript":true,"WSH":true,"XDomainRequest":true},"jquery":{"$":false,"jQuery":false},"yui":{"YAHOO":false,"YAHOO_config":false,"YUI":false,"YUI_config":false},"shelljs":{"cat":false,"cd":false,"chmod":false,"config":false,"cp":false,"dirs":false,"echo":false,"env":false,"error":false,"exec":false,"exit":false,"find":false,"grep":false,"ln":false,"ls":false,"mkdir":false,"mv":false,"popd":false,"pushd":false,"pwd":false,"rm":false,"sed":false,"set":false,"target":false,"tempdir":false,"test":false,"touch":false,"which":false},"prototypejs":{"$":false,"$$":false,"$A":false,"$break":false,"$continue":false,"$F":false,"$H":false,"$R":false,"$w":false,"Abstract":false,"Ajax":false,"Autocompleter":false,"Builder":false,"Class":false,"Control":false,"Draggable":false,"Draggables":false,"Droppables":false,"Effect":false,"Element":false,"Enumerable":false,"Event":false,"Field":false,"Form":false,"Hash":false,"Insertion":false,"ObjectRange":false,"PeriodicalExecuter":false,"Position":false,"Prototype":false,"Scriptaculous":false,"Selector":false,"Sortable":false,"SortableObserver":false,"Sound":false,"Template":false,"Toggle":false,"Try":false},"meteor":{"_":false,"$":false,"Accounts":false,"AccountsClient":false,"AccountsCommon":false,"AccountsServer":false,"App":false,"Assets":false,"Blaze":false,"check":false,"Cordova":false,"DDP":false,"DDPRateLimiter":false,"DDPServer":false,"Deps":false,"EJSON":false,"Email":false,"HTTP":false,"Log":false,"Match":false,"Meteor":false,"Mongo":false,"MongoInternals":false,"Npm":false,"Package":false,"Plugin":false,"process":false,"Random":false,"ReactiveDict":false,"ReactiveVar":false,"Router":false,"ServiceConfiguration":false,"Session":false,"share":false,"Spacebars":false,"Template":false,"Tinytest":false,"Tracker":false,"UI":false,"Utils":false,"WebApp":false,"WebAppInternals":false},"mongo":{"_isWindows":false,"_rand":false,"BulkWriteResult":false,"cat":false,"cd":false,"connect":false,"db":false,"getHostName":false,"getMemInfo":false,"hostname":false,"ISODate":false,"listFiles":false,"load":false,"ls":false,"md5sumFile":false,"mkdir":false,"Mongo":false,"NumberInt":false,"NumberLong":false,"ObjectId":false,"PlanCache":false,"print":false,"printjson":false,"pwd":false,"quit":false,"removeFile":false,"rs":false,"sh":false,"UUID":false,"version":false,"WriteResult":false},"applescript":{"$":false,"Application":false,"Automation":false,"console":false,"delay":false,"Library":false,"ObjC":false,"ObjectSpecifier":false,"Path":false,"Progress":false,"Ref":false},"serviceworker":{"addEventListener":false,"applicationCache":false,"atob":false,"Blob":false,"BroadcastChannel":false,"btoa":false,"Cache":false,"caches":false,"CacheStorage":false,"clearInterval":false,"clearTimeout":false,"Client":false,"clients":false,"Clients":false,"close":true,"console":false,"ExtendableEvent":false,"ExtendableMessageEvent":false,"fetch":false,"FetchEvent":false,"FileReaderSync":false,"FormData":false,"Headers":false,"IDBCursor":false,"IDBCursorWithValue":false,"IDBDatabase":false,"IDBFactory":false,"IDBIndex":false,"IDBKeyRange":false,"IDBObjectStore":false,"IDBOpenDBRequest":false,"IDBRequest":false,"IDBTransaction":false,"IDBVersionChangeEvent":false,"ImageData":false,"importScripts":false,"indexedDB":false,"location":false,"MessageChannel":false,"MessagePort":false,"name":false,"navigator":false,"Notification":false,"onclose":true,"onconnect":true,"onerror":true,"onfetch":true,"oninstall":true,"onlanguagechange":true,"onmessage":true,"onmessageerror":true,"onnotificationclick":true,"onnotificationclose":true,"onoffline":true,"ononline":true,"onpush":true,"onpushsubscriptionchange":true,"onrejectionhandled":true,"onsync":true,"onunhandledrejection":true,"performance":false,"Performance":false,"PerformanceEntry":false,"PerformanceMark":false,"PerformanceMeasure":false,"PerformanceNavigation":false,"PerformanceResourceTiming":false,"PerformanceTiming":false,"postMessage":true,"Promise":false,"queueMicrotask":false,"registration":false,"removeEventListener":false,"Request":false,"Response":false,"self":false,"ServiceWorker":false,"ServiceWorkerContainer":false,"ServiceWorkerGlobalScope":false,"ServiceWorkerMessageEvent":false,"ServiceWorkerRegistration":false,"setInterval":false,"setTimeout":false,"skipWaiting":false,"TextDecoder":false,"TextEncoder":false,"URL":false,"URLSearchParams":false,"WebSocket":false,"WindowClient":false,"Worker":false,"WorkerGlobalScope":false,"XMLHttpRequest":false},"atomtest":{"advanceClock":false,"fakeClearInterval":false,"fakeClearTimeout":false,"fakeSetInterval":false,"fakeSetTimeout":false,"resetTimeouts":false,"waitsForPromise":false},"embertest":{"andThen":false,"click":false,"currentPath":false,"currentRouteName":false,"currentURL":false,"fillIn":false,"find":false,"findAll":false,"findWithAssert":false,"keyEvent":false,"pauseTest":false,"resumeTest":false,"triggerEvent":false,"visit":false,"wait":false},"protractor":{"$":false,"$$":false,"browser":false,"by":false,"By":false,"DartObject":false,"element":false,"protractor":false},"shared-node-browser":{"clearInterval":false,"clearTimeout":false,"console":false,"setInterval":false,"setTimeout":false,"URL":false,"URLSearchParams":false},"webextensions":{"browser":false,"chrome":false,"opr":false},"greasemonkey":{"cloneInto":false,"createObjectIn":false,"exportFunction":false,"GM":false,"GM_addStyle":false,"GM_deleteValue":false,"GM_getResourceText":false,"GM_getResourceURL":false,"GM_getValue":false,"GM_info":false,"GM_listValues":false,"GM_log":false,"GM_openInTab":false,"GM_registerMenuCommand":false,"GM_setClipboard":false,"GM_setValue":false,"GM_xmlhttpRequest":false,"unsafeWindow":false},"devtools":{"$":false,"$_":false,"$$":false,"$0":false,"$1":false,"$2":false,"$3":false,"$4":false,"$x":false,"chrome":false,"clear":false,"copy":false,"debug":false,"dir":false,"dirxml":false,"getEventListeners":false,"inspect":false,"keys":false,"monitor":false,"monitorEvents":false,"profile":false,"profileEnd":false,"queryObjects":false,"table":false,"undebug":false,"unmonitor":false,"unmonitorEvents":false,"values":false}}')
    },
    n9cs: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function addComment(t, r, i, o) {
            return (0,
            a.default)(t, r, [{
                type: o ? "CommentLine" : "CommentBlock",
                value: i
            }])
        }
        ;
        var a = i("mXTk")
    },
    nYh1: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function cleanJSXElementLiteralChild(t, r) {
            for (var i = t.value.split(/\r\n|\n|\r/), o = 0, l = 0; l < i.length; l++)
                i[l].match(/[^ \t]/) && (o = l);
            for (var u = "", p = 0; p < i.length; p++) {
                var c = i[p]
                  , d = 0 === p
                  , y = p === i.length - 1
                  , h = p === o
                  , m = c.replace(/\t/g, " ");
                d || (m = m.replace(/^[ ]+/, "")),
                y || (m = m.replace(/[ ]+$/, "")),
                m && (h || (m += " "),
                u += m)
            }
            u && r.push((0,
            a.stringLiteral)(u))
        }
        ;
        var a = i("UuI8")
    },
    nlFN: function(t, r, i) {
        "use strict";
        function _createForOfIteratorHelper(t, r) {
            var i = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
            if (!i) {
                if (Array.isArray(t) || (i = function _unsupportedIterableToArray(t, r) {
                    if (!t)
                        return;
                    if ("string" == typeof t)
                        return _arrayLikeToArray(t, r);
                    var i = Object.prototype.toString.call(t).slice(8, -1);
                    "Object" === i && t.constructor && (i = t.constructor.name);
                    if ("Map" === i || "Set" === i)
                        return Array.from(t);
                    if ("Arguments" === i || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i))
                        return _arrayLikeToArray(t, r)
                }(t)) || r && t && "number" == typeof t.length) {
                    i && (t = i);
                    var a = 0
                      , o = function F() {};
                    return {
                        s: o,
                        n: function n() {
                            return a >= t.length ? {
                                done: !0
                            } : {
                                done: !1,
                                value: t[a++]
                            }
                        },
                        e: function e(t) {
                            throw t
                        },
                        f: o
                    }
                }
                throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
            }
            var l, u = !0, p = !1;
            return {
                s: function s() {
                    i = i.call(t)
                },
                n: function n() {
                    var t = i.next();
                    return u = t.done,
                    t
                },
                e: function e(t) {
                    p = !0,
                    l = t
                },
                f: function f() {
                    try {
                        u || null == i.return || i.return()
                    } finally {
                        if (p)
                            throw l
                    }
                }
            }
        }
        function _arrayLikeToArray(t, r) {
            (null == r || r > t.length) && (r = t.length);
            for (var i = 0, a = new Array(r); i < r; i++)
                a[i] = t[i];
            return a
        }
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function _default(t) {
            if (!this.isReferenced())
                return;
            var r = this.scope.getBinding(t.name);
            if (r)
                return r.identifier.typeAnnotation ? r.identifier.typeAnnotation : function getTypeAnnotationBindingConstantViolations(t, r, i) {
                    var o = []
                      , l = []
                      , u = getConstantViolationsBefore(t, r, l)
                      , p = function getConditionalAnnotation(t, r, i) {
                        var o = function getParentConditionalPath(t, r, i) {
                            var a;
                            for (; a = r.parentPath; ) {
                                if (a.isIfStatement() || a.isConditionalExpression()) {
                                    if ("test" === r.key)
                                        return;
                                    return a
                                }
                                if (a.isFunction() && a.parentPath.scope.getBinding(i) !== t)
                                    return;
                                r = a
                            }
                        }(t, r, i);
                        if (!o)
                            return;
                        for (var l = [o.get("test")], u = [], p = 0; p < l.length; p++) {
                            var c = l[p];
                            if (c.isLogicalExpression())
                                "&&" === c.node.operator && (l.push(c.get("left")),
                                l.push(c.get("right")));
                            else if (c.isBinaryExpression()) {
                                var d = inferAnnotationFromBinaryExpression(i, c);
                                d && u.push(d)
                            }
                        }
                        if (u.length)
                            return a.isTSTypeAnnotation(u[0]) && a.createTSUnionType ? {
                                typeAnnotation: a.createTSUnionType(u),
                                ifStatement: o
                            } : a.createFlowUnionType ? {
                                typeAnnotation: a.createFlowUnionType(u),
                                ifStatement: o
                            } : {
                                typeAnnotation: a.createUnionTypeAnnotation(u),
                                ifStatement: o
                            };
                        return getConditionalAnnotation(o, i)
                    }(t, r, i);
                    if (p) {
                        var c = getConstantViolationsBefore(t, p.ifStatement);
                        u = u.filter((function(t) {
                            return c.indexOf(t) < 0
                        }
                        )),
                        o.push(p.typeAnnotation)
                    }
                    if (u.length) {
                        var d, y = _createForOfIteratorHelper(u = u.concat(l));
                        try {
                            for (y.s(); !(d = y.n()).done; ) {
                                var h = d.value;
                                o.push(h.getTypeAnnotation())
                            }
                        } catch (t) {
                            y.e(t)
                        } finally {
                            y.f()
                        }
                    }
                    if (!o.length)
                        return;
                    if (a.isTSTypeAnnotation(o[0]) && a.createTSUnionType)
                        return a.createTSUnionType(o);
                    if (a.createFlowUnionType)
                        return a.createFlowUnionType(o);
                    return a.createUnionTypeAnnotation(o)
                }(r, this, t.name);
            if ("undefined" === t.name)
                return a.voidTypeAnnotation();
            if ("NaN" === t.name || "Infinity" === t.name)
                return a.numberTypeAnnotation();
            t.name
        }
        ;
        var a = i("ZtNB");
        function getConstantViolationsBefore(t, r, i) {
            var a = t.constantViolations.slice();
            return a.unshift(t.path),
            a.filter((function(t) {
                var a = (t = t.resolve())._guessExecutionStatusRelativeTo(r);
                return i && "unknown" === a && i.push(t),
                "before" === a
            }
            ))
        }
        function inferAnnotationFromBinaryExpression(t, r) {
            var i, o, l, u = r.node.operator, p = r.get("right").resolve(), c = r.get("left").resolve();
            if (c.isIdentifier({
                name: t
            }) ? i = p : p.isIdentifier({
                name: t
            }) && (i = c),
            i)
                return "===" === u ? i.getTypeAnnotation() : a.BOOLEAN_NUMBER_BINARY_OPERATORS.indexOf(u) >= 0 ? a.numberTypeAnnotation() : void 0;
            if (("===" === u || "==" === u) && (c.isUnaryExpression({
                operator: "typeof"
            }) ? (o = c,
            l = p) : p.isUnaryExpression({
                operator: "typeof"
            }) && (o = p,
            l = c),
            o && o.get("argument").isIdentifier({
                name: t
            }) && (l = l.resolve()).isLiteral())) {
                var d = l.node.value;
                if ("string" == typeof d)
                    return a.createTypeAnnotationBasedOnTypeof(d)
            }
        }
    },
    nmjD: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function isBinding(t, r, i) {
            if (i && "Identifier" === t.type && "ObjectProperty" === r.type && "ObjectExpression" === i.type)
                return !1;
            var o = a.default.keys[r.type];
            if (o)
                for (var l = 0; l < o.length; l++) {
                    var u = o[l]
                      , p = r[u];
                    if (Array.isArray(p)) {
                        if (p.indexOf(t) >= 0)
                            return !0
                    } else if (p === t)
                        return !0
                }
            return !1
        }
        ;
        var a = i("V20z")
    },
    noBd: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.WHILE_TYPES = r.USERWHITESPACABLE_TYPES = r.UNARYLIKE_TYPES = r.TYPESCRIPT_TYPES = r.TSTYPE_TYPES = r.TSTYPEELEMENT_TYPES = r.TSENTITYNAME_TYPES = r.TSBASETYPE_TYPES = r.TERMINATORLESS_TYPES = r.STATEMENT_TYPES = r.STANDARDIZED_TYPES = r.SCOPABLE_TYPES = r.PUREISH_TYPES = r.PROPERTY_TYPES = r.PRIVATE_TYPES = r.PATTERN_TYPES = r.PATTERNLIKE_TYPES = r.OBJECTMEMBER_TYPES = r.MODULESPECIFIER_TYPES = r.MODULEDECLARATION_TYPES = r.MISCELLANEOUS_TYPES = r.METHOD_TYPES = r.LVAL_TYPES = r.LOOP_TYPES = r.LITERAL_TYPES = r.JSX_TYPES = r.IMMUTABLE_TYPES = r.FUNCTION_TYPES = r.FUNCTIONPARENT_TYPES = r.FOR_TYPES = r.FORXSTATEMENT_TYPES = r.FLOW_TYPES = r.FLOWTYPE_TYPES = r.FLOWPREDICATE_TYPES = r.FLOWDECLARATION_TYPES = r.FLOWBASEANNOTATION_TYPES = r.EXPRESSION_TYPES = r.EXPRESSIONWRAPPER_TYPES = r.EXPORTDECLARATION_TYPES = r.ENUMMEMBER_TYPES = r.ENUMBODY_TYPES = r.DECLARATION_TYPES = r.CONDITIONAL_TYPES = r.COMPLETIONSTATEMENT_TYPES = r.CLASS_TYPES = r.BLOCK_TYPES = r.BLOCKPARENT_TYPES = r.BINARY_TYPES = void 0;
        var a = i("uXiX");
        const o = a.FLIPPED_ALIAS_KEYS.Standardized;
        r.STANDARDIZED_TYPES = o;
        const l = a.FLIPPED_ALIAS_KEYS.Expression;
        r.EXPRESSION_TYPES = l;
        const u = a.FLIPPED_ALIAS_KEYS.Binary;
        r.BINARY_TYPES = u;
        const p = a.FLIPPED_ALIAS_KEYS.Scopable;
        r.SCOPABLE_TYPES = p;
        const c = a.FLIPPED_ALIAS_KEYS.BlockParent;
        r.BLOCKPARENT_TYPES = c;
        const d = a.FLIPPED_ALIAS_KEYS.Block;
        r.BLOCK_TYPES = d;
        const y = a.FLIPPED_ALIAS_KEYS.Statement;
        r.STATEMENT_TYPES = y;
        const h = a.FLIPPED_ALIAS_KEYS.Terminatorless;
        r.TERMINATORLESS_TYPES = h;
        const m = a.FLIPPED_ALIAS_KEYS.CompletionStatement;
        r.COMPLETIONSTATEMENT_TYPES = m;
        const T = a.FLIPPED_ALIAS_KEYS.Conditional;
        r.CONDITIONAL_TYPES = T;
        const S = a.FLIPPED_ALIAS_KEYS.Loop;
        r.LOOP_TYPES = S;
        const g = a.FLIPPED_ALIAS_KEYS.While;
        r.WHILE_TYPES = g;
        const b = a.FLIPPED_ALIAS_KEYS.ExpressionWrapper;
        r.EXPRESSIONWRAPPER_TYPES = b;
        const v = a.FLIPPED_ALIAS_KEYS.For;
        r.FOR_TYPES = v;
        const E = a.FLIPPED_ALIAS_KEYS.ForXStatement;
        r.FORXSTATEMENT_TYPES = E;
        const P = a.FLIPPED_ALIAS_KEYS.Function;
        r.FUNCTION_TYPES = P;
        const x = a.FLIPPED_ALIAS_KEYS.FunctionParent;
        r.FUNCTIONPARENT_TYPES = x;
        const A = a.FLIPPED_ALIAS_KEYS.Pureish;
        r.PUREISH_TYPES = A;
        const O = a.FLIPPED_ALIAS_KEYS.Declaration;
        r.DECLARATION_TYPES = O;
        const I = a.FLIPPED_ALIAS_KEYS.PatternLike;
        r.PATTERNLIKE_TYPES = I;
        const w = a.FLIPPED_ALIAS_KEYS.LVal;
        r.LVAL_TYPES = w;
        const C = a.FLIPPED_ALIAS_KEYS.TSEntityName;
        r.TSENTITYNAME_TYPES = C;
        const N = a.FLIPPED_ALIAS_KEYS.Literal;
        r.LITERAL_TYPES = N;
        const D = a.FLIPPED_ALIAS_KEYS.Immutable;
        r.IMMUTABLE_TYPES = D;
        const _ = a.FLIPPED_ALIAS_KEYS.UserWhitespacable;
        r.USERWHITESPACABLE_TYPES = _;
        const L = a.FLIPPED_ALIAS_KEYS.Method;
        r.METHOD_TYPES = L;
        const k = a.FLIPPED_ALIAS_KEYS.ObjectMember;
        r.OBJECTMEMBER_TYPES = k;
        const M = a.FLIPPED_ALIAS_KEYS.Property;
        r.PROPERTY_TYPES = M;
        const j = a.FLIPPED_ALIAS_KEYS.UnaryLike;
        r.UNARYLIKE_TYPES = j;
        const B = a.FLIPPED_ALIAS_KEYS.Pattern;
        r.PATTERN_TYPES = B;
        const R = a.FLIPPED_ALIAS_KEYS.Class;
        r.CLASS_TYPES = R;
        const K = a.FLIPPED_ALIAS_KEYS.ModuleDeclaration;
        r.MODULEDECLARATION_TYPES = K;
        const V = a.FLIPPED_ALIAS_KEYS.ExportDeclaration;
        r.EXPORTDECLARATION_TYPES = V;
        const U = a.FLIPPED_ALIAS_KEYS.ModuleSpecifier;
        r.MODULESPECIFIER_TYPES = U;
        const Y = a.FLIPPED_ALIAS_KEYS.Private;
        r.PRIVATE_TYPES = Y;
        const X = a.FLIPPED_ALIAS_KEYS.Flow;
        r.FLOW_TYPES = X;
        const J = a.FLIPPED_ALIAS_KEYS.FlowType;
        r.FLOWTYPE_TYPES = J;
        const W = a.FLIPPED_ALIAS_KEYS.FlowBaseAnnotation;
        r.FLOWBASEANNOTATION_TYPES = W;
        const q = a.FLIPPED_ALIAS_KEYS.FlowDeclaration;
        r.FLOWDECLARATION_TYPES = q;
        const H = a.FLIPPED_ALIAS_KEYS.FlowPredicate;
        r.FLOWPREDICATE_TYPES = H;
        const G = a.FLIPPED_ALIAS_KEYS.EnumBody;
        r.ENUMBODY_TYPES = G;
        const z = a.FLIPPED_ALIAS_KEYS.EnumMember;
        r.ENUMMEMBER_TYPES = z;
        const Q = a.FLIPPED_ALIAS_KEYS.JSX;
        r.JSX_TYPES = Q;
        const $ = a.FLIPPED_ALIAS_KEYS.Miscellaneous;
        r.MISCELLANEOUS_TYPES = $;
        const Z = a.FLIPPED_ALIAS_KEYS.TypeScript;
        r.TYPESCRIPT_TYPES = Z;
        const ee = a.FLIPPED_ALIAS_KEYS.TSTypeElement;
        r.TSTYPEELEMENT_TYPES = ee;
        const te = a.FLIPPED_ALIAS_KEYS.TSType;
        r.TSTYPE_TYPES = te;
        const re = a.FLIPPED_ALIAS_KEYS.TSBaseType;
        r.TSBASETYPE_TYPES = re
    },
    nsxz: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.assertArrayExpression = function assertArrayExpression(t, r) {
            assert("ArrayExpression", t, r)
        }
        ,
        r.assertAssignmentExpression = function assertAssignmentExpression(t, r) {
            assert("AssignmentExpression", t, r)
        }
        ,
        r.assertBinaryExpression = function assertBinaryExpression(t, r) {
            assert("BinaryExpression", t, r)
        }
        ,
        r.assertInterpreterDirective = function assertInterpreterDirective(t, r) {
            assert("InterpreterDirective", t, r)
        }
        ,
        r.assertDirective = function assertDirective(t, r) {
            assert("Directive", t, r)
        }
        ,
        r.assertDirectiveLiteral = function assertDirectiveLiteral(t, r) {
            assert("DirectiveLiteral", t, r)
        }
        ,
        r.assertBlockStatement = function assertBlockStatement(t, r) {
            assert("BlockStatement", t, r)
        }
        ,
        r.assertBreakStatement = function assertBreakStatement(t, r) {
            assert("BreakStatement", t, r)
        }
        ,
        r.assertCallExpression = function assertCallExpression(t, r) {
            assert("CallExpression", t, r)
        }
        ,
        r.assertCatchClause = function assertCatchClause(t, r) {
            assert("CatchClause", t, r)
        }
        ,
        r.assertConditionalExpression = function assertConditionalExpression(t, r) {
            assert("ConditionalExpression", t, r)
        }
        ,
        r.assertContinueStatement = function assertContinueStatement(t, r) {
            assert("ContinueStatement", t, r)
        }
        ,
        r.assertDebuggerStatement = function assertDebuggerStatement(t, r) {
            assert("DebuggerStatement", t, r)
        }
        ,
        r.assertDoWhileStatement = function assertDoWhileStatement(t, r) {
            assert("DoWhileStatement", t, r)
        }
        ,
        r.assertEmptyStatement = function assertEmptyStatement(t, r) {
            assert("EmptyStatement", t, r)
        }
        ,
        r.assertExpressionStatement = function assertExpressionStatement(t, r) {
            assert("ExpressionStatement", t, r)
        }
        ,
        r.assertFile = function assertFile(t, r) {
            assert("File", t, r)
        }
        ,
        r.assertForInStatement = function assertForInStatement(t, r) {
            assert("ForInStatement", t, r)
        }
        ,
        r.assertForStatement = function assertForStatement(t, r) {
            assert("ForStatement", t, r)
        }
        ,
        r.assertFunctionDeclaration = function assertFunctionDeclaration(t, r) {
            assert("FunctionDeclaration", t, r)
        }
        ,
        r.assertFunctionExpression = function assertFunctionExpression(t, r) {
            assert("FunctionExpression", t, r)
        }
        ,
        r.assertIdentifier = function assertIdentifier(t, r) {
            assert("Identifier", t, r)
        }
        ,
        r.assertIfStatement = function assertIfStatement(t, r) {
            assert("IfStatement", t, r)
        }
        ,
        r.assertLabeledStatement = function assertLabeledStatement(t, r) {
            assert("LabeledStatement", t, r)
        }
        ,
        r.assertStringLiteral = function assertStringLiteral(t, r) {
            assert("StringLiteral", t, r)
        }
        ,
        r.assertNumericLiteral = function assertNumericLiteral(t, r) {
            assert("NumericLiteral", t, r)
        }
        ,
        r.assertNullLiteral = function assertNullLiteral(t, r) {
            assert("NullLiteral", t, r)
        }
        ,
        r.assertBooleanLiteral = function assertBooleanLiteral(t, r) {
            assert("BooleanLiteral", t, r)
        }
        ,
        r.assertRegExpLiteral = function assertRegExpLiteral(t, r) {
            assert("RegExpLiteral", t, r)
        }
        ,
        r.assertLogicalExpression = function assertLogicalExpression(t, r) {
            assert("LogicalExpression", t, r)
        }
        ,
        r.assertMemberExpression = function assertMemberExpression(t, r) {
            assert("MemberExpression", t, r)
        }
        ,
        r.assertNewExpression = function assertNewExpression(t, r) {
            assert("NewExpression", t, r)
        }
        ,
        r.assertProgram = function assertProgram(t, r) {
            assert("Program", t, r)
        }
        ,
        r.assertObjectExpression = function assertObjectExpression(t, r) {
            assert("ObjectExpression", t, r)
        }
        ,
        r.assertObjectMethod = function assertObjectMethod(t, r) {
            assert("ObjectMethod", t, r)
        }
        ,
        r.assertObjectProperty = function assertObjectProperty(t, r) {
            assert("ObjectProperty", t, r)
        }
        ,
        r.assertRestElement = function assertRestElement(t, r) {
            assert("RestElement", t, r)
        }
        ,
        r.assertReturnStatement = function assertReturnStatement(t, r) {
            assert("ReturnStatement", t, r)
        }
        ,
        r.assertSequenceExpression = function assertSequenceExpression(t, r) {
            assert("SequenceExpression", t, r)
        }
        ,
        r.assertParenthesizedExpression = function assertParenthesizedExpression(t, r) {
            assert("ParenthesizedExpression", t, r)
        }
        ,
        r.assertSwitchCase = function assertSwitchCase(t, r) {
            assert("SwitchCase", t, r)
        }
        ,
        r.assertSwitchStatement = function assertSwitchStatement(t, r) {
            assert("SwitchStatement", t, r)
        }
        ,
        r.assertThisExpression = function assertThisExpression(t, r) {
            assert("ThisExpression", t, r)
        }
        ,
        r.assertThrowStatement = function assertThrowStatement(t, r) {
            assert("ThrowStatement", t, r)
        }
        ,
        r.assertTryStatement = function assertTryStatement(t, r) {
            assert("TryStatement", t, r)
        }
        ,
        r.assertUnaryExpression = function assertUnaryExpression(t, r) {
            assert("UnaryExpression", t, r)
        }
        ,
        r.assertUpdateExpression = function assertUpdateExpression(t, r) {
            assert("UpdateExpression", t, r)
        }
        ,
        r.assertVariableDeclaration = function assertVariableDeclaration(t, r) {
            assert("VariableDeclaration", t, r)
        }
        ,
        r.assertVariableDeclarator = function assertVariableDeclarator(t, r) {
            assert("VariableDeclarator", t, r)
        }
        ,
        r.assertWhileStatement = function assertWhileStatement(t, r) {
            assert("WhileStatement", t, r)
        }
        ,
        r.assertWithStatement = function assertWithStatement(t, r) {
            assert("WithStatement", t, r)
        }
        ,
        r.assertAssignmentPattern = function assertAssignmentPattern(t, r) {
            assert("AssignmentPattern", t, r)
        }
        ,
        r.assertArrayPattern = function assertArrayPattern(t, r) {
            assert("ArrayPattern", t, r)
        }
        ,
        r.assertArrowFunctionExpression = function assertArrowFunctionExpression(t, r) {
            assert("ArrowFunctionExpression", t, r)
        }
        ,
        r.assertClassBody = function assertClassBody(t, r) {
            assert("ClassBody", t, r)
        }
        ,
        r.assertClassExpression = function assertClassExpression(t, r) {
            assert("ClassExpression", t, r)
        }
        ,
        r.assertClassDeclaration = function assertClassDeclaration(t, r) {
            assert("ClassDeclaration", t, r)
        }
        ,
        r.assertExportAllDeclaration = function assertExportAllDeclaration(t, r) {
            assert("ExportAllDeclaration", t, r)
        }
        ,
        r.assertExportDefaultDeclaration = function assertExportDefaultDeclaration(t, r) {
            assert("ExportDefaultDeclaration", t, r)
        }
        ,
        r.assertExportNamedDeclaration = function assertExportNamedDeclaration(t, r) {
            assert("ExportNamedDeclaration", t, r)
        }
        ,
        r.assertExportSpecifier = function assertExportSpecifier(t, r) {
            assert("ExportSpecifier", t, r)
        }
        ,
        r.assertForOfStatement = function assertForOfStatement(t, r) {
            assert("ForOfStatement", t, r)
        }
        ,
        r.assertImportDeclaration = function assertImportDeclaration(t, r) {
            assert("ImportDeclaration", t, r)
        }
        ,
        r.assertImportDefaultSpecifier = function assertImportDefaultSpecifier(t, r) {
            assert("ImportDefaultSpecifier", t, r)
        }
        ,
        r.assertImportNamespaceSpecifier = function assertImportNamespaceSpecifier(t, r) {
            assert("ImportNamespaceSpecifier", t, r)
        }
        ,
        r.assertImportSpecifier = function assertImportSpecifier(t, r) {
            assert("ImportSpecifier", t, r)
        }
        ,
        r.assertMetaProperty = function assertMetaProperty(t, r) {
            assert("MetaProperty", t, r)
        }
        ,
        r.assertClassMethod = function assertClassMethod(t, r) {
            assert("ClassMethod", t, r)
        }
        ,
        r.assertObjectPattern = function assertObjectPattern(t, r) {
            assert("ObjectPattern", t, r)
        }
        ,
        r.assertSpreadElement = function assertSpreadElement(t, r) {
            assert("SpreadElement", t, r)
        }
        ,
        r.assertSuper = function assertSuper(t, r) {
            assert("Super", t, r)
        }
        ,
        r.assertTaggedTemplateExpression = function assertTaggedTemplateExpression(t, r) {
            assert("TaggedTemplateExpression", t, r)
        }
        ,
        r.assertTemplateElement = function assertTemplateElement(t, r) {
            assert("TemplateElement", t, r)
        }
        ,
        r.assertTemplateLiteral = function assertTemplateLiteral(t, r) {
            assert("TemplateLiteral", t, r)
        }
        ,
        r.assertYieldExpression = function assertYieldExpression(t, r) {
            assert("YieldExpression", t, r)
        }
        ,
        r.assertAwaitExpression = function assertAwaitExpression(t, r) {
            assert("AwaitExpression", t, r)
        }
        ,
        r.assertImport = function assertImport(t, r) {
            assert("Import", t, r)
        }
        ,
        r.assertBigIntLiteral = function assertBigIntLiteral(t, r) {
            assert("BigIntLiteral", t, r)
        }
        ,
        r.assertExportNamespaceSpecifier = function assertExportNamespaceSpecifier(t, r) {
            assert("ExportNamespaceSpecifier", t, r)
        }
        ,
        r.assertOptionalMemberExpression = function assertOptionalMemberExpression(t, r) {
            assert("OptionalMemberExpression", t, r)
        }
        ,
        r.assertOptionalCallExpression = function assertOptionalCallExpression(t, r) {
            assert("OptionalCallExpression", t, r)
        }
        ,
        r.assertClassProperty = function assertClassProperty(t, r) {
            assert("ClassProperty", t, r)
        }
        ,
        r.assertClassPrivateProperty = function assertClassPrivateProperty(t, r) {
            assert("ClassPrivateProperty", t, r)
        }
        ,
        r.assertClassPrivateMethod = function assertClassPrivateMethod(t, r) {
            assert("ClassPrivateMethod", t, r)
        }
        ,
        r.assertPrivateName = function assertPrivateName(t, r) {
            assert("PrivateName", t, r)
        }
        ,
        r.assertAnyTypeAnnotation = function assertAnyTypeAnnotation(t, r) {
            assert("AnyTypeAnnotation", t, r)
        }
        ,
        r.assertArrayTypeAnnotation = function assertArrayTypeAnnotation(t, r) {
            assert("ArrayTypeAnnotation", t, r)
        }
        ,
        r.assertBooleanTypeAnnotation = function assertBooleanTypeAnnotation(t, r) {
            assert("BooleanTypeAnnotation", t, r)
        }
        ,
        r.assertBooleanLiteralTypeAnnotation = function assertBooleanLiteralTypeAnnotation(t, r) {
            assert("BooleanLiteralTypeAnnotation", t, r)
        }
        ,
        r.assertNullLiteralTypeAnnotation = function assertNullLiteralTypeAnnotation(t, r) {
            assert("NullLiteralTypeAnnotation", t, r)
        }
        ,
        r.assertClassImplements = function assertClassImplements(t, r) {
            assert("ClassImplements", t, r)
        }
        ,
        r.assertDeclareClass = function assertDeclareClass(t, r) {
            assert("DeclareClass", t, r)
        }
        ,
        r.assertDeclareFunction = function assertDeclareFunction(t, r) {
            assert("DeclareFunction", t, r)
        }
        ,
        r.assertDeclareInterface = function assertDeclareInterface(t, r) {
            assert("DeclareInterface", t, r)
        }
        ,
        r.assertDeclareModule = function assertDeclareModule(t, r) {
            assert("DeclareModule", t, r)
        }
        ,
        r.assertDeclareModuleExports = function assertDeclareModuleExports(t, r) {
            assert("DeclareModuleExports", t, r)
        }
        ,
        r.assertDeclareTypeAlias = function assertDeclareTypeAlias(t, r) {
            assert("DeclareTypeAlias", t, r)
        }
        ,
        r.assertDeclareOpaqueType = function assertDeclareOpaqueType(t, r) {
            assert("DeclareOpaqueType", t, r)
        }
        ,
        r.assertDeclareVariable = function assertDeclareVariable(t, r) {
            assert("DeclareVariable", t, r)
        }
        ,
        r.assertDeclareExportDeclaration = function assertDeclareExportDeclaration(t, r) {
            assert("DeclareExportDeclaration", t, r)
        }
        ,
        r.assertDeclareExportAllDeclaration = function assertDeclareExportAllDeclaration(t, r) {
            assert("DeclareExportAllDeclaration", t, r)
        }
        ,
        r.assertDeclaredPredicate = function assertDeclaredPredicate(t, r) {
            assert("DeclaredPredicate", t, r)
        }
        ,
        r.assertExistsTypeAnnotation = function assertExistsTypeAnnotation(t, r) {
            assert("ExistsTypeAnnotation", t, r)
        }
        ,
        r.assertFunctionTypeAnnotation = function assertFunctionTypeAnnotation(t, r) {
            assert("FunctionTypeAnnotation", t, r)
        }
        ,
        r.assertFunctionTypeParam = function assertFunctionTypeParam(t, r) {
            assert("FunctionTypeParam", t, r)
        }
        ,
        r.assertGenericTypeAnnotation = function assertGenericTypeAnnotation(t, r) {
            assert("GenericTypeAnnotation", t, r)
        }
        ,
        r.assertInferredPredicate = function assertInferredPredicate(t, r) {
            assert("InferredPredicate", t, r)
        }
        ,
        r.assertInterfaceExtends = function assertInterfaceExtends(t, r) {
            assert("InterfaceExtends", t, r)
        }
        ,
        r.assertInterfaceDeclaration = function assertInterfaceDeclaration(t, r) {
            assert("InterfaceDeclaration", t, r)
        }
        ,
        r.assertInterfaceTypeAnnotation = function assertInterfaceTypeAnnotation(t, r) {
            assert("InterfaceTypeAnnotation", t, r)
        }
        ,
        r.assertIntersectionTypeAnnotation = function assertIntersectionTypeAnnotation(t, r) {
            assert("IntersectionTypeAnnotation", t, r)
        }
        ,
        r.assertMixedTypeAnnotation = function assertMixedTypeAnnotation(t, r) {
            assert("MixedTypeAnnotation", t, r)
        }
        ,
        r.assertEmptyTypeAnnotation = function assertEmptyTypeAnnotation(t, r) {
            assert("EmptyTypeAnnotation", t, r)
        }
        ,
        r.assertNullableTypeAnnotation = function assertNullableTypeAnnotation(t, r) {
            assert("NullableTypeAnnotation", t, r)
        }
        ,
        r.assertNumberLiteralTypeAnnotation = function assertNumberLiteralTypeAnnotation(t, r) {
            assert("NumberLiteralTypeAnnotation", t, r)
        }
        ,
        r.assertNumberTypeAnnotation = function assertNumberTypeAnnotation(t, r) {
            assert("NumberTypeAnnotation", t, r)
        }
        ,
        r.assertObjectTypeAnnotation = function assertObjectTypeAnnotation(t, r) {
            assert("ObjectTypeAnnotation", t, r)
        }
        ,
        r.assertObjectTypeInternalSlot = function assertObjectTypeInternalSlot(t, r) {
            assert("ObjectTypeInternalSlot", t, r)
        }
        ,
        r.assertObjectTypeCallProperty = function assertObjectTypeCallProperty(t, r) {
            assert("ObjectTypeCallProperty", t, r)
        }
        ,
        r.assertObjectTypeIndexer = function assertObjectTypeIndexer(t, r) {
            assert("ObjectTypeIndexer", t, r)
        }
        ,
        r.assertObjectTypeProperty = function assertObjectTypeProperty(t, r) {
            assert("ObjectTypeProperty", t, r)
        }
        ,
        r.assertObjectTypeSpreadProperty = function assertObjectTypeSpreadProperty(t, r) {
            assert("ObjectTypeSpreadProperty", t, r)
        }
        ,
        r.assertOpaqueType = function assertOpaqueType(t, r) {
            assert("OpaqueType", t, r)
        }
        ,
        r.assertQualifiedTypeIdentifier = function assertQualifiedTypeIdentifier(t, r) {
            assert("QualifiedTypeIdentifier", t, r)
        }
        ,
        r.assertStringLiteralTypeAnnotation = function assertStringLiteralTypeAnnotation(t, r) {
            assert("StringLiteralTypeAnnotation", t, r)
        }
        ,
        r.assertStringTypeAnnotation = function assertStringTypeAnnotation(t, r) {
            assert("StringTypeAnnotation", t, r)
        }
        ,
        r.assertSymbolTypeAnnotation = function assertSymbolTypeAnnotation(t, r) {
            assert("SymbolTypeAnnotation", t, r)
        }
        ,
        r.assertThisTypeAnnotation = function assertThisTypeAnnotation(t, r) {
            assert("ThisTypeAnnotation", t, r)
        }
        ,
        r.assertTupleTypeAnnotation = function assertTupleTypeAnnotation(t, r) {
            assert("TupleTypeAnnotation", t, r)
        }
        ,
        r.assertTypeofTypeAnnotation = function assertTypeofTypeAnnotation(t, r) {
            assert("TypeofTypeAnnotation", t, r)
        }
        ,
        r.assertTypeAlias = function assertTypeAlias(t, r) {
            assert("TypeAlias", t, r)
        }
        ,
        r.assertTypeAnnotation = function assertTypeAnnotation(t, r) {
            assert("TypeAnnotation", t, r)
        }
        ,
        r.assertTypeCastExpression = function assertTypeCastExpression(t, r) {
            assert("TypeCastExpression", t, r)
        }
        ,
        r.assertTypeParameter = function assertTypeParameter(t, r) {
            assert("TypeParameter", t, r)
        }
        ,
        r.assertTypeParameterDeclaration = function assertTypeParameterDeclaration(t, r) {
            assert("TypeParameterDeclaration", t, r)
        }
        ,
        r.assertTypeParameterInstantiation = function assertTypeParameterInstantiation(t, r) {
            assert("TypeParameterInstantiation", t, r)
        }
        ,
        r.assertUnionTypeAnnotation = function assertUnionTypeAnnotation(t, r) {
            assert("UnionTypeAnnotation", t, r)
        }
        ,
        r.assertVariance = function assertVariance(t, r) {
            assert("Variance", t, r)
        }
        ,
        r.assertVoidTypeAnnotation = function assertVoidTypeAnnotation(t, r) {
            assert("VoidTypeAnnotation", t, r)
        }
        ,
        r.assertEnumDeclaration = function assertEnumDeclaration(t, r) {
            assert("EnumDeclaration", t, r)
        }
        ,
        r.assertEnumBooleanBody = function assertEnumBooleanBody(t, r) {
            assert("EnumBooleanBody", t, r)
        }
        ,
        r.assertEnumNumberBody = function assertEnumNumberBody(t, r) {
            assert("EnumNumberBody", t, r)
        }
        ,
        r.assertEnumStringBody = function assertEnumStringBody(t, r) {
            assert("EnumStringBody", t, r)
        }
        ,
        r.assertEnumSymbolBody = function assertEnumSymbolBody(t, r) {
            assert("EnumSymbolBody", t, r)
        }
        ,
        r.assertEnumBooleanMember = function assertEnumBooleanMember(t, r) {
            assert("EnumBooleanMember", t, r)
        }
        ,
        r.assertEnumNumberMember = function assertEnumNumberMember(t, r) {
            assert("EnumNumberMember", t, r)
        }
        ,
        r.assertEnumStringMember = function assertEnumStringMember(t, r) {
            assert("EnumStringMember", t, r)
        }
        ,
        r.assertEnumDefaultedMember = function assertEnumDefaultedMember(t, r) {
            assert("EnumDefaultedMember", t, r)
        }
        ,
        r.assertIndexedAccessType = function assertIndexedAccessType(t, r) {
            assert("IndexedAccessType", t, r)
        }
        ,
        r.assertOptionalIndexedAccessType = function assertOptionalIndexedAccessType(t, r) {
            assert("OptionalIndexedAccessType", t, r)
        }
        ,
        r.assertJSXAttribute = function assertJSXAttribute(t, r) {
            assert("JSXAttribute", t, r)
        }
        ,
        r.assertJSXClosingElement = function assertJSXClosingElement(t, r) {
            assert("JSXClosingElement", t, r)
        }
        ,
        r.assertJSXElement = function assertJSXElement(t, r) {
            assert("JSXElement", t, r)
        }
        ,
        r.assertJSXEmptyExpression = function assertJSXEmptyExpression(t, r) {
            assert("JSXEmptyExpression", t, r)
        }
        ,
        r.assertJSXExpressionContainer = function assertJSXExpressionContainer(t, r) {
            assert("JSXExpressionContainer", t, r)
        }
        ,
        r.assertJSXSpreadChild = function assertJSXSpreadChild(t, r) {
            assert("JSXSpreadChild", t, r)
        }
        ,
        r.assertJSXIdentifier = function assertJSXIdentifier(t, r) {
            assert("JSXIdentifier", t, r)
        }
        ,
        r.assertJSXMemberExpression = function assertJSXMemberExpression(t, r) {
            assert("JSXMemberExpression", t, r)
        }
        ,
        r.assertJSXNamespacedName = function assertJSXNamespacedName(t, r) {
            assert("JSXNamespacedName", t, r)
        }
        ,
        r.assertJSXOpeningElement = function assertJSXOpeningElement(t, r) {
            assert("JSXOpeningElement", t, r)
        }
        ,
        r.assertJSXSpreadAttribute = function assertJSXSpreadAttribute(t, r) {
            assert("JSXSpreadAttribute", t, r)
        }
        ,
        r.assertJSXText = function assertJSXText(t, r) {
            assert("JSXText", t, r)
        }
        ,
        r.assertJSXFragment = function assertJSXFragment(t, r) {
            assert("JSXFragment", t, r)
        }
        ,
        r.assertJSXOpeningFragment = function assertJSXOpeningFragment(t, r) {
            assert("JSXOpeningFragment", t, r)
        }
        ,
        r.assertJSXClosingFragment = function assertJSXClosingFragment(t, r) {
            assert("JSXClosingFragment", t, r)
        }
        ,
        r.assertNoop = function assertNoop(t, r) {
            assert("Noop", t, r)
        }
        ,
        r.assertPlaceholder = function assertPlaceholder(t, r) {
            assert("Placeholder", t, r)
        }
        ,
        r.assertV8IntrinsicIdentifier = function assertV8IntrinsicIdentifier(t, r) {
            assert("V8IntrinsicIdentifier", t, r)
        }
        ,
        r.assertArgumentPlaceholder = function assertArgumentPlaceholder(t, r) {
            assert("ArgumentPlaceholder", t, r)
        }
        ,
        r.assertBindExpression = function assertBindExpression(t, r) {
            assert("BindExpression", t, r)
        }
        ,
        r.assertImportAttribute = function assertImportAttribute(t, r) {
            assert("ImportAttribute", t, r)
        }
        ,
        r.assertDecorator = function assertDecorator(t, r) {
            assert("Decorator", t, r)
        }
        ,
        r.assertDoExpression = function assertDoExpression(t, r) {
            assert("DoExpression", t, r)
        }
        ,
        r.assertExportDefaultSpecifier = function assertExportDefaultSpecifier(t, r) {
            assert("ExportDefaultSpecifier", t, r)
        }
        ,
        r.assertRecordExpression = function assertRecordExpression(t, r) {
            assert("RecordExpression", t, r)
        }
        ,
        r.assertTupleExpression = function assertTupleExpression(t, r) {
            assert("TupleExpression", t, r)
        }
        ,
        r.assertDecimalLiteral = function assertDecimalLiteral(t, r) {
            assert("DecimalLiteral", t, r)
        }
        ,
        r.assertStaticBlock = function assertStaticBlock(t, r) {
            assert("StaticBlock", t, r)
        }
        ,
        r.assertModuleExpression = function assertModuleExpression(t, r) {
            assert("ModuleExpression", t, r)
        }
        ,
        r.assertTopicReference = function assertTopicReference(t, r) {
            assert("TopicReference", t, r)
        }
        ,
        r.assertPipelineTopicExpression = function assertPipelineTopicExpression(t, r) {
            assert("PipelineTopicExpression", t, r)
        }
        ,
        r.assertPipelineBareFunction = function assertPipelineBareFunction(t, r) {
            assert("PipelineBareFunction", t, r)
        }
        ,
        r.assertPipelinePrimaryTopicReference = function assertPipelinePrimaryTopicReference(t, r) {
            assert("PipelinePrimaryTopicReference", t, r)
        }
        ,
        r.assertTSParameterProperty = function assertTSParameterProperty(t, r) {
            assert("TSParameterProperty", t, r)
        }
        ,
        r.assertTSDeclareFunction = function assertTSDeclareFunction(t, r) {
            assert("TSDeclareFunction", t, r)
        }
        ,
        r.assertTSDeclareMethod = function assertTSDeclareMethod(t, r) {
            assert("TSDeclareMethod", t, r)
        }
        ,
        r.assertTSQualifiedName = function assertTSQualifiedName(t, r) {
            assert("TSQualifiedName", t, r)
        }
        ,
        r.assertTSCallSignatureDeclaration = function assertTSCallSignatureDeclaration(t, r) {
            assert("TSCallSignatureDeclaration", t, r)
        }
        ,
        r.assertTSConstructSignatureDeclaration = function assertTSConstructSignatureDeclaration(t, r) {
            assert("TSConstructSignatureDeclaration", t, r)
        }
        ,
        r.assertTSPropertySignature = function assertTSPropertySignature(t, r) {
            assert("TSPropertySignature", t, r)
        }
        ,
        r.assertTSMethodSignature = function assertTSMethodSignature(t, r) {
            assert("TSMethodSignature", t, r)
        }
        ,
        r.assertTSIndexSignature = function assertTSIndexSignature(t, r) {
            assert("TSIndexSignature", t, r)
        }
        ,
        r.assertTSAnyKeyword = function assertTSAnyKeyword(t, r) {
            assert("TSAnyKeyword", t, r)
        }
        ,
        r.assertTSBooleanKeyword = function assertTSBooleanKeyword(t, r) {
            assert("TSBooleanKeyword", t, r)
        }
        ,
        r.assertTSBigIntKeyword = function assertTSBigIntKeyword(t, r) {
            assert("TSBigIntKeyword", t, r)
        }
        ,
        r.assertTSIntrinsicKeyword = function assertTSIntrinsicKeyword(t, r) {
            assert("TSIntrinsicKeyword", t, r)
        }
        ,
        r.assertTSNeverKeyword = function assertTSNeverKeyword(t, r) {
            assert("TSNeverKeyword", t, r)
        }
        ,
        r.assertTSNullKeyword = function assertTSNullKeyword(t, r) {
            assert("TSNullKeyword", t, r)
        }
        ,
        r.assertTSNumberKeyword = function assertTSNumberKeyword(t, r) {
            assert("TSNumberKeyword", t, r)
        }
        ,
        r.assertTSObjectKeyword = function assertTSObjectKeyword(t, r) {
            assert("TSObjectKeyword", t, r)
        }
        ,
        r.assertTSStringKeyword = function assertTSStringKeyword(t, r) {
            assert("TSStringKeyword", t, r)
        }
        ,
        r.assertTSSymbolKeyword = function assertTSSymbolKeyword(t, r) {
            assert("TSSymbolKeyword", t, r)
        }
        ,
        r.assertTSUndefinedKeyword = function assertTSUndefinedKeyword(t, r) {
            assert("TSUndefinedKeyword", t, r)
        }
        ,
        r.assertTSUnknownKeyword = function assertTSUnknownKeyword(t, r) {
            assert("TSUnknownKeyword", t, r)
        }
        ,
        r.assertTSVoidKeyword = function assertTSVoidKeyword(t, r) {
            assert("TSVoidKeyword", t, r)
        }
        ,
        r.assertTSThisType = function assertTSThisType(t, r) {
            assert("TSThisType", t, r)
        }
        ,
        r.assertTSFunctionType = function assertTSFunctionType(t, r) {
            assert("TSFunctionType", t, r)
        }
        ,
        r.assertTSConstructorType = function assertTSConstructorType(t, r) {
            assert("TSConstructorType", t, r)
        }
        ,
        r.assertTSTypeReference = function assertTSTypeReference(t, r) {
            assert("TSTypeReference", t, r)
        }
        ,
        r.assertTSTypePredicate = function assertTSTypePredicate(t, r) {
            assert("TSTypePredicate", t, r)
        }
        ,
        r.assertTSTypeQuery = function assertTSTypeQuery(t, r) {
            assert("TSTypeQuery", t, r)
        }
        ,
        r.assertTSTypeLiteral = function assertTSTypeLiteral(t, r) {
            assert("TSTypeLiteral", t, r)
        }
        ,
        r.assertTSArrayType = function assertTSArrayType(t, r) {
            assert("TSArrayType", t, r)
        }
        ,
        r.assertTSTupleType = function assertTSTupleType(t, r) {
            assert("TSTupleType", t, r)
        }
        ,
        r.assertTSOptionalType = function assertTSOptionalType(t, r) {
            assert("TSOptionalType", t, r)
        }
        ,
        r.assertTSRestType = function assertTSRestType(t, r) {
            assert("TSRestType", t, r)
        }
        ,
        r.assertTSNamedTupleMember = function assertTSNamedTupleMember(t, r) {
            assert("TSNamedTupleMember", t, r)
        }
        ,
        r.assertTSUnionType = function assertTSUnionType(t, r) {
            assert("TSUnionType", t, r)
        }
        ,
        r.assertTSIntersectionType = function assertTSIntersectionType(t, r) {
            assert("TSIntersectionType", t, r)
        }
        ,
        r.assertTSConditionalType = function assertTSConditionalType(t, r) {
            assert("TSConditionalType", t, r)
        }
        ,
        r.assertTSInferType = function assertTSInferType(t, r) {
            assert("TSInferType", t, r)
        }
        ,
        r.assertTSParenthesizedType = function assertTSParenthesizedType(t, r) {
            assert("TSParenthesizedType", t, r)
        }
        ,
        r.assertTSTypeOperator = function assertTSTypeOperator(t, r) {
            assert("TSTypeOperator", t, r)
        }
        ,
        r.assertTSIndexedAccessType = function assertTSIndexedAccessType(t, r) {
            assert("TSIndexedAccessType", t, r)
        }
        ,
        r.assertTSMappedType = function assertTSMappedType(t, r) {
            assert("TSMappedType", t, r)
        }
        ,
        r.assertTSLiteralType = function assertTSLiteralType(t, r) {
            assert("TSLiteralType", t, r)
        }
        ,
        r.assertTSExpressionWithTypeArguments = function assertTSExpressionWithTypeArguments(t, r) {
            assert("TSExpressionWithTypeArguments", t, r)
        }
        ,
        r.assertTSInterfaceDeclaration = function assertTSInterfaceDeclaration(t, r) {
            assert("TSInterfaceDeclaration", t, r)
        }
        ,
        r.assertTSInterfaceBody = function assertTSInterfaceBody(t, r) {
            assert("TSInterfaceBody", t, r)
        }
        ,
        r.assertTSTypeAliasDeclaration = function assertTSTypeAliasDeclaration(t, r) {
            assert("TSTypeAliasDeclaration", t, r)
        }
        ,
        r.assertTSAsExpression = function assertTSAsExpression(t, r) {
            assert("TSAsExpression", t, r)
        }
        ,
        r.assertTSTypeAssertion = function assertTSTypeAssertion(t, r) {
            assert("TSTypeAssertion", t, r)
        }
        ,
        r.assertTSEnumDeclaration = function assertTSEnumDeclaration(t, r) {
            assert("TSEnumDeclaration", t, r)
        }
        ,
        r.assertTSEnumMember = function assertTSEnumMember(t, r) {
            assert("TSEnumMember", t, r)
        }
        ,
        r.assertTSModuleDeclaration = function assertTSModuleDeclaration(t, r) {
            assert("TSModuleDeclaration", t, r)
        }
        ,
        r.assertTSModuleBlock = function assertTSModuleBlock(t, r) {
            assert("TSModuleBlock", t, r)
        }
        ,
        r.assertTSImportType = function assertTSImportType(t, r) {
            assert("TSImportType", t, r)
        }
        ,
        r.assertTSImportEqualsDeclaration = function assertTSImportEqualsDeclaration(t, r) {
            assert("TSImportEqualsDeclaration", t, r)
        }
        ,
        r.assertTSExternalModuleReference = function assertTSExternalModuleReference(t, r) {
            assert("TSExternalModuleReference", t, r)
        }
        ,
        r.assertTSNonNullExpression = function assertTSNonNullExpression(t, r) {
            assert("TSNonNullExpression", t, r)
        }
        ,
        r.assertTSExportAssignment = function assertTSExportAssignment(t, r) {
            assert("TSExportAssignment", t, r)
        }
        ,
        r.assertTSNamespaceExportDeclaration = function assertTSNamespaceExportDeclaration(t, r) {
            assert("TSNamespaceExportDeclaration", t, r)
        }
        ,
        r.assertTSTypeAnnotation = function assertTSTypeAnnotation(t, r) {
            assert("TSTypeAnnotation", t, r)
        }
        ,
        r.assertTSTypeParameterInstantiation = function assertTSTypeParameterInstantiation(t, r) {
            assert("TSTypeParameterInstantiation", t, r)
        }
        ,
        r.assertTSTypeParameterDeclaration = function assertTSTypeParameterDeclaration(t, r) {
            assert("TSTypeParameterDeclaration", t, r)
        }
        ,
        r.assertTSTypeParameter = function assertTSTypeParameter(t, r) {
            assert("TSTypeParameter", t, r)
        }
        ,
        r.assertExpression = function assertExpression(t, r) {
            assert("Expression", t, r)
        }
        ,
        r.assertBinary = function assertBinary(t, r) {
            assert("Binary", t, r)
        }
        ,
        r.assertScopable = function assertScopable(t, r) {
            assert("Scopable", t, r)
        }
        ,
        r.assertBlockParent = function assertBlockParent(t, r) {
            assert("BlockParent", t, r)
        }
        ,
        r.assertBlock = function assertBlock(t, r) {
            assert("Block", t, r)
        }
        ,
        r.assertStatement = function assertStatement(t, r) {
            assert("Statement", t, r)
        }
        ,
        r.assertTerminatorless = function assertTerminatorless(t, r) {
            assert("Terminatorless", t, r)
        }
        ,
        r.assertCompletionStatement = function assertCompletionStatement(t, r) {
            assert("CompletionStatement", t, r)
        }
        ,
        r.assertConditional = function assertConditional(t, r) {
            assert("Conditional", t, r)
        }
        ,
        r.assertLoop = function assertLoop(t, r) {
            assert("Loop", t, r)
        }
        ,
        r.assertWhile = function assertWhile(t, r) {
            assert("While", t, r)
        }
        ,
        r.assertExpressionWrapper = function assertExpressionWrapper(t, r) {
            assert("ExpressionWrapper", t, r)
        }
        ,
        r.assertFor = function assertFor(t, r) {
            assert("For", t, r)
        }
        ,
        r.assertForXStatement = function assertForXStatement(t, r) {
            assert("ForXStatement", t, r)
        }
        ,
        r.assertFunction = function assertFunction(t, r) {
            assert("Function", t, r)
        }
        ,
        r.assertFunctionParent = function assertFunctionParent(t, r) {
            assert("FunctionParent", t, r)
        }
        ,
        r.assertPureish = function assertPureish(t, r) {
            assert("Pureish", t, r)
        }
        ,
        r.assertDeclaration = function assertDeclaration(t, r) {
            assert("Declaration", t, r)
        }
        ,
        r.assertPatternLike = function assertPatternLike(t, r) {
            assert("PatternLike", t, r)
        }
        ,
        r.assertLVal = function assertLVal(t, r) {
            assert("LVal", t, r)
        }
        ,
        r.assertTSEntityName = function assertTSEntityName(t, r) {
            assert("TSEntityName", t, r)
        }
        ,
        r.assertLiteral = function assertLiteral(t, r) {
            assert("Literal", t, r)
        }
        ,
        r.assertImmutable = function assertImmutable(t, r) {
            assert("Immutable", t, r)
        }
        ,
        r.assertUserWhitespacable = function assertUserWhitespacable(t, r) {
            assert("UserWhitespacable", t, r)
        }
        ,
        r.assertMethod = function assertMethod(t, r) {
            assert("Method", t, r)
        }
        ,
        r.assertObjectMember = function assertObjectMember(t, r) {
            assert("ObjectMember", t, r)
        }
        ,
        r.assertProperty = function assertProperty(t, r) {
            assert("Property", t, r)
        }
        ,
        r.assertUnaryLike = function assertUnaryLike(t, r) {
            assert("UnaryLike", t, r)
        }
        ,
        r.assertPattern = function assertPattern(t, r) {
            assert("Pattern", t, r)
        }
        ,
        r.assertClass = function assertClass(t, r) {
            assert("Class", t, r)
        }
        ,
        r.assertModuleDeclaration = function assertModuleDeclaration(t, r) {
            assert("ModuleDeclaration", t, r)
        }
        ,
        r.assertExportDeclaration = function assertExportDeclaration(t, r) {
            assert("ExportDeclaration", t, r)
        }
        ,
        r.assertModuleSpecifier = function assertModuleSpecifier(t, r) {
            assert("ModuleSpecifier", t, r)
        }
        ,
        r.assertPrivate = function assertPrivate(t, r) {
            assert("Private", t, r)
        }
        ,
        r.assertFlow = function assertFlow(t, r) {
            assert("Flow", t, r)
        }
        ,
        r.assertFlowType = function assertFlowType(t, r) {
            assert("FlowType", t, r)
        }
        ,
        r.assertFlowBaseAnnotation = function assertFlowBaseAnnotation(t, r) {
            assert("FlowBaseAnnotation", t, r)
        }
        ,
        r.assertFlowDeclaration = function assertFlowDeclaration(t, r) {
            assert("FlowDeclaration", t, r)
        }
        ,
        r.assertFlowPredicate = function assertFlowPredicate(t, r) {
            assert("FlowPredicate", t, r)
        }
        ,
        r.assertEnumBody = function assertEnumBody(t, r) {
            assert("EnumBody", t, r)
        }
        ,
        r.assertEnumMember = function assertEnumMember(t, r) {
            assert("EnumMember", t, r)
        }
        ,
        r.assertJSX = function assertJSX(t, r) {
            assert("JSX", t, r)
        }
        ,
        r.assertTSTypeElement = function assertTSTypeElement(t, r) {
            assert("TSTypeElement", t, r)
        }
        ,
        r.assertTSType = function assertTSType(t, r) {
            assert("TSType", t, r)
        }
        ,
        r.assertTSBaseType = function assertTSBaseType(t, r) {
            assert("TSBaseType", t, r)
        }
        ,
        r.assertNumberLiteral = function assertNumberLiteral(t, r) {
            console.trace("The node type NumberLiteral has been renamed to NumericLiteral"),
            assert("NumberLiteral", t, r)
        }
        ,
        r.assertRegexLiteral = function assertRegexLiteral(t, r) {
            console.trace("The node type RegexLiteral has been renamed to RegExpLiteral"),
            assert("RegexLiteral", t, r)
        }
        ,
        r.assertRestProperty = function assertRestProperty(t, r) {
            console.trace("The node type RestProperty has been renamed to RestElement"),
            assert("RestProperty", t, r)
        }
        ,
        r.assertSpreadProperty = function assertSpreadProperty(t, r) {
            console.trace("The node type SpreadProperty has been renamed to SpreadElement"),
            assert("SpreadProperty", t, r)
        }
        ;
        var a = i("0G7A");
        function assert(t, r, i) {
            if (!(0,
            a.default)(t, r, i))
                throw new Error('Expected type "'.concat(t, '" with option ').concat(JSON.stringify(i), ", ") + 'but instead got "'.concat(r.type, '".'))
        }
    },
    "oBS/": function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function cloneWithoutLoc(t) {
            return (0,
            a.default)(t, !1, !0)
        }
        ;
        var a = i("sN7J")
    },
    oMr5: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function ensureBlock(t) {
            var r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "body";
            return t[r] = (0,
            a.default)(t[r], t)
        }
        ;
        var a = i("0Awz")
    },
    oUnQ: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = getBindingIdentifiers;
        var a = i("FUES");
        function getBindingIdentifiers(t, r, i) {
            for (var o = [].concat(t), l = Object.create(null); o.length; ) {
                var u = o.shift();
                if (u) {
                    var p = getBindingIdentifiers.keys[u.type];
                    if ((0,
                    a.isIdentifier)(u))
                        r ? (l[u.name] = l[u.name] || []).push(u) : l[u.name] = u;
                    else if (!(0,
                    a.isExportDeclaration)(u) || (0,
                    a.isExportAllDeclaration)(u)) {
                        if (i) {
                            if ((0,
                            a.isFunctionDeclaration)(u)) {
                                o.push(u.id);
                                continue
                            }
                            if ((0,
                            a.isFunctionExpression)(u))
                                continue
                        }
                        if (p)
                            for (var c = 0; c < p.length; c++) {
                                var d = p[c];
                                u[d] && (o = o.concat(u[d]))
                            }
                    } else
                        (0,
                        a.isDeclaration)(u.declaration) && o.push(u.declaration)
                }
            }
            return l
        }
        getBindingIdentifiers.keys = {
            DeclareClass: ["id"],
            DeclareFunction: ["id"],
            DeclareModule: ["id"],
            DeclareVariable: ["id"],
            DeclareInterface: ["id"],
            DeclareTypeAlias: ["id"],
            DeclareOpaqueType: ["id"],
            InterfaceDeclaration: ["id"],
            TypeAlias: ["id"],
            OpaqueType: ["id"],
            CatchClause: ["param"],
            LabeledStatement: ["label"],
            UnaryExpression: ["argument"],
            AssignmentExpression: ["left"],
            ImportSpecifier: ["local"],
            ImportNamespaceSpecifier: ["local"],
            ImportDefaultSpecifier: ["local"],
            ImportDeclaration: ["specifiers"],
            ExportSpecifier: ["exported"],
            ExportNamespaceSpecifier: ["exported"],
            ExportDefaultSpecifier: ["exported"],
            FunctionDeclaration: ["id", "params"],
            FunctionExpression: ["id", "params"],
            ArrowFunctionExpression: ["params"],
            ObjectMethod: ["params"],
            ClassMethod: ["params"],
            ForInStatement: ["left"],
            ForOfStatement: ["left"],
            ClassDeclaration: ["id"],
            ClassExpression: ["id"],
            RestElement: ["argument"],
            UpdateExpression: ["argument"],
            ObjectProperty: ["value"],
            AssignmentPattern: ["left"],
            ArrayPattern: ["elements"],
            ObjectPattern: ["properties"],
            VariableDeclaration: ["declarations"],
            VariableDeclarator: ["id"]
        }
    },
    oxjq: function(t, r, i) {
        "use strict";
        var a = /[|\\{}()[\]^$+*?.]/g;
        t.exports = function(t) {
            if ("string" != typeof t)
                throw new TypeError("Expected a string");
            return t.replace(a, "\\$&")
        }
    },
    pTTH: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = void 0;
        var a = i("pbIU")
          , o = i("UuI8")
          , l = function toStatement(t, r) {
            if ((0,
            a.isStatement)(t))
                return t;
            var i, l = !1;
            if ((0,
            a.isClass)(t))
                l = !0,
                i = "ClassDeclaration";
            else if ((0,
            a.isFunction)(t))
                l = !0,
                i = "FunctionDeclaration";
            else if ((0,
            a.isAssignmentExpression)(t))
                return (0,
                o.expressionStatement)(t);
            l && !t.id && (i = !1);
            if (!i) {
                if (r)
                    return !1;
                throw new Error("cannot turn ".concat(t.type, " to a statement"))
            }
            return t.type = i,
            t
        };
        r.default = l
    },
    pbIU: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.isAnyTypeAnnotation = function isAnyTypeAnnotation(t, r) {
            if (!t)
                return !1;
            if ("AnyTypeAnnotation" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isArgumentPlaceholder = function isArgumentPlaceholder(t, r) {
            if (!t)
                return !1;
            if ("ArgumentPlaceholder" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isArrayExpression = function isArrayExpression(t, r) {
            if (!t)
                return !1;
            if ("ArrayExpression" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isArrayPattern = function isArrayPattern(t, r) {
            if (!t)
                return !1;
            if ("ArrayPattern" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isArrayTypeAnnotation = function isArrayTypeAnnotation(t, r) {
            if (!t)
                return !1;
            if ("ArrayTypeAnnotation" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isArrowFunctionExpression = function isArrowFunctionExpression(t, r) {
            if (!t)
                return !1;
            if ("ArrowFunctionExpression" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isAssignmentExpression = function isAssignmentExpression(t, r) {
            if (!t)
                return !1;
            if ("AssignmentExpression" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isAssignmentPattern = function isAssignmentPattern(t, r) {
            if (!t)
                return !1;
            if ("AssignmentPattern" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isAwaitExpression = function isAwaitExpression(t, r) {
            if (!t)
                return !1;
            if ("AwaitExpression" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isBigIntLiteral = function isBigIntLiteral(t, r) {
            if (!t)
                return !1;
            if ("BigIntLiteral" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isBinary = function isBinary(t, r) {
            if (!t)
                return !1;
            var i = t.type;
            if ("BinaryExpression" === i || "LogicalExpression" === i)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isBinaryExpression = function isBinaryExpression(t, r) {
            if (!t)
                return !1;
            if ("BinaryExpression" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isBindExpression = function isBindExpression(t, r) {
            if (!t)
                return !1;
            if ("BindExpression" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isBlock = function isBlock(t, r) {
            if (!t)
                return !1;
            var i = t.type;
            if ("BlockStatement" === i || "Program" === i || "TSModuleBlock" === i || "Placeholder" === i && "BlockStatement" === t.expectedNode)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isBlockParent = function isBlockParent(t, r) {
            if (!t)
                return !1;
            var i = t.type;
            if ("BlockStatement" === i || "CatchClause" === i || "DoWhileStatement" === i || "ForInStatement" === i || "ForStatement" === i || "FunctionDeclaration" === i || "FunctionExpression" === i || "Program" === i || "ObjectMethod" === i || "SwitchStatement" === i || "WhileStatement" === i || "ArrowFunctionExpression" === i || "ForOfStatement" === i || "ClassMethod" === i || "ClassPrivateMethod" === i || "StaticBlock" === i || "TSModuleBlock" === i || "Placeholder" === i && "BlockStatement" === t.expectedNode)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isBlockStatement = function isBlockStatement(t, r) {
            if (!t)
                return !1;
            if ("BlockStatement" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isBooleanLiteral = function isBooleanLiteral(t, r) {
            if (!t)
                return !1;
            if ("BooleanLiteral" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isBooleanLiteralTypeAnnotation = function isBooleanLiteralTypeAnnotation(t, r) {
            if (!t)
                return !1;
            if ("BooleanLiteralTypeAnnotation" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isBooleanTypeAnnotation = function isBooleanTypeAnnotation(t, r) {
            if (!t)
                return !1;
            if ("BooleanTypeAnnotation" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isBreakStatement = function isBreakStatement(t, r) {
            if (!t)
                return !1;
            if ("BreakStatement" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isCallExpression = function isCallExpression(t, r) {
            if (!t)
                return !1;
            if ("CallExpression" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isCatchClause = function isCatchClause(t, r) {
            if (!t)
                return !1;
            if ("CatchClause" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isClass = function isClass(t, r) {
            if (!t)
                return !1;
            var i = t.type;
            if ("ClassExpression" === i || "ClassDeclaration" === i)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isClassBody = function isClassBody(t, r) {
            if (!t)
                return !1;
            if ("ClassBody" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isClassDeclaration = function isClassDeclaration(t, r) {
            if (!t)
                return !1;
            if ("ClassDeclaration" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isClassExpression = function isClassExpression(t, r) {
            if (!t)
                return !1;
            if ("ClassExpression" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isClassImplements = function isClassImplements(t, r) {
            if (!t)
                return !1;
            if ("ClassImplements" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isClassMethod = function isClassMethod(t, r) {
            if (!t)
                return !1;
            if ("ClassMethod" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isClassPrivateMethod = function isClassPrivateMethod(t, r) {
            if (!t)
                return !1;
            if ("ClassPrivateMethod" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isClassPrivateProperty = function isClassPrivateProperty(t, r) {
            if (!t)
                return !1;
            if ("ClassPrivateProperty" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isClassProperty = function isClassProperty(t, r) {
            if (!t)
                return !1;
            if ("ClassProperty" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isCompletionStatement = function isCompletionStatement(t, r) {
            if (!t)
                return !1;
            var i = t.type;
            if ("BreakStatement" === i || "ContinueStatement" === i || "ReturnStatement" === i || "ThrowStatement" === i)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isConditional = function isConditional(t, r) {
            if (!t)
                return !1;
            var i = t.type;
            if ("ConditionalExpression" === i || "IfStatement" === i)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isConditionalExpression = function isConditionalExpression(t, r) {
            if (!t)
                return !1;
            if ("ConditionalExpression" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isContinueStatement = function isContinueStatement(t, r) {
            if (!t)
                return !1;
            if ("ContinueStatement" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isDebuggerStatement = function isDebuggerStatement(t, r) {
            if (!t)
                return !1;
            if ("DebuggerStatement" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isDecimalLiteral = function isDecimalLiteral(t, r) {
            if (!t)
                return !1;
            if ("DecimalLiteral" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isDeclaration = function isDeclaration(t, r) {
            if (!t)
                return !1;
            var i = t.type;
            if ("FunctionDeclaration" === i || "VariableDeclaration" === i || "ClassDeclaration" === i || "ExportAllDeclaration" === i || "ExportDefaultDeclaration" === i || "ExportNamedDeclaration" === i || "ImportDeclaration" === i || "DeclareClass" === i || "DeclareFunction" === i || "DeclareInterface" === i || "DeclareModule" === i || "DeclareModuleExports" === i || "DeclareTypeAlias" === i || "DeclareOpaqueType" === i || "DeclareVariable" === i || "DeclareExportDeclaration" === i || "DeclareExportAllDeclaration" === i || "InterfaceDeclaration" === i || "OpaqueType" === i || "TypeAlias" === i || "EnumDeclaration" === i || "TSDeclareFunction" === i || "TSInterfaceDeclaration" === i || "TSTypeAliasDeclaration" === i || "TSEnumDeclaration" === i || "TSModuleDeclaration" === i || "Placeholder" === i && "Declaration" === t.expectedNode)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isDeclareClass = function isDeclareClass(t, r) {
            if (!t)
                return !1;
            if ("DeclareClass" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isDeclareExportAllDeclaration = function isDeclareExportAllDeclaration(t, r) {
            if (!t)
                return !1;
            if ("DeclareExportAllDeclaration" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isDeclareExportDeclaration = function isDeclareExportDeclaration(t, r) {
            if (!t)
                return !1;
            if ("DeclareExportDeclaration" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isDeclareFunction = function isDeclareFunction(t, r) {
            if (!t)
                return !1;
            if ("DeclareFunction" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isDeclareInterface = function isDeclareInterface(t, r) {
            if (!t)
                return !1;
            if ("DeclareInterface" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isDeclareModule = function isDeclareModule(t, r) {
            if (!t)
                return !1;
            if ("DeclareModule" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isDeclareModuleExports = function isDeclareModuleExports(t, r) {
            if (!t)
                return !1;
            if ("DeclareModuleExports" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isDeclareOpaqueType = function isDeclareOpaqueType(t, r) {
            if (!t)
                return !1;
            if ("DeclareOpaqueType" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isDeclareTypeAlias = function isDeclareTypeAlias(t, r) {
            if (!t)
                return !1;
            if ("DeclareTypeAlias" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isDeclareVariable = function isDeclareVariable(t, r) {
            if (!t)
                return !1;
            if ("DeclareVariable" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isDeclaredPredicate = function isDeclaredPredicate(t, r) {
            if (!t)
                return !1;
            if ("DeclaredPredicate" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isDecorator = function isDecorator(t, r) {
            if (!t)
                return !1;
            if ("Decorator" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isDirective = function isDirective(t, r) {
            if (!t)
                return !1;
            if ("Directive" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isDirectiveLiteral = function isDirectiveLiteral(t, r) {
            if (!t)
                return !1;
            if ("DirectiveLiteral" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isDoExpression = function isDoExpression(t, r) {
            if (!t)
                return !1;
            if ("DoExpression" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isDoWhileStatement = function isDoWhileStatement(t, r) {
            if (!t)
                return !1;
            if ("DoWhileStatement" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isEmptyStatement = function isEmptyStatement(t, r) {
            if (!t)
                return !1;
            if ("EmptyStatement" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isEmptyTypeAnnotation = function isEmptyTypeAnnotation(t, r) {
            if (!t)
                return !1;
            if ("EmptyTypeAnnotation" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isEnumBody = function isEnumBody(t, r) {
            if (!t)
                return !1;
            var i = t.type;
            if ("EnumBooleanBody" === i || "EnumNumberBody" === i || "EnumStringBody" === i || "EnumSymbolBody" === i)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isEnumBooleanBody = function isEnumBooleanBody(t, r) {
            if (!t)
                return !1;
            if ("EnumBooleanBody" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isEnumBooleanMember = function isEnumBooleanMember(t, r) {
            if (!t)
                return !1;
            if ("EnumBooleanMember" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isEnumDeclaration = function isEnumDeclaration(t, r) {
            if (!t)
                return !1;
            if ("EnumDeclaration" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isEnumDefaultedMember = function isEnumDefaultedMember(t, r) {
            if (!t)
                return !1;
            if ("EnumDefaultedMember" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isEnumMember = function isEnumMember(t, r) {
            if (!t)
                return !1;
            var i = t.type;
            if ("EnumBooleanMember" === i || "EnumNumberMember" === i || "EnumStringMember" === i || "EnumDefaultedMember" === i)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isEnumNumberBody = function isEnumNumberBody(t, r) {
            if (!t)
                return !1;
            if ("EnumNumberBody" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isEnumNumberMember = function isEnumNumberMember(t, r) {
            if (!t)
                return !1;
            if ("EnumNumberMember" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isEnumStringBody = function isEnumStringBody(t, r) {
            if (!t)
                return !1;
            if ("EnumStringBody" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isEnumStringMember = function isEnumStringMember(t, r) {
            if (!t)
                return !1;
            if ("EnumStringMember" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isEnumSymbolBody = function isEnumSymbolBody(t, r) {
            if (!t)
                return !1;
            if ("EnumSymbolBody" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isExistsTypeAnnotation = function isExistsTypeAnnotation(t, r) {
            if (!t)
                return !1;
            if ("ExistsTypeAnnotation" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isExportAllDeclaration = function isExportAllDeclaration(t, r) {
            if (!t)
                return !1;
            if ("ExportAllDeclaration" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isExportDeclaration = function isExportDeclaration(t, r) {
            if (!t)
                return !1;
            var i = t.type;
            if ("ExportAllDeclaration" === i || "ExportDefaultDeclaration" === i || "ExportNamedDeclaration" === i)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isExportDefaultDeclaration = function isExportDefaultDeclaration(t, r) {
            if (!t)
                return !1;
            if ("ExportDefaultDeclaration" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isExportDefaultSpecifier = function isExportDefaultSpecifier(t, r) {
            if (!t)
                return !1;
            if ("ExportDefaultSpecifier" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isExportNamedDeclaration = function isExportNamedDeclaration(t, r) {
            if (!t)
                return !1;
            if ("ExportNamedDeclaration" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isExportNamespaceSpecifier = function isExportNamespaceSpecifier(t, r) {
            if (!t)
                return !1;
            if ("ExportNamespaceSpecifier" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isExportSpecifier = function isExportSpecifier(t, r) {
            if (!t)
                return !1;
            if ("ExportSpecifier" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isExpression = function isExpression(t, r) {
            if (!t)
                return !1;
            var i = t.type;
            if ("ArrayExpression" === i || "AssignmentExpression" === i || "BinaryExpression" === i || "CallExpression" === i || "ConditionalExpression" === i || "FunctionExpression" === i || "Identifier" === i || "StringLiteral" === i || "NumericLiteral" === i || "NullLiteral" === i || "BooleanLiteral" === i || "RegExpLiteral" === i || "LogicalExpression" === i || "MemberExpression" === i || "NewExpression" === i || "ObjectExpression" === i || "SequenceExpression" === i || "ParenthesizedExpression" === i || "ThisExpression" === i || "UnaryExpression" === i || "UpdateExpression" === i || "ArrowFunctionExpression" === i || "ClassExpression" === i || "MetaProperty" === i || "Super" === i || "TaggedTemplateExpression" === i || "TemplateLiteral" === i || "YieldExpression" === i || "AwaitExpression" === i || "Import" === i || "BigIntLiteral" === i || "OptionalMemberExpression" === i || "OptionalCallExpression" === i || "TypeCastExpression" === i || "JSXElement" === i || "JSXFragment" === i || "BindExpression" === i || "DoExpression" === i || "RecordExpression" === i || "TupleExpression" === i || "DecimalLiteral" === i || "ModuleExpression" === i || "TopicReference" === i || "PipelineTopicExpression" === i || "PipelineBareFunction" === i || "PipelinePrimaryTopicReference" === i || "TSAsExpression" === i || "TSTypeAssertion" === i || "TSNonNullExpression" === i || "Placeholder" === i && ("Expression" === t.expectedNode || "Identifier" === t.expectedNode || "StringLiteral" === t.expectedNode))
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isExpressionStatement = function isExpressionStatement(t, r) {
            if (!t)
                return !1;
            if ("ExpressionStatement" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isExpressionWrapper = function isExpressionWrapper(t, r) {
            if (!t)
                return !1;
            var i = t.type;
            if ("ExpressionStatement" === i || "ParenthesizedExpression" === i || "TypeCastExpression" === i)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isFile = function isFile(t, r) {
            if (!t)
                return !1;
            if ("File" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isFlow = function isFlow(t, r) {
            if (!t)
                return !1;
            var i = t.type;
            if ("AnyTypeAnnotation" === i || "ArrayTypeAnnotation" === i || "BooleanTypeAnnotation" === i || "BooleanLiteralTypeAnnotation" === i || "NullLiteralTypeAnnotation" === i || "ClassImplements" === i || "DeclareClass" === i || "DeclareFunction" === i || "DeclareInterface" === i || "DeclareModule" === i || "DeclareModuleExports" === i || "DeclareTypeAlias" === i || "DeclareOpaqueType" === i || "DeclareVariable" === i || "DeclareExportDeclaration" === i || "DeclareExportAllDeclaration" === i || "DeclaredPredicate" === i || "ExistsTypeAnnotation" === i || "FunctionTypeAnnotation" === i || "FunctionTypeParam" === i || "GenericTypeAnnotation" === i || "InferredPredicate" === i || "InterfaceExtends" === i || "InterfaceDeclaration" === i || "InterfaceTypeAnnotation" === i || "IntersectionTypeAnnotation" === i || "MixedTypeAnnotation" === i || "EmptyTypeAnnotation" === i || "NullableTypeAnnotation" === i || "NumberLiteralTypeAnnotation" === i || "NumberTypeAnnotation" === i || "ObjectTypeAnnotation" === i || "ObjectTypeInternalSlot" === i || "ObjectTypeCallProperty" === i || "ObjectTypeIndexer" === i || "ObjectTypeProperty" === i || "ObjectTypeSpreadProperty" === i || "OpaqueType" === i || "QualifiedTypeIdentifier" === i || "StringLiteralTypeAnnotation" === i || "StringTypeAnnotation" === i || "SymbolTypeAnnotation" === i || "ThisTypeAnnotation" === i || "TupleTypeAnnotation" === i || "TypeofTypeAnnotation" === i || "TypeAlias" === i || "TypeAnnotation" === i || "TypeCastExpression" === i || "TypeParameter" === i || "TypeParameterDeclaration" === i || "TypeParameterInstantiation" === i || "UnionTypeAnnotation" === i || "Variance" === i || "VoidTypeAnnotation" === i || "EnumDeclaration" === i || "EnumBooleanBody" === i || "EnumNumberBody" === i || "EnumStringBody" === i || "EnumSymbolBody" === i || "EnumBooleanMember" === i || "EnumNumberMember" === i || "EnumStringMember" === i || "EnumDefaultedMember" === i || "IndexedAccessType" === i || "OptionalIndexedAccessType" === i)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isFlowBaseAnnotation = function isFlowBaseAnnotation(t, r) {
            if (!t)
                return !1;
            var i = t.type;
            if ("AnyTypeAnnotation" === i || "BooleanTypeAnnotation" === i || "NullLiteralTypeAnnotation" === i || "MixedTypeAnnotation" === i || "EmptyTypeAnnotation" === i || "NumberTypeAnnotation" === i || "StringTypeAnnotation" === i || "SymbolTypeAnnotation" === i || "ThisTypeAnnotation" === i || "VoidTypeAnnotation" === i)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isFlowDeclaration = function isFlowDeclaration(t, r) {
            if (!t)
                return !1;
            var i = t.type;
            if ("DeclareClass" === i || "DeclareFunction" === i || "DeclareInterface" === i || "DeclareModule" === i || "DeclareModuleExports" === i || "DeclareTypeAlias" === i || "DeclareOpaqueType" === i || "DeclareVariable" === i || "DeclareExportDeclaration" === i || "DeclareExportAllDeclaration" === i || "InterfaceDeclaration" === i || "OpaqueType" === i || "TypeAlias" === i)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isFlowPredicate = function isFlowPredicate(t, r) {
            if (!t)
                return !1;
            var i = t.type;
            if ("DeclaredPredicate" === i || "InferredPredicate" === i)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isFlowType = function isFlowType(t, r) {
            if (!t)
                return !1;
            var i = t.type;
            if ("AnyTypeAnnotation" === i || "ArrayTypeAnnotation" === i || "BooleanTypeAnnotation" === i || "BooleanLiteralTypeAnnotation" === i || "NullLiteralTypeAnnotation" === i || "ExistsTypeAnnotation" === i || "FunctionTypeAnnotation" === i || "GenericTypeAnnotation" === i || "InterfaceTypeAnnotation" === i || "IntersectionTypeAnnotation" === i || "MixedTypeAnnotation" === i || "EmptyTypeAnnotation" === i || "NullableTypeAnnotation" === i || "NumberLiteralTypeAnnotation" === i || "NumberTypeAnnotation" === i || "ObjectTypeAnnotation" === i || "StringLiteralTypeAnnotation" === i || "StringTypeAnnotation" === i || "SymbolTypeAnnotation" === i || "ThisTypeAnnotation" === i || "TupleTypeAnnotation" === i || "TypeofTypeAnnotation" === i || "UnionTypeAnnotation" === i || "VoidTypeAnnotation" === i || "IndexedAccessType" === i || "OptionalIndexedAccessType" === i)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isFor = function isFor(t, r) {
            if (!t)
                return !1;
            var i = t.type;
            if ("ForInStatement" === i || "ForStatement" === i || "ForOfStatement" === i)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isForInStatement = function isForInStatement(t, r) {
            if (!t)
                return !1;
            if ("ForInStatement" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isForOfStatement = function isForOfStatement(t, r) {
            if (!t)
                return !1;
            if ("ForOfStatement" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isForStatement = function isForStatement(t, r) {
            if (!t)
                return !1;
            if ("ForStatement" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isForXStatement = function isForXStatement(t, r) {
            if (!t)
                return !1;
            var i = t.type;
            if ("ForInStatement" === i || "ForOfStatement" === i)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isFunction = function isFunction(t, r) {
            if (!t)
                return !1;
            var i = t.type;
            if ("FunctionDeclaration" === i || "FunctionExpression" === i || "ObjectMethod" === i || "ArrowFunctionExpression" === i || "ClassMethod" === i || "ClassPrivateMethod" === i)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isFunctionDeclaration = function isFunctionDeclaration(t, r) {
            if (!t)
                return !1;
            if ("FunctionDeclaration" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isFunctionExpression = function isFunctionExpression(t, r) {
            if (!t)
                return !1;
            if ("FunctionExpression" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isFunctionParent = function isFunctionParent(t, r) {
            if (!t)
                return !1;
            var i = t.type;
            if ("FunctionDeclaration" === i || "FunctionExpression" === i || "ObjectMethod" === i || "ArrowFunctionExpression" === i || "ClassMethod" === i || "ClassPrivateMethod" === i || "StaticBlock" === i)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isFunctionTypeAnnotation = function isFunctionTypeAnnotation(t, r) {
            if (!t)
                return !1;
            if ("FunctionTypeAnnotation" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isFunctionTypeParam = function isFunctionTypeParam(t, r) {
            if (!t)
                return !1;
            if ("FunctionTypeParam" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isGenericTypeAnnotation = function isGenericTypeAnnotation(t, r) {
            if (!t)
                return !1;
            if ("GenericTypeAnnotation" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isIdentifier = function isIdentifier(t, r) {
            if (!t)
                return !1;
            if ("Identifier" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isIfStatement = function isIfStatement(t, r) {
            if (!t)
                return !1;
            if ("IfStatement" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isImmutable = function isImmutable(t, r) {
            if (!t)
                return !1;
            var i = t.type;
            if ("StringLiteral" === i || "NumericLiteral" === i || "NullLiteral" === i || "BooleanLiteral" === i || "BigIntLiteral" === i || "JSXAttribute" === i || "JSXClosingElement" === i || "JSXElement" === i || "JSXExpressionContainer" === i || "JSXSpreadChild" === i || "JSXOpeningElement" === i || "JSXText" === i || "JSXFragment" === i || "JSXOpeningFragment" === i || "JSXClosingFragment" === i || "DecimalLiteral" === i || "Placeholder" === i && "StringLiteral" === t.expectedNode)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isImport = function isImport(t, r) {
            if (!t)
                return !1;
            if ("Import" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isImportAttribute = function isImportAttribute(t, r) {
            if (!t)
                return !1;
            if ("ImportAttribute" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isImportDeclaration = function isImportDeclaration(t, r) {
            if (!t)
                return !1;
            if ("ImportDeclaration" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isImportDefaultSpecifier = function isImportDefaultSpecifier(t, r) {
            if (!t)
                return !1;
            if ("ImportDefaultSpecifier" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isImportNamespaceSpecifier = function isImportNamespaceSpecifier(t, r) {
            if (!t)
                return !1;
            if ("ImportNamespaceSpecifier" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isImportSpecifier = function isImportSpecifier(t, r) {
            if (!t)
                return !1;
            if ("ImportSpecifier" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isIndexedAccessType = function isIndexedAccessType(t, r) {
            if (!t)
                return !1;
            if ("IndexedAccessType" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isInferredPredicate = function isInferredPredicate(t, r) {
            if (!t)
                return !1;
            if ("InferredPredicate" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isInterfaceDeclaration = function isInterfaceDeclaration(t, r) {
            if (!t)
                return !1;
            if ("InterfaceDeclaration" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isInterfaceExtends = function isInterfaceExtends(t, r) {
            if (!t)
                return !1;
            if ("InterfaceExtends" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isInterfaceTypeAnnotation = function isInterfaceTypeAnnotation(t, r) {
            if (!t)
                return !1;
            if ("InterfaceTypeAnnotation" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isInterpreterDirective = function isInterpreterDirective(t, r) {
            if (!t)
                return !1;
            if ("InterpreterDirective" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isIntersectionTypeAnnotation = function isIntersectionTypeAnnotation(t, r) {
            if (!t)
                return !1;
            if ("IntersectionTypeAnnotation" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isJSX = function isJSX(t, r) {
            if (!t)
                return !1;
            var i = t.type;
            if ("JSXAttribute" === i || "JSXClosingElement" === i || "JSXElement" === i || "JSXEmptyExpression" === i || "JSXExpressionContainer" === i || "JSXSpreadChild" === i || "JSXIdentifier" === i || "JSXMemberExpression" === i || "JSXNamespacedName" === i || "JSXOpeningElement" === i || "JSXSpreadAttribute" === i || "JSXText" === i || "JSXFragment" === i || "JSXOpeningFragment" === i || "JSXClosingFragment" === i)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isJSXAttribute = function isJSXAttribute(t, r) {
            if (!t)
                return !1;
            if ("JSXAttribute" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isJSXClosingElement = function isJSXClosingElement(t, r) {
            if (!t)
                return !1;
            if ("JSXClosingElement" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isJSXClosingFragment = function isJSXClosingFragment(t, r) {
            if (!t)
                return !1;
            if ("JSXClosingFragment" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isJSXElement = function isJSXElement(t, r) {
            if (!t)
                return !1;
            if ("JSXElement" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isJSXEmptyExpression = function isJSXEmptyExpression(t, r) {
            if (!t)
                return !1;
            if ("JSXEmptyExpression" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isJSXExpressionContainer = function isJSXExpressionContainer(t, r) {
            if (!t)
                return !1;
            if ("JSXExpressionContainer" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isJSXFragment = function isJSXFragment(t, r) {
            if (!t)
                return !1;
            if ("JSXFragment" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isJSXIdentifier = function isJSXIdentifier(t, r) {
            if (!t)
                return !1;
            if ("JSXIdentifier" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isJSXMemberExpression = function isJSXMemberExpression(t, r) {
            if (!t)
                return !1;
            if ("JSXMemberExpression" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isJSXNamespacedName = function isJSXNamespacedName(t, r) {
            if (!t)
                return !1;
            if ("JSXNamespacedName" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isJSXOpeningElement = function isJSXOpeningElement(t, r) {
            if (!t)
                return !1;
            if ("JSXOpeningElement" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isJSXOpeningFragment = function isJSXOpeningFragment(t, r) {
            if (!t)
                return !1;
            if ("JSXOpeningFragment" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isJSXSpreadAttribute = function isJSXSpreadAttribute(t, r) {
            if (!t)
                return !1;
            if ("JSXSpreadAttribute" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isJSXSpreadChild = function isJSXSpreadChild(t, r) {
            if (!t)
                return !1;
            if ("JSXSpreadChild" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isJSXText = function isJSXText(t, r) {
            if (!t)
                return !1;
            if ("JSXText" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isLVal = function isLVal(t, r) {
            if (!t)
                return !1;
            var i = t.type;
            if ("Identifier" === i || "MemberExpression" === i || "RestElement" === i || "AssignmentPattern" === i || "ArrayPattern" === i || "ObjectPattern" === i || "TSParameterProperty" === i || "Placeholder" === i && ("Pattern" === t.expectedNode || "Identifier" === t.expectedNode))
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isLabeledStatement = function isLabeledStatement(t, r) {
            if (!t)
                return !1;
            if ("LabeledStatement" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isLiteral = function isLiteral(t, r) {
            if (!t)
                return !1;
            var i = t.type;
            if ("StringLiteral" === i || "NumericLiteral" === i || "NullLiteral" === i || "BooleanLiteral" === i || "RegExpLiteral" === i || "TemplateLiteral" === i || "BigIntLiteral" === i || "DecimalLiteral" === i || "Placeholder" === i && "StringLiteral" === t.expectedNode)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isLogicalExpression = function isLogicalExpression(t, r) {
            if (!t)
                return !1;
            if ("LogicalExpression" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isLoop = function isLoop(t, r) {
            if (!t)
                return !1;
            var i = t.type;
            if ("DoWhileStatement" === i || "ForInStatement" === i || "ForStatement" === i || "WhileStatement" === i || "ForOfStatement" === i)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isMemberExpression = function isMemberExpression(t, r) {
            if (!t)
                return !1;
            if ("MemberExpression" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isMetaProperty = function isMetaProperty(t, r) {
            if (!t)
                return !1;
            if ("MetaProperty" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isMethod = function isMethod(t, r) {
            if (!t)
                return !1;
            var i = t.type;
            if ("ObjectMethod" === i || "ClassMethod" === i || "ClassPrivateMethod" === i)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isMiscellaneous = function isMiscellaneous(t, r) {
            if (!t)
                return !1;
            var i = t.type;
            if ("Noop" === i || "Placeholder" === i || "V8IntrinsicIdentifier" === i)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isMixedTypeAnnotation = function isMixedTypeAnnotation(t, r) {
            if (!t)
                return !1;
            if ("MixedTypeAnnotation" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isModuleDeclaration = function isModuleDeclaration(t, r) {
            if (!t)
                return !1;
            var i = t.type;
            if ("ExportAllDeclaration" === i || "ExportDefaultDeclaration" === i || "ExportNamedDeclaration" === i || "ImportDeclaration" === i)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isModuleExpression = function isModuleExpression(t, r) {
            if (!t)
                return !1;
            if ("ModuleExpression" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isModuleSpecifier = function isModuleSpecifier(t, r) {
            if (!t)
                return !1;
            var i = t.type;
            if ("ExportSpecifier" === i || "ImportDefaultSpecifier" === i || "ImportNamespaceSpecifier" === i || "ImportSpecifier" === i || "ExportNamespaceSpecifier" === i || "ExportDefaultSpecifier" === i)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isNewExpression = function isNewExpression(t, r) {
            if (!t)
                return !1;
            if ("NewExpression" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isNoop = function isNoop(t, r) {
            if (!t)
                return !1;
            if ("Noop" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isNullLiteral = function isNullLiteral(t, r) {
            if (!t)
                return !1;
            if ("NullLiteral" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isNullLiteralTypeAnnotation = function isNullLiteralTypeAnnotation(t, r) {
            if (!t)
                return !1;
            if ("NullLiteralTypeAnnotation" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isNullableTypeAnnotation = function isNullableTypeAnnotation(t, r) {
            if (!t)
                return !1;
            if ("NullableTypeAnnotation" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isNumberLiteral = function isNumberLiteral(t, r) {
            if (console.trace("The node type NumberLiteral has been renamed to NumericLiteral"),
            !t)
                return !1;
            if ("NumberLiteral" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isNumberLiteralTypeAnnotation = function isNumberLiteralTypeAnnotation(t, r) {
            if (!t)
                return !1;
            if ("NumberLiteralTypeAnnotation" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isNumberTypeAnnotation = function isNumberTypeAnnotation(t, r) {
            if (!t)
                return !1;
            if ("NumberTypeAnnotation" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isNumericLiteral = function isNumericLiteral(t, r) {
            if (!t)
                return !1;
            if ("NumericLiteral" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isObjectExpression = function isObjectExpression(t, r) {
            if (!t)
                return !1;
            if ("ObjectExpression" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isObjectMember = function isObjectMember(t, r) {
            if (!t)
                return !1;
            var i = t.type;
            if ("ObjectMethod" === i || "ObjectProperty" === i)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isObjectMethod = function isObjectMethod(t, r) {
            if (!t)
                return !1;
            if ("ObjectMethod" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isObjectPattern = function isObjectPattern(t, r) {
            if (!t)
                return !1;
            if ("ObjectPattern" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isObjectProperty = function isObjectProperty(t, r) {
            if (!t)
                return !1;
            if ("ObjectProperty" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isObjectTypeAnnotation = function isObjectTypeAnnotation(t, r) {
            if (!t)
                return !1;
            if ("ObjectTypeAnnotation" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isObjectTypeCallProperty = function isObjectTypeCallProperty(t, r) {
            if (!t)
                return !1;
            if ("ObjectTypeCallProperty" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isObjectTypeIndexer = function isObjectTypeIndexer(t, r) {
            if (!t)
                return !1;
            if ("ObjectTypeIndexer" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isObjectTypeInternalSlot = function isObjectTypeInternalSlot(t, r) {
            if (!t)
                return !1;
            if ("ObjectTypeInternalSlot" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isObjectTypeProperty = function isObjectTypeProperty(t, r) {
            if (!t)
                return !1;
            if ("ObjectTypeProperty" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isObjectTypeSpreadProperty = function isObjectTypeSpreadProperty(t, r) {
            if (!t)
                return !1;
            if ("ObjectTypeSpreadProperty" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isOpaqueType = function isOpaqueType(t, r) {
            if (!t)
                return !1;
            if ("OpaqueType" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isOptionalCallExpression = function isOptionalCallExpression(t, r) {
            if (!t)
                return !1;
            if ("OptionalCallExpression" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isOptionalIndexedAccessType = function isOptionalIndexedAccessType(t, r) {
            if (!t)
                return !1;
            if ("OptionalIndexedAccessType" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isOptionalMemberExpression = function isOptionalMemberExpression(t, r) {
            if (!t)
                return !1;
            if ("OptionalMemberExpression" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isParenthesizedExpression = function isParenthesizedExpression(t, r) {
            if (!t)
                return !1;
            if ("ParenthesizedExpression" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isPattern = function isPattern(t, r) {
            if (!t)
                return !1;
            var i = t.type;
            if ("AssignmentPattern" === i || "ArrayPattern" === i || "ObjectPattern" === i || "Placeholder" === i && "Pattern" === t.expectedNode)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isPatternLike = function isPatternLike(t, r) {
            if (!t)
                return !1;
            var i = t.type;
            if ("Identifier" === i || "RestElement" === i || "AssignmentPattern" === i || "ArrayPattern" === i || "ObjectPattern" === i || "Placeholder" === i && ("Pattern" === t.expectedNode || "Identifier" === t.expectedNode))
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isPipelineBareFunction = function isPipelineBareFunction(t, r) {
            if (!t)
                return !1;
            if ("PipelineBareFunction" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isPipelinePrimaryTopicReference = function isPipelinePrimaryTopicReference(t, r) {
            if (!t)
                return !1;
            if ("PipelinePrimaryTopicReference" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isPipelineTopicExpression = function isPipelineTopicExpression(t, r) {
            if (!t)
                return !1;
            if ("PipelineTopicExpression" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isPlaceholder = function isPlaceholder(t, r) {
            if (!t)
                return !1;
            if ("Placeholder" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isPrivate = function isPrivate(t, r) {
            if (!t)
                return !1;
            var i = t.type;
            if ("ClassPrivateProperty" === i || "ClassPrivateMethod" === i || "PrivateName" === i)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isPrivateName = function isPrivateName(t, r) {
            if (!t)
                return !1;
            if ("PrivateName" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isProgram = function isProgram(t, r) {
            if (!t)
                return !1;
            if ("Program" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isProperty = function isProperty(t, r) {
            if (!t)
                return !1;
            var i = t.type;
            if ("ObjectProperty" === i || "ClassProperty" === i || "ClassPrivateProperty" === i)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isPureish = function isPureish(t, r) {
            if (!t)
                return !1;
            var i = t.type;
            if ("FunctionDeclaration" === i || "FunctionExpression" === i || "StringLiteral" === i || "NumericLiteral" === i || "NullLiteral" === i || "BooleanLiteral" === i || "RegExpLiteral" === i || "ArrowFunctionExpression" === i || "BigIntLiteral" === i || "DecimalLiteral" === i || "Placeholder" === i && "StringLiteral" === t.expectedNode)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isQualifiedTypeIdentifier = function isQualifiedTypeIdentifier(t, r) {
            if (!t)
                return !1;
            if ("QualifiedTypeIdentifier" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isRecordExpression = function isRecordExpression(t, r) {
            if (!t)
                return !1;
            if ("RecordExpression" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isRegExpLiteral = function isRegExpLiteral(t, r) {
            if (!t)
                return !1;
            if ("RegExpLiteral" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isRegexLiteral = function isRegexLiteral(t, r) {
            if (console.trace("The node type RegexLiteral has been renamed to RegExpLiteral"),
            !t)
                return !1;
            if ("RegexLiteral" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isRestElement = function isRestElement(t, r) {
            if (!t)
                return !1;
            if ("RestElement" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isRestProperty = function isRestProperty(t, r) {
            if (console.trace("The node type RestProperty has been renamed to RestElement"),
            !t)
                return !1;
            if ("RestProperty" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isReturnStatement = function isReturnStatement(t, r) {
            if (!t)
                return !1;
            if ("ReturnStatement" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isScopable = function isScopable(t, r) {
            if (!t)
                return !1;
            var i = t.type;
            if ("BlockStatement" === i || "CatchClause" === i || "DoWhileStatement" === i || "ForInStatement" === i || "ForStatement" === i || "FunctionDeclaration" === i || "FunctionExpression" === i || "Program" === i || "ObjectMethod" === i || "SwitchStatement" === i || "WhileStatement" === i || "ArrowFunctionExpression" === i || "ClassExpression" === i || "ClassDeclaration" === i || "ForOfStatement" === i || "ClassMethod" === i || "ClassPrivateMethod" === i || "StaticBlock" === i || "TSModuleBlock" === i || "Placeholder" === i && "BlockStatement" === t.expectedNode)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isSequenceExpression = function isSequenceExpression(t, r) {
            if (!t)
                return !1;
            if ("SequenceExpression" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isSpreadElement = function isSpreadElement(t, r) {
            if (!t)
                return !1;
            if ("SpreadElement" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isSpreadProperty = function isSpreadProperty(t, r) {
            if (console.trace("The node type SpreadProperty has been renamed to SpreadElement"),
            !t)
                return !1;
            if ("SpreadProperty" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isStandardized = function isStandardized(t, r) {
            if (!t)
                return !1;
            var i = t.type;
            if ("ArrayExpression" === i || "AssignmentExpression" === i || "BinaryExpression" === i || "InterpreterDirective" === i || "Directive" === i || "DirectiveLiteral" === i || "BlockStatement" === i || "BreakStatement" === i || "CallExpression" === i || "CatchClause" === i || "ConditionalExpression" === i || "ContinueStatement" === i || "DebuggerStatement" === i || "DoWhileStatement" === i || "EmptyStatement" === i || "ExpressionStatement" === i || "File" === i || "ForInStatement" === i || "ForStatement" === i || "FunctionDeclaration" === i || "FunctionExpression" === i || "Identifier" === i || "IfStatement" === i || "LabeledStatement" === i || "StringLiteral" === i || "NumericLiteral" === i || "NullLiteral" === i || "BooleanLiteral" === i || "RegExpLiteral" === i || "LogicalExpression" === i || "MemberExpression" === i || "NewExpression" === i || "Program" === i || "ObjectExpression" === i || "ObjectMethod" === i || "ObjectProperty" === i || "RestElement" === i || "ReturnStatement" === i || "SequenceExpression" === i || "ParenthesizedExpression" === i || "SwitchCase" === i || "SwitchStatement" === i || "ThisExpression" === i || "ThrowStatement" === i || "TryStatement" === i || "UnaryExpression" === i || "UpdateExpression" === i || "VariableDeclaration" === i || "VariableDeclarator" === i || "WhileStatement" === i || "WithStatement" === i || "AssignmentPattern" === i || "ArrayPattern" === i || "ArrowFunctionExpression" === i || "ClassBody" === i || "ClassExpression" === i || "ClassDeclaration" === i || "ExportAllDeclaration" === i || "ExportDefaultDeclaration" === i || "ExportNamedDeclaration" === i || "ExportSpecifier" === i || "ForOfStatement" === i || "ImportDeclaration" === i || "ImportDefaultSpecifier" === i || "ImportNamespaceSpecifier" === i || "ImportSpecifier" === i || "MetaProperty" === i || "ClassMethod" === i || "ObjectPattern" === i || "SpreadElement" === i || "Super" === i || "TaggedTemplateExpression" === i || "TemplateElement" === i || "TemplateLiteral" === i || "YieldExpression" === i || "AwaitExpression" === i || "Import" === i || "BigIntLiteral" === i || "ExportNamespaceSpecifier" === i || "OptionalMemberExpression" === i || "OptionalCallExpression" === i || "ClassProperty" === i || "ClassPrivateProperty" === i || "ClassPrivateMethod" === i || "PrivateName" === i || "StaticBlock" === i || "Placeholder" === i && ("Identifier" === t.expectedNode || "StringLiteral" === t.expectedNode || "BlockStatement" === t.expectedNode || "ClassBody" === t.expectedNode))
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isStatement = function isStatement(t, r) {
            if (!t)
                return !1;
            var i = t.type;
            if ("BlockStatement" === i || "BreakStatement" === i || "ContinueStatement" === i || "DebuggerStatement" === i || "DoWhileStatement" === i || "EmptyStatement" === i || "ExpressionStatement" === i || "ForInStatement" === i || "ForStatement" === i || "FunctionDeclaration" === i || "IfStatement" === i || "LabeledStatement" === i || "ReturnStatement" === i || "SwitchStatement" === i || "ThrowStatement" === i || "TryStatement" === i || "VariableDeclaration" === i || "WhileStatement" === i || "WithStatement" === i || "ClassDeclaration" === i || "ExportAllDeclaration" === i || "ExportDefaultDeclaration" === i || "ExportNamedDeclaration" === i || "ForOfStatement" === i || "ImportDeclaration" === i || "DeclareClass" === i || "DeclareFunction" === i || "DeclareInterface" === i || "DeclareModule" === i || "DeclareModuleExports" === i || "DeclareTypeAlias" === i || "DeclareOpaqueType" === i || "DeclareVariable" === i || "DeclareExportDeclaration" === i || "DeclareExportAllDeclaration" === i || "InterfaceDeclaration" === i || "OpaqueType" === i || "TypeAlias" === i || "EnumDeclaration" === i || "TSDeclareFunction" === i || "TSInterfaceDeclaration" === i || "TSTypeAliasDeclaration" === i || "TSEnumDeclaration" === i || "TSModuleDeclaration" === i || "TSImportEqualsDeclaration" === i || "TSExportAssignment" === i || "TSNamespaceExportDeclaration" === i || "Placeholder" === i && ("Statement" === t.expectedNode || "Declaration" === t.expectedNode || "BlockStatement" === t.expectedNode))
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isStaticBlock = function isStaticBlock(t, r) {
            if (!t)
                return !1;
            if ("StaticBlock" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isStringLiteral = function isStringLiteral(t, r) {
            if (!t)
                return !1;
            if ("StringLiteral" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isStringLiteralTypeAnnotation = function isStringLiteralTypeAnnotation(t, r) {
            if (!t)
                return !1;
            if ("StringLiteralTypeAnnotation" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isStringTypeAnnotation = function isStringTypeAnnotation(t, r) {
            if (!t)
                return !1;
            if ("StringTypeAnnotation" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isSuper = function isSuper(t, r) {
            if (!t)
                return !1;
            if ("Super" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isSwitchCase = function isSwitchCase(t, r) {
            if (!t)
                return !1;
            if ("SwitchCase" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isSwitchStatement = function isSwitchStatement(t, r) {
            if (!t)
                return !1;
            if ("SwitchStatement" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isSymbolTypeAnnotation = function isSymbolTypeAnnotation(t, r) {
            if (!t)
                return !1;
            if ("SymbolTypeAnnotation" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSAnyKeyword = function isTSAnyKeyword(t, r) {
            if (!t)
                return !1;
            if ("TSAnyKeyword" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSArrayType = function isTSArrayType(t, r) {
            if (!t)
                return !1;
            if ("TSArrayType" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSAsExpression = function isTSAsExpression(t, r) {
            if (!t)
                return !1;
            if ("TSAsExpression" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSBaseType = function isTSBaseType(t, r) {
            if (!t)
                return !1;
            var i = t.type;
            if ("TSAnyKeyword" === i || "TSBooleanKeyword" === i || "TSBigIntKeyword" === i || "TSIntrinsicKeyword" === i || "TSNeverKeyword" === i || "TSNullKeyword" === i || "TSNumberKeyword" === i || "TSObjectKeyword" === i || "TSStringKeyword" === i || "TSSymbolKeyword" === i || "TSUndefinedKeyword" === i || "TSUnknownKeyword" === i || "TSVoidKeyword" === i || "TSThisType" === i || "TSLiteralType" === i)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSBigIntKeyword = function isTSBigIntKeyword(t, r) {
            if (!t)
                return !1;
            if ("TSBigIntKeyword" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSBooleanKeyword = function isTSBooleanKeyword(t, r) {
            if (!t)
                return !1;
            if ("TSBooleanKeyword" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSCallSignatureDeclaration = function isTSCallSignatureDeclaration(t, r) {
            if (!t)
                return !1;
            if ("TSCallSignatureDeclaration" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSConditionalType = function isTSConditionalType(t, r) {
            if (!t)
                return !1;
            if ("TSConditionalType" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSConstructSignatureDeclaration = function isTSConstructSignatureDeclaration(t, r) {
            if (!t)
                return !1;
            if ("TSConstructSignatureDeclaration" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSConstructorType = function isTSConstructorType(t, r) {
            if (!t)
                return !1;
            if ("TSConstructorType" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSDeclareFunction = function isTSDeclareFunction(t, r) {
            if (!t)
                return !1;
            if ("TSDeclareFunction" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSDeclareMethod = function isTSDeclareMethod(t, r) {
            if (!t)
                return !1;
            if ("TSDeclareMethod" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSEntityName = function isTSEntityName(t, r) {
            if (!t)
                return !1;
            var i = t.type;
            if ("Identifier" === i || "TSQualifiedName" === i || "Placeholder" === i && "Identifier" === t.expectedNode)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSEnumDeclaration = function isTSEnumDeclaration(t, r) {
            if (!t)
                return !1;
            if ("TSEnumDeclaration" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSEnumMember = function isTSEnumMember(t, r) {
            if (!t)
                return !1;
            if ("TSEnumMember" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSExportAssignment = function isTSExportAssignment(t, r) {
            if (!t)
                return !1;
            if ("TSExportAssignment" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSExpressionWithTypeArguments = function isTSExpressionWithTypeArguments(t, r) {
            if (!t)
                return !1;
            if ("TSExpressionWithTypeArguments" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSExternalModuleReference = function isTSExternalModuleReference(t, r) {
            if (!t)
                return !1;
            if ("TSExternalModuleReference" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSFunctionType = function isTSFunctionType(t, r) {
            if (!t)
                return !1;
            if ("TSFunctionType" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSImportEqualsDeclaration = function isTSImportEqualsDeclaration(t, r) {
            if (!t)
                return !1;
            if ("TSImportEqualsDeclaration" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSImportType = function isTSImportType(t, r) {
            if (!t)
                return !1;
            if ("TSImportType" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSIndexSignature = function isTSIndexSignature(t, r) {
            if (!t)
                return !1;
            if ("TSIndexSignature" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSIndexedAccessType = function isTSIndexedAccessType(t, r) {
            if (!t)
                return !1;
            if ("TSIndexedAccessType" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSInferType = function isTSInferType(t, r) {
            if (!t)
                return !1;
            if ("TSInferType" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSInterfaceBody = function isTSInterfaceBody(t, r) {
            if (!t)
                return !1;
            if ("TSInterfaceBody" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSInterfaceDeclaration = function isTSInterfaceDeclaration(t, r) {
            if (!t)
                return !1;
            if ("TSInterfaceDeclaration" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSIntersectionType = function isTSIntersectionType(t, r) {
            if (!t)
                return !1;
            if ("TSIntersectionType" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSIntrinsicKeyword = function isTSIntrinsicKeyword(t, r) {
            if (!t)
                return !1;
            if ("TSIntrinsicKeyword" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSLiteralType = function isTSLiteralType(t, r) {
            if (!t)
                return !1;
            if ("TSLiteralType" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSMappedType = function isTSMappedType(t, r) {
            if (!t)
                return !1;
            if ("TSMappedType" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSMethodSignature = function isTSMethodSignature(t, r) {
            if (!t)
                return !1;
            if ("TSMethodSignature" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSModuleBlock = function isTSModuleBlock(t, r) {
            if (!t)
                return !1;
            if ("TSModuleBlock" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSModuleDeclaration = function isTSModuleDeclaration(t, r) {
            if (!t)
                return !1;
            if ("TSModuleDeclaration" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSNamedTupleMember = function isTSNamedTupleMember(t, r) {
            if (!t)
                return !1;
            if ("TSNamedTupleMember" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSNamespaceExportDeclaration = function isTSNamespaceExportDeclaration(t, r) {
            if (!t)
                return !1;
            if ("TSNamespaceExportDeclaration" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSNeverKeyword = function isTSNeverKeyword(t, r) {
            if (!t)
                return !1;
            if ("TSNeverKeyword" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSNonNullExpression = function isTSNonNullExpression(t, r) {
            if (!t)
                return !1;
            if ("TSNonNullExpression" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSNullKeyword = function isTSNullKeyword(t, r) {
            if (!t)
                return !1;
            if ("TSNullKeyword" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSNumberKeyword = function isTSNumberKeyword(t, r) {
            if (!t)
                return !1;
            if ("TSNumberKeyword" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSObjectKeyword = function isTSObjectKeyword(t, r) {
            if (!t)
                return !1;
            if ("TSObjectKeyword" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSOptionalType = function isTSOptionalType(t, r) {
            if (!t)
                return !1;
            if ("TSOptionalType" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSParameterProperty = function isTSParameterProperty(t, r) {
            if (!t)
                return !1;
            if ("TSParameterProperty" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSParenthesizedType = function isTSParenthesizedType(t, r) {
            if (!t)
                return !1;
            if ("TSParenthesizedType" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSPropertySignature = function isTSPropertySignature(t, r) {
            if (!t)
                return !1;
            if ("TSPropertySignature" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSQualifiedName = function isTSQualifiedName(t, r) {
            if (!t)
                return !1;
            if ("TSQualifiedName" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSRestType = function isTSRestType(t, r) {
            if (!t)
                return !1;
            if ("TSRestType" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSStringKeyword = function isTSStringKeyword(t, r) {
            if (!t)
                return !1;
            if ("TSStringKeyword" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSSymbolKeyword = function isTSSymbolKeyword(t, r) {
            if (!t)
                return !1;
            if ("TSSymbolKeyword" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSThisType = function isTSThisType(t, r) {
            if (!t)
                return !1;
            if ("TSThisType" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSTupleType = function isTSTupleType(t, r) {
            if (!t)
                return !1;
            if ("TSTupleType" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSType = function isTSType(t, r) {
            if (!t)
                return !1;
            var i = t.type;
            if ("TSAnyKeyword" === i || "TSBooleanKeyword" === i || "TSBigIntKeyword" === i || "TSIntrinsicKeyword" === i || "TSNeverKeyword" === i || "TSNullKeyword" === i || "TSNumberKeyword" === i || "TSObjectKeyword" === i || "TSStringKeyword" === i || "TSSymbolKeyword" === i || "TSUndefinedKeyword" === i || "TSUnknownKeyword" === i || "TSVoidKeyword" === i || "TSThisType" === i || "TSFunctionType" === i || "TSConstructorType" === i || "TSTypeReference" === i || "TSTypePredicate" === i || "TSTypeQuery" === i || "TSTypeLiteral" === i || "TSArrayType" === i || "TSTupleType" === i || "TSOptionalType" === i || "TSRestType" === i || "TSUnionType" === i || "TSIntersectionType" === i || "TSConditionalType" === i || "TSInferType" === i || "TSParenthesizedType" === i || "TSTypeOperator" === i || "TSIndexedAccessType" === i || "TSMappedType" === i || "TSLiteralType" === i || "TSExpressionWithTypeArguments" === i || "TSImportType" === i)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSTypeAliasDeclaration = function isTSTypeAliasDeclaration(t, r) {
            if (!t)
                return !1;
            if ("TSTypeAliasDeclaration" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSTypeAnnotation = function isTSTypeAnnotation(t, r) {
            if (!t)
                return !1;
            if ("TSTypeAnnotation" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSTypeAssertion = function isTSTypeAssertion(t, r) {
            if (!t)
                return !1;
            if ("TSTypeAssertion" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSTypeElement = function isTSTypeElement(t, r) {
            if (!t)
                return !1;
            var i = t.type;
            if ("TSCallSignatureDeclaration" === i || "TSConstructSignatureDeclaration" === i || "TSPropertySignature" === i || "TSMethodSignature" === i || "TSIndexSignature" === i)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSTypeLiteral = function isTSTypeLiteral(t, r) {
            if (!t)
                return !1;
            if ("TSTypeLiteral" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSTypeOperator = function isTSTypeOperator(t, r) {
            if (!t)
                return !1;
            if ("TSTypeOperator" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSTypeParameter = function isTSTypeParameter(t, r) {
            if (!t)
                return !1;
            if ("TSTypeParameter" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSTypeParameterDeclaration = function isTSTypeParameterDeclaration(t, r) {
            if (!t)
                return !1;
            if ("TSTypeParameterDeclaration" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSTypeParameterInstantiation = function isTSTypeParameterInstantiation(t, r) {
            if (!t)
                return !1;
            if ("TSTypeParameterInstantiation" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSTypePredicate = function isTSTypePredicate(t, r) {
            if (!t)
                return !1;
            if ("TSTypePredicate" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSTypeQuery = function isTSTypeQuery(t, r) {
            if (!t)
                return !1;
            if ("TSTypeQuery" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSTypeReference = function isTSTypeReference(t, r) {
            if (!t)
                return !1;
            if ("TSTypeReference" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSUndefinedKeyword = function isTSUndefinedKeyword(t, r) {
            if (!t)
                return !1;
            if ("TSUndefinedKeyword" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSUnionType = function isTSUnionType(t, r) {
            if (!t)
                return !1;
            if ("TSUnionType" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSUnknownKeyword = function isTSUnknownKeyword(t, r) {
            if (!t)
                return !1;
            if ("TSUnknownKeyword" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSVoidKeyword = function isTSVoidKeyword(t, r) {
            if (!t)
                return !1;
            if ("TSVoidKeyword" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTaggedTemplateExpression = function isTaggedTemplateExpression(t, r) {
            if (!t)
                return !1;
            if ("TaggedTemplateExpression" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTemplateElement = function isTemplateElement(t, r) {
            if (!t)
                return !1;
            if ("TemplateElement" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTemplateLiteral = function isTemplateLiteral(t, r) {
            if (!t)
                return !1;
            if ("TemplateLiteral" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTerminatorless = function isTerminatorless(t, r) {
            if (!t)
                return !1;
            var i = t.type;
            if ("BreakStatement" === i || "ContinueStatement" === i || "ReturnStatement" === i || "ThrowStatement" === i || "YieldExpression" === i || "AwaitExpression" === i)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isThisExpression = function isThisExpression(t, r) {
            if (!t)
                return !1;
            if ("ThisExpression" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isThisTypeAnnotation = function isThisTypeAnnotation(t, r) {
            if (!t)
                return !1;
            if ("ThisTypeAnnotation" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isThrowStatement = function isThrowStatement(t, r) {
            if (!t)
                return !1;
            if ("ThrowStatement" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTopicReference = function isTopicReference(t, r) {
            if (!t)
                return !1;
            if ("TopicReference" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTryStatement = function isTryStatement(t, r) {
            if (!t)
                return !1;
            if ("TryStatement" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTupleExpression = function isTupleExpression(t, r) {
            if (!t)
                return !1;
            if ("TupleExpression" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTupleTypeAnnotation = function isTupleTypeAnnotation(t, r) {
            if (!t)
                return !1;
            if ("TupleTypeAnnotation" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTypeAlias = function isTypeAlias(t, r) {
            if (!t)
                return !1;
            if ("TypeAlias" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTypeAnnotation = function isTypeAnnotation(t, r) {
            if (!t)
                return !1;
            if ("TypeAnnotation" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTypeCastExpression = function isTypeCastExpression(t, r) {
            if (!t)
                return !1;
            if ("TypeCastExpression" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTypeParameter = function isTypeParameter(t, r) {
            if (!t)
                return !1;
            if ("TypeParameter" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTypeParameterDeclaration = function isTypeParameterDeclaration(t, r) {
            if (!t)
                return !1;
            if ("TypeParameterDeclaration" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTypeParameterInstantiation = function isTypeParameterInstantiation(t, r) {
            if (!t)
                return !1;
            if ("TypeParameterInstantiation" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTypeScript = function isTypeScript(t, r) {
            if (!t)
                return !1;
            var i = t.type;
            if ("TSParameterProperty" === i || "TSDeclareFunction" === i || "TSDeclareMethod" === i || "TSQualifiedName" === i || "TSCallSignatureDeclaration" === i || "TSConstructSignatureDeclaration" === i || "TSPropertySignature" === i || "TSMethodSignature" === i || "TSIndexSignature" === i || "TSAnyKeyword" === i || "TSBooleanKeyword" === i || "TSBigIntKeyword" === i || "TSIntrinsicKeyword" === i || "TSNeverKeyword" === i || "TSNullKeyword" === i || "TSNumberKeyword" === i || "TSObjectKeyword" === i || "TSStringKeyword" === i || "TSSymbolKeyword" === i || "TSUndefinedKeyword" === i || "TSUnknownKeyword" === i || "TSVoidKeyword" === i || "TSThisType" === i || "TSFunctionType" === i || "TSConstructorType" === i || "TSTypeReference" === i || "TSTypePredicate" === i || "TSTypeQuery" === i || "TSTypeLiteral" === i || "TSArrayType" === i || "TSTupleType" === i || "TSOptionalType" === i || "TSRestType" === i || "TSNamedTupleMember" === i || "TSUnionType" === i || "TSIntersectionType" === i || "TSConditionalType" === i || "TSInferType" === i || "TSParenthesizedType" === i || "TSTypeOperator" === i || "TSIndexedAccessType" === i || "TSMappedType" === i || "TSLiteralType" === i || "TSExpressionWithTypeArguments" === i || "TSInterfaceDeclaration" === i || "TSInterfaceBody" === i || "TSTypeAliasDeclaration" === i || "TSAsExpression" === i || "TSTypeAssertion" === i || "TSEnumDeclaration" === i || "TSEnumMember" === i || "TSModuleDeclaration" === i || "TSModuleBlock" === i || "TSImportType" === i || "TSImportEqualsDeclaration" === i || "TSExternalModuleReference" === i || "TSNonNullExpression" === i || "TSExportAssignment" === i || "TSNamespaceExportDeclaration" === i || "TSTypeAnnotation" === i || "TSTypeParameterInstantiation" === i || "TSTypeParameterDeclaration" === i || "TSTypeParameter" === i)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTypeofTypeAnnotation = function isTypeofTypeAnnotation(t, r) {
            if (!t)
                return !1;
            if ("TypeofTypeAnnotation" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isUnaryExpression = function isUnaryExpression(t, r) {
            if (!t)
                return !1;
            if ("UnaryExpression" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isUnaryLike = function isUnaryLike(t, r) {
            if (!t)
                return !1;
            var i = t.type;
            if ("UnaryExpression" === i || "SpreadElement" === i)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isUnionTypeAnnotation = function isUnionTypeAnnotation(t, r) {
            if (!t)
                return !1;
            if ("UnionTypeAnnotation" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isUpdateExpression = function isUpdateExpression(t, r) {
            if (!t)
                return !1;
            if ("UpdateExpression" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isUserWhitespacable = function isUserWhitespacable(t, r) {
            if (!t)
                return !1;
            var i = t.type;
            if ("ObjectMethod" === i || "ObjectProperty" === i || "ObjectTypeInternalSlot" === i || "ObjectTypeCallProperty" === i || "ObjectTypeIndexer" === i || "ObjectTypeProperty" === i || "ObjectTypeSpreadProperty" === i)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isV8IntrinsicIdentifier = function isV8IntrinsicIdentifier(t, r) {
            if (!t)
                return !1;
            if ("V8IntrinsicIdentifier" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isVariableDeclaration = function isVariableDeclaration(t, r) {
            if (!t)
                return !1;
            if ("VariableDeclaration" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isVariableDeclarator = function isVariableDeclarator(t, r) {
            if (!t)
                return !1;
            if ("VariableDeclarator" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isVariance = function isVariance(t, r) {
            if (!t)
                return !1;
            if ("Variance" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isVoidTypeAnnotation = function isVoidTypeAnnotation(t, r) {
            if (!t)
                return !1;
            if ("VoidTypeAnnotation" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isWhile = function isWhile(t, r) {
            if (!t)
                return !1;
            var i = t.type;
            if ("DoWhileStatement" === i || "WhileStatement" === i)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isWhileStatement = function isWhileStatement(t, r) {
            if (!t)
                return !1;
            if ("WhileStatement" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isWithStatement = function isWithStatement(t, r) {
            if (!t)
                return !1;
            if ("WithStatement" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isYieldExpression = function isYieldExpression(t, r) {
            if (!t)
                return !1;
            if ("YieldExpression" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ;
        var a = i("v3TT")
    },
    pw2U: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function inheritsComments(t, r) {
            return (0,
            a.default)(t, r),
            (0,
            o.default)(t, r),
            (0,
            l.default)(t, r),
            t
        }
        ;
        var a = i("QoWe")
          , o = i("+l3Y")
          , l = i("fkdI")
    },
    "q2+x": function(t, r, i) {
        "use strict";
        var a = i("TqRt")(i("cDf5"));
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function isNodesEquivalent(t, r) {
            if ("object" !== (0,
            a.default)(t) || "object" !== (0,
            a.default)(r) || null == t || null == r)
                return t === r;
            if (t.type !== r.type)
                return !1;
            for (var i = Object.keys(o.NODE_FIELDS[t.type] || t.type), l = o.VISITOR_KEYS[t.type], u = 0, p = i; u < p.length; u++) {
                var c = p[u];
                if ((0,
                a.default)(t[c]) !== (0,
                a.default)(r[c]))
                    return !1;
                if (null != t[c] || null != r[c]) {
                    if (null == t[c] || null == r[c])
                        return !1;
                    if (Array.isArray(t[c])) {
                        if (!Array.isArray(r[c]))
                            return !1;
                        if (t[c].length !== r[c].length)
                            return !1;
                        for (var d = 0; d < t[c].length; d++)
                            if (!isNodesEquivalent(t[c][d], r[c][d]))
                                return !1
                    } else if ("object" !== (0,
                    a.default)(t[c]) || null != l && l.includes(c)) {
                        if (!isNodesEquivalent(t[c], r[c]))
                            return !1
                    } else
                        for (var y = 0, h = Object.keys(t[c]); y < h.length; y++) {
                            var m = h[y];
                            if (t[c][m] !== r[c][m])
                                return !1
                        }
                }
            }
            return !0
        }
        ;
        var o = i("UHlb")
    },
    qGI9: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function buildMatchMemberExpression(t, r) {
            var i = t.split(".");
            return function(t) {
                return (0,
                a.default)(t, i, r)
            }
        }
        ;
        var a = i("s0R5")
    },
    qIut: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function toSequenceExpression(t, r) {
            if (null == t || !t.length)
                return;
            var i = []
              , o = (0,
            a.default)(t, r, i);
            if (!o)
                return;
            for (var l = 0, u = i; l < u.length; l++) {
                var p = u[l];
                r.push(p)
            }
            return o
        }
        ;
        var a = i("LdJy")
    },
    qMwM: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.clear = function clear() {
            clearPath(),
            clearScope()
        }
        ,
        r.clearPath = clearPath,
        r.clearScope = clearScope,
        r.scope = r.path = void 0;
        var a = new WeakMap;
        r.path = a;
        var o = new WeakMap;
        function clearPath() {
            r.path = a = new WeakMap
        }
        function clearScope() {
            r.scope = o = new WeakMap
        }
        r.scope = o
    },
    qjUn: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function isImmutable(t) {
            if ((0,
            a.default)(t.type, "Immutable"))
                return !0;
            if ((0,
            o.isIdentifier)(t))
                return "undefined" === t.name;
            return !1
        }
        ;
        var a = i("ud6b")
          , o = i("pbIU")
    },
    qnHE: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.ArrowFunctionExpression = function ArrowFunctionExpression(t, r) {
            return g(r) || ConditionalExpression(t, r)
        }
        ,
        r.AssignmentExpression = function AssignmentExpression(t, r) {
            return !!L(t.left) || ConditionalExpression(t, r)
        }
        ,
        r.Binary = function Binary(t, r) {
            if ("**" === t.operator && d(r, {
                operator: "**"
            }))
                return r.left === t;
            if (isClassExtendsClause(t, r))
                return !0;
            if (hasPostfixPart(t, r) || Q(r) || p(r))
                return !0;
            if (c(r)) {
                const i = r.operator
                  , a = re[i]
                  , o = t.operator
                  , l = re[o];
                if (a === l && r.right === t && !C(r) || a > l)
                    return !0
            }
        }
        ,
        r.BinaryExpression = function BinaryExpression(t, r) {
            return "in" === t.operator && (Z(r) || E(r))
        }
        ,
        r.ClassExpression = function ClassExpression(t, r, i) {
            return isFirstInContext(i, {
                expressionStatement: !0,
                exportDefault: !0
            })
        }
        ,
        r.ConditionalExpression = ConditionalExpression,
        r.DoExpression = function DoExpression(t, r, i) {
            return !t.async && isFirstInContext(i, {
                expressionStatement: !0
            })
        }
        ,
        r.FunctionExpression = function FunctionExpression(t, r, i) {
            return isFirstInContext(i, {
                expressionStatement: !0,
                exportDefault: !0
            })
        }
        ,
        r.FunctionTypeAnnotation = function FunctionTypeAnnotation(t, r, i) {
            return $(r) || w(r) || o(r) || z(r) && l(i[i.length - 3])
        }
        ,
        r.Identifier = function Identifier(t, r, i) {
            if ("let" === t.name) {
                const a = N(r, {
                    object: t,
                    computed: !0
                }) || M(r, {
                    object: t,
                    computed: !0,
                    optional: !1
                });
                return isFirstInContext(i, {
                    expressionStatement: a,
                    forHead: a,
                    forInHead: a,
                    forOfHead: !0
                })
            }
            return "async" === t.name && x(r) && t === r.left
        }
        ,
        r.LogicalExpression = function LogicalExpression(t, r) {
            switch (t.operator) {
            case "||":
                return !!C(r) && ("??" === r.operator || "&&" === r.operator);
            case "&&":
                return C(r, {
                    operator: "??"
                });
            case "??":
                return C(r) && "??" !== r.operator
            }
        }
        ,
        r.NullableTypeAnnotation = function NullableTypeAnnotation(t, r) {
            return o(r)
        }
        ,
        r.ObjectExpression = function ObjectExpression(t, r, i) {
            return isFirstInContext(i, {
                expressionStatement: !0,
                arrowBody: !0
            })
        }
        ,
        r.OptionalIndexedAccessType = function OptionalIndexedAccessType(t, r) {
            return I(r, {
                objectType: t
            })
        }
        ,
        r.OptionalCallExpression = r.OptionalMemberExpression = function OptionalMemberExpression(t, r) {
            return y(r, {
                callee: t
            }) || N(r, {
                object: t
            })
        }
        ,
        r.SequenceExpression = function SequenceExpression(t, r) {
            if (A(r) || G(r) || j(r) || O(r) && r.test === t || ee(r) && r.test === t || P(r) && r.right === t || R(r) && r.discriminant === t || v(r) && r.expression === t)
                return !1;
            return !0
        }
        ,
        r.TSAsExpression = function TSAsExpression() {
            return !0
        }
        ,
        r.TSInferType = function TSInferType(t, r) {
            return K(r) || X(r)
        }
        ,
        r.TSTypeAssertion = function TSTypeAssertion() {
            return !0
        }
        ,
        r.TSIntersectionType = r.TSUnionType = function TSUnionType(t, r) {
            return K(r) || X(r) || U(r) || q(r) || J(r)
        }
        ,
        r.UnaryLike = UnaryLike,
        r.IntersectionTypeAnnotation = r.UnionTypeAnnotation = function UnionTypeAnnotation(t, r) {
            return o(r) || _(r) || w(r) || $(r)
        }
        ,
        r.UpdateExpression = function UpdateExpression(t, r) {
            return hasPostfixPart(t, r) || isClassExtendsClause(t, r)
        }
        ,
        r.AwaitExpression = r.YieldExpression = function YieldExpression(t, r) {
            return c(r) || Q(r) || hasPostfixPart(t, r) || p(r) && te(t) || S(r) && t === r.test || isClassExtendsClause(t, r)
        }
        ;
        var a = i("JSq2");
        const {isArrayTypeAnnotation: o, isArrowFunctionExpression: l, isAssignmentExpression: u, isAwaitExpression: p, isBinary: c, isBinaryExpression: d, isCallExpression: y, isClassDeclaration: h, isClassExpression: m, isConditional: T, isConditionalExpression: S, isExportDeclaration: g, isExportDefaultDeclaration: b, isExpressionStatement: v, isFor: E, isForInStatement: P, isForOfStatement: x, isForStatement: A, isIfStatement: O, isIndexedAccessType: I, isIntersectionTypeAnnotation: w, isLogicalExpression: C, isMemberExpression: N, isNewExpression: D, isNullableTypeAnnotation: _, isObjectPattern: L, isOptionalCallExpression: k, isOptionalMemberExpression: M, isReturnStatement: j, isSequenceExpression: B, isSwitchStatement: R, isTSArrayType: K, isTSAsExpression: V, isTSIntersectionType: U, isTSNonNullExpression: Y, isTSOptionalType: X, isTSRestType: J, isTSTypeAssertion: W, isTSUnionType: q, isTaggedTemplateExpression: H, isThrowStatement: G, isTypeAnnotation: z, isUnaryLike: Q, isUnionTypeAnnotation: $, isVariableDeclarator: Z, isWhileStatement: ee, isYieldExpression: te} = a
          , re = {
            "||": 0,
            "??": 0,
            "&&": 1,
            "|": 2,
            "^": 3,
            "&": 4,
            "==": 5,
            "===": 5,
            "!=": 5,
            "!==": 5,
            "<": 6,
            ">": 6,
            "<=": 6,
            ">=": 6,
            in: 6,
            instanceof: 6,
            ">>": 7,
            "<<": 7,
            ">>>": 7,
            "+": 8,
            "-": 8,
            "*": 9,
            "/": 9,
            "%": 9,
            "**": 10
        }
          , isClassExtendsClause = (t,r)=>(h(r) || m(r)) && r.superClass === t
          , hasPostfixPart = (t,r)=>(N(r) || M(r)) && r.object === t || (y(r) || k(r) || D(r)) && r.callee === t || H(r) && r.tag === t || Y(r);
        function UnaryLike(t, r) {
            return hasPostfixPart(t, r) || d(r, {
                operator: "**",
                left: t
            }) || isClassExtendsClause(t, r)
        }
        function ConditionalExpression(t, r) {
            return !!(Q(r) || c(r) || S(r, {
                test: t
            }) || p(r) || W(r) || V(r)) || UnaryLike(t, r)
        }
        function isFirstInContext(t, {expressionStatement: r=!1, arrowBody: i=!1, exportDefault: a=!1, forHead: o=!1, forInHead: p=!1, forOfHead: d=!1}) {
            let y = t.length - 1
              , h = t[y];
            y--;
            let m = t[y];
            for (; y >= 0; ) {
                if (r && v(m, {
                    expression: h
                }) || a && b(m, {
                    declaration: h
                }) || i && l(m, {
                    body: h
                }) || o && A(m, {
                    init: h
                }) || p && P(m, {
                    left: h
                }) || d && x(m, {
                    left: h
                }))
                    return !0;
                if (!(hasPostfixPart(h, m) && !D(m) || B(m) && m.expressions[0] === h || T(m, {
                    test: h
                }) || c(m, {
                    left: h
                }) || u(m, {
                    left: h
                })))
                    return !1;
                h = m,
                y--,
                m = t[y]
            }
            return !1
        }
    },
    qtGH: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = toKeyAlias;
        var a = i("FUES")
          , o = i("sN7J")
          , l = i("dm8S");
        function toKeyAlias(t) {
            var r, i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : t.key;
            return "method" === t.kind ? toKeyAlias.increment() + "" : (r = (0,
            a.isIdentifier)(i) ? i.name : (0,
            a.isStringLiteral)(i) ? JSON.stringify(i.value) : JSON.stringify((0,
            l.default)((0,
            o.default)(i))),
            t.computed && (r = "[".concat(r, "]")),
            t.static && (r = "static:".concat(r)),
            r)
        }
        toKeyAlias.uid = 0,
        toKeyAlias.increment = function() {
            return toKeyAlias.uid >= Number.MAX_SAFE_INTEGER ? toKeyAlias.uid = 0 : toKeyAlias.uid++
        }
    },
    qwL7: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = void 0;
        var a = i("wffa")
          , o = function getOuterBindingIdentifiers(t, r) {
            return (0,
            a.default)(t, r, !0)
        };
        r.default = o
    },
    "r+0P": function(t, r, i) {
        "use strict";
        var a = i("89jI")
          , o = i("9aGZ")
          , l = i("PUqz");
        t.exports = function(t, r) {
            var i = l(t, r);
            return {
                ast: i,
                scopeManager: o(i, r),
                visitorKeys: a
            }
        }
    },
    rHqr: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function isNode(t) {
            return !(!t || !a.VISITOR_KEYS[t.type])
        }
        ;
        var a = i("UHlb")
    },
    rXlq: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.ArrowFunctionExpression = function ArrowFunctionExpression(t) {
            t.async && (this.word("async"),
            this.space());
            const r = t.params[0];
            this.format.retainLines || this.format.auxiliaryCommentBefore || this.format.auxiliaryCommentAfter || 1 !== t.params.length || !o(r) || function hasTypesOrComments(t, r) {
                var i, a;
                return !!(t.typeParameters || t.returnType || t.predicate || r.typeAnnotation || r.optional || null != (i = r.leadingComments) && i.length || null != (a = r.trailingComments) && a.length)
            }(t, r) ? this._params(t) : this.print(r, t);
            this._predicate(t),
            this.space(),
            this.token("=>"),
            this.space(),
            this.print(t.body, t)
        }
        ,
        r.FunctionDeclaration = r.FunctionExpression = function FunctionExpression(t) {
            this._functionHead(t),
            this.space(),
            this.print(t.body, t)
        }
        ,
        r._functionHead = function _functionHead(t) {
            t.async && (this.word("async"),
            this.space());
            this.word("function"),
            t.generator && this.token("*");
            this.printInnerComments(t),
            this.space(),
            t.id && this.print(t.id, t);
            this._params(t),
            this._predicate(t)
        }
        ,
        r._methodHead = function _methodHead(t) {
            const r = t.kind
              , i = t.key;
            "get" !== r && "set" !== r || (this.word(r),
            this.space());
            t.async && (this._catchUp("start", i.loc),
            this.word("async"),
            this.space());
            "method" !== r && "init" !== r || t.generator && this.token("*");
            t.computed ? (this.token("["),
            this.print(i, t),
            this.token("]")) : this.print(i, t);
            t.optional && this.token("?");
            this._params(t)
        }
        ,
        r._param = function _param(t, r) {
            this.printJoin(t.decorators, t),
            this.print(t, r),
            t.optional && this.token("?");
            this.print(t.typeAnnotation, t)
        }
        ,
        r._parameters = function _parameters(t, r) {
            for (let i = 0; i < t.length; i++)
                this._param(t[i], r),
                i < t.length - 1 && (this.token(","),
                this.space())
        }
        ,
        r._params = function _params(t) {
            this.print(t.typeParameters, t),
            this.token("("),
            this._parameters(t.params, t),
            this.token(")"),
            this.print(t.returnType, t)
        }
        ,
        r._predicate = function _predicate(t) {
            t.predicate && (t.returnType || this.token(":"),
            this.space(),
            this.print(t.predicate, t))
        }
        ;
        var a = i("JSq2");
        const {isIdentifier: o} = a
    },
    rZZI: function(t, r, i) {
        "use strict";
        var a = i("TqRt")
          , o = a(i("J4zp"))
          , l = a(i("lwsE"))
          , u = a(i("W8MJ"));
        function _createForOfIteratorHelper(t, r) {
            var i = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
            if (!i) {
                if (Array.isArray(t) || (i = function _unsupportedIterableToArray(t, r) {
                    if (!t)
                        return;
                    if ("string" == typeof t)
                        return _arrayLikeToArray(t, r);
                    var i = Object.prototype.toString.call(t).slice(8, -1);
                    "Object" === i && t.constructor && (i = t.constructor.name);
                    if ("Map" === i || "Set" === i)
                        return Array.from(t);
                    if ("Arguments" === i || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i))
                        return _arrayLikeToArray(t, r)
                }(t)) || r && t && "number" == typeof t.length) {
                    i && (t = i);
                    var a = 0
                      , o = function F() {};
                    return {
                        s: o,
                        n: function n() {
                            return a >= t.length ? {
                                done: !0
                            } : {
                                done: !1,
                                value: t[a++]
                            }
                        },
                        e: function e(t) {
                            throw t
                        },
                        f: o
                    }
                }
                throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
            }
            var l, u = !0, p = !1;
            return {
                s: function s() {
                    i = i.call(t)
                },
                n: function n() {
                    var t = i.next();
                    return u = t.done,
                    t
                },
                e: function e(t) {
                    p = !0,
                    l = t
                },
                f: function f() {
                    try {
                        u || null == i.return || i.return()
                    } finally {
                        if (p)
                            throw l
                    }
                }
            }
        }
        function _arrayLikeToArray(t, r) {
            (null == r || r > t.length) && (r = t.length);
            for (var i = 0, a = new Array(r); i < r; i++)
                a[i] = t[i];
            return a
        }
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = void 0;
        var p = i("DsXD")
          , c = i("LR/y")
          , d = i("O0/1")
          , y = i("XfNL")
          , h = i("ZtNB")
          , m = i("qMwM");
        var T = {
            For: function For(t) {
                var r, i = _createForOfIteratorHelper(h.FOR_INIT_KEYS);
                try {
                    for (i.s(); !(r = i.n()).done; ) {
                        var a = r.value
                          , o = t.get(a);
                        if (o.isVar())
                            (t.scope.getFunctionParent() || t.scope.getProgramParent()).registerBinding("var", o)
                    }
                } catch (t) {
                    i.e(t)
                } finally {
                    i.f()
                }
            },
            Declaration: function Declaration(t) {
                t.isBlockScoped() || (t.isImportDeclaration() || t.isExportDeclaration() || (t.scope.getFunctionParent() || t.scope.getProgramParent()).registerDeclaration(t))
            },
            ImportDeclaration: function ImportDeclaration(t) {
                t.scope.getBlockParent().registerDeclaration(t)
            },
            ReferencedIdentifier: function ReferencedIdentifier(t, r) {
                r.references.push(t)
            },
            ForXStatement: function ForXStatement(t, r) {
                var i = t.get("left");
                (i.isPattern() || i.isIdentifier()) && r.constantViolations.push(t)
            },
            ExportDeclaration: {
                exit: function exit(t) {
                    var r = t.node
                      , i = t.scope;
                    if (!h.isExportAllDeclaration(r)) {
                        var a = r.declaration;
                        if (h.isClassDeclaration(a) || h.isFunctionDeclaration(a)) {
                            var o = a.id;
                            if (!o)
                                return;
                            var l = i.getBinding(o.name);
                            l && l.reference(t)
                        } else if (h.isVariableDeclaration(a)) {
                            var u, p = _createForOfIteratorHelper(a.declarations);
                            try {
                                for (p.s(); !(u = p.n()).done; )
                                    for (var c = u.value, d = 0, y = Object.keys(h.getBindingIdentifiers(c)); d < y.length; d++) {
                                        var m = y[d]
                                          , T = i.getBinding(m);
                                        T && T.reference(t)
                                    }
                            } catch (t) {
                                p.e(t)
                            } finally {
                                p.f()
                            }
                        }
                    }
                }
            },
            LabeledStatement: function LabeledStatement(t) {
                t.scope.getBlockParent().registerDeclaration(t)
            },
            AssignmentExpression: function AssignmentExpression(t, r) {
                r.assignments.push(t)
            },
            UpdateExpression: function UpdateExpression(t, r) {
                r.constantViolations.push(t)
            },
            UnaryExpression: function UnaryExpression(t, r) {
                "delete" === t.node.operator && r.constantViolations.push(t)
            },
            BlockScoped: function BlockScoped(t) {
                var r = t.scope;
                if (r.path === t && (r = r.parent),
                r.getBlockParent().registerDeclaration(t),
                t.isClassDeclaration() && t.node.id) {
                    var i = t.node.id.name;
                    t.scope.bindings[i] = t.scope.parent.getBinding(i)
                }
            },
            CatchClause: function CatchClause(t) {
                t.scope.registerBinding("let", t)
            },
            Function: function Function(t) {
                t.isFunctionExpression() && t.has("id") && !t.get("id").node[h.NOT_LOCAL_BINDING] && t.scope.registerBinding("local", t.get("id"), t);
                var r, i = _createForOfIteratorHelper(t.get("params"));
                try {
                    for (i.s(); !(r = i.n()).done; ) {
                        var a = r.value;
                        t.scope.registerBinding("param", a)
                    }
                } catch (t) {
                    i.e(t)
                } finally {
                    i.f()
                }
            },
            ClassExpression: function ClassExpression(t) {
                t.has("id") && !t.get("id").node[h.NOT_LOCAL_BINDING] && t.scope.registerBinding("local", t)
            }
        }
          , S = 0
          , g = function() {
            function Scope(t) {
                (0,
                l.default)(this, Scope),
                this.uid = void 0,
                this.path = void 0,
                this.block = void 0,
                this.labels = void 0,
                this.inited = void 0,
                this.bindings = void 0,
                this.references = void 0,
                this.globals = void 0,
                this.uids = void 0,
                this.data = void 0,
                this.crawling = void 0;
                var r = t.node
                  , i = m.scope.get(r);
                if ((null == i ? void 0 : i.path) === t)
                    return i;
                m.scope.set(r, this),
                this.uid = S++,
                this.block = r,
                this.path = t,
                this.labels = new Map,
                this.inited = !1
            }
            return (0,
            u.default)(Scope, [{
                key: "parent",
                get: function get() {
                    var t, r, i = this.path;
                    do {
                        var a = "key" === i.key;
                        i = i.parentPath,
                        a && i.isMethod() && (i = i.parentPath),
                        i && i.isScope() && (r = i)
                    } while (i && !r);
                    return null == (t = r) ? void 0 : t.scope
                }
            }, {
                key: "parentBlock",
                get: function get() {
                    return this.path.parent
                }
            }, {
                key: "hub",
                get: function get() {
                    return this.path.hub
                }
            }, {
                key: "traverse",
                value: function traverse(t, r, i) {
                    (0,
                    c.default)(t, r, this, i, this.path)
                }
            }, {
                key: "generateDeclaredUidIdentifier",
                value: function generateDeclaredUidIdentifier(t) {
                    var r = this.generateUidIdentifier(t);
                    return this.push({
                        id: r
                    }),
                    h.cloneNode(r)
                }
            }, {
                key: "generateUidIdentifier",
                value: function generateUidIdentifier(t) {
                    return h.identifier(this.generateUid(t))
                }
            }, {
                key: "generateUid",
                value: function generateUid() {
                    var t, r = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "temp";
                    r = h.toIdentifier(r).replace(/^_+/, "").replace(/[0-9]+$/g, "");
                    var i = 1;
                    do {
                        t = this._generateUid(r, i),
                        i++
                    } while (this.hasLabel(t) || this.hasBinding(t) || this.hasGlobal(t) || this.hasReference(t));
                    var a = this.getProgramParent();
                    return a.references[t] = !0,
                    a.uids[t] = !0,
                    t
                }
            }, {
                key: "_generateUid",
                value: function _generateUid(t, r) {
                    var i = t;
                    return r > 1 && (i += r),
                    "_".concat(i)
                }
            }, {
                key: "generateUidBasedOnNode",
                value: function generateUidBasedOnNode(t, r) {
                    var i = [];
                    !function gatherNodeParts(t, r) {
                        switch (null == t ? void 0 : t.type) {
                        default:
                            if (h.isModuleDeclaration(t))
                                if ((h.isExportAllDeclaration(t) || h.isExportNamedDeclaration(t) || h.isImportDeclaration(t)) && t.source)
                                    gatherNodeParts(t.source, r);
                                else if ((h.isExportNamedDeclaration(t) || h.isImportDeclaration(t)) && t.specifiers && t.specifiers.length) {
                                    var i, a = _createForOfIteratorHelper(t.specifiers);
                                    try {
                                        for (a.s(); !(i = a.n()).done; ) {
                                            gatherNodeParts(i.value, r)
                                        }
                                    } catch (t) {
                                        a.e(t)
                                    } finally {
                                        a.f()
                                    }
                                } else
                                    (h.isExportDefaultDeclaration(t) || h.isExportNamedDeclaration(t)) && t.declaration && gatherNodeParts(t.declaration, r);
                            else
                                h.isModuleSpecifier(t) ? gatherNodeParts(t.local, r) : h.isLiteral(t) && r.push(t.value);
                            break;
                        case "MemberExpression":
                        case "OptionalMemberExpression":
                        case "JSXMemberExpression":
                            gatherNodeParts(t.object, r),
                            gatherNodeParts(t.property, r);
                            break;
                        case "Identifier":
                        case "JSXIdentifier":
                            r.push(t.name);
                            break;
                        case "CallExpression":
                        case "OptionalCallExpression":
                        case "NewExpression":
                            gatherNodeParts(t.callee, r);
                            break;
                        case "ObjectExpression":
                        case "ObjectPattern":
                            var o, l = _createForOfIteratorHelper(t.properties);
                            try {
                                for (l.s(); !(o = l.n()).done; ) {
                                    gatherNodeParts(o.value, r)
                                }
                            } catch (t) {
                                l.e(t)
                            } finally {
                                l.f()
                            }
                            break;
                        case "SpreadElement":
                        case "RestElement":
                            gatherNodeParts(t.argument, r);
                            break;
                        case "ObjectProperty":
                        case "ObjectMethod":
                        case "ClassProperty":
                        case "ClassMethod":
                        case "ClassPrivateProperty":
                        case "ClassPrivateMethod":
                            gatherNodeParts(t.key, r);
                            break;
                        case "ThisExpression":
                            r.push("this");
                            break;
                        case "Super":
                            r.push("super");
                            break;
                        case "Import":
                            r.push("import");
                            break;
                        case "DoExpression":
                            r.push("do");
                            break;
                        case "YieldExpression":
                            r.push("yield"),
                            gatherNodeParts(t.argument, r);
                            break;
                        case "AwaitExpression":
                            r.push("await"),
                            gatherNodeParts(t.argument, r);
                            break;
                        case "AssignmentExpression":
                            gatherNodeParts(t.left, r);
                            break;
                        case "VariableDeclarator":
                            gatherNodeParts(t.id, r);
                            break;
                        case "FunctionExpression":
                        case "FunctionDeclaration":
                        case "ClassExpression":
                        case "ClassDeclaration":
                        case "PrivateName":
                            gatherNodeParts(t.id, r);
                            break;
                        case "ParenthesizedExpression":
                            gatherNodeParts(t.expression, r);
                            break;
                        case "UnaryExpression":
                        case "UpdateExpression":
                            gatherNodeParts(t.argument, r);
                            break;
                        case "MetaProperty":
                            gatherNodeParts(t.meta, r),
                            gatherNodeParts(t.property, r);
                            break;
                        case "JSXElement":
                            gatherNodeParts(t.openingElement, r);
                            break;
                        case "JSXOpeningElement":
                            r.push(t.name);
                            break;
                        case "JSXFragment":
                            gatherNodeParts(t.openingFragment, r);
                            break;
                        case "JSXOpeningFragment":
                            r.push("Fragment");
                            break;
                        case "JSXNamespacedName":
                            gatherNodeParts(t.namespace, r),
                            gatherNodeParts(t.name, r)
                        }
                    }(t, i);
                    var a = i.join("$");
                    return a = a.replace(/^_/, "") || r || "ref",
                    this.generateUid(a.slice(0, 20))
                }
            }, {
                key: "generateUidIdentifierBasedOnNode",
                value: function generateUidIdentifierBasedOnNode(t, r) {
                    return h.identifier(this.generateUidBasedOnNode(t, r))
                }
            }, {
                key: "isStatic",
                value: function isStatic(t) {
                    if (h.isThisExpression(t) || h.isSuper(t))
                        return !0;
                    if (h.isIdentifier(t)) {
                        var r = this.getBinding(t.name);
                        return r ? r.constant : this.hasBinding(t.name)
                    }
                    return !1
                }
            }, {
                key: "maybeGenerateMemoised",
                value: function maybeGenerateMemoised(t, r) {
                    if (this.isStatic(t))
                        return null;
                    var i = this.generateUidIdentifierBasedOnNode(t);
                    return r ? i : (this.push({
                        id: i
                    }),
                    h.cloneNode(i))
                }
            }, {
                key: "checkBlockScopedCollisions",
                value: function checkBlockScopedCollisions(t, r, i, a) {
                    if ("param" !== r && ("local" !== t.kind && ("let" === r || "let" === t.kind || "const" === t.kind || "module" === t.kind || "param" === t.kind && ("let" === r || "const" === r))))
                        throw this.hub.buildError(a, 'Duplicate declaration "'.concat(i, '"'), TypeError)
                }
            }, {
                key: "rename",
                value: function rename(t, r, i) {
                    var a = this.getBinding(t);
                    if (a)
                        return r = r || this.generateUidIdentifier(t).name,
                        new p.default(a,t,r).rename(i)
                }
            }, {
                key: "_renameFromMap",
                value: function _renameFromMap(t, r, i, a) {
                    t[r] && (t[i] = a,
                    t[r] = null)
                }
            }, {
                key: "dump",
                value: function dump() {
                    var t = "-".repeat(60);
                    console.log(t);
                    var r = this;
                    do {
                        console.log("#", r.block.type);
                        for (var i = 0, a = Object.keys(r.bindings); i < a.length; i++) {
                            var o = a[i]
                              , l = r.bindings[o];
                            console.log(" -", o, {
                                constant: l.constant,
                                references: l.references,
                                violations: l.constantViolations.length,
                                kind: l.kind
                            })
                        }
                    } while (r = r.parent);
                    console.log(t)
                }
            }, {
                key: "toArray",
                value: function toArray(t, r, i) {
                    if (h.isIdentifier(t)) {
                        var a = this.getBinding(t.name);
                        if (null != a && a.constant && a.path.isGenericType("Array"))
                            return t
                    }
                    if (h.isArrayExpression(t))
                        return t;
                    if (h.isIdentifier(t, {
                        name: "arguments"
                    }))
                        return h.callExpression(h.memberExpression(h.memberExpression(h.memberExpression(h.identifier("Array"), h.identifier("prototype")), h.identifier("slice")), h.identifier("call")), [t]);
                    var o, l = [t];
                    return !0 === r ? o = "toConsumableArray" : r ? (l.push(h.numericLiteral(r)),
                    o = "slicedToArray") : o = "toArray",
                    i && (l.unshift(this.hub.addHelper(o)),
                    o = "maybeArrayLike"),
                    h.callExpression(this.hub.addHelper(o), l)
                }
            }, {
                key: "hasLabel",
                value: function hasLabel(t) {
                    return !!this.getLabel(t)
                }
            }, {
                key: "getLabel",
                value: function getLabel(t) {
                    return this.labels.get(t)
                }
            }, {
                key: "registerLabel",
                value: function registerLabel(t) {
                    this.labels.set(t.node.label.name, t)
                }
            }, {
                key: "registerDeclaration",
                value: function registerDeclaration(t) {
                    if (t.isLabeledStatement())
                        this.registerLabel(t);
                    else if (t.isFunctionDeclaration())
                        this.registerBinding("hoisted", t.get("id"), t);
                    else if (t.isVariableDeclaration()) {
                        var r, i = _createForOfIteratorHelper(t.get("declarations"));
                        try {
                            for (i.s(); !(r = i.n()).done; ) {
                                var a = r.value;
                                this.registerBinding(t.node.kind, a)
                            }
                        } catch (t) {
                            i.e(t)
                        } finally {
                            i.f()
                        }
                    } else if (t.isClassDeclaration())
                        this.registerBinding("let", t);
                    else if (t.isImportDeclaration()) {
                        var o, l = _createForOfIteratorHelper(t.get("specifiers"));
                        try {
                            for (l.s(); !(o = l.n()).done; ) {
                                var u = o.value;
                                this.registerBinding("module", u)
                            }
                        } catch (t) {
                            l.e(t)
                        } finally {
                            l.f()
                        }
                    } else if (t.isExportDeclaration()) {
                        var p = t.get("declaration");
                        (p.isClassDeclaration() || p.isFunctionDeclaration() || p.isVariableDeclaration()) && this.registerDeclaration(p)
                    } else
                        this.registerBinding("unknown", t)
                }
            }, {
                key: "buildUndefinedNode",
                value: function buildUndefinedNode() {
                    return h.unaryExpression("void", h.numericLiteral(0), !0)
                }
            }, {
                key: "registerConstantViolation",
                value: function registerConstantViolation(t) {
                    for (var r = t.getBindingIdentifiers(), i = 0, a = Object.keys(r); i < a.length; i++) {
                        var o = a[i]
                          , l = this.getBinding(o);
                        l && l.reassign(t)
                    }
                }
            }, {
                key: "registerBinding",
                value: function registerBinding(t, r) {
                    var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : r;
                    if (!t)
                        throw new ReferenceError("no `kind`");
                    if (r.isVariableDeclaration()) {
                        var a, o = r.get("declarations"), l = _createForOfIteratorHelper(o);
                        try {
                            for (l.s(); !(a = l.n()).done; ) {
                                var u = a.value;
                                this.registerBinding(t, u)
                            }
                        } catch (t) {
                            l.e(t)
                        } finally {
                            l.f()
                        }
                    } else
                        for (var p = this.getProgramParent(), c = r.getOuterBindingIdentifiers(!0), y = 0, h = Object.keys(c); y < h.length; y++) {
                            var m = h[y];
                            p.references[m] = !0;
                            var T, S = _createForOfIteratorHelper(c[m]);
                            try {
                                for (S.s(); !(T = S.n()).done; ) {
                                    var g = T.value
                                      , b = this.getOwnBinding(m);
                                    if (b) {
                                        if (b.identifier === g)
                                            continue;
                                        this.checkBlockScopedCollisions(b, t, m, g)
                                    }
                                    b ? this.registerConstantViolation(i) : this.bindings[m] = new d.default({
                                        identifier: g,
                                        scope: this,
                                        path: i,
                                        kind: t
                                    })
                                }
                            } catch (t) {
                                S.e(t)
                            } finally {
                                S.f()
                            }
                        }
                }
            }, {
                key: "addGlobal",
                value: function addGlobal(t) {
                    this.globals[t.name] = t
                }
            }, {
                key: "hasUid",
                value: function hasUid(t) {
                    var r = this;
                    do {
                        if (r.uids[t])
                            return !0
                    } while (r = r.parent);
                    return !1
                }
            }, {
                key: "hasGlobal",
                value: function hasGlobal(t) {
                    var r = this;
                    do {
                        if (r.globals[t])
                            return !0
                    } while (r = r.parent);
                    return !1
                }
            }, {
                key: "hasReference",
                value: function hasReference(t) {
                    return !!this.getProgramParent().references[t]
                }
            }, {
                key: "isPure",
                value: function isPure(t, r) {
                    if (h.isIdentifier(t)) {
                        var i = this.getBinding(t.name);
                        return !!i && (!r || i.constant)
                    }
                    if (h.isClass(t))
                        return !(t.superClass && !this.isPure(t.superClass, r)) && this.isPure(t.body, r);
                    if (h.isClassBody(t)) {
                        var a, o = _createForOfIteratorHelper(t.body);
                        try {
                            for (o.s(); !(a = o.n()).done; ) {
                                var l = a.value;
                                if (!this.isPure(l, r))
                                    return !1
                            }
                        } catch (t) {
                            o.e(t)
                        } finally {
                            o.f()
                        }
                        return !0
                    }
                    if (h.isBinary(t))
                        return this.isPure(t.left, r) && this.isPure(t.right, r);
                    if (h.isArrayExpression(t)) {
                        var u, p = _createForOfIteratorHelper(t.elements);
                        try {
                            for (p.s(); !(u = p.n()).done; ) {
                                var c = u.value;
                                if (!this.isPure(c, r))
                                    return !1
                            }
                        } catch (t) {
                            p.e(t)
                        } finally {
                            p.f()
                        }
                        return !0
                    }
                    if (h.isObjectExpression(t)) {
                        var d, y = _createForOfIteratorHelper(t.properties);
                        try {
                            for (y.s(); !(d = y.n()).done; ) {
                                var m = d.value;
                                if (!this.isPure(m, r))
                                    return !1
                            }
                        } catch (t) {
                            y.e(t)
                        } finally {
                            y.f()
                        }
                        return !0
                    }
                    if (h.isMethod(t))
                        return !(t.computed && !this.isPure(t.key, r)) && ("get" !== t.kind && "set" !== t.kind);
                    if (h.isProperty(t))
                        return !(t.computed && !this.isPure(t.key, r)) && this.isPure(t.value, r);
                    if (h.isUnaryExpression(t))
                        return this.isPure(t.argument, r);
                    if (h.isTaggedTemplateExpression(t))
                        return h.matchesPattern(t.tag, "String.raw") && !this.hasBinding("String", !0) && this.isPure(t.quasi, r);
                    if (h.isTemplateLiteral(t)) {
                        var T, S = _createForOfIteratorHelper(t.expressions);
                        try {
                            for (S.s(); !(T = S.n()).done; ) {
                                var g = T.value;
                                if (!this.isPure(g, r))
                                    return !1
                            }
                        } catch (t) {
                            S.e(t)
                        } finally {
                            S.f()
                        }
                        return !0
                    }
                    return h.isPureish(t)
                }
            }, {
                key: "setData",
                value: function setData(t, r) {
                    return this.data[t] = r
                }
            }, {
                key: "getData",
                value: function getData(t) {
                    var r = this;
                    do {
                        var i = r.data[t];
                        if (null != i)
                            return i
                    } while (r = r.parent)
                }
            }, {
                key: "removeData",
                value: function removeData(t) {
                    var r = this;
                    do {
                        null != r.data[t] && (r.data[t] = null)
                    } while (r = r.parent)
                }
            }, {
                key: "init",
                value: function init() {
                    this.inited || (this.inited = !0,
                    this.crawl())
                }
            }, {
                key: "crawl",
                value: function crawl() {
                    var t = this.path;
                    this.references = Object.create(null),
                    this.bindings = Object.create(null),
                    this.globals = Object.create(null),
                    this.uids = Object.create(null),
                    this.data = Object.create(null);
                    var r = this.getProgramParent();
                    if (!r.crawling) {
                        var i = {
                            references: [],
                            constantViolations: [],
                            assignments: []
                        };
                        if (this.crawling = !0,
                        "Program" !== t.type && T._exploded) {
                            var a, o = _createForOfIteratorHelper(T.enter);
                            try {
                                for (o.s(); !(a = o.n()).done; ) {
                                    (0,
                                    a.value)(t, i)
                                }
                            } catch (t) {
                                o.e(t)
                            } finally {
                                o.f()
                            }
                            var l = T[t.type];
                            if (l) {
                                var u, p = _createForOfIteratorHelper(l.enter);
                                try {
                                    for (p.s(); !(u = p.n()).done; ) {
                                        (0,
                                        u.value)(t, i)
                                    }
                                } catch (t) {
                                    p.e(t)
                                } finally {
                                    p.f()
                                }
                            }
                        }
                        t.traverse(T, i),
                        this.crawling = !1;
                        var c, d = _createForOfIteratorHelper(i.assignments);
                        try {
                            for (d.s(); !(c = d.n()).done; ) {
                                for (var y = c.value, h = y.getBindingIdentifiers(), m = 0, S = Object.keys(h); m < S.length; m++) {
                                    var g = S[m];
                                    y.scope.getBinding(g) || r.addGlobal(h[g])
                                }
                                y.scope.registerConstantViolation(y)
                            }
                        } catch (t) {
                            d.e(t)
                        } finally {
                            d.f()
                        }
                        var b, v = _createForOfIteratorHelper(i.references);
                        try {
                            for (v.s(); !(b = v.n()).done; ) {
                                var E = b.value
                                  , P = E.scope.getBinding(E.node.name);
                                P ? P.reference(E) : r.addGlobal(E.node)
                            }
                        } catch (t) {
                            v.e(t)
                        } finally {
                            v.f()
                        }
                        var x, A = _createForOfIteratorHelper(i.constantViolations);
                        try {
                            for (A.s(); !(x = A.n()).done; ) {
                                var O = x.value;
                                O.scope.registerConstantViolation(O)
                            }
                        } catch (t) {
                            A.e(t)
                        } finally {
                            A.f()
                        }
                    }
                }
            }, {
                key: "push",
                value: function push(t) {
                    var r = this.path;
                    r.isBlockStatement() || r.isProgram() || (r = this.getBlockParent().path),
                    r.isSwitchStatement() && (r = (this.getFunctionParent() || this.getProgramParent()).path),
                    (r.isLoop() || r.isCatchClause() || r.isFunction()) && (r.ensureBlock(),
                    r = r.get("body"));
                    var i = t.unique
                      , a = t.kind || "var"
                      , l = null == t._blockHoist ? 2 : t._blockHoist
                      , u = "declaration:".concat(a, ":").concat(l)
                      , p = !i && r.getData(u);
                    if (!p) {
                        var c = h.variableDeclaration(a, []);
                        c._blockHoist = l;
                        var d = r.unshiftContainer("body", [c]);
                        p = (0,
                        o.default)(d, 1)[0],
                        i || r.setData(u, p)
                    }
                    var y = h.variableDeclarator(t.id, t.init);
                    p.node.declarations.push(y),
                    this.registerBinding(a, p.get("declarations").pop())
                }
            }, {
                key: "getProgramParent",
                value: function getProgramParent() {
                    var t = this;
                    do {
                        if (t.path.isProgram())
                            return t
                    } while (t = t.parent);
                    throw new Error("Couldn't find a Program")
                }
            }, {
                key: "getFunctionParent",
                value: function getFunctionParent() {
                    var t = this;
                    do {
                        if (t.path.isFunctionParent())
                            return t
                    } while (t = t.parent);
                    return null
                }
            }, {
                key: "getBlockParent",
                value: function getBlockParent() {
                    var t = this;
                    do {
                        if (t.path.isBlockParent())
                            return t
                    } while (t = t.parent);
                    throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...")
                }
            }, {
                key: "getAllBindings",
                value: function getAllBindings() {
                    var t = Object.create(null)
                      , r = this;
                    do {
                        for (var i = 0, a = Object.keys(r.bindings); i < a.length; i++) {
                            var o = a[i];
                            o in t == !1 && (t[o] = r.bindings[o])
                        }
                        r = r.parent
                    } while (r);
                    return t
                }
            }, {
                key: "getAllBindingsOfKind",
                value: function getAllBindingsOfKind() {
                    for (var t = Object.create(null), r = arguments.length, i = new Array(r), a = 0; a < r; a++)
                        i[a] = arguments[a];
                    for (var o = 0, l = i; o < l.length; o++) {
                        var u = l[o]
                          , p = this;
                        do {
                            for (var c = 0, d = Object.keys(p.bindings); c < d.length; c++) {
                                var y = d[c]
                                  , h = p.bindings[y];
                                h.kind === u && (t[y] = h)
                            }
                            p = p.parent
                        } while (p)
                    }
                    return t
                }
            }, {
                key: "bindingIdentifierEquals",
                value: function bindingIdentifierEquals(t, r) {
                    return this.getBindingIdentifier(t) === r
                }
            }, {
                key: "getBinding",
                value: function getBinding(t) {
                    var r, i = this;
                    do {
                        var a, o = i.getOwnBinding(t);
                        if (o)
                            if (null == (a = r) || !a.isPattern() || "param" === o.kind)
                                return o;
                        r = i.path
                    } while (i = i.parent)
                }
            }, {
                key: "getOwnBinding",
                value: function getOwnBinding(t) {
                    return this.bindings[t]
                }
            }, {
                key: "getBindingIdentifier",
                value: function getBindingIdentifier(t) {
                    var r;
                    return null == (r = this.getBinding(t)) ? void 0 : r.identifier
                }
            }, {
                key: "getOwnBindingIdentifier",
                value: function getOwnBindingIdentifier(t) {
                    var r = this.bindings[t];
                    return null == r ? void 0 : r.identifier
                }
            }, {
                key: "hasOwnBinding",
                value: function hasOwnBinding(t) {
                    return !!this.getOwnBinding(t)
                }
            }, {
                key: "hasBinding",
                value: function hasBinding(t, r) {
                    return !!t && (!!this.hasOwnBinding(t) || (!!this.parentHasBinding(t, r) || (!!this.hasUid(t) || (!(r || !Scope.globals.includes(t)) || !(r || !Scope.contextVariables.includes(t))))))
                }
            }, {
                key: "parentHasBinding",
                value: function parentHasBinding(t, r) {
                    var i;
                    return null == (i = this.parent) ? void 0 : i.hasBinding(t, r)
                }
            }, {
                key: "moveBindingTo",
                value: function moveBindingTo(t, r) {
                    var i = this.getBinding(t);
                    i && (i.scope.removeOwnBinding(t),
                    i.scope = r,
                    r.bindings[t] = i)
                }
            }, {
                key: "removeOwnBinding",
                value: function removeOwnBinding(t) {
                    delete this.bindings[t]
                }
            }, {
                key: "removeBinding",
                value: function removeBinding(t) {
                    var r;
                    null == (r = this.getBinding(t)) || r.scope.removeOwnBinding(t);
                    var i = this;
                    do {
                        i.uids[t] && (i.uids[t] = !1)
                    } while (i = i.parent)
                }
            }]),
            Scope
        }();
        r.default = g,
        g.globals = Object.keys(y.builtin),
        g.contextVariables = ["arguments", "undefined", "Infinity", "NaN"]
    },
    s0R5: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function matchesPattern(t, r, i) {
            if (!(0,
            a.isMemberExpression)(t))
                return !1;
            var o, l = Array.isArray(r) ? r : r.split("."), u = [];
            for (o = t; (0,
            a.isMemberExpression)(o); o = o.object)
                u.push(o.property);
            if (u.push(o),
            u.length < l.length)
                return !1;
            if (!i && u.length > l.length)
                return !1;
            for (var p = 0, c = u.length - 1; p < l.length; p++,
            c--) {
                var d = u[c]
                  , y = void 0;
                if ((0,
                a.isIdentifier)(d))
                    y = d.name;
                else if ((0,
                a.isStringLiteral)(d))
                    y = d.value;
                else {
                    if (!(0,
                    a.isThisExpression)(d))
                        return !1;
                    y = "this"
                }
                if (l[p] !== y)
                    return !1
            }
            return !0
        }
        ;
        var a = i("pbIU")
    },
    sN7J: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = cloneNode;
        var a = i("Resm")
          , o = i("FUES")
          , l = Function.call.bind(Object.prototype.hasOwnProperty);
        function cloneIfNode(t, r, i) {
            return t && "string" == typeof t.type ? cloneNode(t, r, i) : t
        }
        function cloneIfNodeOrArray(t, r, i) {
            return Array.isArray(t) ? t.map((function(t) {
                return cloneIfNode(t, r, i)
            }
            )) : cloneIfNode(t, r, i)
        }
        function cloneNode(t) {
            var r = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1]
              , i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
            if (!t)
                return t;
            var u = t.type
              , p = {
                type: t.type
            };
            if ((0,
            o.isIdentifier)(t))
                p.name = t.name,
                l(t, "optional") && "boolean" == typeof t.optional && (p.optional = t.optional),
                l(t, "typeAnnotation") && (p.typeAnnotation = r ? cloneIfNodeOrArray(t.typeAnnotation, !0, i) : t.typeAnnotation);
            else {
                if (!l(a.NODE_FIELDS, u))
                    throw new Error('Unknown node type: "'.concat(u, '"'));
                for (var c = 0, d = Object.keys(a.NODE_FIELDS[u]); c < d.length; c++) {
                    var y = d[c];
                    l(t, y) && (p[y] = r ? (0,
                    o.isFile)(t) && "comments" === y ? maybeCloneComments(t.comments, r, i) : cloneIfNodeOrArray(t[y], !0, i) : t[y])
                }
            }
            return l(t, "loc") && (p.loc = i ? null : t.loc),
            l(t, "leadingComments") && (p.leadingComments = maybeCloneComments(t.leadingComments, r, i)),
            l(t, "innerComments") && (p.innerComments = maybeCloneComments(t.innerComments, r, i)),
            l(t, "trailingComments") && (p.trailingComments = maybeCloneComments(t.trailingComments, r, i)),
            l(t, "extra") && (p.extra = Object.assign({}, t.extra)),
            p
        }
        function maybeCloneComments(t, r, i) {
            return t && r ? t.map((function(t) {
                var r = t.type
                  , a = t.value
                  , o = t.loc;
                return i ? {
                    type: r,
                    value: a,
                    loc: null
                } : {
                    type: r,
                    value: a,
                    loc: o
                }
            }
            )) : t
        }
    },
    sNN5: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.BlockStatement = function BlockStatement(t) {
            var r;
            this.token("{"),
            this.printInnerComments(t);
            const i = null == (r = t.directives) ? void 0 : r.length;
            t.body.length || i ? (this.newline(),
            this.printSequence(t.directives, t, {
                indent: !0
            }),
            i && this.newline(),
            this.printSequence(t.body, t, {
                indent: !0
            }),
            this.removeTrailingNewline(),
            this.source("end", t.loc),
            this.endsWith(10) || this.newline(),
            this.rightBrace()) : (this.source("end", t.loc),
            this.token("}"))
        }
        ,
        r.Directive = function Directive(t) {
            this.print(t.value, t),
            this.semicolon()
        }
        ,
        r.DirectiveLiteral = function DirectiveLiteral(t) {
            const r = this.getPossibleRaw(t);
            if (!this.format.minified && null != r)
                return void this.token(r);
            const {value: i} = t;
            if (o.test(i)) {
                if (a.test(i))
                    throw new Error("Malformed AST: it is not possible to print a directive containing both unescaped single and double quotes.");
                this.token(`'${i}'`)
            } else
                this.token(`"${i}"`)
        }
        ,
        r.File = function File(t) {
            t.program && this.print(t.program.interpreter, t);
            this.print(t.program, t)
        }
        ,
        r.InterpreterDirective = function InterpreterDirective(t) {
            this.token(`#!${t.value}\n`)
        }
        ,
        r.Placeholder = function Placeholder(t) {
            this.token("%%"),
            this.print(t.name),
            this.token("%%"),
            "Statement" === t.expectedNode && this.semicolon()
        }
        ,
        r.Program = function Program(t) {
            this.printInnerComments(t, !1),
            this.printSequence(t.directives, t),
            t.directives && t.directives.length && this.newline();
            this.printSequence(t.body, t)
        }
        ;
        const a = /(?:^|[^\\])(?:\\\\)*'/
          , o = /(?:^|[^\\])(?:\\\\)*"/
    },
    sP6y: function(t, r, i) {
        "use strict";
        function tokenIfPlusMinus(t, r) {
            !0 !== r && t.token(r)
        }
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.TSAnyKeyword = function TSAnyKeyword() {
            this.word("any")
        }
        ,
        r.TSArrayType = function TSArrayType(t) {
            this.print(t.elementType, t),
            this.token("[]")
        }
        ,
        r.TSAsExpression = function TSAsExpression(t) {
            const {expression: r, typeAnnotation: i} = t;
            this.print(r, t),
            this.space(),
            this.word("as"),
            this.space(),
            this.print(i, t)
        }
        ,
        r.TSBigIntKeyword = function TSBigIntKeyword() {
            this.word("bigint")
        }
        ,
        r.TSBooleanKeyword = function TSBooleanKeyword() {
            this.word("boolean")
        }
        ,
        r.TSCallSignatureDeclaration = function TSCallSignatureDeclaration(t) {
            this.tsPrintSignatureDeclarationBase(t),
            this.token(";")
        }
        ,
        r.TSConditionalType = function TSConditionalType(t) {
            this.print(t.checkType),
            this.space(),
            this.word("extends"),
            this.space(),
            this.print(t.extendsType),
            this.space(),
            this.token("?"),
            this.space(),
            this.print(t.trueType),
            this.space(),
            this.token(":"),
            this.space(),
            this.print(t.falseType)
        }
        ,
        r.TSConstructSignatureDeclaration = function TSConstructSignatureDeclaration(t) {
            this.word("new"),
            this.space(),
            this.tsPrintSignatureDeclarationBase(t),
            this.token(";")
        }
        ,
        r.TSConstructorType = function TSConstructorType(t) {
            t.abstract && (this.word("abstract"),
            this.space());
            this.word("new"),
            this.space(),
            this.tsPrintFunctionOrConstructorType(t)
        }
        ,
        r.TSDeclareFunction = function TSDeclareFunction(t) {
            t.declare && (this.word("declare"),
            this.space());
            this._functionHead(t),
            this.token(";")
        }
        ,
        r.TSDeclareMethod = function TSDeclareMethod(t) {
            this._classMethodHead(t),
            this.token(";")
        }
        ,
        r.TSEnumDeclaration = function TSEnumDeclaration(t) {
            const {declare: r, const: i, id: a, members: o} = t;
            r && (this.word("declare"),
            this.space());
            i && (this.word("const"),
            this.space());
            this.word("enum"),
            this.space(),
            this.print(a, t),
            this.space(),
            this.tsPrintBraced(o, t)
        }
        ,
        r.TSEnumMember = function TSEnumMember(t) {
            const {id: r, initializer: i} = t;
            this.print(r, t),
            i && (this.space(),
            this.token("="),
            this.space(),
            this.print(i, t));
            this.token(",")
        }
        ,
        r.TSExportAssignment = function TSExportAssignment(t) {
            this.word("export"),
            this.space(),
            this.token("="),
            this.space(),
            this.print(t.expression, t),
            this.token(";")
        }
        ,
        r.TSExpressionWithTypeArguments = function TSExpressionWithTypeArguments(t) {
            this.print(t.expression, t),
            this.print(t.typeParameters, t)
        }
        ,
        r.TSExternalModuleReference = function TSExternalModuleReference(t) {
            this.token("require("),
            this.print(t.expression, t),
            this.token(")")
        }
        ,
        r.TSFunctionType = function TSFunctionType(t) {
            this.tsPrintFunctionOrConstructorType(t)
        }
        ,
        r.TSImportEqualsDeclaration = function TSImportEqualsDeclaration(t) {
            const {isExport: r, id: i, moduleReference: a} = t;
            r && (this.word("export"),
            this.space());
            this.word("import"),
            this.space(),
            this.print(i, t),
            this.space(),
            this.token("="),
            this.space(),
            this.print(a, t),
            this.token(";")
        }
        ,
        r.TSImportType = function TSImportType(t) {
            const {argument: r, qualifier: i, typeParameters: a} = t;
            this.word("import"),
            this.token("("),
            this.print(r, t),
            this.token(")"),
            i && (this.token("."),
            this.print(i, t));
            a && this.print(a, t)
        }
        ,
        r.TSIndexSignature = function TSIndexSignature(t) {
            const {readonly: r, static: i} = t;
            i && (this.word("static"),
            this.space());
            r && (this.word("readonly"),
            this.space());
            this.token("["),
            this._parameters(t.parameters, t),
            this.token("]"),
            this.print(t.typeAnnotation, t),
            this.token(";")
        }
        ,
        r.TSIndexedAccessType = function TSIndexedAccessType(t) {
            this.print(t.objectType, t),
            this.token("["),
            this.print(t.indexType, t),
            this.token("]")
        }
        ,
        r.TSInferType = function TSInferType(t) {
            this.token("infer"),
            this.space(),
            this.print(t.typeParameter)
        }
        ,
        r.TSInterfaceBody = function TSInterfaceBody(t) {
            this.tsPrintTypeLiteralOrInterfaceBody(t.body, t)
        }
        ,
        r.TSInterfaceDeclaration = function TSInterfaceDeclaration(t) {
            const {declare: r, id: i, typeParameters: a, extends: o, body: l} = t;
            r && (this.word("declare"),
            this.space());
            this.word("interface"),
            this.space(),
            this.print(i, t),
            this.print(a, t),
            null != o && o.length && (this.space(),
            this.word("extends"),
            this.space(),
            this.printList(o, t));
            this.space(),
            this.print(l, t)
        }
        ,
        r.TSIntersectionType = function TSIntersectionType(t) {
            this.tsPrintUnionOrIntersectionType(t, "&")
        }
        ,
        r.TSIntrinsicKeyword = function TSIntrinsicKeyword() {
            this.word("intrinsic")
        }
        ,
        r.TSLiteralType = function TSLiteralType(t) {
            this.print(t.literal, t)
        }
        ,
        r.TSMappedType = function TSMappedType(t) {
            const {nameType: r, optional: i, readonly: a, typeParameter: o} = t;
            this.token("{"),
            this.space(),
            a && (tokenIfPlusMinus(this, a),
            this.word("readonly"),
            this.space());
            this.token("["),
            this.word(o.name),
            this.space(),
            this.word("in"),
            this.space(),
            this.print(o.constraint, o),
            r && (this.space(),
            this.word("as"),
            this.space(),
            this.print(r, t));
            this.token("]"),
            i && (tokenIfPlusMinus(this, i),
            this.token("?"));
            this.token(":"),
            this.space(),
            this.print(t.typeAnnotation, t),
            this.space(),
            this.token("}")
        }
        ,
        r.TSMethodSignature = function TSMethodSignature(t) {
            const {kind: r} = t;
            "set" !== r && "get" !== r || (this.word(r),
            this.space());
            this.tsPrintPropertyOrMethodName(t),
            this.tsPrintSignatureDeclarationBase(t),
            this.token(";")
        }
        ,
        r.TSModuleBlock = function TSModuleBlock(t) {
            this.tsPrintBraced(t.body, t)
        }
        ,
        r.TSModuleDeclaration = function TSModuleDeclaration(t) {
            const {declare: r, id: i} = t;
            r && (this.word("declare"),
            this.space());
            t.global || (this.word("Identifier" === i.type ? "namespace" : "module"),
            this.space());
            if (this.print(i, t),
            !t.body)
                return void this.token(";");
            let a = t.body;
            for (; "TSModuleDeclaration" === a.type; )
                this.token("."),
                this.print(a.id, a),
                a = a.body;
            this.space(),
            this.print(a, t)
        }
        ,
        r.TSNamedTupleMember = function TSNamedTupleMember(t) {
            this.print(t.label, t),
            t.optional && this.token("?");
            this.token(":"),
            this.space(),
            this.print(t.elementType, t)
        }
        ,
        r.TSNamespaceExportDeclaration = function TSNamespaceExportDeclaration(t) {
            this.word("export"),
            this.space(),
            this.word("as"),
            this.space(),
            this.word("namespace"),
            this.space(),
            this.print(t.id, t)
        }
        ,
        r.TSNeverKeyword = function TSNeverKeyword() {
            this.word("never")
        }
        ,
        r.TSNonNullExpression = function TSNonNullExpression(t) {
            this.print(t.expression, t),
            this.token("!")
        }
        ,
        r.TSNullKeyword = function TSNullKeyword() {
            this.word("null")
        }
        ,
        r.TSNumberKeyword = function TSNumberKeyword() {
            this.word("number")
        }
        ,
        r.TSObjectKeyword = function TSObjectKeyword() {
            this.word("object")
        }
        ,
        r.TSOptionalType = function TSOptionalType(t) {
            this.print(t.typeAnnotation, t),
            this.token("?")
        }
        ,
        r.TSParameterProperty = function TSParameterProperty(t) {
            t.accessibility && (this.word(t.accessibility),
            this.space());
            t.readonly && (this.word("readonly"),
            this.space());
            this._param(t.parameter)
        }
        ,
        r.TSParenthesizedType = function TSParenthesizedType(t) {
            this.token("("),
            this.print(t.typeAnnotation, t),
            this.token(")")
        }
        ,
        r.TSPropertySignature = function TSPropertySignature(t) {
            const {readonly: r, initializer: i} = t;
            r && (this.word("readonly"),
            this.space());
            this.tsPrintPropertyOrMethodName(t),
            this.print(t.typeAnnotation, t),
            i && (this.space(),
            this.token("="),
            this.space(),
            this.print(i, t));
            this.token(";")
        }
        ,
        r.TSQualifiedName = function TSQualifiedName(t) {
            this.print(t.left, t),
            this.token("."),
            this.print(t.right, t)
        }
        ,
        r.TSRestType = function TSRestType(t) {
            this.token("..."),
            this.print(t.typeAnnotation, t)
        }
        ,
        r.TSStringKeyword = function TSStringKeyword() {
            this.word("string")
        }
        ,
        r.TSSymbolKeyword = function TSSymbolKeyword() {
            this.word("symbol")
        }
        ,
        r.TSThisType = function TSThisType() {
            this.word("this")
        }
        ,
        r.TSTupleType = function TSTupleType(t) {
            this.token("["),
            this.printList(t.elementTypes, t),
            this.token("]")
        }
        ,
        r.TSTypeAliasDeclaration = function TSTypeAliasDeclaration(t) {
            const {declare: r, id: i, typeParameters: a, typeAnnotation: o} = t;
            r && (this.word("declare"),
            this.space());
            this.word("type"),
            this.space(),
            this.print(i, t),
            this.print(a, t),
            this.space(),
            this.token("="),
            this.space(),
            this.print(o, t),
            this.token(";")
        }
        ,
        r.TSTypeAnnotation = function TSTypeAnnotation(t) {
            this.token(":"),
            this.space(),
            t.optional && this.token("?");
            this.print(t.typeAnnotation, t)
        }
        ,
        r.TSTypeAssertion = function TSTypeAssertion(t) {
            const {typeAnnotation: r, expression: i} = t;
            this.token("<"),
            this.print(r, t),
            this.token(">"),
            this.space(),
            this.print(i, t)
        }
        ,
        r.TSTypeLiteral = function TSTypeLiteral(t) {
            this.tsPrintTypeLiteralOrInterfaceBody(t.members, t)
        }
        ,
        r.TSTypeOperator = function TSTypeOperator(t) {
            this.word(t.operator),
            this.space(),
            this.print(t.typeAnnotation, t)
        }
        ,
        r.TSTypeParameter = function TSTypeParameter(t) {
            this.word(t.name),
            t.constraint && (this.space(),
            this.word("extends"),
            this.space(),
            this.print(t.constraint, t));
            t.default && (this.space(),
            this.token("="),
            this.space(),
            this.print(t.default, t))
        }
        ,
        r.TSTypeParameterDeclaration = r.TSTypeParameterInstantiation = function TSTypeParameterInstantiation(t, r) {
            this.token("<"),
            this.printList(t.params, t, {}),
            "ArrowFunctionExpression" === r.type && 1 === t.params.length && this.token(",");
            this.token(">")
        }
        ,
        r.TSTypePredicate = function TSTypePredicate(t) {
            t.asserts && (this.word("asserts"),
            this.space());
            this.print(t.parameterName),
            t.typeAnnotation && (this.space(),
            this.word("is"),
            this.space(),
            this.print(t.typeAnnotation.typeAnnotation))
        }
        ,
        r.TSTypeQuery = function TSTypeQuery(t) {
            this.word("typeof"),
            this.space(),
            this.print(t.exprName)
        }
        ,
        r.TSTypeReference = function TSTypeReference(t) {
            this.print(t.typeName, t),
            this.print(t.typeParameters, t)
        }
        ,
        r.TSUndefinedKeyword = function TSUndefinedKeyword() {
            this.word("undefined")
        }
        ,
        r.TSUnionType = function TSUnionType(t) {
            this.tsPrintUnionOrIntersectionType(t, "|")
        }
        ,
        r.TSUnknownKeyword = function TSUnknownKeyword() {
            this.word("unknown")
        }
        ,
        r.TSVoidKeyword = function TSVoidKeyword() {
            this.word("void")
        }
        ,
        r.tsPrintBraced = function tsPrintBraced(t, r) {
            if (this.token("{"),
            t.length) {
                this.indent(),
                this.newline();
                for (const i of t)
                    this.print(i, r),
                    this.newline();
                this.dedent(),
                this.rightBrace()
            } else
                this.token("}")
        }
        ,
        r.tsPrintClassMemberModifiers = function tsPrintClassMemberModifiers(t, r) {
            r && t.declare && (this.word("declare"),
            this.space());
            t.accessibility && (this.word(t.accessibility),
            this.space());
            t.static && (this.word("static"),
            this.space());
            t.override && (this.word("override"),
            this.space());
            t.abstract && (this.word("abstract"),
            this.space());
            r && t.readonly && (this.word("readonly"),
            this.space())
        }
        ,
        r.tsPrintFunctionOrConstructorType = function tsPrintFunctionOrConstructorType(t) {
            const {typeParameters: r} = t
              , i = t.parameters;
            this.print(r, t),
            this.token("("),
            this._parameters(i, t),
            this.token(")"),
            this.space(),
            this.token("=>"),
            this.space();
            const a = t.typeAnnotation;
            this.print(a.typeAnnotation, t)
        }
        ,
        r.tsPrintPropertyOrMethodName = function tsPrintPropertyOrMethodName(t) {
            t.computed && this.token("[");
            this.print(t.key, t),
            t.computed && this.token("]");
            t.optional && this.token("?")
        }
        ,
        r.tsPrintSignatureDeclarationBase = function tsPrintSignatureDeclarationBase(t) {
            const {typeParameters: r} = t
              , i = t.parameters;
            this.print(r, t),
            this.token("("),
            this._parameters(i, t),
            this.token(")");
            const a = t.typeAnnotation;
            this.print(a, t)
        }
        ,
        r.tsPrintTypeLiteralOrInterfaceBody = function tsPrintTypeLiteralOrInterfaceBody(t, r) {
            this.tsPrintBraced(t, r)
        }
        ,
        r.tsPrintUnionOrIntersectionType = function tsPrintUnionOrIntersectionType(t, r) {
            this.printJoin(t.types, t, {
                separator() {
                    this.space(),
                    this.token(r),
                    this.space()
                }
            })
        }
    },
    sR6L: function(t, r, i) {
        !function clone(t) {
            "use strict";
            var r, a, o, l, u, p;
            function deepCopy(t) {
                var r, i, a = {};
                for (r in t)
                    t.hasOwnProperty(r) && (i = t[r],
                    a[r] = "object" == typeof i && null !== i ? deepCopy(i) : i);
                return a
            }
            function Reference(t, r) {
                this.parent = t,
                this.key = r
            }
            function Element(t, r, i, a) {
                this.node = t,
                this.path = r,
                this.wrap = i,
                this.ref = a
            }
            function Controller() {}
            function isNode(t) {
                return null != t && ("object" == typeof t && "string" == typeof t.type)
            }
            function isProperty(t, i) {
                return (t === r.ObjectExpression || t === r.ObjectPattern) && "properties" === i
            }
            function traverse(t, r) {
                return (new Controller).traverse(t, r)
            }
            function extendCommentRange(t, r) {
                var i;
                return i = function upperBound(t, r) {
                    var i, a, o, l;
                    for (a = t.length,
                    o = 0; a; )
                        r(t[l = o + (i = a >>> 1)]) ? a = i : (o = l + 1,
                        a -= i + 1);
                    return o
                }(r, (function search(r) {
                    return r.range[0] > t.range[0]
                }
                )),
                t.extendedRange = [t.range[0], t.range[1]],
                i !== r.length && (t.extendedRange[1] = r[i].range[0]),
                (i -= 1) >= 0 && (t.extendedRange[0] = r[i].range[1]),
                t
            }
            return r = {
                AssignmentExpression: "AssignmentExpression",
                AssignmentPattern: "AssignmentPattern",
                ArrayExpression: "ArrayExpression",
                ArrayPattern: "ArrayPattern",
                ArrowFunctionExpression: "ArrowFunctionExpression",
                AwaitExpression: "AwaitExpression",
                BlockStatement: "BlockStatement",
                BinaryExpression: "BinaryExpression",
                BreakStatement: "BreakStatement",
                CallExpression: "CallExpression",
                CatchClause: "CatchClause",
                ClassBody: "ClassBody",
                ClassDeclaration: "ClassDeclaration",
                ClassExpression: "ClassExpression",
                ComprehensionBlock: "ComprehensionBlock",
                ComprehensionExpression: "ComprehensionExpression",
                ConditionalExpression: "ConditionalExpression",
                ContinueStatement: "ContinueStatement",
                DebuggerStatement: "DebuggerStatement",
                DirectiveStatement: "DirectiveStatement",
                DoWhileStatement: "DoWhileStatement",
                EmptyStatement: "EmptyStatement",
                ExportAllDeclaration: "ExportAllDeclaration",
                ExportDefaultDeclaration: "ExportDefaultDeclaration",
                ExportNamedDeclaration: "ExportNamedDeclaration",
                ExportSpecifier: "ExportSpecifier",
                ExpressionStatement: "ExpressionStatement",
                ForStatement: "ForStatement",
                ForInStatement: "ForInStatement",
                ForOfStatement: "ForOfStatement",
                FunctionDeclaration: "FunctionDeclaration",
                FunctionExpression: "FunctionExpression",
                GeneratorExpression: "GeneratorExpression",
                Identifier: "Identifier",
                IfStatement: "IfStatement",
                ImportExpression: "ImportExpression",
                ImportDeclaration: "ImportDeclaration",
                ImportDefaultSpecifier: "ImportDefaultSpecifier",
                ImportNamespaceSpecifier: "ImportNamespaceSpecifier",
                ImportSpecifier: "ImportSpecifier",
                Literal: "Literal",
                LabeledStatement: "LabeledStatement",
                LogicalExpression: "LogicalExpression",
                MemberExpression: "MemberExpression",
                MetaProperty: "MetaProperty",
                MethodDefinition: "MethodDefinition",
                ModuleSpecifier: "ModuleSpecifier",
                NewExpression: "NewExpression",
                ObjectExpression: "ObjectExpression",
                ObjectPattern: "ObjectPattern",
                Program: "Program",
                Property: "Property",
                RestElement: "RestElement",
                ReturnStatement: "ReturnStatement",
                SequenceExpression: "SequenceExpression",
                SpreadElement: "SpreadElement",
                Super: "Super",
                SwitchStatement: "SwitchStatement",
                SwitchCase: "SwitchCase",
                TaggedTemplateExpression: "TaggedTemplateExpression",
                TemplateElement: "TemplateElement",
                TemplateLiteral: "TemplateLiteral",
                ThisExpression: "ThisExpression",
                ThrowStatement: "ThrowStatement",
                TryStatement: "TryStatement",
                UnaryExpression: "UnaryExpression",
                UpdateExpression: "UpdateExpression",
                VariableDeclaration: "VariableDeclaration",
                VariableDeclarator: "VariableDeclarator",
                WhileStatement: "WhileStatement",
                WithStatement: "WithStatement",
                YieldExpression: "YieldExpression"
            },
            o = {
                AssignmentExpression: ["left", "right"],
                AssignmentPattern: ["left", "right"],
                ArrayExpression: ["elements"],
                ArrayPattern: ["elements"],
                ArrowFunctionExpression: ["params", "body"],
                AwaitExpression: ["argument"],
                BlockStatement: ["body"],
                BinaryExpression: ["left", "right"],
                BreakStatement: ["label"],
                CallExpression: ["callee", "arguments"],
                CatchClause: ["param", "body"],
                ClassBody: ["body"],
                ClassDeclaration: ["id", "superClass", "body"],
                ClassExpression: ["id", "superClass", "body"],
                ComprehensionBlock: ["left", "right"],
                ComprehensionExpression: ["blocks", "filter", "body"],
                ConditionalExpression: ["test", "consequent", "alternate"],
                ContinueStatement: ["label"],
                DebuggerStatement: [],
                DirectiveStatement: [],
                DoWhileStatement: ["body", "test"],
                EmptyStatement: [],
                ExportAllDeclaration: ["source"],
                ExportDefaultDeclaration: ["declaration"],
                ExportNamedDeclaration: ["declaration", "specifiers", "source"],
                ExportSpecifier: ["exported", "local"],
                ExpressionStatement: ["expression"],
                ForStatement: ["init", "test", "update", "body"],
                ForInStatement: ["left", "right", "body"],
                ForOfStatement: ["left", "right", "body"],
                FunctionDeclaration: ["id", "params", "body"],
                FunctionExpression: ["id", "params", "body"],
                GeneratorExpression: ["blocks", "filter", "body"],
                Identifier: [],
                IfStatement: ["test", "consequent", "alternate"],
                ImportExpression: ["source"],
                ImportDeclaration: ["specifiers", "source"],
                ImportDefaultSpecifier: ["local"],
                ImportNamespaceSpecifier: ["local"],
                ImportSpecifier: ["imported", "local"],
                Literal: [],
                LabeledStatement: ["label", "body"],
                LogicalExpression: ["left", "right"],
                MemberExpression: ["object", "property"],
                MetaProperty: ["meta", "property"],
                MethodDefinition: ["key", "value"],
                ModuleSpecifier: [],
                NewExpression: ["callee", "arguments"],
                ObjectExpression: ["properties"],
                ObjectPattern: ["properties"],
                Program: ["body"],
                Property: ["key", "value"],
                RestElement: ["argument"],
                ReturnStatement: ["argument"],
                SequenceExpression: ["expressions"],
                SpreadElement: ["argument"],
                Super: [],
                SwitchStatement: ["discriminant", "cases"],
                SwitchCase: ["test", "consequent"],
                TaggedTemplateExpression: ["tag", "quasi"],
                TemplateElement: [],
                TemplateLiteral: ["quasis", "expressions"],
                ThisExpression: [],
                ThrowStatement: ["argument"],
                TryStatement: ["block", "handler", "finalizer"],
                UnaryExpression: ["argument"],
                UpdateExpression: ["argument"],
                VariableDeclaration: ["declarations"],
                VariableDeclarator: ["id", "init"],
                WhileStatement: ["test", "body"],
                WithStatement: ["object", "body"],
                YieldExpression: ["argument"]
            },
            a = {
                Break: l = {},
                Skip: u = {},
                Remove: p = {}
            },
            Reference.prototype.replace = function replace(t) {
                this.parent[this.key] = t
            }
            ,
            Reference.prototype.remove = function remove() {
                return Array.isArray(this.parent) ? (this.parent.splice(this.key, 1),
                !0) : (this.replace(null),
                !1)
            }
            ,
            Controller.prototype.path = function path() {
                var t, r, i, a, o;
                function addToPath(t, r) {
                    if (Array.isArray(r))
                        for (i = 0,
                        a = r.length; i < a; ++i)
                            t.push(r[i]);
                    else
                        t.push(r)
                }
                if (!this.__current.path)
                    return null;
                for (o = [],
                t = 2,
                r = this.__leavelist.length; t < r; ++t)
                    addToPath(o, this.__leavelist[t].path);
                return addToPath(o, this.__current.path),
                o
            }
            ,
            Controller.prototype.type = function() {
                return this.current().type || this.__current.wrap
            }
            ,
            Controller.prototype.parents = function parents() {
                var t, r, i;
                for (i = [],
                t = 1,
                r = this.__leavelist.length; t < r; ++t)
                    i.push(this.__leavelist[t].node);
                return i
            }
            ,
            Controller.prototype.current = function current() {
                return this.__current.node
            }
            ,
            Controller.prototype.__execute = function __execute(t, r) {
                var i, a;
                return a = void 0,
                i = this.__current,
                this.__current = r,
                this.__state = null,
                t && (a = t.call(this, r.node, this.__leavelist[this.__leavelist.length - 1].node)),
                this.__current = i,
                a
            }
            ,
            Controller.prototype.notify = function notify(t) {
                this.__state = t
            }
            ,
            Controller.prototype.skip = function() {
                this.notify(u)
            }
            ,
            Controller.prototype.break = function() {
                this.notify(l)
            }
            ,
            Controller.prototype.remove = function() {
                this.notify(p)
            }
            ,
            Controller.prototype.__initialize = function(t, r) {
                this.visitor = r,
                this.root = t,
                this.__worklist = [],
                this.__leavelist = [],
                this.__current = null,
                this.__state = null,
                this.__fallback = null,
                "iteration" === r.fallback ? this.__fallback = Object.keys : "function" == typeof r.fallback && (this.__fallback = r.fallback),
                this.__keys = o,
                r.keys && (this.__keys = Object.assign(Object.create(this.__keys), r.keys))
            }
            ,
            Controller.prototype.traverse = function traverse(t, r) {
                var i, a, o, p, c, d, y, h, m, T, S, g;
                for (this.__initialize(t, r),
                g = {},
                i = this.__worklist,
                a = this.__leavelist,
                i.push(new Element(t,null,null,null)),
                a.push(new Element(null,null,null,null)); i.length; )
                    if ((o = i.pop()) !== g) {
                        if (o.node) {
                            if (d = this.__execute(r.enter, o),
                            this.__state === l || d === l)
                                return;
                            if (i.push(g),
                            a.push(o),
                            this.__state === u || d === u)
                                continue;
                            if (c = (p = o.node).type || o.wrap,
                            !(T = this.__keys[c])) {
                                if (!this.__fallback)
                                    throw new Error("Unknown node type " + c + ".");
                                T = this.__fallback(p)
                            }
                            for (h = T.length; (h -= 1) >= 0; )
                                if (S = p[y = T[h]])
                                    if (Array.isArray(S)) {
                                        for (m = S.length; (m -= 1) >= 0; )
                                            if (S[m]) {
                                                if (isProperty(c, T[h]))
                                                    o = new Element(S[m],[y, m],"Property",null);
                                                else {
                                                    if (!isNode(S[m]))
                                                        continue;
                                                    o = new Element(S[m],[y, m],null,null)
                                                }
                                                i.push(o)
                                            }
                                    } else
                                        isNode(S) && i.push(new Element(S,y,null,null))
                        }
                    } else if (o = a.pop(),
                    d = this.__execute(r.leave, o),
                    this.__state === l || d === l)
                        return
            }
            ,
            Controller.prototype.replace = function replace(t, r) {
                var i, a, o, c, d, y, h, m, T, S, g, b, v;
                function removeElem(t) {
                    var r, a, o, l;
                    if (t.ref.remove())
                        for (a = t.ref.key,
                        l = t.ref.parent,
                        r = i.length; r--; )
                            if ((o = i[r]).ref && o.ref.parent === l) {
                                if (o.ref.key < a)
                                    break;
                                --o.ref.key
                            }
                }
                for (this.__initialize(t, r),
                g = {},
                i = this.__worklist,
                a = this.__leavelist,
                y = new Element(t,null,null,new Reference(b = {
                    root: t
                },"root")),
                i.push(y),
                a.push(y); i.length; )
                    if ((y = i.pop()) !== g) {
                        if (void 0 !== (d = this.__execute(r.enter, y)) && d !== l && d !== u && d !== p && (y.ref.replace(d),
                        y.node = d),
                        this.__state !== p && d !== p || (removeElem(y),
                        y.node = null),
                        this.__state === l || d === l)
                            return b.root;
                        if ((o = y.node) && (i.push(g),
                        a.push(y),
                        this.__state !== u && d !== u)) {
                            if (c = o.type || y.wrap,
                            !(T = this.__keys[c])) {
                                if (!this.__fallback)
                                    throw new Error("Unknown node type " + c + ".");
                                T = this.__fallback(o)
                            }
                            for (h = T.length; (h -= 1) >= 0; )
                                if (S = o[v = T[h]])
                                    if (Array.isArray(S)) {
                                        for (m = S.length; (m -= 1) >= 0; )
                                            if (S[m]) {
                                                if (isProperty(c, T[h]))
                                                    y = new Element(S[m],[v, m],"Property",new Reference(S,m));
                                                else {
                                                    if (!isNode(S[m]))
                                                        continue;
                                                    y = new Element(S[m],[v, m],null,new Reference(S,m))
                                                }
                                                i.push(y)
                                            }
                                    } else
                                        isNode(S) && i.push(new Element(S,v,null,new Reference(o,v)))
                        }
                    } else if (y = a.pop(),
                    void 0 !== (d = this.__execute(r.leave, y)) && d !== l && d !== u && d !== p && y.ref.replace(d),
                    this.__state !== p && d !== p || removeElem(y),
                    this.__state === l || d === l)
                        return b.root;
                return b.root
            }
            ,
            t.version = i("V9Y0").version,
            t.Syntax = r,
            t.traverse = traverse,
            t.replace = function replace(t, r) {
                return (new Controller).replace(t, r)
            }
            ,
            t.attachComments = function attachComments(t, r, i) {
                var o, l, u, p, c = [];
                if (!t.range)
                    throw new Error("attachComments needs range information");
                if (!i.length) {
                    if (r.length) {
                        for (u = 0,
                        l = r.length; u < l; u += 1)
                            (o = deepCopy(r[u])).extendedRange = [0, t.range[0]],
                            c.push(o);
                        t.leadingComments = c
                    }
                    return t
                }
                for (u = 0,
                l = r.length; u < l; u += 1)
                    c.push(extendCommentRange(deepCopy(r[u]), i));
                return p = 0,
                traverse(t, {
                    enter: function(t) {
                        for (var r; p < c.length && !((r = c[p]).extendedRange[1] > t.range[0]); )
                            r.extendedRange[1] === t.range[0] ? (t.leadingComments || (t.leadingComments = []),
                            t.leadingComments.push(r),
                            c.splice(p, 1)) : p += 1;
                        return p === c.length ? a.Break : c[p].extendedRange[0] > t.range[1] ? a.Skip : void 0
                    }
                }),
                p = 0,
                traverse(t, {
                    leave: function(t) {
                        for (var r; p < c.length && (r = c[p],
                        !(t.range[1] < r.extendedRange[0])); )
                            t.range[1] === r.extendedRange[0] ? (t.trailingComments || (t.trailingComments = []),
                            t.trailingComments.push(r),
                            c.splice(p, 1)) : p += 1;
                        return p === c.length ? a.Break : c[p].extendedRange[0] > t.range[1] ? a.Skip : void 0
                    }
                }),
                t
            }
            ,
            t.VisitorKeys = o,
            t.VisitorOption = a,
            t.Controller = Controller,
            t.cloneEnvironment = function() {
                return clone({})
            }
            ,
            t
        }(r)
    },
    shor: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function isReferenced(t, r, i) {
            switch (r.type) {
            case "MemberExpression":
            case "OptionalMemberExpression":
                return r.property === t ? !!r.computed : r.object === t;
            case "JSXMemberExpression":
                return r.object === t;
            case "VariableDeclarator":
                return r.init === t;
            case "ArrowFunctionExpression":
                return r.body === t;
            case "PrivateName":
                return !1;
            case "ClassMethod":
            case "ClassPrivateMethod":
            case "ObjectMethod":
                return r.key === t && !!r.computed;
            case "ObjectProperty":
                return r.key === t ? !!r.computed : !i || "ObjectPattern" !== i.type;
            case "ClassProperty":
                return r.key !== t || !!r.computed;
            case "ClassPrivateProperty":
                return r.key !== t;
            case "ClassDeclaration":
            case "ClassExpression":
                return r.superClass === t;
            case "AssignmentExpression":
            case "AssignmentPattern":
                return r.right === t;
            case "LabeledStatement":
            case "CatchClause":
            case "RestElement":
                return !1;
            case "BreakStatement":
            case "ContinueStatement":
                return !1;
            case "FunctionDeclaration":
            case "FunctionExpression":
                return !1;
            case "ExportNamespaceSpecifier":
            case "ExportDefaultSpecifier":
                return !1;
            case "ExportSpecifier":
                return (null == i || !i.source) && r.local === t;
            case "ImportDefaultSpecifier":
            case "ImportNamespaceSpecifier":
            case "ImportSpecifier":
            case "ImportAttribute":
            case "JSXAttribute":
                return !1;
            case "ObjectPattern":
            case "ArrayPattern":
            case "MetaProperty":
                return !1;
            case "ObjectTypeProperty":
                return r.key !== t;
            case "TSEnumMember":
                return r.id !== t;
            case "TSPropertySignature":
                return r.key !== t || !!r.computed
            }
            return !0
        }
    },
    skWS: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function createTSUnionType(t) {
            var r = t.map((function(t) {
                return t.typeAnnotation
            }
            ))
              , i = (0,
            o.default)(r);
            return 1 === i.length ? i[0] : (0,
            a.tsUnionType)(i)
        }
        ;
        var a = i("UuI8")
          , o = i("Yb52")
    },
    "sqI+": function(t, r, i) {
        "use strict";
        var a = i("V97+");
        const o = (0,
        a.defineAliasedType)("JSX");
        o("JSXAttribute", {
            visitor: ["name", "value"],
            aliases: ["Immutable"],
            fields: {
                name: {
                    validate: (0,
                    a.assertNodeType)("JSXIdentifier", "JSXNamespacedName")
                },
                value: {
                    optional: !0,
                    validate: (0,
                    a.assertNodeType)("JSXElement", "JSXFragment", "StringLiteral", "JSXExpressionContainer")
                }
            }
        }),
        o("JSXClosingElement", {
            visitor: ["name"],
            aliases: ["Immutable"],
            fields: {
                name: {
                    validate: (0,
                    a.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
                }
            }
        }),
        o("JSXElement", {
            builder: ["openingElement", "closingElement", "children", "selfClosing"],
            visitor: ["openingElement", "children", "closingElement"],
            aliases: ["Immutable", "Expression"],
            fields: {
                openingElement: {
                    validate: (0,
                    a.assertNodeType)("JSXOpeningElement")
                },
                closingElement: {
                    optional: !0,
                    validate: (0,
                    a.assertNodeType)("JSXClosingElement")
                },
                children: {
                    validate: (0,
                    a.chain)((0,
                    a.assertValueType)("array"), (0,
                    a.assertEach)((0,
                    a.assertNodeType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")))
                },
                selfClosing: {
                    validate: (0,
                    a.assertValueType)("boolean"),
                    optional: !0
                }
            }
        }),
        o("JSXEmptyExpression", {}),
        o("JSXExpressionContainer", {
            visitor: ["expression"],
            aliases: ["Immutable"],
            fields: {
                expression: {
                    validate: (0,
                    a.assertNodeType)("Expression", "JSXEmptyExpression")
                }
            }
        }),
        o("JSXSpreadChild", {
            visitor: ["expression"],
            aliases: ["Immutable"],
            fields: {
                expression: {
                    validate: (0,
                    a.assertNodeType)("Expression")
                }
            }
        }),
        o("JSXIdentifier", {
            builder: ["name"],
            fields: {
                name: {
                    validate: (0,
                    a.assertValueType)("string")
                }
            }
        }),
        o("JSXMemberExpression", {
            visitor: ["object", "property"],
            fields: {
                object: {
                    validate: (0,
                    a.assertNodeType)("JSXMemberExpression", "JSXIdentifier")
                },
                property: {
                    validate: (0,
                    a.assertNodeType)("JSXIdentifier")
                }
            }
        }),
        o("JSXNamespacedName", {
            visitor: ["namespace", "name"],
            fields: {
                namespace: {
                    validate: (0,
                    a.assertNodeType)("JSXIdentifier")
                },
                name: {
                    validate: (0,
                    a.assertNodeType)("JSXIdentifier")
                }
            }
        }),
        o("JSXOpeningElement", {
            builder: ["name", "attributes", "selfClosing"],
            visitor: ["name", "attributes"],
            aliases: ["Immutable"],
            fields: {
                name: {
                    validate: (0,
                    a.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
                },
                selfClosing: {
                    default: !1
                },
                attributes: {
                    validate: (0,
                    a.chain)((0,
                    a.assertValueType)("array"), (0,
                    a.assertEach)((0,
                    a.assertNodeType)("JSXAttribute", "JSXSpreadAttribute")))
                },
                typeParameters: {
                    validate: (0,
                    a.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
                    optional: !0
                }
            }
        }),
        o("JSXSpreadAttribute", {
            visitor: ["argument"],
            fields: {
                argument: {
                    validate: (0,
                    a.assertNodeType)("Expression")
                }
            }
        }),
        o("JSXText", {
            aliases: ["Immutable"],
            builder: ["value"],
            fields: {
                value: {
                    validate: (0,
                    a.assertValueType)("string")
                }
            }
        }),
        o("JSXFragment", {
            builder: ["openingFragment", "closingFragment", "children"],
            visitor: ["openingFragment", "children", "closingFragment"],
            aliases: ["Immutable", "Expression"],
            fields: {
                openingFragment: {
                    validate: (0,
                    a.assertNodeType)("JSXOpeningFragment")
                },
                closingFragment: {
                    validate: (0,
                    a.assertNodeType)("JSXClosingFragment")
                },
                children: {
                    validate: (0,
                    a.chain)((0,
                    a.assertValueType)("array"), (0,
                    a.assertEach)((0,
                    a.assertNodeType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")))
                }
            }
        }),
        o("JSXOpeningFragment", {
            aliases: ["Immutable"]
        }),
        o("JSXClosingFragment", {
            aliases: ["Immutable"]
        })
    },
    tAhW: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function isValidES3Identifier(t) {
            return (0,
            a.default)(t) && !o.has(t)
        }
        ;
        var a = i("Aniq")
          , o = new Set(["abstract", "boolean", "byte", "char", "double", "enum", "final", "float", "goto", "implements", "int", "interface", "long", "native", "package", "private", "protected", "public", "short", "static", "synchronized", "throws", "transient", "volatile"])
    },
    tGnh: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.AnyTypeAnnotation = function AnyTypeAnnotation() {
            this.word("any")
        }
        ,
        r.ArrayTypeAnnotation = function ArrayTypeAnnotation(t) {
            this.print(t.elementType, t),
            this.token("["),
            this.token("]")
        }
        ,
        r.BooleanLiteralTypeAnnotation = function BooleanLiteralTypeAnnotation(t) {
            this.word(t.value ? "true" : "false")
        }
        ,
        r.BooleanTypeAnnotation = function BooleanTypeAnnotation() {
            this.word("boolean")
        }
        ,
        r.DeclareClass = function DeclareClass(t, r) {
            u(r) || (this.word("declare"),
            this.space());
            this.word("class"),
            this.space(),
            this._interfaceish(t)
        }
        ,
        r.DeclareExportAllDeclaration = function DeclareExportAllDeclaration() {
            this.word("declare"),
            this.space(),
            o.ExportAllDeclaration.apply(this, arguments)
        }
        ,
        r.DeclareExportDeclaration = function DeclareExportDeclaration(t) {
            this.word("declare"),
            this.space(),
            this.word("export"),
            this.space(),
            t.default && (this.word("default"),
            this.space());
            FlowExportDeclaration.apply(this, arguments)
        }
        ,
        r.DeclareFunction = function DeclareFunction(t, r) {
            u(r) || (this.word("declare"),
            this.space());
            this.word("function"),
            this.space(),
            this.print(t.id, t),
            this.print(t.id.typeAnnotation.typeAnnotation, t),
            t.predicate && (this.space(),
            this.print(t.predicate, t));
            this.semicolon()
        }
        ,
        r.DeclareInterface = function DeclareInterface(t) {
            this.word("declare"),
            this.space(),
            this.InterfaceDeclaration(t)
        }
        ,
        r.DeclareModule = function DeclareModule(t) {
            this.word("declare"),
            this.space(),
            this.word("module"),
            this.space(),
            this.print(t.id, t),
            this.space(),
            this.print(t.body, t)
        }
        ,
        r.DeclareModuleExports = function DeclareModuleExports(t) {
            this.word("declare"),
            this.space(),
            this.word("module"),
            this.token("."),
            this.word("exports"),
            this.print(t.typeAnnotation, t)
        }
        ,
        r.DeclareOpaqueType = function DeclareOpaqueType(t, r) {
            u(r) || (this.word("declare"),
            this.space());
            this.OpaqueType(t)
        }
        ,
        r.DeclareTypeAlias = function DeclareTypeAlias(t) {
            this.word("declare"),
            this.space(),
            this.TypeAlias(t)
        }
        ,
        r.DeclareVariable = function DeclareVariable(t, r) {
            u(r) || (this.word("declare"),
            this.space());
            this.word("var"),
            this.space(),
            this.print(t.id, t),
            this.print(t.id.typeAnnotation, t),
            this.semicolon()
        }
        ,
        r.DeclaredPredicate = function DeclaredPredicate(t) {
            this.token("%"),
            this.word("checks"),
            this.token("("),
            this.print(t.value, t),
            this.token(")")
        }
        ,
        r.EmptyTypeAnnotation = function EmptyTypeAnnotation() {
            this.word("empty")
        }
        ,
        r.EnumBooleanBody = function EnumBooleanBody(t) {
            const {explicitType: r} = t;
            enumExplicitType(this, "boolean", r),
            enumBody(this, t)
        }
        ,
        r.EnumBooleanMember = function EnumBooleanMember(t) {
            enumInitializedMember(this, t)
        }
        ,
        r.EnumDeclaration = function EnumDeclaration(t) {
            const {id: r, body: i} = t;
            this.word("enum"),
            this.space(),
            this.print(r, t),
            this.print(i, t)
        }
        ,
        r.EnumDefaultedMember = function EnumDefaultedMember(t) {
            const {id: r} = t;
            this.print(r, t),
            this.token(",")
        }
        ,
        r.EnumNumberBody = function EnumNumberBody(t) {
            const {explicitType: r} = t;
            enumExplicitType(this, "number", r),
            enumBody(this, t)
        }
        ,
        r.EnumNumberMember = function EnumNumberMember(t) {
            enumInitializedMember(this, t)
        }
        ,
        r.EnumStringBody = function EnumStringBody(t) {
            const {explicitType: r} = t;
            enumExplicitType(this, "string", r),
            enumBody(this, t)
        }
        ,
        r.EnumStringMember = function EnumStringMember(t) {
            enumInitializedMember(this, t)
        }
        ,
        r.EnumSymbolBody = function EnumSymbolBody(t) {
            enumExplicitType(this, "symbol", !0),
            enumBody(this, t)
        }
        ,
        r.ExistsTypeAnnotation = function ExistsTypeAnnotation() {
            this.token("*")
        }
        ,
        r.FunctionTypeAnnotation = function FunctionTypeAnnotation(t, r) {
            this.print(t.typeParameters, t),
            this.token("("),
            t.this && (this.word("this"),
            this.token(":"),
            this.space(),
            this.print(t.this.typeAnnotation, t),
            (t.params.length || t.rest) && (this.token(","),
            this.space()));
            this.printList(t.params, t),
            t.rest && (t.params.length && (this.token(","),
            this.space()),
            this.token("..."),
            this.print(t.rest, t));
            this.token(")"),
            r && ("ObjectTypeCallProperty" === r.type || "DeclareFunction" === r.type || "ObjectTypeProperty" === r.type && r.method) ? this.token(":") : (this.space(),
            this.token("=>"));
            this.space(),
            this.print(t.returnType, t)
        }
        ,
        r.FunctionTypeParam = function FunctionTypeParam(t) {
            this.print(t.name, t),
            t.optional && this.token("?");
            t.name && (this.token(":"),
            this.space());
            this.print(t.typeAnnotation, t)
        }
        ,
        r.IndexedAccessType = function IndexedAccessType(t) {
            this.print(t.objectType, t),
            this.token("["),
            this.print(t.indexType, t),
            this.token("]")
        }
        ,
        r.InferredPredicate = function InferredPredicate() {
            this.token("%"),
            this.word("checks")
        }
        ,
        r.InterfaceDeclaration = function InterfaceDeclaration(t) {
            this.word("interface"),
            this.space(),
            this._interfaceish(t)
        }
        ,
        r.GenericTypeAnnotation = r.ClassImplements = r.InterfaceExtends = function InterfaceExtends(t) {
            this.print(t.id, t),
            this.print(t.typeParameters, t)
        }
        ,
        r.InterfaceTypeAnnotation = function InterfaceTypeAnnotation(t) {
            this.word("interface"),
            t.extends && t.extends.length && (this.space(),
            this.word("extends"),
            this.space(),
            this.printList(t.extends, t));
            this.space(),
            this.print(t.body, t)
        }
        ,
        r.IntersectionTypeAnnotation = function IntersectionTypeAnnotation(t) {
            this.printJoin(t.types, t, {
                separator: andSeparator
            })
        }
        ,
        r.MixedTypeAnnotation = function MixedTypeAnnotation() {
            this.word("mixed")
        }
        ,
        r.NullLiteralTypeAnnotation = function NullLiteralTypeAnnotation() {
            this.word("null")
        }
        ,
        r.NullableTypeAnnotation = function NullableTypeAnnotation(t) {
            this.token("?"),
            this.print(t.typeAnnotation, t)
        }
        ,
        Object.defineProperty(r, "NumberLiteralTypeAnnotation", {
            enumerable: !0,
            get: function() {
                return l.NumericLiteral
            }
        }),
        r.NumberTypeAnnotation = function NumberTypeAnnotation() {
            this.word("number")
        }
        ,
        r.ObjectTypeAnnotation = function ObjectTypeAnnotation(t) {
            t.exact ? this.token("{|") : this.token("{");
            const r = [...t.properties, ...t.callProperties || [], ...t.indexers || [], ...t.internalSlots || []];
            r.length && (this.space(),
            this.printJoin(r, t, {
                addNewlines(t) {
                    if (t && !r[0])
                        return 1
                },
                indent: !0,
                statement: !0,
                iterator: ()=>{
                    (1 !== r.length || t.inexact) && (this.token(","),
                    this.space())
                }
            }),
            this.space());
            t.inexact && (this.indent(),
            this.token("..."),
            r.length && this.newline(),
            this.dedent());
            t.exact ? this.token("|}") : this.token("}")
        }
        ,
        r.ObjectTypeCallProperty = function ObjectTypeCallProperty(t) {
            t.static && (this.word("static"),
            this.space());
            this.print(t.value, t)
        }
        ,
        r.ObjectTypeIndexer = function ObjectTypeIndexer(t) {
            t.static && (this.word("static"),
            this.space());
            this._variance(t),
            this.token("["),
            t.id && (this.print(t.id, t),
            this.token(":"),
            this.space());
            this.print(t.key, t),
            this.token("]"),
            this.token(":"),
            this.space(),
            this.print(t.value, t)
        }
        ,
        r.ObjectTypeInternalSlot = function ObjectTypeInternalSlot(t) {
            t.static && (this.word("static"),
            this.space());
            this.token("["),
            this.token("["),
            this.print(t.id, t),
            this.token("]"),
            this.token("]"),
            t.optional && this.token("?");
            t.method || (this.token(":"),
            this.space());
            this.print(t.value, t)
        }
        ,
        r.ObjectTypeProperty = function ObjectTypeProperty(t) {
            t.proto && (this.word("proto"),
            this.space());
            t.static && (this.word("static"),
            this.space());
            "get" !== t.kind && "set" !== t.kind || (this.word(t.kind),
            this.space());
            this._variance(t),
            this.print(t.key, t),
            t.optional && this.token("?");
            t.method || (this.token(":"),
            this.space());
            this.print(t.value, t)
        }
        ,
        r.ObjectTypeSpreadProperty = function ObjectTypeSpreadProperty(t) {
            this.token("..."),
            this.print(t.argument, t)
        }
        ,
        r.OpaqueType = function OpaqueType(t) {
            this.word("opaque"),
            this.space(),
            this.word("type"),
            this.space(),
            this.print(t.id, t),
            this.print(t.typeParameters, t),
            t.supertype && (this.token(":"),
            this.space(),
            this.print(t.supertype, t));
            t.impltype && (this.space(),
            this.token("="),
            this.space(),
            this.print(t.impltype, t));
            this.semicolon()
        }
        ,
        r.OptionalIndexedAccessType = function OptionalIndexedAccessType(t) {
            this.print(t.objectType, t),
            t.optional && this.token("?.");
            this.token("["),
            this.print(t.indexType, t),
            this.token("]")
        }
        ,
        r.QualifiedTypeIdentifier = function QualifiedTypeIdentifier(t) {
            this.print(t.qualification, t),
            this.token("."),
            this.print(t.id, t)
        }
        ,
        Object.defineProperty(r, "StringLiteralTypeAnnotation", {
            enumerable: !0,
            get: function() {
                return l.StringLiteral
            }
        }),
        r.StringTypeAnnotation = function StringTypeAnnotation() {
            this.word("string")
        }
        ,
        r.SymbolTypeAnnotation = function SymbolTypeAnnotation() {
            this.word("symbol")
        }
        ,
        r.ThisTypeAnnotation = function ThisTypeAnnotation() {
            this.word("this")
        }
        ,
        r.TupleTypeAnnotation = function TupleTypeAnnotation(t) {
            this.token("["),
            this.printList(t.types, t),
            this.token("]")
        }
        ,
        r.TypeAlias = function TypeAlias(t) {
            this.word("type"),
            this.space(),
            this.print(t.id, t),
            this.print(t.typeParameters, t),
            this.space(),
            this.token("="),
            this.space(),
            this.print(t.right, t),
            this.semicolon()
        }
        ,
        r.TypeAnnotation = function TypeAnnotation(t) {
            this.token(":"),
            this.space(),
            t.optional && this.token("?");
            this.print(t.typeAnnotation, t)
        }
        ,
        r.TypeCastExpression = function TypeCastExpression(t) {
            this.token("("),
            this.print(t.expression, t),
            this.print(t.typeAnnotation, t),
            this.token(")")
        }
        ,
        r.TypeParameter = function TypeParameter(t) {
            this._variance(t),
            this.word(t.name),
            t.bound && this.print(t.bound, t);
            t.default && (this.space(),
            this.token("="),
            this.space(),
            this.print(t.default, t))
        }
        ,
        r.TypeParameterDeclaration = r.TypeParameterInstantiation = function TypeParameterInstantiation(t) {
            this.token("<"),
            this.printList(t.params, t, {}),
            this.token(">")
        }
        ,
        r.TypeofTypeAnnotation = function TypeofTypeAnnotation(t) {
            this.word("typeof"),
            this.space(),
            this.print(t.argument, t)
        }
        ,
        r.UnionTypeAnnotation = function UnionTypeAnnotation(t) {
            this.printJoin(t.types, t, {
                separator: orSeparator
            })
        }
        ,
        r.Variance = function Variance(t) {
            "plus" === t.kind ? this.token("+") : this.token("-")
        }
        ,
        r.VoidTypeAnnotation = function VoidTypeAnnotation() {
            this.word("void")
        }
        ,
        r._interfaceish = function _interfaceish(t) {
            var r;
            this.print(t.id, t),
            this.print(t.typeParameters, t),
            null != (r = t.extends) && r.length && (this.space(),
            this.word("extends"),
            this.space(),
            this.printList(t.extends, t));
            t.mixins && t.mixins.length && (this.space(),
            this.word("mixins"),
            this.space(),
            this.printList(t.mixins, t));
            t.implements && t.implements.length && (this.space(),
            this.word("implements"),
            this.space(),
            this.printList(t.implements, t));
            this.space(),
            this.print(t.body, t)
        }
        ,
        r._variance = function _variance(t) {
            t.variance && ("plus" === t.variance.kind ? this.token("+") : "minus" === t.variance.kind && this.token("-"))
        }
        ;
        var a = i("JSq2")
          , o = i("Ns23")
          , l = i("0GJC");
        const {isDeclareExportDeclaration: u, isStatement: p} = a;
        function enumExplicitType(t, r, i) {
            i && (t.space(),
            t.word("of"),
            t.space(),
            t.word(r)),
            t.space()
        }
        function enumBody(t, r) {
            const {members: i} = r;
            t.token("{"),
            t.indent(),
            t.newline();
            for (const a of i)
                t.print(a, r),
                t.newline();
            r.hasUnknownMembers && (t.token("..."),
            t.newline()),
            t.dedent(),
            t.token("}")
        }
        function enumInitializedMember(t, r) {
            const {id: i, init: a} = r;
            t.print(i, r),
            t.space(),
            t.token("="),
            t.space(),
            t.print(a, r),
            t.token(",")
        }
        function FlowExportDeclaration(t) {
            if (t.declaration) {
                const r = t.declaration;
                this.print(r, t),
                p(r) || this.semicolon()
            } else
                this.token("{"),
                t.specifiers.length && (this.space(),
                this.printList(t.specifiers, t),
                this.space()),
                this.token("}"),
                t.source && (this.space(),
                this.word("from"),
                this.space(),
                this.print(t.source, t)),
                this.semicolon()
        }
        function andSeparator() {
            this.space(),
            this.token("&"),
            this.space()
        }
        function orSeparator() {
            this.space(),
            this.token("|"),
            this.space()
        }
    },
    tXCm: function(t, r, i) {
        var a = i("ub0H")
          , o = i("Z1lV")
          , l = i("kkH2").ArraySet
          , u = i("DW02")
          , p = i("ap7b").quickSort;
        function SourceMapConsumer(t) {
            var r = t;
            return "string" == typeof t && (r = JSON.parse(t.replace(/^\)\]\}'/, ""))),
            null != r.sections ? new IndexedSourceMapConsumer(r) : new BasicSourceMapConsumer(r)
        }
        function BasicSourceMapConsumer(t) {
            var r = t;
            "string" == typeof t && (r = JSON.parse(t.replace(/^\)\]\}'/, "")));
            var i = a.getArg(r, "version")
              , o = a.getArg(r, "sources")
              , u = a.getArg(r, "names", [])
              , p = a.getArg(r, "sourceRoot", null)
              , c = a.getArg(r, "sourcesContent", null)
              , d = a.getArg(r, "mappings")
              , y = a.getArg(r, "file", null);
            if (i != this._version)
                throw new Error("Unsupported version: " + i);
            o = o.map(String).map(a.normalize).map((function(t) {
                return p && a.isAbsolute(p) && a.isAbsolute(t) ? a.relative(p, t) : t
            }
            )),
            this._names = l.fromArray(u.map(String), !0),
            this._sources = l.fromArray(o, !0),
            this.sourceRoot = p,
            this.sourcesContent = c,
            this._mappings = d,
            this.file = y
        }
        function Mapping() {
            this.generatedLine = 0,
            this.generatedColumn = 0,
            this.source = null,
            this.originalLine = null,
            this.originalColumn = null,
            this.name = null
        }
        function IndexedSourceMapConsumer(t) {
            var r = t;
            "string" == typeof t && (r = JSON.parse(t.replace(/^\)\]\}'/, "")));
            var i = a.getArg(r, "version")
              , o = a.getArg(r, "sections");
            if (i != this._version)
                throw new Error("Unsupported version: " + i);
            this._sources = new l,
            this._names = new l;
            var u = {
                line: -1,
                column: 0
            };
            this._sections = o.map((function(t) {
                if (t.url)
                    throw new Error("Support for url field in sections not implemented.");
                var r = a.getArg(t, "offset")
                  , i = a.getArg(r, "line")
                  , o = a.getArg(r, "column");
                if (i < u.line || i === u.line && o < u.column)
                    throw new Error("Section offsets must be ordered and non-overlapping.");
                return u = r,
                {
                    generatedOffset: {
                        generatedLine: i + 1,
                        generatedColumn: o + 1
                    },
                    consumer: new SourceMapConsumer(a.getArg(t, "map"))
                }
            }
            ))
        }
        SourceMapConsumer.fromSourceMap = function(t) {
            return BasicSourceMapConsumer.fromSourceMap(t)
        }
        ,
        SourceMapConsumer.prototype._version = 3,
        SourceMapConsumer.prototype.__generatedMappings = null,
        Object.defineProperty(SourceMapConsumer.prototype, "_generatedMappings", {
            get: function() {
                return this.__generatedMappings || this._parseMappings(this._mappings, this.sourceRoot),
                this.__generatedMappings
            }
        }),
        SourceMapConsumer.prototype.__originalMappings = null,
        Object.defineProperty(SourceMapConsumer.prototype, "_originalMappings", {
            get: function() {
                return this.__originalMappings || this._parseMappings(this._mappings, this.sourceRoot),
                this.__originalMappings
            }
        }),
        SourceMapConsumer.prototype._charIsMappingSeparator = function SourceMapConsumer_charIsMappingSeparator(t, r) {
            var i = t.charAt(r);
            return ";" === i || "," === i
        }
        ,
        SourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(t, r) {
            throw new Error("Subclasses must implement _parseMappings")
        }
        ,
        SourceMapConsumer.GENERATED_ORDER = 1,
        SourceMapConsumer.ORIGINAL_ORDER = 2,
        SourceMapConsumer.GREATEST_LOWER_BOUND = 1,
        SourceMapConsumer.LEAST_UPPER_BOUND = 2,
        SourceMapConsumer.prototype.eachMapping = function SourceMapConsumer_eachMapping(t, r, i) {
            var o, l = r || null;
            switch (i || SourceMapConsumer.GENERATED_ORDER) {
            case SourceMapConsumer.GENERATED_ORDER:
                o = this._generatedMappings;
                break;
            case SourceMapConsumer.ORIGINAL_ORDER:
                o = this._originalMappings;
                break;
            default:
                throw new Error("Unknown order of iteration.")
            }
            var u = this.sourceRoot;
            o.map((function(t) {
                var r = null === t.source ? null : this._sources.at(t.source);
                return null != r && null != u && (r = a.join(u, r)),
                {
                    source: r,
                    generatedLine: t.generatedLine,
                    generatedColumn: t.generatedColumn,
                    originalLine: t.originalLine,
                    originalColumn: t.originalColumn,
                    name: null === t.name ? null : this._names.at(t.name)
                }
            }
            ), this).forEach(t, l)
        }
        ,
        SourceMapConsumer.prototype.allGeneratedPositionsFor = function SourceMapConsumer_allGeneratedPositionsFor(t) {
            var r = a.getArg(t, "line")
              , i = {
                source: a.getArg(t, "source"),
                originalLine: r,
                originalColumn: a.getArg(t, "column", 0)
            };
            if (null != this.sourceRoot && (i.source = a.relative(this.sourceRoot, i.source)),
            !this._sources.has(i.source))
                return [];
            i.source = this._sources.indexOf(i.source);
            var l = []
              , u = this._findMapping(i, this._originalMappings, "originalLine", "originalColumn", a.compareByOriginalPositions, o.LEAST_UPPER_BOUND);
            if (u >= 0) {
                var p = this._originalMappings[u];
                if (void 0 === t.column)
                    for (var c = p.originalLine; p && p.originalLine === c; )
                        l.push({
                            line: a.getArg(p, "generatedLine", null),
                            column: a.getArg(p, "generatedColumn", null),
                            lastColumn: a.getArg(p, "lastGeneratedColumn", null)
                        }),
                        p = this._originalMappings[++u];
                else
                    for (var d = p.originalColumn; p && p.originalLine === r && p.originalColumn == d; )
                        l.push({
                            line: a.getArg(p, "generatedLine", null),
                            column: a.getArg(p, "generatedColumn", null),
                            lastColumn: a.getArg(p, "lastGeneratedColumn", null)
                        }),
                        p = this._originalMappings[++u]
            }
            return l
        }
        ,
        r.SourceMapConsumer = SourceMapConsumer,
        BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype),
        BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer,
        BasicSourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(t) {
            var r = Object.create(BasicSourceMapConsumer.prototype)
              , i = r._names = l.fromArray(t._names.toArray(), !0)
              , o = r._sources = l.fromArray(t._sources.toArray(), !0);
            r.sourceRoot = t._sourceRoot,
            r.sourcesContent = t._generateSourcesContent(r._sources.toArray(), r.sourceRoot),
            r.file = t._file;
            for (var u = t._mappings.toArray().slice(), c = r.__generatedMappings = [], d = r.__originalMappings = [], y = 0, h = u.length; y < h; y++) {
                var m = u[y]
                  , T = new Mapping;
                T.generatedLine = m.generatedLine,
                T.generatedColumn = m.generatedColumn,
                m.source && (T.source = o.indexOf(m.source),
                T.originalLine = m.originalLine,
                T.originalColumn = m.originalColumn,
                m.name && (T.name = i.indexOf(m.name)),
                d.push(T)),
                c.push(T)
            }
            return p(r.__originalMappings, a.compareByOriginalPositions),
            r
        }
        ,
        BasicSourceMapConsumer.prototype._version = 3,
        Object.defineProperty(BasicSourceMapConsumer.prototype, "sources", {
            get: function() {
                return this._sources.toArray().map((function(t) {
                    return null != this.sourceRoot ? a.join(this.sourceRoot, t) : t
                }
                ), this)
            }
        }),
        BasicSourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(t, r) {
            for (var i, o, l, c, d, y = 1, h = 0, m = 0, T = 0, S = 0, g = 0, b = t.length, v = 0, E = {}, P = {}, x = [], A = []; v < b; )
                if (";" === t.charAt(v))
                    y++,
                    v++,
                    h = 0;
                else if ("," === t.charAt(v))
                    v++;
                else {
                    for ((i = new Mapping).generatedLine = y,
                    c = v; c < b && !this._charIsMappingSeparator(t, c); c++)
                        ;
                    if (l = E[o = t.slice(v, c)])
                        v += o.length;
                    else {
                        for (l = []; v < c; )
                            u.decode(t, v, P),
                            d = P.value,
                            v = P.rest,
                            l.push(d);
                        if (2 === l.length)
                            throw new Error("Found a source, but no line and column");
                        if (3 === l.length)
                            throw new Error("Found a source and line, but no column");
                        E[o] = l
                    }
                    i.generatedColumn = h + l[0],
                    h = i.generatedColumn,
                    l.length > 1 && (i.source = S + l[1],
                    S += l[1],
                    i.originalLine = m + l[2],
                    m = i.originalLine,
                    i.originalLine += 1,
                    i.originalColumn = T + l[3],
                    T = i.originalColumn,
                    l.length > 4 && (i.name = g + l[4],
                    g += l[4])),
                    A.push(i),
                    "number" == typeof i.originalLine && x.push(i)
                }
            p(A, a.compareByGeneratedPositionsDeflated),
            this.__generatedMappings = A,
            p(x, a.compareByOriginalPositions),
            this.__originalMappings = x
        }
        ,
        BasicSourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(t, r, i, a, l, u) {
            if (t[i] <= 0)
                throw new TypeError("Line must be greater than or equal to 1, got " + t[i]);
            if (t[a] < 0)
                throw new TypeError("Column must be greater than or equal to 0, got " + t[a]);
            return o.search(t, r, l, u)
        }
        ,
        BasicSourceMapConsumer.prototype.computeColumnSpans = function SourceMapConsumer_computeColumnSpans() {
            for (var t = 0; t < this._generatedMappings.length; ++t) {
                var r = this._generatedMappings[t];
                if (t + 1 < this._generatedMappings.length) {
                    var i = this._generatedMappings[t + 1];
                    if (r.generatedLine === i.generatedLine) {
                        r.lastGeneratedColumn = i.generatedColumn - 1;
                        continue
                    }
                }
                r.lastGeneratedColumn = 1 / 0
            }
        }
        ,
        BasicSourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(t) {
            var r = {
                generatedLine: a.getArg(t, "line"),
                generatedColumn: a.getArg(t, "column")
            }
              , i = this._findMapping(r, this._generatedMappings, "generatedLine", "generatedColumn", a.compareByGeneratedPositionsDeflated, a.getArg(t, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND));
            if (i >= 0) {
                var o = this._generatedMappings[i];
                if (o.generatedLine === r.generatedLine) {
                    var l = a.getArg(o, "source", null);
                    null !== l && (l = this._sources.at(l),
                    null != this.sourceRoot && (l = a.join(this.sourceRoot, l)));
                    var u = a.getArg(o, "name", null);
                    return null !== u && (u = this._names.at(u)),
                    {
                        source: l,
                        line: a.getArg(o, "originalLine", null),
                        column: a.getArg(o, "originalColumn", null),
                        name: u
                    }
                }
            }
            return {
                source: null,
                line: null,
                column: null,
                name: null
            }
        }
        ,
        BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function BasicSourceMapConsumer_hasContentsOfAllSources() {
            return !!this.sourcesContent && (this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some((function(t) {
                return null == t
            }
            )))
        }
        ,
        BasicSourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(t, r) {
            if (!this.sourcesContent)
                return null;
            if (null != this.sourceRoot && (t = a.relative(this.sourceRoot, t)),
            this._sources.has(t))
                return this.sourcesContent[this._sources.indexOf(t)];
            var i;
            if (null != this.sourceRoot && (i = a.urlParse(this.sourceRoot))) {
                var o = t.replace(/^file:\/\//, "");
                if ("file" == i.scheme && this._sources.has(o))
                    return this.sourcesContent[this._sources.indexOf(o)];
                if ((!i.path || "/" == i.path) && this._sources.has("/" + t))
                    return this.sourcesContent[this._sources.indexOf("/" + t)]
            }
            if (r)
                return null;
            throw new Error('"' + t + '" is not in the SourceMap.')
        }
        ,
        BasicSourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(t) {
            var r = a.getArg(t, "source");
            if (null != this.sourceRoot && (r = a.relative(this.sourceRoot, r)),
            !this._sources.has(r))
                return {
                    line: null,
                    column: null,
                    lastColumn: null
                };
            var i = {
                source: r = this._sources.indexOf(r),
                originalLine: a.getArg(t, "line"),
                originalColumn: a.getArg(t, "column")
            }
              , o = this._findMapping(i, this._originalMappings, "originalLine", "originalColumn", a.compareByOriginalPositions, a.getArg(t, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND));
            if (o >= 0) {
                var l = this._originalMappings[o];
                if (l.source === i.source)
                    return {
                        line: a.getArg(l, "generatedLine", null),
                        column: a.getArg(l, "generatedColumn", null),
                        lastColumn: a.getArg(l, "lastGeneratedColumn", null)
                    }
            }
            return {
                line: null,
                column: null,
                lastColumn: null
            }
        }
        ,
        r.BasicSourceMapConsumer = BasicSourceMapConsumer,
        IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype),
        IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer,
        IndexedSourceMapConsumer.prototype._version = 3,
        Object.defineProperty(IndexedSourceMapConsumer.prototype, "sources", {
            get: function() {
                for (var t = [], r = 0; r < this._sections.length; r++)
                    for (var i = 0; i < this._sections[r].consumer.sources.length; i++)
                        t.push(this._sections[r].consumer.sources[i]);
                return t
            }
        }),
        IndexedSourceMapConsumer.prototype.originalPositionFor = function IndexedSourceMapConsumer_originalPositionFor(t) {
            var r = {
                generatedLine: a.getArg(t, "line"),
                generatedColumn: a.getArg(t, "column")
            }
              , i = o.search(r, this._sections, (function(t, r) {
                var i = t.generatedLine - r.generatedOffset.generatedLine;
                return i || t.generatedColumn - r.generatedOffset.generatedColumn
            }
            ))
              , l = this._sections[i];
            return l ? l.consumer.originalPositionFor({
                line: r.generatedLine - (l.generatedOffset.generatedLine - 1),
                column: r.generatedColumn - (l.generatedOffset.generatedLine === r.generatedLine ? l.generatedOffset.generatedColumn - 1 : 0),
                bias: t.bias
            }) : {
                source: null,
                line: null,
                column: null,
                name: null
            }
        }
        ,
        IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function IndexedSourceMapConsumer_hasContentsOfAllSources() {
            return this._sections.every((function(t) {
                return t.consumer.hasContentsOfAllSources()
            }
            ))
        }
        ,
        IndexedSourceMapConsumer.prototype.sourceContentFor = function IndexedSourceMapConsumer_sourceContentFor(t, r) {
            for (var i = 0; i < this._sections.length; i++) {
                var a = this._sections[i].consumer.sourceContentFor(t, !0);
                if (a)
                    return a
            }
            if (r)
                return null;
            throw new Error('"' + t + '" is not in the SourceMap.')
        }
        ,
        IndexedSourceMapConsumer.prototype.generatedPositionFor = function IndexedSourceMapConsumer_generatedPositionFor(t) {
            for (var r = 0; r < this._sections.length; r++) {
                var i = this._sections[r];
                if (-1 !== i.consumer.sources.indexOf(a.getArg(t, "source"))) {
                    var o = i.consumer.generatedPositionFor(t);
                    if (o)
                        return {
                            line: o.line + (i.generatedOffset.generatedLine - 1),
                            column: o.column + (i.generatedOffset.generatedLine === o.line ? i.generatedOffset.generatedColumn - 1 : 0)
                        }
                }
            }
            return {
                line: null,
                column: null
            }
        }
        ,
        IndexedSourceMapConsumer.prototype._parseMappings = function IndexedSourceMapConsumer_parseMappings(t, r) {
            this.__generatedMappings = [],
            this.__originalMappings = [];
            for (var i = 0; i < this._sections.length; i++)
                for (var o = this._sections[i], l = o.consumer._generatedMappings, u = 0; u < l.length; u++) {
                    var c = l[u]
                      , d = o.consumer._sources.at(c.source);
                    null !== o.consumer.sourceRoot && (d = a.join(o.consumer.sourceRoot, d)),
                    this._sources.add(d),
                    d = this._sources.indexOf(d);
                    var y = o.consumer._names.at(c.name);
                    this._names.add(y),
                    y = this._names.indexOf(y);
                    var h = {
                        source: d,
                        generatedLine: c.generatedLine + (o.generatedOffset.generatedLine - 1),
                        generatedColumn: c.generatedColumn + (o.generatedOffset.generatedLine === c.generatedLine ? o.generatedOffset.generatedColumn - 1 : 0),
                        originalLine: c.originalLine,
                        originalColumn: c.originalColumn,
                        name: y
                    };
                    this.__generatedMappings.push(h),
                    "number" == typeof h.originalLine && this.__originalMappings.push(h)
                }
            p(this.__generatedMappings, a.compareByGeneratedPositionsDeflated),
            p(this.__originalMappings, a.compareByOriginalPositions)
        }
        ,
        r.IndexedSourceMapConsumer = IndexedSourceMapConsumer
    },
    tZ1K: function(t, r, i) {
        "use strict";
        (function(r) {
            var i = {}
              , a = i.hasOwnProperty
              , o = function forOwn(t, r) {
                for (var i in t)
                    a.call(t, i) && r(i, t[i])
            }
              , l = i.toString
              , u = Array.isArray
              , p = r.isBuffer
              , c = {
                '"': '\\"',
                "'": "\\'",
                "\\": "\\\\",
                "\b": "\\b",
                "\f": "\\f",
                "\n": "\\n",
                "\r": "\\r",
                "\t": "\\t"
            }
              , d = /["'\\\b\f\n\r\t]/
              , y = /[0-9]/
              , h = /[ !#-&\(-\[\]-_a-~]/
              , m = function jsesc(t, r) {
                var i = function increaseIndentation() {
                    E = v,
                    ++r.indentLevel,
                    v = r.indent.repeat(r.indentLevel)
                }
                  , a = {
                    escapeEverything: !1,
                    minimal: !1,
                    isScriptContext: !1,
                    quotes: "single",
                    wrap: !1,
                    es6: !1,
                    json: !1,
                    compact: !0,
                    lowercaseHex: !1,
                    numbers: "decimal",
                    indent: "\t",
                    indentLevel: 0,
                    __inline1__: !1,
                    __inline2__: !1
                }
                  , m = r && r.json;
                m && (a.quotes = "double",
                a.wrap = !0),
                "single" != (r = function extend(t, r) {
                    return r ? (o(r, (function(r, i) {
                        t[r] = i
                    }
                    )),
                    t) : t
                }(a, r)).quotes && "double" != r.quotes && "backtick" != r.quotes && (r.quotes = "single");
                var T, S = "double" == r.quotes ? '"' : "backtick" == r.quotes ? "`" : "'", g = r.compact, b = r.lowercaseHex, v = r.indent.repeat(r.indentLevel), E = "", P = r.__inline1__, x = r.__inline2__, A = g ? "" : "\n", O = !0, I = "binary" == r.numbers, w = "octal" == r.numbers, C = "decimal" == r.numbers, N = "hexadecimal" == r.numbers;
                if (m && t && function isFunction(t) {
                    return "function" == typeof t
                }(t.toJSON) && (t = t.toJSON()),
                !function isString(t) {
                    return "string" == typeof t || "[object String]" == l.call(t)
                }(t)) {
                    if (function isMap(t) {
                        return "[object Map]" == l.call(t)
                    }(t))
                        return 0 == t.size ? "new Map()" : (g || (r.__inline1__ = !0,
                        r.__inline2__ = !1),
                        "new Map(" + jsesc(Array.from(t), r) + ")");
                    if (function isSet(t) {
                        return "[object Set]" == l.call(t)
                    }(t))
                        return 0 == t.size ? "new Set()" : "new Set(" + jsesc(Array.from(t), r) + ")";
                    if (p(t))
                        return 0 == t.length ? "Buffer.from([])" : "Buffer.from(" + jsesc(Array.from(t), r) + ")";
                    if (u(t))
                        return T = [],
                        r.wrap = !0,
                        P && (r.__inline1__ = !1,
                        r.__inline2__ = !0),
                        x || i(),
                        function forEach(t, r) {
                            for (var i = t.length, a = -1; ++a < i; )
                                r(t[a])
                        }(t, (function(t) {
                            O = !1,
                            x && (r.__inline2__ = !1),
                            T.push((g || x ? "" : v) + jsesc(t, r))
                        }
                        )),
                        O ? "[]" : x ? "[" + T.join(", ") + "]" : "[" + A + T.join("," + A) + A + (g ? "" : E) + "]";
                    if (!function isNumber(t) {
                        return "number" == typeof t || "[object Number]" == l.call(t)
                    }(t))
                        return function isObject(t) {
                            return "[object Object]" == l.call(t)
                        }(t) ? (T = [],
                        r.wrap = !0,
                        i(),
                        o(t, (function(t, i) {
                            O = !1,
                            T.push((g ? "" : v) + jsesc(t, r) + ":" + (g ? "" : " ") + jsesc(i, r))
                        }
                        )),
                        O ? "{}" : "{" + A + T.join("," + A) + A + (g ? "" : E) + "}") : m ? JSON.stringify(t) || "null" : String(t);
                    if (m)
                        return JSON.stringify(t);
                    if (C)
                        return String(t);
                    if (N) {
                        var D = t.toString(16);
                        return b || (D = D.toUpperCase()),
                        "0x" + D
                    }
                    if (I)
                        return "0b" + t.toString(2);
                    if (w)
                        return "0o" + t.toString(8)
                }
                var _ = t
                  , L = -1
                  , k = _.length;
                for (T = ""; ++L < k; ) {
                    var M = _.charAt(L);
                    if (r.es6) {
                        var j = _.charCodeAt(L);
                        if (j >= 55296 && j <= 56319 && k > L + 1) {
                            var B = _.charCodeAt(L + 1);
                            if (B >= 56320 && B <= 57343) {
                                var R = (1024 * (j - 55296) + B - 56320 + 65536).toString(16);
                                b || (R = R.toUpperCase()),
                                T += "\\u{" + R + "}",
                                ++L;
                                continue
                            }
                        }
                    }
                    if (!r.escapeEverything) {
                        if (h.test(M)) {
                            T += M;
                            continue
                        }
                        if ('"' == M) {
                            T += S == M ? '\\"' : M;
                            continue
                        }
                        if ("`" == M) {
                            T += S == M ? "\\`" : M;
                            continue
                        }
                        if ("'" == M) {
                            T += S == M ? "\\'" : M;
                            continue
                        }
                    }
                    if ("\0" != M || m || y.test(_.charAt(L + 1)))
                        if (d.test(M))
                            T += c[M];
                        else {
                            var K = M.charCodeAt(0);
                            if (r.minimal && 8232 != K && 8233 != K)
                                T += M;
                            else {
                                var V = K.toString(16);
                                b || (V = V.toUpperCase());
                                var U = V.length > 2 || m
                                  , Y = "\\" + (U ? "u" : "x") + ("0000" + V).slice(U ? -4 : -2);
                                T += Y
                            }
                        }
                    else
                        T += "\\0"
                }
                return r.wrap && (T = S + T + S),
                "`" == S && (T = T.replace(/\$\{/g, "\\${")),
                r.isScriptContext ? T.replace(/<\/(script|style)/gi, "<\\/$1").replace(/<!--/g, m ? "\\u003C!--" : "\\x3C!--") : T
            };
            m.version = "2.5.2",
            t.exports = m
        }
        ).call(this, i("tjlA").Buffer)
    },
    tjlA: function(t, r, i) {
        "use strict";
        (function(t) {
            var a = i("H7XF")
              , o = i("kVK+")
              , l = i("49sm");
            function kMaxLength() {
                return Buffer.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823
            }
            function createBuffer(t, r) {
                if (kMaxLength() < r)
                    throw new RangeError("Invalid typed array length");
                return Buffer.TYPED_ARRAY_SUPPORT ? (t = new Uint8Array(r)).__proto__ = Buffer.prototype : (null === t && (t = new Buffer(r)),
                t.length = r),
                t
            }
            function Buffer(t, r, i) {
                if (!(Buffer.TYPED_ARRAY_SUPPORT || this instanceof Buffer))
                    return new Buffer(t,r,i);
                if ("number" == typeof t) {
                    if ("string" == typeof r)
                        throw new Error("If encoding is specified then the first argument must be a string");
                    return allocUnsafe(this, t)
                }
                return from(this, t, r, i)
            }
            function from(t, r, i, a) {
                if ("number" == typeof r)
                    throw new TypeError('"value" argument must not be a number');
                return "undefined" != typeof ArrayBuffer && r instanceof ArrayBuffer ? function fromArrayBuffer(t, r, i, a) {
                    if (r.byteLength,
                    i < 0 || r.byteLength < i)
                        throw new RangeError("'offset' is out of bounds");
                    if (r.byteLength < i + (a || 0))
                        throw new RangeError("'length' is out of bounds");
                    r = void 0 === i && void 0 === a ? new Uint8Array(r) : void 0 === a ? new Uint8Array(r,i) : new Uint8Array(r,i,a);
                    Buffer.TYPED_ARRAY_SUPPORT ? (t = r).__proto__ = Buffer.prototype : t = fromArrayLike(t, r);
                    return t
                }(t, r, i, a) : "string" == typeof r ? function fromString(t, r, i) {
                    "string" == typeof i && "" !== i || (i = "utf8");
                    if (!Buffer.isEncoding(i))
                        throw new TypeError('"encoding" must be a valid string encoding');
                    var a = 0 | byteLength(r, i)
                      , o = (t = createBuffer(t, a)).write(r, i);
                    o !== a && (t = t.slice(0, o));
                    return t
                }(t, r, i) : function fromObject(t, r) {
                    if (Buffer.isBuffer(r)) {
                        var i = 0 | checked(r.length);
                        return 0 === (t = createBuffer(t, i)).length || r.copy(t, 0, 0, i),
                        t
                    }
                    if (r) {
                        if ("undefined" != typeof ArrayBuffer && r.buffer instanceof ArrayBuffer || "length"in r)
                            return "number" != typeof r.length || function isnan(t) {
                                return t != t
                            }(r.length) ? createBuffer(t, 0) : fromArrayLike(t, r);
                        if ("Buffer" === r.type && l(r.data))
                            return fromArrayLike(t, r.data)
                    }
                    throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.")
                }(t, r)
            }
            function assertSize(t) {
                if ("number" != typeof t)
                    throw new TypeError('"size" argument must be a number');
                if (t < 0)
                    throw new RangeError('"size" argument must not be negative')
            }
            function allocUnsafe(t, r) {
                if (assertSize(r),
                t = createBuffer(t, r < 0 ? 0 : 0 | checked(r)),
                !Buffer.TYPED_ARRAY_SUPPORT)
                    for (var i = 0; i < r; ++i)
                        t[i] = 0;
                return t
            }
            function fromArrayLike(t, r) {
                var i = r.length < 0 ? 0 : 0 | checked(r.length);
                t = createBuffer(t, i);
                for (var a = 0; a < i; a += 1)
                    t[a] = 255 & r[a];
                return t
            }
            function checked(t) {
                if (t >= kMaxLength())
                    throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + kMaxLength().toString(16) + " bytes");
                return 0 | t
            }
            function byteLength(t, r) {
                if (Buffer.isBuffer(t))
                    return t.length;
                if ("undefined" != typeof ArrayBuffer && "function" == typeof ArrayBuffer.isView && (ArrayBuffer.isView(t) || t instanceof ArrayBuffer))
                    return t.byteLength;
                "string" != typeof t && (t = "" + t);
                var i = t.length;
                if (0 === i)
                    return 0;
                for (var a = !1; ; )
                    switch (r) {
                    case "ascii":
                    case "latin1":
                    case "binary":
                        return i;
                    case "utf8":
                    case "utf-8":
                    case void 0:
                        return utf8ToBytes(t).length;
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                        return 2 * i;
                    case "hex":
                        return i >>> 1;
                    case "base64":
                        return base64ToBytes(t).length;
                    default:
                        if (a)
                            return utf8ToBytes(t).length;
                        r = ("" + r).toLowerCase(),
                        a = !0
                    }
            }
            function slowToString(t, r, i) {
                var a = !1;
                if ((void 0 === r || r < 0) && (r = 0),
                r > this.length)
                    return "";
                if ((void 0 === i || i > this.length) && (i = this.length),
                i <= 0)
                    return "";
                if ((i >>>= 0) <= (r >>>= 0))
                    return "";
                for (t || (t = "utf8"); ; )
                    switch (t) {
                    case "hex":
                        return hexSlice(this, r, i);
                    case "utf8":
                    case "utf-8":
                        return utf8Slice(this, r, i);
                    case "ascii":
                        return asciiSlice(this, r, i);
                    case "latin1":
                    case "binary":
                        return latin1Slice(this, r, i);
                    case "base64":
                        return base64Slice(this, r, i);
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                        return utf16leSlice(this, r, i);
                    default:
                        if (a)
                            throw new TypeError("Unknown encoding: " + t);
                        t = (t + "").toLowerCase(),
                        a = !0
                    }
            }
            function swap(t, r, i) {
                var a = t[r];
                t[r] = t[i],
                t[i] = a
            }
            function bidirectionalIndexOf(t, r, i, a, o) {
                if (0 === t.length)
                    return -1;
                if ("string" == typeof i ? (a = i,
                i = 0) : i > 2147483647 ? i = 2147483647 : i < -2147483648 && (i = -2147483648),
                i = +i,
                isNaN(i) && (i = o ? 0 : t.length - 1),
                i < 0 && (i = t.length + i),
                i >= t.length) {
                    if (o)
                        return -1;
                    i = t.length - 1
                } else if (i < 0) {
                    if (!o)
                        return -1;
                    i = 0
                }
                if ("string" == typeof r && (r = Buffer.from(r, a)),
                Buffer.isBuffer(r))
                    return 0 === r.length ? -1 : arrayIndexOf(t, r, i, a, o);
                if ("number" == typeof r)
                    return r &= 255,
                    Buffer.TYPED_ARRAY_SUPPORT && "function" == typeof Uint8Array.prototype.indexOf ? o ? Uint8Array.prototype.indexOf.call(t, r, i) : Uint8Array.prototype.lastIndexOf.call(t, r, i) : arrayIndexOf(t, [r], i, a, o);
                throw new TypeError("val must be string, number or Buffer")
            }
            function arrayIndexOf(t, r, i, a, o) {
                var l, u = 1, p = t.length, c = r.length;
                if (void 0 !== a && ("ucs2" === (a = String(a).toLowerCase()) || "ucs-2" === a || "utf16le" === a || "utf-16le" === a)) {
                    if (t.length < 2 || r.length < 2)
                        return -1;
                    u = 2,
                    p /= 2,
                    c /= 2,
                    i /= 2
                }
                function read(t, r) {
                    return 1 === u ? t[r] : t.readUInt16BE(r * u)
                }
                if (o) {
                    var d = -1;
                    for (l = i; l < p; l++)
                        if (read(t, l) === read(r, -1 === d ? 0 : l - d)) {
                            if (-1 === d && (d = l),
                            l - d + 1 === c)
                                return d * u
                        } else
                            -1 !== d && (l -= l - d),
                            d = -1
                } else
                    for (i + c > p && (i = p - c),
                    l = i; l >= 0; l--) {
                        for (var y = !0, h = 0; h < c; h++)
                            if (read(t, l + h) !== read(r, h)) {
                                y = !1;
                                break
                            }
                        if (y)
                            return l
                    }
                return -1
            }
            function hexWrite(t, r, i, a) {
                i = Number(i) || 0;
                var o = t.length - i;
                a ? (a = Number(a)) > o && (a = o) : a = o;
                var l = r.length;
                if (l % 2 != 0)
                    throw new TypeError("Invalid hex string");
                a > l / 2 && (a = l / 2);
                for (var u = 0; u < a; ++u) {
                    var p = parseInt(r.substr(2 * u, 2), 16);
                    if (isNaN(p))
                        return u;
                    t[i + u] = p
                }
                return u
            }
            function utf8Write(t, r, i, a) {
                return blitBuffer(utf8ToBytes(r, t.length - i), t, i, a)
            }
            function asciiWrite(t, r, i, a) {
                return blitBuffer(function asciiToBytes(t) {
                    for (var r = [], i = 0; i < t.length; ++i)
                        r.push(255 & t.charCodeAt(i));
                    return r
                }(r), t, i, a)
            }
            function latin1Write(t, r, i, a) {
                return asciiWrite(t, r, i, a)
            }
            function base64Write(t, r, i, a) {
                return blitBuffer(base64ToBytes(r), t, i, a)
            }
            function ucs2Write(t, r, i, a) {
                return blitBuffer(function utf16leToBytes(t, r) {
                    for (var i, a, o, l = [], u = 0; u < t.length && !((r -= 2) < 0); ++u)
                        i = t.charCodeAt(u),
                        a = i >> 8,
                        o = i % 256,
                        l.push(o),
                        l.push(a);
                    return l
                }(r, t.length - i), t, i, a)
            }
            function base64Slice(t, r, i) {
                return 0 === r && i === t.length ? a.fromByteArray(t) : a.fromByteArray(t.slice(r, i))
            }
            function utf8Slice(t, r, i) {
                i = Math.min(t.length, i);
                for (var a = [], o = r; o < i; ) {
                    var l, u, p, c, d = t[o], y = null, h = d > 239 ? 4 : d > 223 ? 3 : d > 191 ? 2 : 1;
                    if (o + h <= i)
                        switch (h) {
                        case 1:
                            d < 128 && (y = d);
                            break;
                        case 2:
                            128 == (192 & (l = t[o + 1])) && (c = (31 & d) << 6 | 63 & l) > 127 && (y = c);
                            break;
                        case 3:
                            l = t[o + 1],
                            u = t[o + 2],
                            128 == (192 & l) && 128 == (192 & u) && (c = (15 & d) << 12 | (63 & l) << 6 | 63 & u) > 2047 && (c < 55296 || c > 57343) && (y = c);
                            break;
                        case 4:
                            l = t[o + 1],
                            u = t[o + 2],
                            p = t[o + 3],
                            128 == (192 & l) && 128 == (192 & u) && 128 == (192 & p) && (c = (15 & d) << 18 | (63 & l) << 12 | (63 & u) << 6 | 63 & p) > 65535 && c < 1114112 && (y = c)
                        }
                    null === y ? (y = 65533,
                    h = 1) : y > 65535 && (y -= 65536,
                    a.push(y >>> 10 & 1023 | 55296),
                    y = 56320 | 1023 & y),
                    a.push(y),
                    o += h
                }
                return function decodeCodePointsArray(t) {
                    var r = t.length;
                    if (r <= 4096)
                        return String.fromCharCode.apply(String, t);
                    var i = ""
                      , a = 0;
                    for (; a < r; )
                        i += String.fromCharCode.apply(String, t.slice(a, a += 4096));
                    return i
                }(a)
            }
            r.Buffer = Buffer,
            r.SlowBuffer = function SlowBuffer(t) {
                +t != t && (t = 0);
                return Buffer.alloc(+t)
            }
            ,
            r.INSPECT_MAX_BYTES = 50,
            Buffer.TYPED_ARRAY_SUPPORT = void 0 !== t.TYPED_ARRAY_SUPPORT ? t.TYPED_ARRAY_SUPPORT : function typedArraySupport() {
                try {
                    var t = new Uint8Array(1);
                    return t.__proto__ = {
                        __proto__: Uint8Array.prototype,
                        foo: function() {
                            return 42
                        }
                    },
                    42 === t.foo() && "function" == typeof t.subarray && 0 === t.subarray(1, 1).byteLength
                } catch (t) {
                    return !1
                }
            }(),
            r.kMaxLength = kMaxLength(),
            Buffer.poolSize = 8192,
            Buffer._augment = function(t) {
                return t.__proto__ = Buffer.prototype,
                t
            }
            ,
            Buffer.from = function(t, r, i) {
                return from(null, t, r, i)
            }
            ,
            Buffer.TYPED_ARRAY_SUPPORT && (Buffer.prototype.__proto__ = Uint8Array.prototype,
            Buffer.__proto__ = Uint8Array,
            "undefined" != typeof Symbol && Symbol.species && Buffer[Symbol.species] === Buffer && Object.defineProperty(Buffer, Symbol.species, {
                value: null,
                configurable: !0
            })),
            Buffer.alloc = function(t, r, i) {
                return function alloc(t, r, i, a) {
                    return assertSize(r),
                    r <= 0 ? createBuffer(t, r) : void 0 !== i ? "string" == typeof a ? createBuffer(t, r).fill(i, a) : createBuffer(t, r).fill(i) : createBuffer(t, r)
                }(null, t, r, i)
            }
            ,
            Buffer.allocUnsafe = function(t) {
                return allocUnsafe(null, t)
            }
            ,
            Buffer.allocUnsafeSlow = function(t) {
                return allocUnsafe(null, t)
            }
            ,
            Buffer.isBuffer = function isBuffer(t) {
                return !(null == t || !t._isBuffer)
            }
            ,
            Buffer.compare = function compare(t, r) {
                if (!Buffer.isBuffer(t) || !Buffer.isBuffer(r))
                    throw new TypeError("Arguments must be Buffers");
                if (t === r)
                    return 0;
                for (var i = t.length, a = r.length, o = 0, l = Math.min(i, a); o < l; ++o)
                    if (t[o] !== r[o]) {
                        i = t[o],
                        a = r[o];
                        break
                    }
                return i < a ? -1 : a < i ? 1 : 0
            }
            ,
            Buffer.isEncoding = function isEncoding(t) {
                switch (String(t).toLowerCase()) {
                case "hex":
                case "utf8":
                case "utf-8":
                case "ascii":
                case "latin1":
                case "binary":
                case "base64":
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                    return !0;
                default:
                    return !1
                }
            }
            ,
            Buffer.concat = function concat(t, r) {
                if (!l(t))
                    throw new TypeError('"list" argument must be an Array of Buffers');
                if (0 === t.length)
                    return Buffer.alloc(0);
                var i;
                if (void 0 === r)
                    for (r = 0,
                    i = 0; i < t.length; ++i)
                        r += t[i].length;
                var a = Buffer.allocUnsafe(r)
                  , o = 0;
                for (i = 0; i < t.length; ++i) {
                    var u = t[i];
                    if (!Buffer.isBuffer(u))
                        throw new TypeError('"list" argument must be an Array of Buffers');
                    u.copy(a, o),
                    o += u.length
                }
                return a
            }
            ,
            Buffer.byteLength = byteLength,
            Buffer.prototype._isBuffer = !0,
            Buffer.prototype.swap16 = function swap16() {
                var t = this.length;
                if (t % 2 != 0)
                    throw new RangeError("Buffer size must be a multiple of 16-bits");
                for (var r = 0; r < t; r += 2)
                    swap(this, r, r + 1);
                return this
            }
            ,
            Buffer.prototype.swap32 = function swap32() {
                var t = this.length;
                if (t % 4 != 0)
                    throw new RangeError("Buffer size must be a multiple of 32-bits");
                for (var r = 0; r < t; r += 4)
                    swap(this, r, r + 3),
                    swap(this, r + 1, r + 2);
                return this
            }
            ,
            Buffer.prototype.swap64 = function swap64() {
                var t = this.length;
                if (t % 8 != 0)
                    throw new RangeError("Buffer size must be a multiple of 64-bits");
                for (var r = 0; r < t; r += 8)
                    swap(this, r, r + 7),
                    swap(this, r + 1, r + 6),
                    swap(this, r + 2, r + 5),
                    swap(this, r + 3, r + 4);
                return this
            }
            ,
            Buffer.prototype.toString = function toString() {
                var t = 0 | this.length;
                return 0 === t ? "" : 0 === arguments.length ? utf8Slice(this, 0, t) : slowToString.apply(this, arguments)
            }
            ,
            Buffer.prototype.equals = function equals(t) {
                if (!Buffer.isBuffer(t))
                    throw new TypeError("Argument must be a Buffer");
                return this === t || 0 === Buffer.compare(this, t)
            }
            ,
            Buffer.prototype.inspect = function inspect() {
                var t = ""
                  , i = r.INSPECT_MAX_BYTES;
                return this.length > 0 && (t = this.toString("hex", 0, i).match(/.{2}/g).join(" "),
                this.length > i && (t += " ... ")),
                "<Buffer " + t + ">"
            }
            ,
            Buffer.prototype.compare = function compare(t, r, i, a, o) {
                if (!Buffer.isBuffer(t))
                    throw new TypeError("Argument must be a Buffer");
                if (void 0 === r && (r = 0),
                void 0 === i && (i = t ? t.length : 0),
                void 0 === a && (a = 0),
                void 0 === o && (o = this.length),
                r < 0 || i > t.length || a < 0 || o > this.length)
                    throw new RangeError("out of range index");
                if (a >= o && r >= i)
                    return 0;
                if (a >= o)
                    return -1;
                if (r >= i)
                    return 1;
                if (this === t)
                    return 0;
                for (var l = (o >>>= 0) - (a >>>= 0), u = (i >>>= 0) - (r >>>= 0), p = Math.min(l, u), c = this.slice(a, o), d = t.slice(r, i), y = 0; y < p; ++y)
                    if (c[y] !== d[y]) {
                        l = c[y],
                        u = d[y];
                        break
                    }
                return l < u ? -1 : u < l ? 1 : 0
            }
            ,
            Buffer.prototype.includes = function includes(t, r, i) {
                return -1 !== this.indexOf(t, r, i)
            }
            ,
            Buffer.prototype.indexOf = function indexOf(t, r, i) {
                return bidirectionalIndexOf(this, t, r, i, !0)
            }
            ,
            Buffer.prototype.lastIndexOf = function lastIndexOf(t, r, i) {
                return bidirectionalIndexOf(this, t, r, i, !1)
            }
            ,
            Buffer.prototype.write = function write(t, r, i, a) {
                if (void 0 === r)
                    a = "utf8",
                    i = this.length,
                    r = 0;
                else if (void 0 === i && "string" == typeof r)
                    a = r,
                    i = this.length,
                    r = 0;
                else {
                    if (!isFinite(r))
                        throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
                    r |= 0,
                    isFinite(i) ? (i |= 0,
                    void 0 === a && (a = "utf8")) : (a = i,
                    i = void 0)
                }
                var o = this.length - r;
                if ((void 0 === i || i > o) && (i = o),
                t.length > 0 && (i < 0 || r < 0) || r > this.length)
                    throw new RangeError("Attempt to write outside buffer bounds");
                a || (a = "utf8");
                for (var l = !1; ; )
                    switch (a) {
                    case "hex":
                        return hexWrite(this, t, r, i);
                    case "utf8":
                    case "utf-8":
                        return utf8Write(this, t, r, i);
                    case "ascii":
                        return asciiWrite(this, t, r, i);
                    case "latin1":
                    case "binary":
                        return latin1Write(this, t, r, i);
                    case "base64":
                        return base64Write(this, t, r, i);
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                        return ucs2Write(this, t, r, i);
                    default:
                        if (l)
                            throw new TypeError("Unknown encoding: " + a);
                        a = ("" + a).toLowerCase(),
                        l = !0
                    }
            }
            ,
            Buffer.prototype.toJSON = function toJSON() {
                return {
                    type: "Buffer",
                    data: Array.prototype.slice.call(this._arr || this, 0)
                }
            }
            ;
            function asciiSlice(t, r, i) {
                var a = "";
                i = Math.min(t.length, i);
                for (var o = r; o < i; ++o)
                    a += String.fromCharCode(127 & t[o]);
                return a
            }
            function latin1Slice(t, r, i) {
                var a = "";
                i = Math.min(t.length, i);
                for (var o = r; o < i; ++o)
                    a += String.fromCharCode(t[o]);
                return a
            }
            function hexSlice(t, r, i) {
                var a = t.length;
                (!r || r < 0) && (r = 0),
                (!i || i < 0 || i > a) && (i = a);
                for (var o = "", l = r; l < i; ++l)
                    o += toHex(t[l]);
                return o
            }
            function utf16leSlice(t, r, i) {
                for (var a = t.slice(r, i), o = "", l = 0; l < a.length; l += 2)
                    o += String.fromCharCode(a[l] + 256 * a[l + 1]);
                return o
            }
            function checkOffset(t, r, i) {
                if (t % 1 != 0 || t < 0)
                    throw new RangeError("offset is not uint");
                if (t + r > i)
                    throw new RangeError("Trying to access beyond buffer length")
            }
            function checkInt(t, r, i, a, o, l) {
                if (!Buffer.isBuffer(t))
                    throw new TypeError('"buffer" argument must be a Buffer instance');
                if (r > o || r < l)
                    throw new RangeError('"value" argument is out of bounds');
                if (i + a > t.length)
                    throw new RangeError("Index out of range")
            }
            function objectWriteUInt16(t, r, i, a) {
                r < 0 && (r = 65535 + r + 1);
                for (var o = 0, l = Math.min(t.length - i, 2); o < l; ++o)
                    t[i + o] = (r & 255 << 8 * (a ? o : 1 - o)) >>> 8 * (a ? o : 1 - o)
            }
            function objectWriteUInt32(t, r, i, a) {
                r < 0 && (r = 4294967295 + r + 1);
                for (var o = 0, l = Math.min(t.length - i, 4); o < l; ++o)
                    t[i + o] = r >>> 8 * (a ? o : 3 - o) & 255
            }
            function checkIEEE754(t, r, i, a, o, l) {
                if (i + a > t.length)
                    throw new RangeError("Index out of range");
                if (i < 0)
                    throw new RangeError("Index out of range")
            }
            function writeFloat(t, r, i, a, l) {
                return l || checkIEEE754(t, 0, i, 4),
                o.write(t, r, i, a, 23, 4),
                i + 4
            }
            function writeDouble(t, r, i, a, l) {
                return l || checkIEEE754(t, 0, i, 8),
                o.write(t, r, i, a, 52, 8),
                i + 8
            }
            Buffer.prototype.slice = function slice(t, r) {
                var i, a = this.length;
                if ((t = ~~t) < 0 ? (t += a) < 0 && (t = 0) : t > a && (t = a),
                (r = void 0 === r ? a : ~~r) < 0 ? (r += a) < 0 && (r = 0) : r > a && (r = a),
                r < t && (r = t),
                Buffer.TYPED_ARRAY_SUPPORT)
                    (i = this.subarray(t, r)).__proto__ = Buffer.prototype;
                else {
                    var o = r - t;
                    i = new Buffer(o,void 0);
                    for (var l = 0; l < o; ++l)
                        i[l] = this[l + t]
                }
                return i
            }
            ,
            Buffer.prototype.readUIntLE = function readUIntLE(t, r, i) {
                t |= 0,
                r |= 0,
                i || checkOffset(t, r, this.length);
                for (var a = this[t], o = 1, l = 0; ++l < r && (o *= 256); )
                    a += this[t + l] * o;
                return a
            }
            ,
            Buffer.prototype.readUIntBE = function readUIntBE(t, r, i) {
                t |= 0,
                r |= 0,
                i || checkOffset(t, r, this.length);
                for (var a = this[t + --r], o = 1; r > 0 && (o *= 256); )
                    a += this[t + --r] * o;
                return a
            }
            ,
            Buffer.prototype.readUInt8 = function readUInt8(t, r) {
                return r || checkOffset(t, 1, this.length),
                this[t]
            }
            ,
            Buffer.prototype.readUInt16LE = function readUInt16LE(t, r) {
                return r || checkOffset(t, 2, this.length),
                this[t] | this[t + 1] << 8
            }
            ,
            Buffer.prototype.readUInt16BE = function readUInt16BE(t, r) {
                return r || checkOffset(t, 2, this.length),
                this[t] << 8 | this[t + 1]
            }
            ,
            Buffer.prototype.readUInt32LE = function readUInt32LE(t, r) {
                return r || checkOffset(t, 4, this.length),
                (this[t] | this[t + 1] << 8 | this[t + 2] << 16) + 16777216 * this[t + 3]
            }
            ,
            Buffer.prototype.readUInt32BE = function readUInt32BE(t, r) {
                return r || checkOffset(t, 4, this.length),
                16777216 * this[t] + (this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3])
            }
            ,
            Buffer.prototype.readIntLE = function readIntLE(t, r, i) {
                t |= 0,
                r |= 0,
                i || checkOffset(t, r, this.length);
                for (var a = this[t], o = 1, l = 0; ++l < r && (o *= 256); )
                    a += this[t + l] * o;
                return a >= (o *= 128) && (a -= Math.pow(2, 8 * r)),
                a
            }
            ,
            Buffer.prototype.readIntBE = function readIntBE(t, r, i) {
                t |= 0,
                r |= 0,
                i || checkOffset(t, r, this.length);
                for (var a = r, o = 1, l = this[t + --a]; a > 0 && (o *= 256); )
                    l += this[t + --a] * o;
                return l >= (o *= 128) && (l -= Math.pow(2, 8 * r)),
                l
            }
            ,
            Buffer.prototype.readInt8 = function readInt8(t, r) {
                return r || checkOffset(t, 1, this.length),
                128 & this[t] ? -1 * (255 - this[t] + 1) : this[t]
            }
            ,
            Buffer.prototype.readInt16LE = function readInt16LE(t, r) {
                r || checkOffset(t, 2, this.length);
                var i = this[t] | this[t + 1] << 8;
                return 32768 & i ? 4294901760 | i : i
            }
            ,
            Buffer.prototype.readInt16BE = function readInt16BE(t, r) {
                r || checkOffset(t, 2, this.length);
                var i = this[t + 1] | this[t] << 8;
                return 32768 & i ? 4294901760 | i : i
            }
            ,
            Buffer.prototype.readInt32LE = function readInt32LE(t, r) {
                return r || checkOffset(t, 4, this.length),
                this[t] | this[t + 1] << 8 | this[t + 2] << 16 | this[t + 3] << 24
            }
            ,
            Buffer.prototype.readInt32BE = function readInt32BE(t, r) {
                return r || checkOffset(t, 4, this.length),
                this[t] << 24 | this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3]
            }
            ,
            Buffer.prototype.readFloatLE = function readFloatLE(t, r) {
                return r || checkOffset(t, 4, this.length),
                o.read(this, t, !0, 23, 4)
            }
            ,
            Buffer.prototype.readFloatBE = function readFloatBE(t, r) {
                return r || checkOffset(t, 4, this.length),
                o.read(this, t, !1, 23, 4)
            }
            ,
            Buffer.prototype.readDoubleLE = function readDoubleLE(t, r) {
                return r || checkOffset(t, 8, this.length),
                o.read(this, t, !0, 52, 8)
            }
            ,
            Buffer.prototype.readDoubleBE = function readDoubleBE(t, r) {
                return r || checkOffset(t, 8, this.length),
                o.read(this, t, !1, 52, 8)
            }
            ,
            Buffer.prototype.writeUIntLE = function writeUIntLE(t, r, i, a) {
                (t = +t,
                r |= 0,
                i |= 0,
                a) || checkInt(this, t, r, i, Math.pow(2, 8 * i) - 1, 0);
                var o = 1
                  , l = 0;
                for (this[r] = 255 & t; ++l < i && (o *= 256); )
                    this[r + l] = t / o & 255;
                return r + i
            }
            ,
            Buffer.prototype.writeUIntBE = function writeUIntBE(t, r, i, a) {
                (t = +t,
                r |= 0,
                i |= 0,
                a) || checkInt(this, t, r, i, Math.pow(2, 8 * i) - 1, 0);
                var o = i - 1
                  , l = 1;
                for (this[r + o] = 255 & t; --o >= 0 && (l *= 256); )
                    this[r + o] = t / l & 255;
                return r + i
            }
            ,
            Buffer.prototype.writeUInt8 = function writeUInt8(t, r, i) {
                return t = +t,
                r |= 0,
                i || checkInt(this, t, r, 1, 255, 0),
                Buffer.TYPED_ARRAY_SUPPORT || (t = Math.floor(t)),
                this[r] = 255 & t,
                r + 1
            }
            ,
            Buffer.prototype.writeUInt16LE = function writeUInt16LE(t, r, i) {
                return t = +t,
                r |= 0,
                i || checkInt(this, t, r, 2, 65535, 0),
                Buffer.TYPED_ARRAY_SUPPORT ? (this[r] = 255 & t,
                this[r + 1] = t >>> 8) : objectWriteUInt16(this, t, r, !0),
                r + 2
            }
            ,
            Buffer.prototype.writeUInt16BE = function writeUInt16BE(t, r, i) {
                return t = +t,
                r |= 0,
                i || checkInt(this, t, r, 2, 65535, 0),
                Buffer.TYPED_ARRAY_SUPPORT ? (this[r] = t >>> 8,
                this[r + 1] = 255 & t) : objectWriteUInt16(this, t, r, !1),
                r + 2
            }
            ,
            Buffer.prototype.writeUInt32LE = function writeUInt32LE(t, r, i) {
                return t = +t,
                r |= 0,
                i || checkInt(this, t, r, 4, 4294967295, 0),
                Buffer.TYPED_ARRAY_SUPPORT ? (this[r + 3] = t >>> 24,
                this[r + 2] = t >>> 16,
                this[r + 1] = t >>> 8,
                this[r] = 255 & t) : objectWriteUInt32(this, t, r, !0),
                r + 4
            }
            ,
            Buffer.prototype.writeUInt32BE = function writeUInt32BE(t, r, i) {
                return t = +t,
                r |= 0,
                i || checkInt(this, t, r, 4, 4294967295, 0),
                Buffer.TYPED_ARRAY_SUPPORT ? (this[r] = t >>> 24,
                this[r + 1] = t >>> 16,
                this[r + 2] = t >>> 8,
                this[r + 3] = 255 & t) : objectWriteUInt32(this, t, r, !1),
                r + 4
            }
            ,
            Buffer.prototype.writeIntLE = function writeIntLE(t, r, i, a) {
                if (t = +t,
                r |= 0,
                !a) {
                    var o = Math.pow(2, 8 * i - 1);
                    checkInt(this, t, r, i, o - 1, -o)
                }
                var l = 0
                  , u = 1
                  , p = 0;
                for (this[r] = 255 & t; ++l < i && (u *= 256); )
                    t < 0 && 0 === p && 0 !== this[r + l - 1] && (p = 1),
                    this[r + l] = (t / u >> 0) - p & 255;
                return r + i
            }
            ,
            Buffer.prototype.writeIntBE = function writeIntBE(t, r, i, a) {
                if (t = +t,
                r |= 0,
                !a) {
                    var o = Math.pow(2, 8 * i - 1);
                    checkInt(this, t, r, i, o - 1, -o)
                }
                var l = i - 1
                  , u = 1
                  , p = 0;
                for (this[r + l] = 255 & t; --l >= 0 && (u *= 256); )
                    t < 0 && 0 === p && 0 !== this[r + l + 1] && (p = 1),
                    this[r + l] = (t / u >> 0) - p & 255;
                return r + i
            }
            ,
            Buffer.prototype.writeInt8 = function writeInt8(t, r, i) {
                return t = +t,
                r |= 0,
                i || checkInt(this, t, r, 1, 127, -128),
                Buffer.TYPED_ARRAY_SUPPORT || (t = Math.floor(t)),
                t < 0 && (t = 255 + t + 1),
                this[r] = 255 & t,
                r + 1
            }
            ,
            Buffer.prototype.writeInt16LE = function writeInt16LE(t, r, i) {
                return t = +t,
                r |= 0,
                i || checkInt(this, t, r, 2, 32767, -32768),
                Buffer.TYPED_ARRAY_SUPPORT ? (this[r] = 255 & t,
                this[r + 1] = t >>> 8) : objectWriteUInt16(this, t, r, !0),
                r + 2
            }
            ,
            Buffer.prototype.writeInt16BE = function writeInt16BE(t, r, i) {
                return t = +t,
                r |= 0,
                i || checkInt(this, t, r, 2, 32767, -32768),
                Buffer.TYPED_ARRAY_SUPPORT ? (this[r] = t >>> 8,
                this[r + 1] = 255 & t) : objectWriteUInt16(this, t, r, !1),
                r + 2
            }
            ,
            Buffer.prototype.writeInt32LE = function writeInt32LE(t, r, i) {
                return t = +t,
                r |= 0,
                i || checkInt(this, t, r, 4, 2147483647, -2147483648),
                Buffer.TYPED_ARRAY_SUPPORT ? (this[r] = 255 & t,
                this[r + 1] = t >>> 8,
                this[r + 2] = t >>> 16,
                this[r + 3] = t >>> 24) : objectWriteUInt32(this, t, r, !0),
                r + 4
            }
            ,
            Buffer.prototype.writeInt32BE = function writeInt32BE(t, r, i) {
                return t = +t,
                r |= 0,
                i || checkInt(this, t, r, 4, 2147483647, -2147483648),
                t < 0 && (t = 4294967295 + t + 1),
                Buffer.TYPED_ARRAY_SUPPORT ? (this[r] = t >>> 24,
                this[r + 1] = t >>> 16,
                this[r + 2] = t >>> 8,
                this[r + 3] = 255 & t) : objectWriteUInt32(this, t, r, !1),
                r + 4
            }
            ,
            Buffer.prototype.writeFloatLE = function writeFloatLE(t, r, i) {
                return writeFloat(this, t, r, !0, i)
            }
            ,
            Buffer.prototype.writeFloatBE = function writeFloatBE(t, r, i) {
                return writeFloat(this, t, r, !1, i)
            }
            ,
            Buffer.prototype.writeDoubleLE = function writeDoubleLE(t, r, i) {
                return writeDouble(this, t, r, !0, i)
            }
            ,
            Buffer.prototype.writeDoubleBE = function writeDoubleBE(t, r, i) {
                return writeDouble(this, t, r, !1, i)
            }
            ,
            Buffer.prototype.copy = function copy(t, r, i, a) {
                if (i || (i = 0),
                a || 0 === a || (a = this.length),
                r >= t.length && (r = t.length),
                r || (r = 0),
                a > 0 && a < i && (a = i),
                a === i)
                    return 0;
                if (0 === t.length || 0 === this.length)
                    return 0;
                if (r < 0)
                    throw new RangeError("targetStart out of bounds");
                if (i < 0 || i >= this.length)
                    throw new RangeError("sourceStart out of bounds");
                if (a < 0)
                    throw new RangeError("sourceEnd out of bounds");
                a > this.length && (a = this.length),
                t.length - r < a - i && (a = t.length - r + i);
                var o, l = a - i;
                if (this === t && i < r && r < a)
                    for (o = l - 1; o >= 0; --o)
                        t[o + r] = this[o + i];
                else if (l < 1e3 || !Buffer.TYPED_ARRAY_SUPPORT)
                    for (o = 0; o < l; ++o)
                        t[o + r] = this[o + i];
                else
                    Uint8Array.prototype.set.call(t, this.subarray(i, i + l), r);
                return l
            }
            ,
            Buffer.prototype.fill = function fill(t, r, i, a) {
                if ("string" == typeof t) {
                    if ("string" == typeof r ? (a = r,
                    r = 0,
                    i = this.length) : "string" == typeof i && (a = i,
                    i = this.length),
                    1 === t.length) {
                        var o = t.charCodeAt(0);
                        o < 256 && (t = o)
                    }
                    if (void 0 !== a && "string" != typeof a)
                        throw new TypeError("encoding must be a string");
                    if ("string" == typeof a && !Buffer.isEncoding(a))
                        throw new TypeError("Unknown encoding: " + a)
                } else
                    "number" == typeof t && (t &= 255);
                if (r < 0 || this.length < r || this.length < i)
                    throw new RangeError("Out of range index");
                if (i <= r)
                    return this;
                var l;
                if (r >>>= 0,
                i = void 0 === i ? this.length : i >>> 0,
                t || (t = 0),
                "number" == typeof t)
                    for (l = r; l < i; ++l)
                        this[l] = t;
                else {
                    var u = Buffer.isBuffer(t) ? t : utf8ToBytes(new Buffer(t,a).toString())
                      , p = u.length;
                    for (l = 0; l < i - r; ++l)
                        this[l + r] = u[l % p]
                }
                return this
            }
            ;
            var u = /[^+\/0-9A-Za-z-_]/g;
            function toHex(t) {
                return t < 16 ? "0" + t.toString(16) : t.toString(16)
            }
            function utf8ToBytes(t, r) {
                var i;
                r = r || 1 / 0;
                for (var a = t.length, o = null, l = [], u = 0; u < a; ++u) {
                    if ((i = t.charCodeAt(u)) > 55295 && i < 57344) {
                        if (!o) {
                            if (i > 56319) {
                                (r -= 3) > -1 && l.push(239, 191, 189);
                                continue
                            }
                            if (u + 1 === a) {
                                (r -= 3) > -1 && l.push(239, 191, 189);
                                continue
                            }
                            o = i;
                            continue
                        }
                        if (i < 56320) {
                            (r -= 3) > -1 && l.push(239, 191, 189),
                            o = i;
                            continue
                        }
                        i = 65536 + (o - 55296 << 10 | i - 56320)
                    } else
                        o && (r -= 3) > -1 && l.push(239, 191, 189);
                    if (o = null,
                    i < 128) {
                        if ((r -= 1) < 0)
                            break;
                        l.push(i)
                    } else if (i < 2048) {
                        if ((r -= 2) < 0)
                            break;
                        l.push(i >> 6 | 192, 63 & i | 128)
                    } else if (i < 65536) {
                        if ((r -= 3) < 0)
                            break;
                        l.push(i >> 12 | 224, i >> 6 & 63 | 128, 63 & i | 128)
                    } else {
                        if (!(i < 1114112))
                            throw new Error("Invalid code point");
                        if ((r -= 4) < 0)
                            break;
                        l.push(i >> 18 | 240, i >> 12 & 63 | 128, i >> 6 & 63 | 128, 63 & i | 128)
                    }
                }
                return l
            }
            function base64ToBytes(t) {
                return a.toByteArray(function base64clean(t) {
                    if ((t = function stringtrim(t) {
                        return t.trim ? t.trim() : t.replace(/^\s+|\s+$/g, "")
                    }(t).replace(u, "")).length < 2)
                        return "";
                    for (; t.length % 4 != 0; )
                        t += "=";
                    return t
                }(t))
            }
            function blitBuffer(t, r, i, a) {
                for (var o = 0; o < a && !(o + i >= r.length || o >= t.length); ++o)
                    r[o + i] = t[o];
                return o
            }
        }
        ).call(this, i("yLpj"))
    },
    uDmM: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function inheritLeadingComments(t, r) {
            (0,
            a.default)("leadingComments", t, r)
        }
        ;
        var a = i("Df4y")
    },
    uQT7: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.TaggedTemplateExpression = function TaggedTemplateExpression(t) {
            this.print(t.tag, t),
            this.print(t.typeParameters, t),
            this.print(t.quasi, t)
        }
        ,
        r.TemplateElement = function TemplateElement(t, r) {
            const i = r.quasis[0] === t
              , a = r.quasis[r.quasis.length - 1] === t
              , o = (i ? "`" : "}") + t.value.raw + (a ? "`" : "${");
            this.token(o)
        }
        ,
        r.TemplateLiteral = function TemplateLiteral(t) {
            const r = t.quasis;
            for (let i = 0; i < r.length; i++)
                this.print(r[i], t),
                i + 1 < r.length && this.print(t.expressions[i], t)
        }
    },
    uXiX: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        Object.defineProperty(r, "ALIAS_KEYS", {
            enumerable: !0,
            get: function() {
                return o.ALIAS_KEYS
            }
        }),
        Object.defineProperty(r, "BUILDER_KEYS", {
            enumerable: !0,
            get: function() {
                return o.BUILDER_KEYS
            }
        }),
        Object.defineProperty(r, "DEPRECATED_KEYS", {
            enumerable: !0,
            get: function() {
                return o.DEPRECATED_KEYS
            }
        }),
        Object.defineProperty(r, "FLIPPED_ALIAS_KEYS", {
            enumerable: !0,
            get: function() {
                return o.FLIPPED_ALIAS_KEYS
            }
        }),
        Object.defineProperty(r, "NODE_FIELDS", {
            enumerable: !0,
            get: function() {
                return o.NODE_FIELDS
            }
        }),
        Object.defineProperty(r, "NODE_PARENT_VALIDATIONS", {
            enumerable: !0,
            get: function() {
                return o.NODE_PARENT_VALIDATIONS
            }
        }),
        Object.defineProperty(r, "PLACEHOLDERS", {
            enumerable: !0,
            get: function() {
                return l.PLACEHOLDERS
            }
        }),
        Object.defineProperty(r, "PLACEHOLDERS_ALIAS", {
            enumerable: !0,
            get: function() {
                return l.PLACEHOLDERS_ALIAS
            }
        }),
        Object.defineProperty(r, "PLACEHOLDERS_FLIPPED_ALIAS", {
            enumerable: !0,
            get: function() {
                return l.PLACEHOLDERS_FLIPPED_ALIAS
            }
        }),
        r.TYPES = void 0,
        Object.defineProperty(r, "VISITOR_KEYS", {
            enumerable: !0,
            get: function() {
                return o.VISITOR_KEYS
            }
        });
        var a = i("0ZK1");
        i("8o0k"),
        i("i2G0"),
        i("sqI+"),
        i("vqrH"),
        i("b25T"),
        i("Y7t6");
        var o = i("V97+")
          , l = i("z0QK");
        a(o.VISITOR_KEYS),
        a(o.ALIAS_KEYS),
        a(o.FLIPPED_ALIAS_KEYS),
        a(o.NODE_FIELDS),
        a(o.BUILDER_KEYS),
        a(o.DEPRECATED_KEYS),
        a(l.PLACEHOLDERS_ALIAS),
        a(l.PLACEHOLDERS_FLIPPED_ALIAS);
        const u = [].concat(Object.keys(o.VISITOR_KEYS), Object.keys(o.FLIPPED_ALIAS_KEYS), Object.keys(o.DEPRECATED_KEYS));
        r.TYPES = u
    },
    ub0H: function(t, r) {
        r.getArg = function getArg(t, r, i) {
            if (r in t)
                return t[r];
            if (3 === arguments.length)
                return i;
            throw new Error('"' + r + '" is a required argument.')
        }
        ;
        var i = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.]*)(?::(\d+))?(\S*)$/
          , a = /^data:.+\,.+$/;
        function urlParse(t) {
            var r = t.match(i);
            return r ? {
                scheme: r[1],
                auth: r[2],
                host: r[3],
                port: r[4],
                path: r[5]
            } : null
        }
        function urlGenerate(t) {
            var r = "";
            return t.scheme && (r += t.scheme + ":"),
            r += "//",
            t.auth && (r += t.auth + "@"),
            t.host && (r += t.host),
            t.port && (r += ":" + t.port),
            t.path && (r += t.path),
            r
        }
        function normalize(t) {
            var i = t
              , a = urlParse(t);
            if (a) {
                if (!a.path)
                    return t;
                i = a.path
            }
            for (var o, l = r.isAbsolute(i), u = i.split(/\/+/), p = 0, c = u.length - 1; c >= 0; c--)
                "." === (o = u[c]) ? u.splice(c, 1) : ".." === o ? p++ : p > 0 && ("" === o ? (u.splice(c + 1, p),
                p = 0) : (u.splice(c, 2),
                p--));
            return "" === (i = u.join("/")) && (i = l ? "/" : "."),
            a ? (a.path = i,
            urlGenerate(a)) : i
        }
        r.urlParse = urlParse,
        r.urlGenerate = urlGenerate,
        r.normalize = normalize,
        r.join = function join(t, r) {
            "" === t && (t = "."),
            "" === r && (r = ".");
            var i = urlParse(r)
              , o = urlParse(t);
            if (o && (t = o.path || "/"),
            i && !i.scheme)
                return o && (i.scheme = o.scheme),
                urlGenerate(i);
            if (i || r.match(a))
                return r;
            if (o && !o.host && !o.path)
                return o.host = r,
                urlGenerate(o);
            var l = "/" === r.charAt(0) ? r : normalize(t.replace(/\/+$/, "") + "/" + r);
            return o ? (o.path = l,
            urlGenerate(o)) : l
        }
        ,
        r.isAbsolute = function(t) {
            return "/" === t.charAt(0) || !!t.match(i)
        }
        ,
        r.relative = function relative(t, r) {
            "" === t && (t = "."),
            t = t.replace(/\/$/, "");
            for (var i = 0; 0 !== r.indexOf(t + "/"); ) {
                var a = t.lastIndexOf("/");
                if (a < 0)
                    return r;
                if ((t = t.slice(0, a)).match(/^([^\/]+:\/)?\/*$/))
                    return r;
                ++i
            }
            return Array(i + 1).join("../") + r.substr(t.length + 1)
        }
        ;
        var o = !("__proto__"in Object.create(null));
        function identity(t) {
            return t
        }
        function isProtoString(t) {
            if (!t)
                return !1;
            var r = t.length;
            if (r < 9)
                return !1;
            if (95 !== t.charCodeAt(r - 1) || 95 !== t.charCodeAt(r - 2) || 111 !== t.charCodeAt(r - 3) || 116 !== t.charCodeAt(r - 4) || 111 !== t.charCodeAt(r - 5) || 114 !== t.charCodeAt(r - 6) || 112 !== t.charCodeAt(r - 7) || 95 !== t.charCodeAt(r - 8) || 95 !== t.charCodeAt(r - 9))
                return !1;
            for (var i = r - 10; i >= 0; i--)
                if (36 !== t.charCodeAt(i))
                    return !1;
            return !0
        }
        function strcmp(t, r) {
            return t === r ? 0 : t > r ? 1 : -1
        }
        r.toSetString = o ? identity : function toSetString(t) {
            return isProtoString(t) ? "$" + t : t
        }
        ,
        r.fromSetString = o ? identity : function fromSetString(t) {
            return isProtoString(t) ? t.slice(1) : t
        }
        ,
        r.compareByOriginalPositions = function compareByOriginalPositions(t, r, i) {
            var a = t.source - r.source;
            return 0 !== a || 0 !== (a = t.originalLine - r.originalLine) || 0 !== (a = t.originalColumn - r.originalColumn) || i || 0 !== (a = t.generatedColumn - r.generatedColumn) || 0 !== (a = t.generatedLine - r.generatedLine) ? a : t.name - r.name
        }
        ,
        r.compareByGeneratedPositionsDeflated = function compareByGeneratedPositionsDeflated(t, r, i) {
            var a = t.generatedLine - r.generatedLine;
            return 0 !== a || 0 !== (a = t.generatedColumn - r.generatedColumn) || i || 0 !== (a = t.source - r.source) || 0 !== (a = t.originalLine - r.originalLine) || 0 !== (a = t.originalColumn - r.originalColumn) ? a : t.name - r.name
        }
        ,
        r.compareByGeneratedPositionsInflated = function compareByGeneratedPositionsInflated(t, r) {
            var i = t.generatedLine - r.generatedLine;
            return 0 !== i || 0 !== (i = t.generatedColumn - r.generatedColumn) || 0 !== (i = strcmp(t.source, r.source)) || 0 !== (i = t.originalLine - r.originalLine) || 0 !== (i = t.originalColumn - r.originalColumn) ? i : strcmp(t.name, r.name)
        }
    },
    ucPi: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function isValidIdentifier(t, r=!0) {
            if ("string" != typeof t)
                return !1;
            if (r && ((0,
            a.isKeyword)(t) || (0,
            a.isStrictReservedWord)(t, !0)))
                return !1;
            return (0,
            a.isIdentifierName)(t)
        }
        ;
        var a = i("A27I")
    },
    ud6b: function(t, r, i) {
        "use strict";
        function _createForOfIteratorHelper(t, r) {
            var i = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
            if (!i) {
                if (Array.isArray(t) || (i = function _unsupportedIterableToArray(t, r) {
                    if (!t)
                        return;
                    if ("string" == typeof t)
                        return _arrayLikeToArray(t, r);
                    var i = Object.prototype.toString.call(t).slice(8, -1);
                    "Object" === i && t.constructor && (i = t.constructor.name);
                    if ("Map" === i || "Set" === i)
                        return Array.from(t);
                    if ("Arguments" === i || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i))
                        return _arrayLikeToArray(t, r)
                }(t)) || r && t && "number" == typeof t.length) {
                    i && (t = i);
                    var a = 0
                      , o = function F() {};
                    return {
                        s: o,
                        n: function n() {
                            return a >= t.length ? {
                                done: !0
                            } : {
                                done: !1,
                                value: t[a++]
                            }
                        },
                        e: function e(t) {
                            throw t
                        },
                        f: o
                    }
                }
                throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
            }
            var l, u = !0, p = !1;
            return {
                s: function s() {
                    i = i.call(t)
                },
                n: function n() {
                    var t = i.next();
                    return u = t.done,
                    t
                },
                e: function e(t) {
                    p = !0,
                    l = t
                },
                f: function f() {
                    try {
                        u || null == i.return || i.return()
                    } finally {
                        if (p)
                            throw l
                    }
                }
            }
        }
        function _arrayLikeToArray(t, r) {
            (null == r || r > t.length) && (r = t.length);
            for (var i = 0, a = new Array(r); i < r; i++)
                a[i] = t[i];
            return a
        }
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function isType(t, r) {
            if (t === r)
                return !0;
            if (a.ALIAS_KEYS[r])
                return !1;
            var i = a.FLIPPED_ALIAS_KEYS[r];
            if (i) {
                if (i[0] === t)
                    return !0;
                var o, l = _createForOfIteratorHelper(i);
                try {
                    for (l.s(); !(o = l.n()).done; ) {
                        var u = o.value;
                        if (t === u)
                            return !0
                    }
                } catch (t) {
                    l.e(t)
                } finally {
                    l.f()
                }
            }
            return !1
        }
        ;
        var a = i("UHlb")
    },
    unU7: function(t, r, i) {},
    uqjE: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function prependToMemberExpression(t, r) {
            return t.object = (0,
            a.memberExpression)(r, t.object),
            t
        }
        ;
        var a = i("57mi")
    },
    "v+vk": function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = void 0;
        var a = i("oUnQ")
          , o = function getOuterBindingIdentifiers(t, r) {
            return (0,
            a.default)(t, r, !0)
        };
        r.default = o
    },
    v3TT: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function shallowEqual(t, r) {
            for (var i = Object.keys(r), a = 0, o = i; a < o.length; a++) {
                var l = o[a];
                if (t[l] !== r[l])
                    return !1
            }
            return !0
        }
    },
    v3g0: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = cloneNode;
        var a = i("uXiX")
          , o = i("xIU+");
        const l = Function.call.bind(Object.prototype.hasOwnProperty);
        function cloneIfNode(t, r, i) {
            return t && "string" == typeof t.type ? cloneNode(t, r, i) : t
        }
        function cloneIfNodeOrArray(t, r, i) {
            return Array.isArray(t) ? t.map(t=>cloneIfNode(t, r, i)) : cloneIfNode(t, r, i)
        }
        function cloneNode(t, r=!0, i=!1) {
            if (!t)
                return t;
            const {type: u} = t
              , p = {
                type: t.type
            };
            if ((0,
            o.isIdentifier)(t))
                p.name = t.name,
                l(t, "optional") && "boolean" == typeof t.optional && (p.optional = t.optional),
                l(t, "typeAnnotation") && (p.typeAnnotation = r ? cloneIfNodeOrArray(t.typeAnnotation, !0, i) : t.typeAnnotation);
            else {
                if (!l(a.NODE_FIELDS, u))
                    throw new Error(`Unknown node type: "${u}"`);
                for (const c of Object.keys(a.NODE_FIELDS[u]))
                    l(t, c) && (p[c] = r ? (0,
                    o.isFile)(t) && "comments" === c ? maybeCloneComments(t.comments, r, i) : cloneIfNodeOrArray(t[c], !0, i) : t[c])
            }
            return l(t, "loc") && (p.loc = i ? null : t.loc),
            l(t, "leadingComments") && (p.leadingComments = maybeCloneComments(t.leadingComments, r, i)),
            l(t, "innerComments") && (p.innerComments = maybeCloneComments(t.innerComments, r, i)),
            l(t, "trailingComments") && (p.trailingComments = maybeCloneComments(t.trailingComments, r, i)),
            l(t, "extra") && (p.extra = Object.assign({}, t.extra)),
            p
        }
        function maybeCloneComments(t, r, i) {
            return t && r ? t.map(({type: t, value: r, loc: a})=>i ? {
                type: t,
                value: r,
                loc: null
            } : {
                type: t,
                value: r,
                loc: a
            }) : t
        }
    },
    vKzK: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.isIdentifierStart = isIdentifierStart,
        r.isIdentifierChar = isIdentifierChar,
        r.isIdentifierName = function isIdentifierName(t) {
            for (var r = !0, i = 0; i < t.length; i++) {
                var a = t.charCodeAt(i);
                if (55296 == (64512 & a) && i + 1 < t.length) {
                    var o = t.charCodeAt(++i);
                    56320 == (64512 & o) && (a = 65536 + ((1023 & a) << 10) + (1023 & o))
                }
                if (r) {
                    if (r = !1,
                    !isIdentifierStart(a))
                        return !1
                } else if (!isIdentifierChar(a))
                    return !1
            }
            return !r
        }
        ;
        var a = "ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࢠ-ࢴࢶ-ࣇऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೞೠೡೱೲഄ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜌᜎ-ᜑᜠ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭋᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲈᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳳᳵᳶᳺᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-Ⱞⰰ-ⱞⱠ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆿㇰ-ㇿ㐀-䶿一-鿼ꀀ-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꞿꟂ-ꟊꟵ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭩꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ"
          , o = "‌‍·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛࣓-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍୕-ୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఄా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ඁ-ඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ຼ່-ໍ໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜔ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠐-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᪿᫀᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭᳴᳷-᳹᷀-᷹᷻-᷿‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧ꠬ꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱ꣿ-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿"
          , l = new RegExp("[" + a + "]")
          , u = new RegExp("[" + a + o + "]");
        a = o = null;
        var p = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 107, 20, 28, 22, 13, 52, 76, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 230, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 35, 56, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 190, 0, 80, 921, 103, 110, 18, 195, 2749, 1070, 4050, 582, 8634, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8952, 286, 50, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 2357, 44, 11, 6, 17, 0, 370, 43, 1301, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42717, 35, 4148, 12, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938]
          , c = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 154, 10, 176, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 135, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 419, 13, 1495, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
        function isInAstralSet(t, r) {
            for (var i = 65536, a = 0, o = r.length; a < o; a += 2) {
                if ((i += r[a]) > t)
                    return !1;
                if ((i += r[a + 1]) >= t)
                    return !0
            }
            return !1
        }
        function isIdentifierStart(t) {
            return t < 65 ? 36 === t : t <= 90 || (t < 97 ? 95 === t : t <= 122 || (t <= 65535 ? t >= 170 && l.test(String.fromCharCode(t)) : isInAstralSet(t, p)))
        }
        function isIdentifierChar(t) {
            return t < 48 ? 36 === t : t < 58 || !(t < 65) && (t <= 90 || (t < 97 ? 95 === t : t <= 122 || (t <= 65535 ? t >= 170 && u.test(String.fromCharCode(t)) : isInAstralSet(t, p) || isInAstralSet(t, c))))
        }
    },
    "vW+O": function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function toComputedKey(t, r=t.key || t.property) {
            !t.computed && (0,
            a.isIdentifier)(r) && (r = (0,
            o.stringLiteral)(r.name));
            return r
        }
        ;
        var a = i("xIU+")
          , o = i("61uC")
    },
    vqrH: function(t, r, i) {
        "use strict";
        var a = i("V97+")
          , o = i("z0QK");
        const l = (0,
        a.defineAliasedType)("Miscellaneous");
        l("Noop", {
            visitor: []
        }),
        l("Placeholder", {
            visitor: [],
            builder: ["expectedNode", "name"],
            fields: {
                name: {
                    validate: (0,
                    a.assertNodeType)("Identifier")
                },
                expectedNode: {
                    validate: (0,
                    a.assertOneOf)(...o.PLACEHOLDERS)
                }
            }
        }),
        l("V8IntrinsicIdentifier", {
            builder: ["name"],
            fields: {
                name: {
                    validate: (0,
                    a.assertValueType)("string")
                }
            }
        })
    },
    wJi8: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.shareCommentsWithSiblings = function shareCommentsWithSiblings() {
            if ("string" == typeof this.key)
                return;
            var t = this.node;
            if (!t)
                return;
            var r = t.trailingComments
              , i = t.leadingComments;
            if (!r && !i)
                return;
            var a = this.getSibling(this.key - 1)
              , o = this.getSibling(this.key + 1)
              , l = Boolean(a.node)
              , u = Boolean(o.node);
            l && !u ? a.addComments("trailing", r) : u && !l && o.addComments("leading", i)
        }
        ,
        r.addComment = function addComment(t, r, i) {
            a.addComment(this.node, t, r, i)
        }
        ,
        r.addComments = function addComments(t, r) {
            a.addComments(this.node, t, r)
        }
        ;
        var a = i("ZtNB")
    },
    wOpn: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function populatePlaceholders(t, r) {
            const i = l(t.ast);
            r && (t.placeholders.forEach(t=>{
                if (!Object.prototype.hasOwnProperty.call(r, t.name)) {
                    const r = t.name;
                    throw new Error(`Error: No substitution given for "${r}". If this is not meant to be a\n            placeholder you may want to consider passing one of the following options to @babel/template:\n            - { placeholderPattern: false, placeholderWhitelist: new Set(['${r}'])}\n            - { placeholderPattern: /^${r}$/ }`)
                }
            }
            ),
            Object.keys(r).forEach(r=>{
                if (!t.placeholderNames.has(r))
                    throw new Error(`Unknown substitution "${r}" given`)
            }
            ));
            return t.placeholders.slice().reverse().forEach(t=>{
                try {
                    !function applyReplacement(t, r, i) {
                        t.isDuplicate && (Array.isArray(i) ? i = i.map(t=>l(t)) : "object" == typeof i && (i = l(i)));
                        const {parent: a, key: T, index: S} = t.resolve(r);
                        if ("string" === t.type) {
                            if ("string" == typeof i && (i = h(i)),
                            !i || !y(i))
                                throw new Error("Expected string substitution")
                        } else if ("statement" === t.type)
                            void 0 === S ? i ? Array.isArray(i) ? i = o(i) : "string" == typeof i ? i = p(c(i)) : d(i) || (i = p(i)) : i = u() : i && !Array.isArray(i) && ("string" == typeof i && (i = c(i)),
                            d(i) || (i = p(i)));
                        else if ("param" === t.type) {
                            if ("string" == typeof i && (i = c(i)),
                            void 0 === S)
                                throw new Error("Assertion failure.")
                        } else if ("string" == typeof i && (i = c(i)),
                        Array.isArray(i))
                            throw new Error("Cannot replace single expression with an array.");
                        if (void 0 === S)
                            m(a, T, i),
                            a[T] = i;
                        else {
                            const r = a[T].slice();
                            "statement" === t.type || "param" === t.type ? null == i ? r.splice(S, 1) : Array.isArray(i) ? r.splice(S, 1, ...i) : r[S] = i : r[S] = i,
                            m(a, T, r),
                            a[T] = r
                        }
                    }(t, i, r && r[t.name] || null)
                } catch (r) {
                    throw r.message = `@babel/template placeholder "${t.name}": ${r.message}`,
                    r
                }
            }
            ),
            i
        }
        ;
        var a = i("JSq2");
        const {blockStatement: o, cloneNode: l, emptyStatement: u, expressionStatement: p, identifier: c, isStatement: d, isStringLiteral: y, stringLiteral: h, validate: m} = a
    },
    wQ14: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function isLet(t) {
            return (0,
            a.isVariableDeclaration)(t) && ("var" !== t.kind || t[o.BLOCK_SCOPED_SYMBOL])
        }
        ;
        var a = i("xIU+")
          , o = i("kEZX")
    },
    weqI: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function prependToMemberExpression(t, r) {
            return t.object = (0,
            a.memberExpression)(r, t.object),
            t
        }
        ;
        var a = i("UuI8")
    },
    wffa: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = getBindingIdentifiers;
        var a = i("xIU+");
        function getBindingIdentifiers(t, r, i) {
            let o = [].concat(t);
            const l = Object.create(null);
            for (; o.length; ) {
                const t = o.shift();
                if (!t)
                    continue;
                const u = getBindingIdentifiers.keys[t.type];
                if ((0,
                a.isIdentifier)(t))
                    if (r) {
                        (l[t.name] = l[t.name] || []).push(t)
                    } else
                        l[t.name] = t;
                else if (!(0,
                a.isExportDeclaration)(t) || (0,
                a.isExportAllDeclaration)(t)) {
                    if (i) {
                        if ((0,
                        a.isFunctionDeclaration)(t)) {
                            o.push(t.id);
                            continue
                        }
                        if ((0,
                        a.isFunctionExpression)(t))
                            continue
                    }
                    if (u)
                        for (let r = 0; r < u.length; r++) {
                            const i = u[r];
                            t[i] && (o = o.concat(t[i]))
                        }
                } else
                    (0,
                    a.isDeclaration)(t.declaration) && o.push(t.declaration)
            }
            return l
        }
        getBindingIdentifiers.keys = {
            DeclareClass: ["id"],
            DeclareFunction: ["id"],
            DeclareModule: ["id"],
            DeclareVariable: ["id"],
            DeclareInterface: ["id"],
            DeclareTypeAlias: ["id"],
            DeclareOpaqueType: ["id"],
            InterfaceDeclaration: ["id"],
            TypeAlias: ["id"],
            OpaqueType: ["id"],
            CatchClause: ["param"],
            LabeledStatement: ["label"],
            UnaryExpression: ["argument"],
            AssignmentExpression: ["left"],
            ImportSpecifier: ["local"],
            ImportNamespaceSpecifier: ["local"],
            ImportDefaultSpecifier: ["local"],
            ImportDeclaration: ["specifiers"],
            ExportSpecifier: ["exported"],
            ExportNamespaceSpecifier: ["exported"],
            ExportDefaultSpecifier: ["exported"],
            FunctionDeclaration: ["id", "params"],
            FunctionExpression: ["id", "params"],
            ArrowFunctionExpression: ["params"],
            ObjectMethod: ["params"],
            ClassMethod: ["params"],
            ClassPrivateMethod: ["params"],
            ForInStatement: ["left"],
            ForOfStatement: ["left"],
            ClassDeclaration: ["id"],
            ClassExpression: ["id"],
            RestElement: ["argument"],
            UpdateExpression: ["argument"],
            ObjectProperty: ["value"],
            AssignmentPattern: ["left"],
            ArrayPattern: ["elements"],
            ObjectPattern: ["properties"],
            VariableDeclaration: ["declarations"],
            VariableDeclarator: ["id"]
        }
    },
    wh3u: function(t, r, i) {
        "use strict";
        var a = i("aaMo")
          , o = (0,
        a.defineAliasedType)("JSX");
        o("JSXAttribute", {
            visitor: ["name", "value"],
            aliases: ["Immutable"],
            fields: {
                name: {
                    validate: (0,
                    a.assertNodeType)("JSXIdentifier", "JSXNamespacedName")
                },
                value: {
                    optional: !0,
                    validate: (0,
                    a.assertNodeType)("JSXElement", "JSXFragment", "StringLiteral", "JSXExpressionContainer")
                }
            }
        }),
        o("JSXClosingElement", {
            visitor: ["name"],
            aliases: ["Immutable"],
            fields: {
                name: {
                    validate: (0,
                    a.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
                }
            }
        }),
        o("JSXElement", {
            builder: ["openingElement", "closingElement", "children", "selfClosing"],
            visitor: ["openingElement", "children", "closingElement"],
            aliases: ["Immutable", "Expression"],
            fields: {
                openingElement: {
                    validate: (0,
                    a.assertNodeType)("JSXOpeningElement")
                },
                closingElement: {
                    optional: !0,
                    validate: (0,
                    a.assertNodeType)("JSXClosingElement")
                },
                children: {
                    validate: (0,
                    a.chain)((0,
                    a.assertValueType)("array"), (0,
                    a.assertEach)((0,
                    a.assertNodeType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")))
                },
                selfClosing: {
                    validate: (0,
                    a.assertValueType)("boolean"),
                    optional: !0
                }
            }
        }),
        o("JSXEmptyExpression", {}),
        o("JSXExpressionContainer", {
            visitor: ["expression"],
            aliases: ["Immutable"],
            fields: {
                expression: {
                    validate: (0,
                    a.assertNodeType)("Expression", "JSXEmptyExpression")
                }
            }
        }),
        o("JSXSpreadChild", {
            visitor: ["expression"],
            aliases: ["Immutable"],
            fields: {
                expression: {
                    validate: (0,
                    a.assertNodeType)("Expression")
                }
            }
        }),
        o("JSXIdentifier", {
            builder: ["name"],
            fields: {
                name: {
                    validate: (0,
                    a.assertValueType)("string")
                }
            }
        }),
        o("JSXMemberExpression", {
            visitor: ["object", "property"],
            fields: {
                object: {
                    validate: (0,
                    a.assertNodeType)("JSXMemberExpression", "JSXIdentifier")
                },
                property: {
                    validate: (0,
                    a.assertNodeType)("JSXIdentifier")
                }
            }
        }),
        o("JSXNamespacedName", {
            visitor: ["namespace", "name"],
            fields: {
                namespace: {
                    validate: (0,
                    a.assertNodeType)("JSXIdentifier")
                },
                name: {
                    validate: (0,
                    a.assertNodeType)("JSXIdentifier")
                }
            }
        }),
        o("JSXOpeningElement", {
            builder: ["name", "attributes", "selfClosing"],
            visitor: ["name", "attributes"],
            aliases: ["Immutable"],
            fields: {
                name: {
                    validate: (0,
                    a.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
                },
                selfClosing: {
                    default: !1
                },
                attributes: {
                    validate: (0,
                    a.chain)((0,
                    a.assertValueType)("array"), (0,
                    a.assertEach)((0,
                    a.assertNodeType)("JSXAttribute", "JSXSpreadAttribute")))
                },
                typeParameters: {
                    validate: (0,
                    a.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
                    optional: !0
                }
            }
        }),
        o("JSXSpreadAttribute", {
            visitor: ["argument"],
            fields: {
                argument: {
                    validate: (0,
                    a.assertNodeType)("Expression")
                }
            }
        }),
        o("JSXText", {
            aliases: ["Immutable"],
            builder: ["value"],
            fields: {
                value: {
                    validate: (0,
                    a.assertValueType)("string")
                }
            }
        }),
        o("JSXFragment", {
            builder: ["openingFragment", "closingFragment", "children"],
            visitor: ["openingFragment", "children", "closingFragment"],
            aliases: ["Immutable", "Expression"],
            fields: {
                openingFragment: {
                    validate: (0,
                    a.assertNodeType)("JSXOpeningFragment")
                },
                closingFragment: {
                    validate: (0,
                    a.assertNodeType)("JSXClosingFragment")
                },
                children: {
                    validate: (0,
                    a.chain)((0,
                    a.assertValueType)("array"), (0,
                    a.assertEach)((0,
                    a.assertNodeType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")))
                }
            }
        }),
        o("JSXOpeningFragment", {
            aliases: ["Immutable"]
        }),
        o("JSXClosingFragment", {
            aliases: ["Immutable"]
        })
    },
    whFr: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function _default({node: t, parent: r, scope: i, id: o}, l=!1, I=!1) {
            if (t.id)
                return;
            if (!g(r) && !S(r, {
                kind: "method"
            }) || r.computed && !m(r.key)) {
                if (E(r)) {
                    if (o = r.id,
                    h(o) && !l) {
                        const r = i.parent.getBinding(o.name);
                        if (r && r.constant && i.getBinding(o.name) === r)
                            return t.id = p(o),
                            void (t.id[u] = !0)
                    }
                } else if (d(r, {
                    operator: "="
                }))
                    o = r.left;
                else if (!o)
                    return
            } else
                o = r.key;
            let w;
            o && m(o) ? w = function getNameFromLiteralId(t) {
                if (T(t))
                    return "null";
                if (b(t))
                    return `_${t.pattern}_${t.flags}`;
                if (v(t))
                    return t.quasis.map(t=>t.value.raw).join("");
                if (void 0 !== t.value)
                    return t.value + "";
                return ""
            }(o) : o && h(o) && (w = o.name);
            if (void 0 === w)
                return;
            if (!I && y(t) && /[\uD800-\uDFFF]/.test(w))
                return;
            return w = P(w),
            (o = c(w))[u] = !0,
            function wrap(t, r, i, o) {
                if (t.selfReference) {
                    if (!o.hasBinding(i.name) || o.hasGlobal(i.name)) {
                        if (!y(r))
                            return;
                        let t = x;
                        r.generator && (t = A);
                        const l = t({
                            FUNCTION: r,
                            FUNCTION_ID: i,
                            FUNCTION_KEY: o.generateUidIdentifier(i.name)
                        }).expression
                          , u = l.callee.body.body[0].params;
                        for (let t = 0, i = (0,
                        a.default)(r); t < i; t++)
                            u.push(o.generateUidIdentifier("x"));
                        return l
                    }
                    o.rename(i.name)
                }
                r.id = i,
                o.getProgramParent().references[i.name] = !0
            }(function visit(t, r, i) {
                const a = {
                    selfAssignment: !1,
                    selfReference: !1,
                    outerDeclar: i.getBindingIdentifier(r),
                    references: [],
                    name: r
                }
                  , o = i.getOwnBinding(r);
                o ? "param" === o.kind && (a.selfReference = !0) : (a.outerDeclar || i.hasGlobal(r)) && i.traverse(t, O, a);
                return a
            }(t, w, i), t, o, i) || t
        }
        ;
        var a = i("3MYS")
          , o = i("/YTm")
          , l = i("JSq2");
        const {NOT_LOCAL_BINDING: u, cloneNode: p, identifier: c, isAssignmentExpression: d, isFunction: y, isIdentifier: h, isLiteral: m, isNullLiteral: T, isObjectMethod: S, isObjectProperty: g, isRegExpLiteral: b, isTemplateLiteral: v, isVariableDeclarator: E, toBindingIdentifierName: P} = l
          , x = (0,
        o.default)("\n  (function (FUNCTION_KEY) {\n    function FUNCTION_ID() {\n      return FUNCTION_KEY.apply(this, arguments);\n    }\n\n    FUNCTION_ID.toString = function () {\n      return FUNCTION_KEY.toString();\n    }\n\n    return FUNCTION_ID;\n  })(FUNCTION)\n")
          , A = (0,
        o.default)("\n  (function (FUNCTION_KEY) {\n    function* FUNCTION_ID() {\n      return yield* FUNCTION_KEY.apply(this, arguments);\n    }\n\n    FUNCTION_ID.toString = function () {\n      return FUNCTION_KEY.toString();\n    };\n\n    return FUNCTION_ID;\n  })(FUNCTION)\n")
          , O = {
            "ReferencedIdentifier|BindingIdentifier"(t, r) {
                if (t.node.name !== r.name)
                    return;
                t.scope.getBindingIdentifier(r.name) === r.outerDeclar && (r.selfReference = !0,
                t.stop())
            }
        }
    },
    wqfs: function(t, r, i) {
        "use strict";
        function _createForOfIteratorHelper(t, r) {
            var i = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
            if (!i) {
                if (Array.isArray(t) || (i = function _unsupportedIterableToArray(t, r) {
                    if (!t)
                        return;
                    if ("string" == typeof t)
                        return _arrayLikeToArray(t, r);
                    var i = Object.prototype.toString.call(t).slice(8, -1);
                    "Object" === i && t.constructor && (i = t.constructor.name);
                    if ("Map" === i || "Set" === i)
                        return Array.from(t);
                    if ("Arguments" === i || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i))
                        return _arrayLikeToArray(t, r)
                }(t)) || r && t && "number" == typeof t.length) {
                    i && (t = i);
                    var a = 0
                      , o = function F() {};
                    return {
                        s: o,
                        n: function n() {
                            return a >= t.length ? {
                                done: !0
                            } : {
                                done: !1,
                                value: t[a++]
                            }
                        },
                        e: function e(t) {
                            throw t
                        },
                        f: o
                    }
                }
                throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
            }
            var l, u = !0, p = !1;
            return {
                s: function s() {
                    i = i.call(t)
                },
                n: function n() {
                    var t = i.next();
                    return u = t.done,
                    t
                },
                e: function e(t) {
                    p = !0,
                    l = t
                },
                f: function f() {
                    try {
                        u || null == i.return || i.return()
                    } finally {
                        if (p)
                            throw l
                    }
                }
            }
        }
        function _arrayLikeToArray(t, r) {
            (null == r || r > t.length) && (r = t.length);
            for (var i = 0, a = new Array(r); i < r; i++)
                a[i] = t[i];
            return a
        }
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.remove = function remove() {
            var t;
            this._assertUnremoved(),
            this.resync(),
            null != (t = this.opts) && t.noScope || this._removeFromScope();
            if (this._callRemovalHooks())
                return void this._markRemoved();
            this.shareCommentsWithSiblings(),
            this._remove(),
            this._markRemoved()
        }
        ,
        r._removeFromScope = function _removeFromScope() {
            var t = this
              , r = this.getBindingIdentifiers();
            Object.keys(r).forEach((function(r) {
                return t.scope.removeBinding(r)
            }
            ))
        }
        ,
        r._callRemovalHooks = function _callRemovalHooks() {
            var t, r = _createForOfIteratorHelper(a.hooks);
            try {
                for (r.s(); !(t = r.n()).done; ) {
                    if ((0,
                    t.value)(this, this.parentPath))
                        return !0
                }
            } catch (t) {
                r.e(t)
            } finally {
                r.f()
            }
        }
        ,
        r._remove = function _remove() {
            Array.isArray(this.container) ? (this.container.splice(this.key, 1),
            this.updateSiblingKeys(this.key, -1)) : this._replaceWith(null)
        }
        ,
        r._markRemoved = function _markRemoved() {
            this._traverseFlags |= l.SHOULD_SKIP | l.REMOVED,
            this.parent && o.path.get(this.parent).delete(this.node);
            this.node = null
        }
        ,
        r._assertUnremoved = function _assertUnremoved() {
            if (this.removed)
                throw this.buildCodeFrameError("NodePath has been removed so is read-only.")
        }
        ;
        var a = i("f0nW")
          , o = i("qMwM")
          , l = i("MBGo")
    },
    wv7U: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function createFlowUnionType(t) {
            var r = (0,
            o.default)(t);
            return 1 === r.length ? r[0] : (0,
            a.unionTypeAnnotation)(r)
        }
        ;
        var a = i("UuI8")
          , o = i("4r8k")
    },
    wv99: function(t, r, i) {
        "use strict";
        function _createForOfIteratorHelper(t, r) {
            var i = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
            if (!i) {
                if (Array.isArray(t) || (i = function _unsupportedIterableToArray(t, r) {
                    if (!t)
                        return;
                    if ("string" == typeof t)
                        return _arrayLikeToArray(t, r);
                    var i = Object.prototype.toString.call(t).slice(8, -1);
                    "Object" === i && t.constructor && (i = t.constructor.name);
                    if ("Map" === i || "Set" === i)
                        return Array.from(t);
                    if ("Arguments" === i || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i))
                        return _arrayLikeToArray(t, r)
                }(t)) || r && t && "number" == typeof t.length) {
                    i && (t = i);
                    var a = 0
                      , o = function F() {};
                    return {
                        s: o,
                        n: function n() {
                            return a >= t.length ? {
                                done: !0
                            } : {
                                done: !1,
                                value: t[a++]
                            }
                        },
                        e: function e(t) {
                            throw t
                        },
                        f: o
                    }
                }
                throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
            }
            var l, u = !0, p = !1;
            return {
                s: function s() {
                    i = i.call(t)
                },
                n: function n() {
                    var t = i.next();
                    return u = t.done,
                    t
                },
                e: function e(t) {
                    p = !0,
                    l = t
                },
                f: function f() {
                    try {
                        u || null == i.return || i.return()
                    } finally {
                        if (p)
                            throw l
                    }
                }
            }
        }
        function _arrayLikeToArray(t, r) {
            (null == r || r > t.length) && (r = t.length);
            for (var i = 0, a = new Array(r); i < r; i++)
                a[i] = t[i];
            return a
        }
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function toIdentifier(t) {
            var r, i = "", l = _createForOfIteratorHelper(t += "");
            try {
                for (l.s(); !(r = l.n()).done; ) {
                    var u = r.value;
                    i += (0,
                    o.isIdentifierChar)(u.codePointAt(0)) ? u : "-"
                }
            } catch (t) {
                l.e(t)
            } finally {
                l.f()
            }
            i = (i = i.replace(/^[-0-9]+/, "")).replace(/[-\s]+(.)?/g, (function(t, r) {
                return r ? r.toUpperCase() : ""
            }
            )),
            (0,
            a.default)(i) || (i = "_".concat(i));
            return i || "_"
        }
        ;
        var a = i("Aniq")
          , o = i("KPS7")
    },
    xDlH: function(t, r, i) {
        "use strict";
        var a = i("TqRt")
          , o = a(i("lwsE"))
          , l = a(i("W8MJ"));
        function _createForOfIteratorHelper(t, r) {
            var i = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
            if (!i) {
                if (Array.isArray(t) || (i = function _unsupportedIterableToArray(t, r) {
                    if (!t)
                        return;
                    if ("string" == typeof t)
                        return _arrayLikeToArray(t, r);
                    var i = Object.prototype.toString.call(t).slice(8, -1);
                    "Object" === i && t.constructor && (i = t.constructor.name);
                    if ("Map" === i || "Set" === i)
                        return Array.from(t);
                    if ("Arguments" === i || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i))
                        return _arrayLikeToArray(t, r)
                }(t)) || r && t && "number" == typeof t.length) {
                    i && (t = i);
                    var a = 0
                      , o = function F() {};
                    return {
                        s: o,
                        n: function n() {
                            return a >= t.length ? {
                                done: !0
                            } : {
                                done: !1,
                                value: t[a++]
                            }
                        },
                        e: function e(t) {
                            throw t
                        },
                        f: o
                    }
                }
                throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
            }
            var l, u = !0, p = !1;
            return {
                s: function s() {
                    i = i.call(t)
                },
                n: function n() {
                    var t = i.next();
                    return u = t.done,
                    t
                },
                e: function e(t) {
                    p = !0,
                    l = t
                },
                f: function f() {
                    try {
                        u || null == i.return || i.return()
                    } finally {
                        if (p)
                            throw l
                    }
                }
            }
        }
        function _arrayLikeToArray(t, r) {
            (null == r || r > t.length) && (r = t.length);
            for (var i = 0, a = new Array(r); i < r; i++)
                a[i] = t[i];
            return a
        }
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = void 0;
        var u = i("MBGo")
          , p = i("ZtNB")
          , c = function() {
            function TraversalContext(t, r, i, a) {
                (0,
                o.default)(this, TraversalContext),
                this.queue = null,
                this.priorityQueue = null,
                this.parentPath = a,
                this.scope = t,
                this.state = i,
                this.opts = r
            }
            return (0,
            l.default)(TraversalContext, [{
                key: "shouldVisit",
                value: function shouldVisit(t) {
                    var r = this.opts;
                    if (r.enter || r.exit)
                        return !0;
                    if (r[t.type])
                        return !0;
                    var i = p.VISITOR_KEYS[t.type];
                    if (null == i || !i.length)
                        return !1;
                    var a, o = _createForOfIteratorHelper(i);
                    try {
                        for (o.s(); !(a = o.n()).done; ) {
                            if (t[a.value])
                                return !0
                        }
                    } catch (t) {
                        o.e(t)
                    } finally {
                        o.f()
                    }
                    return !1
                }
            }, {
                key: "create",
                value: function create(t, r, i, a) {
                    return u.default.get({
                        parentPath: this.parentPath,
                        parent: t,
                        container: r,
                        key: i,
                        listKey: a
                    })
                }
            }, {
                key: "maybeQueue",
                value: function maybeQueue(t, r) {
                    this.queue && (r ? this.queue.push(t) : this.priorityQueue.push(t))
                }
            }, {
                key: "visitMultiple",
                value: function visitMultiple(t, r, i) {
                    if (0 === t.length)
                        return !1;
                    for (var a = [], o = 0; o < t.length; o++) {
                        var l = t[o];
                        l && this.shouldVisit(l) && a.push(this.create(r, t, o, i))
                    }
                    return this.visitQueue(a)
                }
            }, {
                key: "visitSingle",
                value: function visitSingle(t, r) {
                    return !!this.shouldVisit(t[r]) && this.visitQueue([this.create(t, t, r)])
                }
            }, {
                key: "visitQueue",
                value: function visitQueue(t) {
                    this.queue = t,
                    this.priorityQueue = [];
                    var r, i = new WeakSet, a = !1, o = _createForOfIteratorHelper(t);
                    try {
                        for (o.s(); !(r = o.n()).done; ) {
                            var l = r.value;
                            if (l.resync(),
                            0 !== l.contexts.length && l.contexts[l.contexts.length - 1] === this || l.pushContext(this),
                            null !== l.key) {
                                var u = l.node;
                                if (!i.has(u)) {
                                    if (u && i.add(u),
                                    l.visit()) {
                                        a = !0;
                                        break
                                    }
                                    if (this.priorityQueue.length && (a = this.visitQueue(this.priorityQueue),
                                    this.priorityQueue = [],
                                    this.queue = t,
                                    a))
                                        break
                                }
                            }
                        }
                    } catch (t) {
                        o.e(t)
                    } finally {
                        o.f()
                    }
                    var p, c = _createForOfIteratorHelper(t);
                    try {
                        for (c.s(); !(p = c.n()).done; ) {
                            p.value.popContext()
                        }
                    } catch (t) {
                        c.e(t)
                    } finally {
                        c.f()
                    }
                    return this.queue = null,
                    a
                }
            }, {
                key: "visit",
                value: function visit(t, r) {
                    var i = t[r];
                    return !!i && (Array.isArray(i) ? this.visitMultiple(i, t, r) : this.visitSingle(t, r))
                }
            }]),
            TraversalContext
        }();
        r.default = c
    },
    "xIU+": function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.isAnyTypeAnnotation = function isAnyTypeAnnotation(t, r) {
            if (!t)
                return !1;
            if ("AnyTypeAnnotation" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isArgumentPlaceholder = function isArgumentPlaceholder(t, r) {
            if (!t)
                return !1;
            if ("ArgumentPlaceholder" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isArrayExpression = function isArrayExpression(t, r) {
            if (!t)
                return !1;
            if ("ArrayExpression" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isArrayPattern = function isArrayPattern(t, r) {
            if (!t)
                return !1;
            if ("ArrayPattern" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isArrayTypeAnnotation = function isArrayTypeAnnotation(t, r) {
            if (!t)
                return !1;
            if ("ArrayTypeAnnotation" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isArrowFunctionExpression = function isArrowFunctionExpression(t, r) {
            if (!t)
                return !1;
            if ("ArrowFunctionExpression" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isAssignmentExpression = function isAssignmentExpression(t, r) {
            if (!t)
                return !1;
            if ("AssignmentExpression" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isAssignmentPattern = function isAssignmentPattern(t, r) {
            if (!t)
                return !1;
            if ("AssignmentPattern" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isAwaitExpression = function isAwaitExpression(t, r) {
            if (!t)
                return !1;
            if ("AwaitExpression" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isBigIntLiteral = function isBigIntLiteral(t, r) {
            if (!t)
                return !1;
            if ("BigIntLiteral" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isBinary = function isBinary(t, r) {
            if (!t)
                return !1;
            const i = t.type;
            if ("BinaryExpression" === i || "LogicalExpression" === i)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isBinaryExpression = function isBinaryExpression(t, r) {
            if (!t)
                return !1;
            if ("BinaryExpression" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isBindExpression = function isBindExpression(t, r) {
            if (!t)
                return !1;
            if ("BindExpression" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isBlock = function isBlock(t, r) {
            if (!t)
                return !1;
            const i = t.type;
            if ("BlockStatement" === i || "Program" === i || "TSModuleBlock" === i || "Placeholder" === i && "BlockStatement" === t.expectedNode)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isBlockParent = function isBlockParent(t, r) {
            if (!t)
                return !1;
            const i = t.type;
            if ("BlockStatement" === i || "CatchClause" === i || "DoWhileStatement" === i || "ForInStatement" === i || "ForStatement" === i || "FunctionDeclaration" === i || "FunctionExpression" === i || "Program" === i || "ObjectMethod" === i || "SwitchStatement" === i || "WhileStatement" === i || "ArrowFunctionExpression" === i || "ForOfStatement" === i || "ClassMethod" === i || "ClassPrivateMethod" === i || "StaticBlock" === i || "TSModuleBlock" === i || "Placeholder" === i && "BlockStatement" === t.expectedNode)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isBlockStatement = function isBlockStatement(t, r) {
            if (!t)
                return !1;
            if ("BlockStatement" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isBooleanLiteral = function isBooleanLiteral(t, r) {
            if (!t)
                return !1;
            if ("BooleanLiteral" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isBooleanLiteralTypeAnnotation = function isBooleanLiteralTypeAnnotation(t, r) {
            if (!t)
                return !1;
            if ("BooleanLiteralTypeAnnotation" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isBooleanTypeAnnotation = function isBooleanTypeAnnotation(t, r) {
            if (!t)
                return !1;
            if ("BooleanTypeAnnotation" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isBreakStatement = function isBreakStatement(t, r) {
            if (!t)
                return !1;
            if ("BreakStatement" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isCallExpression = function isCallExpression(t, r) {
            if (!t)
                return !1;
            if ("CallExpression" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isCatchClause = function isCatchClause(t, r) {
            if (!t)
                return !1;
            if ("CatchClause" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isClass = function isClass(t, r) {
            if (!t)
                return !1;
            const i = t.type;
            if ("ClassExpression" === i || "ClassDeclaration" === i)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isClassBody = function isClassBody(t, r) {
            if (!t)
                return !1;
            if ("ClassBody" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isClassDeclaration = function isClassDeclaration(t, r) {
            if (!t)
                return !1;
            if ("ClassDeclaration" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isClassExpression = function isClassExpression(t, r) {
            if (!t)
                return !1;
            if ("ClassExpression" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isClassImplements = function isClassImplements(t, r) {
            if (!t)
                return !1;
            if ("ClassImplements" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isClassMethod = function isClassMethod(t, r) {
            if (!t)
                return !1;
            if ("ClassMethod" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isClassPrivateMethod = function isClassPrivateMethod(t, r) {
            if (!t)
                return !1;
            if ("ClassPrivateMethod" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isClassPrivateProperty = function isClassPrivateProperty(t, r) {
            if (!t)
                return !1;
            if ("ClassPrivateProperty" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isClassProperty = function isClassProperty(t, r) {
            if (!t)
                return !1;
            if ("ClassProperty" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isCompletionStatement = function isCompletionStatement(t, r) {
            if (!t)
                return !1;
            const i = t.type;
            if ("BreakStatement" === i || "ContinueStatement" === i || "ReturnStatement" === i || "ThrowStatement" === i)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isConditional = function isConditional(t, r) {
            if (!t)
                return !1;
            const i = t.type;
            if ("ConditionalExpression" === i || "IfStatement" === i)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isConditionalExpression = function isConditionalExpression(t, r) {
            if (!t)
                return !1;
            if ("ConditionalExpression" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isContinueStatement = function isContinueStatement(t, r) {
            if (!t)
                return !1;
            if ("ContinueStatement" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isDebuggerStatement = function isDebuggerStatement(t, r) {
            if (!t)
                return !1;
            if ("DebuggerStatement" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isDecimalLiteral = function isDecimalLiteral(t, r) {
            if (!t)
                return !1;
            if ("DecimalLiteral" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isDeclaration = function isDeclaration(t, r) {
            if (!t)
                return !1;
            const i = t.type;
            if ("FunctionDeclaration" === i || "VariableDeclaration" === i || "ClassDeclaration" === i || "ExportAllDeclaration" === i || "ExportDefaultDeclaration" === i || "ExportNamedDeclaration" === i || "ImportDeclaration" === i || "DeclareClass" === i || "DeclareFunction" === i || "DeclareInterface" === i || "DeclareModule" === i || "DeclareModuleExports" === i || "DeclareTypeAlias" === i || "DeclareOpaqueType" === i || "DeclareVariable" === i || "DeclareExportDeclaration" === i || "DeclareExportAllDeclaration" === i || "InterfaceDeclaration" === i || "OpaqueType" === i || "TypeAlias" === i || "EnumDeclaration" === i || "TSDeclareFunction" === i || "TSInterfaceDeclaration" === i || "TSTypeAliasDeclaration" === i || "TSEnumDeclaration" === i || "TSModuleDeclaration" === i || "Placeholder" === i && "Declaration" === t.expectedNode)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isDeclareClass = function isDeclareClass(t, r) {
            if (!t)
                return !1;
            if ("DeclareClass" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isDeclareExportAllDeclaration = function isDeclareExportAllDeclaration(t, r) {
            if (!t)
                return !1;
            if ("DeclareExportAllDeclaration" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isDeclareExportDeclaration = function isDeclareExportDeclaration(t, r) {
            if (!t)
                return !1;
            if ("DeclareExportDeclaration" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isDeclareFunction = function isDeclareFunction(t, r) {
            if (!t)
                return !1;
            if ("DeclareFunction" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isDeclareInterface = function isDeclareInterface(t, r) {
            if (!t)
                return !1;
            if ("DeclareInterface" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isDeclareModule = function isDeclareModule(t, r) {
            if (!t)
                return !1;
            if ("DeclareModule" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isDeclareModuleExports = function isDeclareModuleExports(t, r) {
            if (!t)
                return !1;
            if ("DeclareModuleExports" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isDeclareOpaqueType = function isDeclareOpaqueType(t, r) {
            if (!t)
                return !1;
            if ("DeclareOpaqueType" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isDeclareTypeAlias = function isDeclareTypeAlias(t, r) {
            if (!t)
                return !1;
            if ("DeclareTypeAlias" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isDeclareVariable = function isDeclareVariable(t, r) {
            if (!t)
                return !1;
            if ("DeclareVariable" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isDeclaredPredicate = function isDeclaredPredicate(t, r) {
            if (!t)
                return !1;
            if ("DeclaredPredicate" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isDecorator = function isDecorator(t, r) {
            if (!t)
                return !1;
            if ("Decorator" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isDirective = function isDirective(t, r) {
            if (!t)
                return !1;
            if ("Directive" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isDirectiveLiteral = function isDirectiveLiteral(t, r) {
            if (!t)
                return !1;
            if ("DirectiveLiteral" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isDoExpression = function isDoExpression(t, r) {
            if (!t)
                return !1;
            if ("DoExpression" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isDoWhileStatement = function isDoWhileStatement(t, r) {
            if (!t)
                return !1;
            if ("DoWhileStatement" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isEmptyStatement = function isEmptyStatement(t, r) {
            if (!t)
                return !1;
            if ("EmptyStatement" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isEmptyTypeAnnotation = function isEmptyTypeAnnotation(t, r) {
            if (!t)
                return !1;
            if ("EmptyTypeAnnotation" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isEnumBody = function isEnumBody(t, r) {
            if (!t)
                return !1;
            const i = t.type;
            if ("EnumBooleanBody" === i || "EnumNumberBody" === i || "EnumStringBody" === i || "EnumSymbolBody" === i)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isEnumBooleanBody = function isEnumBooleanBody(t, r) {
            if (!t)
                return !1;
            if ("EnumBooleanBody" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isEnumBooleanMember = function isEnumBooleanMember(t, r) {
            if (!t)
                return !1;
            if ("EnumBooleanMember" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isEnumDeclaration = function isEnumDeclaration(t, r) {
            if (!t)
                return !1;
            if ("EnumDeclaration" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isEnumDefaultedMember = function isEnumDefaultedMember(t, r) {
            if (!t)
                return !1;
            if ("EnumDefaultedMember" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isEnumMember = function isEnumMember(t, r) {
            if (!t)
                return !1;
            const i = t.type;
            if ("EnumBooleanMember" === i || "EnumNumberMember" === i || "EnumStringMember" === i || "EnumDefaultedMember" === i)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isEnumNumberBody = function isEnumNumberBody(t, r) {
            if (!t)
                return !1;
            if ("EnumNumberBody" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isEnumNumberMember = function isEnumNumberMember(t, r) {
            if (!t)
                return !1;
            if ("EnumNumberMember" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isEnumStringBody = function isEnumStringBody(t, r) {
            if (!t)
                return !1;
            if ("EnumStringBody" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isEnumStringMember = function isEnumStringMember(t, r) {
            if (!t)
                return !1;
            if ("EnumStringMember" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isEnumSymbolBody = function isEnumSymbolBody(t, r) {
            if (!t)
                return !1;
            if ("EnumSymbolBody" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isExistsTypeAnnotation = function isExistsTypeAnnotation(t, r) {
            if (!t)
                return !1;
            if ("ExistsTypeAnnotation" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isExportAllDeclaration = function isExportAllDeclaration(t, r) {
            if (!t)
                return !1;
            if ("ExportAllDeclaration" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isExportDeclaration = function isExportDeclaration(t, r) {
            if (!t)
                return !1;
            const i = t.type;
            if ("ExportAllDeclaration" === i || "ExportDefaultDeclaration" === i || "ExportNamedDeclaration" === i)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isExportDefaultDeclaration = function isExportDefaultDeclaration(t, r) {
            if (!t)
                return !1;
            if ("ExportDefaultDeclaration" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isExportDefaultSpecifier = function isExportDefaultSpecifier(t, r) {
            if (!t)
                return !1;
            if ("ExportDefaultSpecifier" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isExportNamedDeclaration = function isExportNamedDeclaration(t, r) {
            if (!t)
                return !1;
            if ("ExportNamedDeclaration" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isExportNamespaceSpecifier = function isExportNamespaceSpecifier(t, r) {
            if (!t)
                return !1;
            if ("ExportNamespaceSpecifier" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isExportSpecifier = function isExportSpecifier(t, r) {
            if (!t)
                return !1;
            if ("ExportSpecifier" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isExpression = function isExpression(t, r) {
            if (!t)
                return !1;
            const i = t.type;
            if ("ArrayExpression" === i || "AssignmentExpression" === i || "BinaryExpression" === i || "CallExpression" === i || "ConditionalExpression" === i || "FunctionExpression" === i || "Identifier" === i || "StringLiteral" === i || "NumericLiteral" === i || "NullLiteral" === i || "BooleanLiteral" === i || "RegExpLiteral" === i || "LogicalExpression" === i || "MemberExpression" === i || "NewExpression" === i || "ObjectExpression" === i || "SequenceExpression" === i || "ParenthesizedExpression" === i || "ThisExpression" === i || "UnaryExpression" === i || "UpdateExpression" === i || "ArrowFunctionExpression" === i || "ClassExpression" === i || "MetaProperty" === i || "Super" === i || "TaggedTemplateExpression" === i || "TemplateLiteral" === i || "YieldExpression" === i || "AwaitExpression" === i || "Import" === i || "BigIntLiteral" === i || "OptionalMemberExpression" === i || "OptionalCallExpression" === i || "TypeCastExpression" === i || "JSXElement" === i || "JSXFragment" === i || "BindExpression" === i || "DoExpression" === i || "RecordExpression" === i || "TupleExpression" === i || "DecimalLiteral" === i || "ModuleExpression" === i || "TopicReference" === i || "PipelineTopicExpression" === i || "PipelineBareFunction" === i || "PipelinePrimaryTopicReference" === i || "TSAsExpression" === i || "TSTypeAssertion" === i || "TSNonNullExpression" === i || "Placeholder" === i && ("Expression" === t.expectedNode || "Identifier" === t.expectedNode || "StringLiteral" === t.expectedNode))
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isExpressionStatement = function isExpressionStatement(t, r) {
            if (!t)
                return !1;
            if ("ExpressionStatement" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isExpressionWrapper = function isExpressionWrapper(t, r) {
            if (!t)
                return !1;
            const i = t.type;
            if ("ExpressionStatement" === i || "ParenthesizedExpression" === i || "TypeCastExpression" === i)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isFile = function isFile(t, r) {
            if (!t)
                return !1;
            if ("File" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isFlow = function isFlow(t, r) {
            if (!t)
                return !1;
            const i = t.type;
            if ("AnyTypeAnnotation" === i || "ArrayTypeAnnotation" === i || "BooleanTypeAnnotation" === i || "BooleanLiteralTypeAnnotation" === i || "NullLiteralTypeAnnotation" === i || "ClassImplements" === i || "DeclareClass" === i || "DeclareFunction" === i || "DeclareInterface" === i || "DeclareModule" === i || "DeclareModuleExports" === i || "DeclareTypeAlias" === i || "DeclareOpaqueType" === i || "DeclareVariable" === i || "DeclareExportDeclaration" === i || "DeclareExportAllDeclaration" === i || "DeclaredPredicate" === i || "ExistsTypeAnnotation" === i || "FunctionTypeAnnotation" === i || "FunctionTypeParam" === i || "GenericTypeAnnotation" === i || "InferredPredicate" === i || "InterfaceExtends" === i || "InterfaceDeclaration" === i || "InterfaceTypeAnnotation" === i || "IntersectionTypeAnnotation" === i || "MixedTypeAnnotation" === i || "EmptyTypeAnnotation" === i || "NullableTypeAnnotation" === i || "NumberLiteralTypeAnnotation" === i || "NumberTypeAnnotation" === i || "ObjectTypeAnnotation" === i || "ObjectTypeInternalSlot" === i || "ObjectTypeCallProperty" === i || "ObjectTypeIndexer" === i || "ObjectTypeProperty" === i || "ObjectTypeSpreadProperty" === i || "OpaqueType" === i || "QualifiedTypeIdentifier" === i || "StringLiteralTypeAnnotation" === i || "StringTypeAnnotation" === i || "SymbolTypeAnnotation" === i || "ThisTypeAnnotation" === i || "TupleTypeAnnotation" === i || "TypeofTypeAnnotation" === i || "TypeAlias" === i || "TypeAnnotation" === i || "TypeCastExpression" === i || "TypeParameter" === i || "TypeParameterDeclaration" === i || "TypeParameterInstantiation" === i || "UnionTypeAnnotation" === i || "Variance" === i || "VoidTypeAnnotation" === i || "EnumDeclaration" === i || "EnumBooleanBody" === i || "EnumNumberBody" === i || "EnumStringBody" === i || "EnumSymbolBody" === i || "EnumBooleanMember" === i || "EnumNumberMember" === i || "EnumStringMember" === i || "EnumDefaultedMember" === i || "IndexedAccessType" === i || "OptionalIndexedAccessType" === i)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isFlowBaseAnnotation = function isFlowBaseAnnotation(t, r) {
            if (!t)
                return !1;
            const i = t.type;
            if ("AnyTypeAnnotation" === i || "BooleanTypeAnnotation" === i || "NullLiteralTypeAnnotation" === i || "MixedTypeAnnotation" === i || "EmptyTypeAnnotation" === i || "NumberTypeAnnotation" === i || "StringTypeAnnotation" === i || "SymbolTypeAnnotation" === i || "ThisTypeAnnotation" === i || "VoidTypeAnnotation" === i)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isFlowDeclaration = function isFlowDeclaration(t, r) {
            if (!t)
                return !1;
            const i = t.type;
            if ("DeclareClass" === i || "DeclareFunction" === i || "DeclareInterface" === i || "DeclareModule" === i || "DeclareModuleExports" === i || "DeclareTypeAlias" === i || "DeclareOpaqueType" === i || "DeclareVariable" === i || "DeclareExportDeclaration" === i || "DeclareExportAllDeclaration" === i || "InterfaceDeclaration" === i || "OpaqueType" === i || "TypeAlias" === i)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isFlowPredicate = function isFlowPredicate(t, r) {
            if (!t)
                return !1;
            const i = t.type;
            if ("DeclaredPredicate" === i || "InferredPredicate" === i)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isFlowType = function isFlowType(t, r) {
            if (!t)
                return !1;
            const i = t.type;
            if ("AnyTypeAnnotation" === i || "ArrayTypeAnnotation" === i || "BooleanTypeAnnotation" === i || "BooleanLiteralTypeAnnotation" === i || "NullLiteralTypeAnnotation" === i || "ExistsTypeAnnotation" === i || "FunctionTypeAnnotation" === i || "GenericTypeAnnotation" === i || "InterfaceTypeAnnotation" === i || "IntersectionTypeAnnotation" === i || "MixedTypeAnnotation" === i || "EmptyTypeAnnotation" === i || "NullableTypeAnnotation" === i || "NumberLiteralTypeAnnotation" === i || "NumberTypeAnnotation" === i || "ObjectTypeAnnotation" === i || "StringLiteralTypeAnnotation" === i || "StringTypeAnnotation" === i || "SymbolTypeAnnotation" === i || "ThisTypeAnnotation" === i || "TupleTypeAnnotation" === i || "TypeofTypeAnnotation" === i || "UnionTypeAnnotation" === i || "VoidTypeAnnotation" === i || "IndexedAccessType" === i || "OptionalIndexedAccessType" === i)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isFor = function isFor(t, r) {
            if (!t)
                return !1;
            const i = t.type;
            if ("ForInStatement" === i || "ForStatement" === i || "ForOfStatement" === i)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isForInStatement = function isForInStatement(t, r) {
            if (!t)
                return !1;
            if ("ForInStatement" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isForOfStatement = function isForOfStatement(t, r) {
            if (!t)
                return !1;
            if ("ForOfStatement" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isForStatement = function isForStatement(t, r) {
            if (!t)
                return !1;
            if ("ForStatement" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isForXStatement = function isForXStatement(t, r) {
            if (!t)
                return !1;
            const i = t.type;
            if ("ForInStatement" === i || "ForOfStatement" === i)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isFunction = function isFunction(t, r) {
            if (!t)
                return !1;
            const i = t.type;
            if ("FunctionDeclaration" === i || "FunctionExpression" === i || "ObjectMethod" === i || "ArrowFunctionExpression" === i || "ClassMethod" === i || "ClassPrivateMethod" === i)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isFunctionDeclaration = function isFunctionDeclaration(t, r) {
            if (!t)
                return !1;
            if ("FunctionDeclaration" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isFunctionExpression = function isFunctionExpression(t, r) {
            if (!t)
                return !1;
            if ("FunctionExpression" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isFunctionParent = function isFunctionParent(t, r) {
            if (!t)
                return !1;
            const i = t.type;
            if ("FunctionDeclaration" === i || "FunctionExpression" === i || "ObjectMethod" === i || "ArrowFunctionExpression" === i || "ClassMethod" === i || "ClassPrivateMethod" === i || "StaticBlock" === i)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isFunctionTypeAnnotation = function isFunctionTypeAnnotation(t, r) {
            if (!t)
                return !1;
            if ("FunctionTypeAnnotation" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isFunctionTypeParam = function isFunctionTypeParam(t, r) {
            if (!t)
                return !1;
            if ("FunctionTypeParam" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isGenericTypeAnnotation = function isGenericTypeAnnotation(t, r) {
            if (!t)
                return !1;
            if ("GenericTypeAnnotation" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isIdentifier = function isIdentifier(t, r) {
            if (!t)
                return !1;
            if ("Identifier" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isIfStatement = function isIfStatement(t, r) {
            if (!t)
                return !1;
            if ("IfStatement" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isImmutable = function isImmutable(t, r) {
            if (!t)
                return !1;
            const i = t.type;
            if ("StringLiteral" === i || "NumericLiteral" === i || "NullLiteral" === i || "BooleanLiteral" === i || "BigIntLiteral" === i || "JSXAttribute" === i || "JSXClosingElement" === i || "JSXElement" === i || "JSXExpressionContainer" === i || "JSXSpreadChild" === i || "JSXOpeningElement" === i || "JSXText" === i || "JSXFragment" === i || "JSXOpeningFragment" === i || "JSXClosingFragment" === i || "DecimalLiteral" === i || "Placeholder" === i && "StringLiteral" === t.expectedNode)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isImport = function isImport(t, r) {
            if (!t)
                return !1;
            if ("Import" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isImportAttribute = function isImportAttribute(t, r) {
            if (!t)
                return !1;
            if ("ImportAttribute" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isImportDeclaration = function isImportDeclaration(t, r) {
            if (!t)
                return !1;
            if ("ImportDeclaration" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isImportDefaultSpecifier = function isImportDefaultSpecifier(t, r) {
            if (!t)
                return !1;
            if ("ImportDefaultSpecifier" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isImportNamespaceSpecifier = function isImportNamespaceSpecifier(t, r) {
            if (!t)
                return !1;
            if ("ImportNamespaceSpecifier" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isImportSpecifier = function isImportSpecifier(t, r) {
            if (!t)
                return !1;
            if ("ImportSpecifier" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isIndexedAccessType = function isIndexedAccessType(t, r) {
            if (!t)
                return !1;
            if ("IndexedAccessType" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isInferredPredicate = function isInferredPredicate(t, r) {
            if (!t)
                return !1;
            if ("InferredPredicate" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isInterfaceDeclaration = function isInterfaceDeclaration(t, r) {
            if (!t)
                return !1;
            if ("InterfaceDeclaration" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isInterfaceExtends = function isInterfaceExtends(t, r) {
            if (!t)
                return !1;
            if ("InterfaceExtends" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isInterfaceTypeAnnotation = function isInterfaceTypeAnnotation(t, r) {
            if (!t)
                return !1;
            if ("InterfaceTypeAnnotation" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isInterpreterDirective = function isInterpreterDirective(t, r) {
            if (!t)
                return !1;
            if ("InterpreterDirective" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isIntersectionTypeAnnotation = function isIntersectionTypeAnnotation(t, r) {
            if (!t)
                return !1;
            if ("IntersectionTypeAnnotation" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isJSX = function isJSX(t, r) {
            if (!t)
                return !1;
            const i = t.type;
            if ("JSXAttribute" === i || "JSXClosingElement" === i || "JSXElement" === i || "JSXEmptyExpression" === i || "JSXExpressionContainer" === i || "JSXSpreadChild" === i || "JSXIdentifier" === i || "JSXMemberExpression" === i || "JSXNamespacedName" === i || "JSXOpeningElement" === i || "JSXSpreadAttribute" === i || "JSXText" === i || "JSXFragment" === i || "JSXOpeningFragment" === i || "JSXClosingFragment" === i)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isJSXAttribute = function isJSXAttribute(t, r) {
            if (!t)
                return !1;
            if ("JSXAttribute" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isJSXClosingElement = function isJSXClosingElement(t, r) {
            if (!t)
                return !1;
            if ("JSXClosingElement" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isJSXClosingFragment = function isJSXClosingFragment(t, r) {
            if (!t)
                return !1;
            if ("JSXClosingFragment" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isJSXElement = function isJSXElement(t, r) {
            if (!t)
                return !1;
            if ("JSXElement" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isJSXEmptyExpression = function isJSXEmptyExpression(t, r) {
            if (!t)
                return !1;
            if ("JSXEmptyExpression" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isJSXExpressionContainer = function isJSXExpressionContainer(t, r) {
            if (!t)
                return !1;
            if ("JSXExpressionContainer" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isJSXFragment = function isJSXFragment(t, r) {
            if (!t)
                return !1;
            if ("JSXFragment" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isJSXIdentifier = function isJSXIdentifier(t, r) {
            if (!t)
                return !1;
            if ("JSXIdentifier" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isJSXMemberExpression = function isJSXMemberExpression(t, r) {
            if (!t)
                return !1;
            if ("JSXMemberExpression" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isJSXNamespacedName = function isJSXNamespacedName(t, r) {
            if (!t)
                return !1;
            if ("JSXNamespacedName" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isJSXOpeningElement = function isJSXOpeningElement(t, r) {
            if (!t)
                return !1;
            if ("JSXOpeningElement" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isJSXOpeningFragment = function isJSXOpeningFragment(t, r) {
            if (!t)
                return !1;
            if ("JSXOpeningFragment" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isJSXSpreadAttribute = function isJSXSpreadAttribute(t, r) {
            if (!t)
                return !1;
            if ("JSXSpreadAttribute" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isJSXSpreadChild = function isJSXSpreadChild(t, r) {
            if (!t)
                return !1;
            if ("JSXSpreadChild" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isJSXText = function isJSXText(t, r) {
            if (!t)
                return !1;
            if ("JSXText" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isLVal = function isLVal(t, r) {
            if (!t)
                return !1;
            const i = t.type;
            if ("Identifier" === i || "MemberExpression" === i || "RestElement" === i || "AssignmentPattern" === i || "ArrayPattern" === i || "ObjectPattern" === i || "TSParameterProperty" === i || "Placeholder" === i && ("Pattern" === t.expectedNode || "Identifier" === t.expectedNode))
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isLabeledStatement = function isLabeledStatement(t, r) {
            if (!t)
                return !1;
            if ("LabeledStatement" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isLiteral = function isLiteral(t, r) {
            if (!t)
                return !1;
            const i = t.type;
            if ("StringLiteral" === i || "NumericLiteral" === i || "NullLiteral" === i || "BooleanLiteral" === i || "RegExpLiteral" === i || "TemplateLiteral" === i || "BigIntLiteral" === i || "DecimalLiteral" === i || "Placeholder" === i && "StringLiteral" === t.expectedNode)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isLogicalExpression = function isLogicalExpression(t, r) {
            if (!t)
                return !1;
            if ("LogicalExpression" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isLoop = function isLoop(t, r) {
            if (!t)
                return !1;
            const i = t.type;
            if ("DoWhileStatement" === i || "ForInStatement" === i || "ForStatement" === i || "WhileStatement" === i || "ForOfStatement" === i)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isMemberExpression = function isMemberExpression(t, r) {
            if (!t)
                return !1;
            if ("MemberExpression" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isMetaProperty = function isMetaProperty(t, r) {
            if (!t)
                return !1;
            if ("MetaProperty" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isMethod = function isMethod(t, r) {
            if (!t)
                return !1;
            const i = t.type;
            if ("ObjectMethod" === i || "ClassMethod" === i || "ClassPrivateMethod" === i)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isMiscellaneous = function isMiscellaneous(t, r) {
            if (!t)
                return !1;
            const i = t.type;
            if ("Noop" === i || "Placeholder" === i || "V8IntrinsicIdentifier" === i)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isMixedTypeAnnotation = function isMixedTypeAnnotation(t, r) {
            if (!t)
                return !1;
            if ("MixedTypeAnnotation" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isModuleDeclaration = function isModuleDeclaration(t, r) {
            if (!t)
                return !1;
            const i = t.type;
            if ("ExportAllDeclaration" === i || "ExportDefaultDeclaration" === i || "ExportNamedDeclaration" === i || "ImportDeclaration" === i)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isModuleExpression = function isModuleExpression(t, r) {
            if (!t)
                return !1;
            if ("ModuleExpression" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isModuleSpecifier = function isModuleSpecifier(t, r) {
            if (!t)
                return !1;
            const i = t.type;
            if ("ExportSpecifier" === i || "ImportDefaultSpecifier" === i || "ImportNamespaceSpecifier" === i || "ImportSpecifier" === i || "ExportNamespaceSpecifier" === i || "ExportDefaultSpecifier" === i)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isNewExpression = function isNewExpression(t, r) {
            if (!t)
                return !1;
            if ("NewExpression" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isNoop = function isNoop(t, r) {
            if (!t)
                return !1;
            if ("Noop" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isNullLiteral = function isNullLiteral(t, r) {
            if (!t)
                return !1;
            if ("NullLiteral" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isNullLiteralTypeAnnotation = function isNullLiteralTypeAnnotation(t, r) {
            if (!t)
                return !1;
            if ("NullLiteralTypeAnnotation" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isNullableTypeAnnotation = function isNullableTypeAnnotation(t, r) {
            if (!t)
                return !1;
            if ("NullableTypeAnnotation" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isNumberLiteral = function isNumberLiteral(t, r) {
            if (console.trace("The node type NumberLiteral has been renamed to NumericLiteral"),
            !t)
                return !1;
            if ("NumberLiteral" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isNumberLiteralTypeAnnotation = function isNumberLiteralTypeAnnotation(t, r) {
            if (!t)
                return !1;
            if ("NumberLiteralTypeAnnotation" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isNumberTypeAnnotation = function isNumberTypeAnnotation(t, r) {
            if (!t)
                return !1;
            if ("NumberTypeAnnotation" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isNumericLiteral = function isNumericLiteral(t, r) {
            if (!t)
                return !1;
            if ("NumericLiteral" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isObjectExpression = function isObjectExpression(t, r) {
            if (!t)
                return !1;
            if ("ObjectExpression" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isObjectMember = function isObjectMember(t, r) {
            if (!t)
                return !1;
            const i = t.type;
            if ("ObjectMethod" === i || "ObjectProperty" === i)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isObjectMethod = function isObjectMethod(t, r) {
            if (!t)
                return !1;
            if ("ObjectMethod" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isObjectPattern = function isObjectPattern(t, r) {
            if (!t)
                return !1;
            if ("ObjectPattern" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isObjectProperty = function isObjectProperty(t, r) {
            if (!t)
                return !1;
            if ("ObjectProperty" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isObjectTypeAnnotation = function isObjectTypeAnnotation(t, r) {
            if (!t)
                return !1;
            if ("ObjectTypeAnnotation" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isObjectTypeCallProperty = function isObjectTypeCallProperty(t, r) {
            if (!t)
                return !1;
            if ("ObjectTypeCallProperty" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isObjectTypeIndexer = function isObjectTypeIndexer(t, r) {
            if (!t)
                return !1;
            if ("ObjectTypeIndexer" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isObjectTypeInternalSlot = function isObjectTypeInternalSlot(t, r) {
            if (!t)
                return !1;
            if ("ObjectTypeInternalSlot" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isObjectTypeProperty = function isObjectTypeProperty(t, r) {
            if (!t)
                return !1;
            if ("ObjectTypeProperty" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isObjectTypeSpreadProperty = function isObjectTypeSpreadProperty(t, r) {
            if (!t)
                return !1;
            if ("ObjectTypeSpreadProperty" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isOpaqueType = function isOpaqueType(t, r) {
            if (!t)
                return !1;
            if ("OpaqueType" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isOptionalCallExpression = function isOptionalCallExpression(t, r) {
            if (!t)
                return !1;
            if ("OptionalCallExpression" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isOptionalIndexedAccessType = function isOptionalIndexedAccessType(t, r) {
            if (!t)
                return !1;
            if ("OptionalIndexedAccessType" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isOptionalMemberExpression = function isOptionalMemberExpression(t, r) {
            if (!t)
                return !1;
            if ("OptionalMemberExpression" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isParenthesizedExpression = function isParenthesizedExpression(t, r) {
            if (!t)
                return !1;
            if ("ParenthesizedExpression" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isPattern = function isPattern(t, r) {
            if (!t)
                return !1;
            const i = t.type;
            if ("AssignmentPattern" === i || "ArrayPattern" === i || "ObjectPattern" === i || "Placeholder" === i && "Pattern" === t.expectedNode)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isPatternLike = function isPatternLike(t, r) {
            if (!t)
                return !1;
            const i = t.type;
            if ("Identifier" === i || "RestElement" === i || "AssignmentPattern" === i || "ArrayPattern" === i || "ObjectPattern" === i || "Placeholder" === i && ("Pattern" === t.expectedNode || "Identifier" === t.expectedNode))
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isPipelineBareFunction = function isPipelineBareFunction(t, r) {
            if (!t)
                return !1;
            if ("PipelineBareFunction" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isPipelinePrimaryTopicReference = function isPipelinePrimaryTopicReference(t, r) {
            if (!t)
                return !1;
            if ("PipelinePrimaryTopicReference" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isPipelineTopicExpression = function isPipelineTopicExpression(t, r) {
            if (!t)
                return !1;
            if ("PipelineTopicExpression" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isPlaceholder = function isPlaceholder(t, r) {
            if (!t)
                return !1;
            if ("Placeholder" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isPrivate = function isPrivate(t, r) {
            if (!t)
                return !1;
            const i = t.type;
            if ("ClassPrivateProperty" === i || "ClassPrivateMethod" === i || "PrivateName" === i)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isPrivateName = function isPrivateName(t, r) {
            if (!t)
                return !1;
            if ("PrivateName" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isProgram = function isProgram(t, r) {
            if (!t)
                return !1;
            if ("Program" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isProperty = function isProperty(t, r) {
            if (!t)
                return !1;
            const i = t.type;
            if ("ObjectProperty" === i || "ClassProperty" === i || "ClassPrivateProperty" === i)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isPureish = function isPureish(t, r) {
            if (!t)
                return !1;
            const i = t.type;
            if ("FunctionDeclaration" === i || "FunctionExpression" === i || "StringLiteral" === i || "NumericLiteral" === i || "NullLiteral" === i || "BooleanLiteral" === i || "RegExpLiteral" === i || "ArrowFunctionExpression" === i || "BigIntLiteral" === i || "DecimalLiteral" === i || "Placeholder" === i && "StringLiteral" === t.expectedNode)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isQualifiedTypeIdentifier = function isQualifiedTypeIdentifier(t, r) {
            if (!t)
                return !1;
            if ("QualifiedTypeIdentifier" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isRecordExpression = function isRecordExpression(t, r) {
            if (!t)
                return !1;
            if ("RecordExpression" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isRegExpLiteral = function isRegExpLiteral(t, r) {
            if (!t)
                return !1;
            if ("RegExpLiteral" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isRegexLiteral = function isRegexLiteral(t, r) {
            if (console.trace("The node type RegexLiteral has been renamed to RegExpLiteral"),
            !t)
                return !1;
            if ("RegexLiteral" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isRestElement = function isRestElement(t, r) {
            if (!t)
                return !1;
            if ("RestElement" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isRestProperty = function isRestProperty(t, r) {
            if (console.trace("The node type RestProperty has been renamed to RestElement"),
            !t)
                return !1;
            if ("RestProperty" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isReturnStatement = function isReturnStatement(t, r) {
            if (!t)
                return !1;
            if ("ReturnStatement" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isScopable = function isScopable(t, r) {
            if (!t)
                return !1;
            const i = t.type;
            if ("BlockStatement" === i || "CatchClause" === i || "DoWhileStatement" === i || "ForInStatement" === i || "ForStatement" === i || "FunctionDeclaration" === i || "FunctionExpression" === i || "Program" === i || "ObjectMethod" === i || "SwitchStatement" === i || "WhileStatement" === i || "ArrowFunctionExpression" === i || "ClassExpression" === i || "ClassDeclaration" === i || "ForOfStatement" === i || "ClassMethod" === i || "ClassPrivateMethod" === i || "StaticBlock" === i || "TSModuleBlock" === i || "Placeholder" === i && "BlockStatement" === t.expectedNode)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isSequenceExpression = function isSequenceExpression(t, r) {
            if (!t)
                return !1;
            if ("SequenceExpression" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isSpreadElement = function isSpreadElement(t, r) {
            if (!t)
                return !1;
            if ("SpreadElement" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isSpreadProperty = function isSpreadProperty(t, r) {
            if (console.trace("The node type SpreadProperty has been renamed to SpreadElement"),
            !t)
                return !1;
            if ("SpreadProperty" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isStandardized = function isStandardized(t, r) {
            if (!t)
                return !1;
            const i = t.type;
            if ("ArrayExpression" === i || "AssignmentExpression" === i || "BinaryExpression" === i || "InterpreterDirective" === i || "Directive" === i || "DirectiveLiteral" === i || "BlockStatement" === i || "BreakStatement" === i || "CallExpression" === i || "CatchClause" === i || "ConditionalExpression" === i || "ContinueStatement" === i || "DebuggerStatement" === i || "DoWhileStatement" === i || "EmptyStatement" === i || "ExpressionStatement" === i || "File" === i || "ForInStatement" === i || "ForStatement" === i || "FunctionDeclaration" === i || "FunctionExpression" === i || "Identifier" === i || "IfStatement" === i || "LabeledStatement" === i || "StringLiteral" === i || "NumericLiteral" === i || "NullLiteral" === i || "BooleanLiteral" === i || "RegExpLiteral" === i || "LogicalExpression" === i || "MemberExpression" === i || "NewExpression" === i || "Program" === i || "ObjectExpression" === i || "ObjectMethod" === i || "ObjectProperty" === i || "RestElement" === i || "ReturnStatement" === i || "SequenceExpression" === i || "ParenthesizedExpression" === i || "SwitchCase" === i || "SwitchStatement" === i || "ThisExpression" === i || "ThrowStatement" === i || "TryStatement" === i || "UnaryExpression" === i || "UpdateExpression" === i || "VariableDeclaration" === i || "VariableDeclarator" === i || "WhileStatement" === i || "WithStatement" === i || "AssignmentPattern" === i || "ArrayPattern" === i || "ArrowFunctionExpression" === i || "ClassBody" === i || "ClassExpression" === i || "ClassDeclaration" === i || "ExportAllDeclaration" === i || "ExportDefaultDeclaration" === i || "ExportNamedDeclaration" === i || "ExportSpecifier" === i || "ForOfStatement" === i || "ImportDeclaration" === i || "ImportDefaultSpecifier" === i || "ImportNamespaceSpecifier" === i || "ImportSpecifier" === i || "MetaProperty" === i || "ClassMethod" === i || "ObjectPattern" === i || "SpreadElement" === i || "Super" === i || "TaggedTemplateExpression" === i || "TemplateElement" === i || "TemplateLiteral" === i || "YieldExpression" === i || "AwaitExpression" === i || "Import" === i || "BigIntLiteral" === i || "ExportNamespaceSpecifier" === i || "OptionalMemberExpression" === i || "OptionalCallExpression" === i || "ClassProperty" === i || "ClassPrivateProperty" === i || "ClassPrivateMethod" === i || "PrivateName" === i || "StaticBlock" === i || "Placeholder" === i && ("Identifier" === t.expectedNode || "StringLiteral" === t.expectedNode || "BlockStatement" === t.expectedNode || "ClassBody" === t.expectedNode))
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isStatement = function isStatement(t, r) {
            if (!t)
                return !1;
            const i = t.type;
            if ("BlockStatement" === i || "BreakStatement" === i || "ContinueStatement" === i || "DebuggerStatement" === i || "DoWhileStatement" === i || "EmptyStatement" === i || "ExpressionStatement" === i || "ForInStatement" === i || "ForStatement" === i || "FunctionDeclaration" === i || "IfStatement" === i || "LabeledStatement" === i || "ReturnStatement" === i || "SwitchStatement" === i || "ThrowStatement" === i || "TryStatement" === i || "VariableDeclaration" === i || "WhileStatement" === i || "WithStatement" === i || "ClassDeclaration" === i || "ExportAllDeclaration" === i || "ExportDefaultDeclaration" === i || "ExportNamedDeclaration" === i || "ForOfStatement" === i || "ImportDeclaration" === i || "DeclareClass" === i || "DeclareFunction" === i || "DeclareInterface" === i || "DeclareModule" === i || "DeclareModuleExports" === i || "DeclareTypeAlias" === i || "DeclareOpaqueType" === i || "DeclareVariable" === i || "DeclareExportDeclaration" === i || "DeclareExportAllDeclaration" === i || "InterfaceDeclaration" === i || "OpaqueType" === i || "TypeAlias" === i || "EnumDeclaration" === i || "TSDeclareFunction" === i || "TSInterfaceDeclaration" === i || "TSTypeAliasDeclaration" === i || "TSEnumDeclaration" === i || "TSModuleDeclaration" === i || "TSImportEqualsDeclaration" === i || "TSExportAssignment" === i || "TSNamespaceExportDeclaration" === i || "Placeholder" === i && ("Statement" === t.expectedNode || "Declaration" === t.expectedNode || "BlockStatement" === t.expectedNode))
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isStaticBlock = function isStaticBlock(t, r) {
            if (!t)
                return !1;
            if ("StaticBlock" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isStringLiteral = function isStringLiteral(t, r) {
            if (!t)
                return !1;
            if ("StringLiteral" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isStringLiteralTypeAnnotation = function isStringLiteralTypeAnnotation(t, r) {
            if (!t)
                return !1;
            if ("StringLiteralTypeAnnotation" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isStringTypeAnnotation = function isStringTypeAnnotation(t, r) {
            if (!t)
                return !1;
            if ("StringTypeAnnotation" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isSuper = function isSuper(t, r) {
            if (!t)
                return !1;
            if ("Super" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isSwitchCase = function isSwitchCase(t, r) {
            if (!t)
                return !1;
            if ("SwitchCase" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isSwitchStatement = function isSwitchStatement(t, r) {
            if (!t)
                return !1;
            if ("SwitchStatement" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isSymbolTypeAnnotation = function isSymbolTypeAnnotation(t, r) {
            if (!t)
                return !1;
            if ("SymbolTypeAnnotation" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSAnyKeyword = function isTSAnyKeyword(t, r) {
            if (!t)
                return !1;
            if ("TSAnyKeyword" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSArrayType = function isTSArrayType(t, r) {
            if (!t)
                return !1;
            if ("TSArrayType" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSAsExpression = function isTSAsExpression(t, r) {
            if (!t)
                return !1;
            if ("TSAsExpression" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSBaseType = function isTSBaseType(t, r) {
            if (!t)
                return !1;
            const i = t.type;
            if ("TSAnyKeyword" === i || "TSBooleanKeyword" === i || "TSBigIntKeyword" === i || "TSIntrinsicKeyword" === i || "TSNeverKeyword" === i || "TSNullKeyword" === i || "TSNumberKeyword" === i || "TSObjectKeyword" === i || "TSStringKeyword" === i || "TSSymbolKeyword" === i || "TSUndefinedKeyword" === i || "TSUnknownKeyword" === i || "TSVoidKeyword" === i || "TSThisType" === i || "TSLiteralType" === i)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSBigIntKeyword = function isTSBigIntKeyword(t, r) {
            if (!t)
                return !1;
            if ("TSBigIntKeyword" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSBooleanKeyword = function isTSBooleanKeyword(t, r) {
            if (!t)
                return !1;
            if ("TSBooleanKeyword" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSCallSignatureDeclaration = function isTSCallSignatureDeclaration(t, r) {
            if (!t)
                return !1;
            if ("TSCallSignatureDeclaration" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSConditionalType = function isTSConditionalType(t, r) {
            if (!t)
                return !1;
            if ("TSConditionalType" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSConstructSignatureDeclaration = function isTSConstructSignatureDeclaration(t, r) {
            if (!t)
                return !1;
            if ("TSConstructSignatureDeclaration" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSConstructorType = function isTSConstructorType(t, r) {
            if (!t)
                return !1;
            if ("TSConstructorType" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSDeclareFunction = function isTSDeclareFunction(t, r) {
            if (!t)
                return !1;
            if ("TSDeclareFunction" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSDeclareMethod = function isTSDeclareMethod(t, r) {
            if (!t)
                return !1;
            if ("TSDeclareMethod" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSEntityName = function isTSEntityName(t, r) {
            if (!t)
                return !1;
            const i = t.type;
            if ("Identifier" === i || "TSQualifiedName" === i || "Placeholder" === i && "Identifier" === t.expectedNode)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSEnumDeclaration = function isTSEnumDeclaration(t, r) {
            if (!t)
                return !1;
            if ("TSEnumDeclaration" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSEnumMember = function isTSEnumMember(t, r) {
            if (!t)
                return !1;
            if ("TSEnumMember" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSExportAssignment = function isTSExportAssignment(t, r) {
            if (!t)
                return !1;
            if ("TSExportAssignment" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSExpressionWithTypeArguments = function isTSExpressionWithTypeArguments(t, r) {
            if (!t)
                return !1;
            if ("TSExpressionWithTypeArguments" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSExternalModuleReference = function isTSExternalModuleReference(t, r) {
            if (!t)
                return !1;
            if ("TSExternalModuleReference" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSFunctionType = function isTSFunctionType(t, r) {
            if (!t)
                return !1;
            if ("TSFunctionType" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSImportEqualsDeclaration = function isTSImportEqualsDeclaration(t, r) {
            if (!t)
                return !1;
            if ("TSImportEqualsDeclaration" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSImportType = function isTSImportType(t, r) {
            if (!t)
                return !1;
            if ("TSImportType" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSIndexSignature = function isTSIndexSignature(t, r) {
            if (!t)
                return !1;
            if ("TSIndexSignature" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSIndexedAccessType = function isTSIndexedAccessType(t, r) {
            if (!t)
                return !1;
            if ("TSIndexedAccessType" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSInferType = function isTSInferType(t, r) {
            if (!t)
                return !1;
            if ("TSInferType" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSInterfaceBody = function isTSInterfaceBody(t, r) {
            if (!t)
                return !1;
            if ("TSInterfaceBody" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSInterfaceDeclaration = function isTSInterfaceDeclaration(t, r) {
            if (!t)
                return !1;
            if ("TSInterfaceDeclaration" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSIntersectionType = function isTSIntersectionType(t, r) {
            if (!t)
                return !1;
            if ("TSIntersectionType" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSIntrinsicKeyword = function isTSIntrinsicKeyword(t, r) {
            if (!t)
                return !1;
            if ("TSIntrinsicKeyword" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSLiteralType = function isTSLiteralType(t, r) {
            if (!t)
                return !1;
            if ("TSLiteralType" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSMappedType = function isTSMappedType(t, r) {
            if (!t)
                return !1;
            if ("TSMappedType" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSMethodSignature = function isTSMethodSignature(t, r) {
            if (!t)
                return !1;
            if ("TSMethodSignature" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSModuleBlock = function isTSModuleBlock(t, r) {
            if (!t)
                return !1;
            if ("TSModuleBlock" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSModuleDeclaration = function isTSModuleDeclaration(t, r) {
            if (!t)
                return !1;
            if ("TSModuleDeclaration" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSNamedTupleMember = function isTSNamedTupleMember(t, r) {
            if (!t)
                return !1;
            if ("TSNamedTupleMember" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSNamespaceExportDeclaration = function isTSNamespaceExportDeclaration(t, r) {
            if (!t)
                return !1;
            if ("TSNamespaceExportDeclaration" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSNeverKeyword = function isTSNeverKeyword(t, r) {
            if (!t)
                return !1;
            if ("TSNeverKeyword" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSNonNullExpression = function isTSNonNullExpression(t, r) {
            if (!t)
                return !1;
            if ("TSNonNullExpression" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSNullKeyword = function isTSNullKeyword(t, r) {
            if (!t)
                return !1;
            if ("TSNullKeyword" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSNumberKeyword = function isTSNumberKeyword(t, r) {
            if (!t)
                return !1;
            if ("TSNumberKeyword" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSObjectKeyword = function isTSObjectKeyword(t, r) {
            if (!t)
                return !1;
            if ("TSObjectKeyword" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSOptionalType = function isTSOptionalType(t, r) {
            if (!t)
                return !1;
            if ("TSOptionalType" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSParameterProperty = function isTSParameterProperty(t, r) {
            if (!t)
                return !1;
            if ("TSParameterProperty" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSParenthesizedType = function isTSParenthesizedType(t, r) {
            if (!t)
                return !1;
            if ("TSParenthesizedType" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSPropertySignature = function isTSPropertySignature(t, r) {
            if (!t)
                return !1;
            if ("TSPropertySignature" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSQualifiedName = function isTSQualifiedName(t, r) {
            if (!t)
                return !1;
            if ("TSQualifiedName" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSRestType = function isTSRestType(t, r) {
            if (!t)
                return !1;
            if ("TSRestType" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSStringKeyword = function isTSStringKeyword(t, r) {
            if (!t)
                return !1;
            if ("TSStringKeyword" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSSymbolKeyword = function isTSSymbolKeyword(t, r) {
            if (!t)
                return !1;
            if ("TSSymbolKeyword" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSThisType = function isTSThisType(t, r) {
            if (!t)
                return !1;
            if ("TSThisType" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSTupleType = function isTSTupleType(t, r) {
            if (!t)
                return !1;
            if ("TSTupleType" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSType = function isTSType(t, r) {
            if (!t)
                return !1;
            const i = t.type;
            if ("TSAnyKeyword" === i || "TSBooleanKeyword" === i || "TSBigIntKeyword" === i || "TSIntrinsicKeyword" === i || "TSNeverKeyword" === i || "TSNullKeyword" === i || "TSNumberKeyword" === i || "TSObjectKeyword" === i || "TSStringKeyword" === i || "TSSymbolKeyword" === i || "TSUndefinedKeyword" === i || "TSUnknownKeyword" === i || "TSVoidKeyword" === i || "TSThisType" === i || "TSFunctionType" === i || "TSConstructorType" === i || "TSTypeReference" === i || "TSTypePredicate" === i || "TSTypeQuery" === i || "TSTypeLiteral" === i || "TSArrayType" === i || "TSTupleType" === i || "TSOptionalType" === i || "TSRestType" === i || "TSUnionType" === i || "TSIntersectionType" === i || "TSConditionalType" === i || "TSInferType" === i || "TSParenthesizedType" === i || "TSTypeOperator" === i || "TSIndexedAccessType" === i || "TSMappedType" === i || "TSLiteralType" === i || "TSExpressionWithTypeArguments" === i || "TSImportType" === i)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSTypeAliasDeclaration = function isTSTypeAliasDeclaration(t, r) {
            if (!t)
                return !1;
            if ("TSTypeAliasDeclaration" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSTypeAnnotation = function isTSTypeAnnotation(t, r) {
            if (!t)
                return !1;
            if ("TSTypeAnnotation" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSTypeAssertion = function isTSTypeAssertion(t, r) {
            if (!t)
                return !1;
            if ("TSTypeAssertion" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSTypeElement = function isTSTypeElement(t, r) {
            if (!t)
                return !1;
            const i = t.type;
            if ("TSCallSignatureDeclaration" === i || "TSConstructSignatureDeclaration" === i || "TSPropertySignature" === i || "TSMethodSignature" === i || "TSIndexSignature" === i)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSTypeLiteral = function isTSTypeLiteral(t, r) {
            if (!t)
                return !1;
            if ("TSTypeLiteral" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSTypeOperator = function isTSTypeOperator(t, r) {
            if (!t)
                return !1;
            if ("TSTypeOperator" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSTypeParameter = function isTSTypeParameter(t, r) {
            if (!t)
                return !1;
            if ("TSTypeParameter" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSTypeParameterDeclaration = function isTSTypeParameterDeclaration(t, r) {
            if (!t)
                return !1;
            if ("TSTypeParameterDeclaration" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSTypeParameterInstantiation = function isTSTypeParameterInstantiation(t, r) {
            if (!t)
                return !1;
            if ("TSTypeParameterInstantiation" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSTypePredicate = function isTSTypePredicate(t, r) {
            if (!t)
                return !1;
            if ("TSTypePredicate" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSTypeQuery = function isTSTypeQuery(t, r) {
            if (!t)
                return !1;
            if ("TSTypeQuery" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSTypeReference = function isTSTypeReference(t, r) {
            if (!t)
                return !1;
            if ("TSTypeReference" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSUndefinedKeyword = function isTSUndefinedKeyword(t, r) {
            if (!t)
                return !1;
            if ("TSUndefinedKeyword" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSUnionType = function isTSUnionType(t, r) {
            if (!t)
                return !1;
            if ("TSUnionType" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSUnknownKeyword = function isTSUnknownKeyword(t, r) {
            if (!t)
                return !1;
            if ("TSUnknownKeyword" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTSVoidKeyword = function isTSVoidKeyword(t, r) {
            if (!t)
                return !1;
            if ("TSVoidKeyword" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTaggedTemplateExpression = function isTaggedTemplateExpression(t, r) {
            if (!t)
                return !1;
            if ("TaggedTemplateExpression" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTemplateElement = function isTemplateElement(t, r) {
            if (!t)
                return !1;
            if ("TemplateElement" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTemplateLiteral = function isTemplateLiteral(t, r) {
            if (!t)
                return !1;
            if ("TemplateLiteral" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTerminatorless = function isTerminatorless(t, r) {
            if (!t)
                return !1;
            const i = t.type;
            if ("BreakStatement" === i || "ContinueStatement" === i || "ReturnStatement" === i || "ThrowStatement" === i || "YieldExpression" === i || "AwaitExpression" === i)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isThisExpression = function isThisExpression(t, r) {
            if (!t)
                return !1;
            if ("ThisExpression" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isThisTypeAnnotation = function isThisTypeAnnotation(t, r) {
            if (!t)
                return !1;
            if ("ThisTypeAnnotation" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isThrowStatement = function isThrowStatement(t, r) {
            if (!t)
                return !1;
            if ("ThrowStatement" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTopicReference = function isTopicReference(t, r) {
            if (!t)
                return !1;
            if ("TopicReference" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTryStatement = function isTryStatement(t, r) {
            if (!t)
                return !1;
            if ("TryStatement" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTupleExpression = function isTupleExpression(t, r) {
            if (!t)
                return !1;
            if ("TupleExpression" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTupleTypeAnnotation = function isTupleTypeAnnotation(t, r) {
            if (!t)
                return !1;
            if ("TupleTypeAnnotation" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTypeAlias = function isTypeAlias(t, r) {
            if (!t)
                return !1;
            if ("TypeAlias" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTypeAnnotation = function isTypeAnnotation(t, r) {
            if (!t)
                return !1;
            if ("TypeAnnotation" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTypeCastExpression = function isTypeCastExpression(t, r) {
            if (!t)
                return !1;
            if ("TypeCastExpression" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTypeParameter = function isTypeParameter(t, r) {
            if (!t)
                return !1;
            if ("TypeParameter" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTypeParameterDeclaration = function isTypeParameterDeclaration(t, r) {
            if (!t)
                return !1;
            if ("TypeParameterDeclaration" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTypeParameterInstantiation = function isTypeParameterInstantiation(t, r) {
            if (!t)
                return !1;
            if ("TypeParameterInstantiation" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTypeScript = function isTypeScript(t, r) {
            if (!t)
                return !1;
            const i = t.type;
            if ("TSParameterProperty" === i || "TSDeclareFunction" === i || "TSDeclareMethod" === i || "TSQualifiedName" === i || "TSCallSignatureDeclaration" === i || "TSConstructSignatureDeclaration" === i || "TSPropertySignature" === i || "TSMethodSignature" === i || "TSIndexSignature" === i || "TSAnyKeyword" === i || "TSBooleanKeyword" === i || "TSBigIntKeyword" === i || "TSIntrinsicKeyword" === i || "TSNeverKeyword" === i || "TSNullKeyword" === i || "TSNumberKeyword" === i || "TSObjectKeyword" === i || "TSStringKeyword" === i || "TSSymbolKeyword" === i || "TSUndefinedKeyword" === i || "TSUnknownKeyword" === i || "TSVoidKeyword" === i || "TSThisType" === i || "TSFunctionType" === i || "TSConstructorType" === i || "TSTypeReference" === i || "TSTypePredicate" === i || "TSTypeQuery" === i || "TSTypeLiteral" === i || "TSArrayType" === i || "TSTupleType" === i || "TSOptionalType" === i || "TSRestType" === i || "TSNamedTupleMember" === i || "TSUnionType" === i || "TSIntersectionType" === i || "TSConditionalType" === i || "TSInferType" === i || "TSParenthesizedType" === i || "TSTypeOperator" === i || "TSIndexedAccessType" === i || "TSMappedType" === i || "TSLiteralType" === i || "TSExpressionWithTypeArguments" === i || "TSInterfaceDeclaration" === i || "TSInterfaceBody" === i || "TSTypeAliasDeclaration" === i || "TSAsExpression" === i || "TSTypeAssertion" === i || "TSEnumDeclaration" === i || "TSEnumMember" === i || "TSModuleDeclaration" === i || "TSModuleBlock" === i || "TSImportType" === i || "TSImportEqualsDeclaration" === i || "TSExternalModuleReference" === i || "TSNonNullExpression" === i || "TSExportAssignment" === i || "TSNamespaceExportDeclaration" === i || "TSTypeAnnotation" === i || "TSTypeParameterInstantiation" === i || "TSTypeParameterDeclaration" === i || "TSTypeParameter" === i)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isTypeofTypeAnnotation = function isTypeofTypeAnnotation(t, r) {
            if (!t)
                return !1;
            if ("TypeofTypeAnnotation" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isUnaryExpression = function isUnaryExpression(t, r) {
            if (!t)
                return !1;
            if ("UnaryExpression" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isUnaryLike = function isUnaryLike(t, r) {
            if (!t)
                return !1;
            const i = t.type;
            if ("UnaryExpression" === i || "SpreadElement" === i)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isUnionTypeAnnotation = function isUnionTypeAnnotation(t, r) {
            if (!t)
                return !1;
            if ("UnionTypeAnnotation" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isUpdateExpression = function isUpdateExpression(t, r) {
            if (!t)
                return !1;
            if ("UpdateExpression" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isUserWhitespacable = function isUserWhitespacable(t, r) {
            if (!t)
                return !1;
            const i = t.type;
            if ("ObjectMethod" === i || "ObjectProperty" === i || "ObjectTypeInternalSlot" === i || "ObjectTypeCallProperty" === i || "ObjectTypeIndexer" === i || "ObjectTypeProperty" === i || "ObjectTypeSpreadProperty" === i)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isV8IntrinsicIdentifier = function isV8IntrinsicIdentifier(t, r) {
            if (!t)
                return !1;
            if ("V8IntrinsicIdentifier" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isVariableDeclaration = function isVariableDeclaration(t, r) {
            if (!t)
                return !1;
            if ("VariableDeclaration" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isVariableDeclarator = function isVariableDeclarator(t, r) {
            if (!t)
                return !1;
            if ("VariableDeclarator" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isVariance = function isVariance(t, r) {
            if (!t)
                return !1;
            if ("Variance" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isVoidTypeAnnotation = function isVoidTypeAnnotation(t, r) {
            if (!t)
                return !1;
            if ("VoidTypeAnnotation" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isWhile = function isWhile(t, r) {
            if (!t)
                return !1;
            const i = t.type;
            if ("DoWhileStatement" === i || "WhileStatement" === i)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isWhileStatement = function isWhileStatement(t, r) {
            if (!t)
                return !1;
            if ("WhileStatement" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isWithStatement = function isWithStatement(t, r) {
            if (!t)
                return !1;
            if ("WithStatement" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ,
        r.isYieldExpression = function isYieldExpression(t, r) {
            if (!t)
                return !1;
            if ("YieldExpression" === t.type)
                return void 0 === r || (0,
                a.default)(t, r);
            return !1
        }
        ;
        var a = i("OS6d")
    },
    xJ6i: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function toSequenceExpression(t, r) {
            if (null == t || !t.length)
                return;
            const i = []
              , o = (0,
            a.default)(t, r, i);
            if (!o)
                return;
            for (const t of i)
                r.push(t);
            return o
        }
        ;
        var a = i("c700")
    },
    "xl6+": function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function cloneDeep(t) {
            return (0,
            a.default)(t)
        }
        ;
        var a = i("v3g0")
    },
    xu3U: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function appendToMemberExpression(t, r) {
            var i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
            return t.object = (0,
            a.memberExpression)(t.object, t.property, t.computed),
            t.property = r,
            t.computed = !!i,
            t
        }
        ;
        var a = i("57mi")
    },
    "yK+d": function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function isValidIdentifier(t) {
            var r = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
            if ("string" != typeof t)
                return !1;
            if (r && ((0,
            a.isKeyword)(t) || (0,
            a.isStrictReservedWord)(t, !0)))
                return !1;
            return (0,
            a.isIdentifierName)(t)
        }
        ;
        var a = i("KPS7")
    },
    yKLv: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.VariableDeclarator = function VariableDeclarator() {
            var t;
            if (!this.get("id").isIdentifier())
                return;
            var r = this.get("init")
              , i = r.getTypeAnnotation();
            "AnyTypeAnnotation" === (null == (t = i) ? void 0 : t.type) && r.isCallExpression() && r.get("callee").isIdentifier({
                name: "Array"
            }) && !r.scope.hasBinding("Array", !0) && (i = ArrayExpression());
            return i
        }
        ,
        r.TypeCastExpression = TypeCastExpression,
        r.NewExpression = function NewExpression(t) {
            if (this.get("callee").isIdentifier())
                return a.genericTypeAnnotation(t.callee)
        }
        ,
        r.TemplateLiteral = function TemplateLiteral() {
            return a.stringTypeAnnotation()
        }
        ,
        r.UnaryExpression = function UnaryExpression(t) {
            var r = t.operator;
            if ("void" === r)
                return a.voidTypeAnnotation();
            if (a.NUMBER_UNARY_OPERATORS.indexOf(r) >= 0)
                return a.numberTypeAnnotation();
            if (a.STRING_UNARY_OPERATORS.indexOf(r) >= 0)
                return a.stringTypeAnnotation();
            if (a.BOOLEAN_UNARY_OPERATORS.indexOf(r) >= 0)
                return a.booleanTypeAnnotation()
        }
        ,
        r.BinaryExpression = function BinaryExpression(t) {
            var r = t.operator;
            if (a.NUMBER_BINARY_OPERATORS.indexOf(r) >= 0)
                return a.numberTypeAnnotation();
            if (a.BOOLEAN_BINARY_OPERATORS.indexOf(r) >= 0)
                return a.booleanTypeAnnotation();
            if ("+" === r) {
                var i = this.get("right")
                  , o = this.get("left");
                return o.isBaseType("number") && i.isBaseType("number") ? a.numberTypeAnnotation() : o.isBaseType("string") || i.isBaseType("string") ? a.stringTypeAnnotation() : a.unionTypeAnnotation([a.stringTypeAnnotation(), a.numberTypeAnnotation()])
            }
        }
        ,
        r.LogicalExpression = function LogicalExpression() {
            var t = [this.get("left").getTypeAnnotation(), this.get("right").getTypeAnnotation()];
            if (a.isTSTypeAnnotation(t[0]) && a.createTSUnionType)
                return a.createTSUnionType(t);
            if (a.createFlowUnionType)
                return a.createFlowUnionType(t);
            return a.createUnionTypeAnnotation(t)
        }
        ,
        r.ConditionalExpression = function ConditionalExpression() {
            var t = [this.get("consequent").getTypeAnnotation(), this.get("alternate").getTypeAnnotation()];
            if (a.isTSTypeAnnotation(t[0]) && a.createTSUnionType)
                return a.createTSUnionType(t);
            if (a.createFlowUnionType)
                return a.createFlowUnionType(t);
            return a.createUnionTypeAnnotation(t)
        }
        ,
        r.SequenceExpression = function SequenceExpression() {
            return this.get("expressions").pop().getTypeAnnotation()
        }
        ,
        r.ParenthesizedExpression = function ParenthesizedExpression() {
            return this.get("expression").getTypeAnnotation()
        }
        ,
        r.AssignmentExpression = function AssignmentExpression() {
            return this.get("right").getTypeAnnotation()
        }
        ,
        r.UpdateExpression = function UpdateExpression(t) {
            var r = t.operator;
            if ("++" === r || "--" === r)
                return a.numberTypeAnnotation()
        }
        ,
        r.StringLiteral = function StringLiteral() {
            return a.stringTypeAnnotation()
        }
        ,
        r.NumericLiteral = function NumericLiteral() {
            return a.numberTypeAnnotation()
        }
        ,
        r.BooleanLiteral = function BooleanLiteral() {
            return a.booleanTypeAnnotation()
        }
        ,
        r.NullLiteral = function NullLiteral() {
            return a.nullLiteralTypeAnnotation()
        }
        ,
        r.RegExpLiteral = function RegExpLiteral() {
            return a.genericTypeAnnotation(a.identifier("RegExp"))
        }
        ,
        r.ObjectExpression = function ObjectExpression() {
            return a.genericTypeAnnotation(a.identifier("Object"))
        }
        ,
        r.ArrayExpression = ArrayExpression,
        r.RestElement = RestElement,
        r.ClassDeclaration = r.ClassExpression = r.FunctionDeclaration = r.ArrowFunctionExpression = r.FunctionExpression = function Func() {
            return a.genericTypeAnnotation(a.identifier("Function"))
        }
        ,
        r.CallExpression = function CallExpression() {
            var t = this.node.callee;
            if (u(t))
                return a.arrayTypeAnnotation(a.stringTypeAnnotation());
            if (l(t) || p(t))
                return a.arrayTypeAnnotation(a.anyTypeAnnotation());
            if (c(t))
                return a.arrayTypeAnnotation(a.tupleTypeAnnotation([a.stringTypeAnnotation(), a.anyTypeAnnotation()]));
            return resolveCall(this.get("callee"))
        }
        ,
        r.TaggedTemplateExpression = function TaggedTemplateExpression() {
            return resolveCall(this.get("tag"))
        }
        ,
        Object.defineProperty(r, "Identifier", {
            enumerable: !0,
            get: function get() {
                return o.default
            }
        });
        var a = i("ZtNB")
          , o = i("nlFN");
        function TypeCastExpression(t) {
            return t.typeAnnotation
        }
        function ArrayExpression() {
            return a.genericTypeAnnotation(a.identifier("Array"))
        }
        function RestElement() {
            return ArrayExpression()
        }
        TypeCastExpression.validParent = !0,
        RestElement.validParent = !0;
        var l = a.buildMatchMemberExpression("Array.from")
          , u = a.buildMatchMemberExpression("Object.keys")
          , p = a.buildMatchMemberExpression("Object.values")
          , c = a.buildMatchMemberExpression("Object.entries");
        function resolveCall(t) {
            if ((t = t.resolve()).isFunction()) {
                if (t.is("async"))
                    return t.is("generator") ? a.genericTypeAnnotation(a.identifier("AsyncIterator")) : a.genericTypeAnnotation(a.identifier("Promise"));
                if (t.node.returnType)
                    return t.node.returnType
            }
        }
    },
    yKvr: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function highlight(t, r={}) {
            if ("" !== t && shouldHighlight(r)) {
                return function highlightTokens(t, r) {
                    let i = "";
                    for (const {type: a, value: o} of d(r)) {
                        const r = t[a];
                        i += r ? o.split(p).map(t=>r(t)).join("\n") : o
                    }
                    return i
                }(function getDefs(t) {
                    return {
                        keyword: t.cyan,
                        capitalized: t.yellow,
                        jsxIdentifier: t.yellow,
                        punctuator: t.yellow,
                        number: t.magenta,
                        string: t.green,
                        regex: t.magenta,
                        comment: t.grey,
                        invalid: t.white.bgRed.bold
                    }
                }(getChalk(r)), t)
            }
            return t
        }
        ,
        r.getChalk = getChalk,
        r.shouldHighlight = shouldHighlight;
        var a = i("cb78")
          , o = i("A27I")
          , l = i("4JQ2");
        const u = new Set(["as", "async", "from", "get", "of", "set"]);
        const p = /\r\n|[\n\r\u2028\u2029]/
          , c = /^[()[\]{}]$/;
        let d;
        {
            const t = /^[a-z][\w-]*$/i
              , getTokenType = function(r, i, a) {
                if ("name" === r.type) {
                    if ((0,
                    o.isKeyword)(r.value) || (0,
                    o.isStrictReservedWord)(r.value, !0) || u.has(r.value))
                        return "keyword";
                    if (t.test(r.value) && ("<" === a[i - 1] || "</" == a.substr(i - 2, 2)))
                        return "jsxIdentifier";
                    if (r.value[0] !== r.value[0].toLowerCase())
                        return "capitalized"
                }
                return "punctuator" === r.type && c.test(r.value) ? "bracket" : "invalid" !== r.type || "@" !== r.value && "#" !== r.value ? r.type : "punctuator"
            };
            d = function*(t) {
                let r;
                for (; r = a.default.exec(t); ) {
                    const i = a.matchToToken(r);
                    yield{
                        type: getTokenType(i, r.index, t),
                        value: i.value
                    }
                }
            }
        }
        function shouldHighlight(t) {
            return !!l.supportsColor || t.forceColor
        }
        function getChalk(t) {
            return t.forceColor ? new l.constructor({
                enabled: !0,
                level: 1
            }) : l
        }
    },
    ylBm: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.TSBASETYPE_TYPES = r.TSTYPE_TYPES = r.TSTYPEELEMENT_TYPES = r.JSX_TYPES = r.ENUMMEMBER_TYPES = r.ENUMBODY_TYPES = r.FLOWPREDICATE_TYPES = r.FLOWDECLARATION_TYPES = r.FLOWBASEANNOTATION_TYPES = r.FLOWTYPE_TYPES = r.FLOW_TYPES = r.PRIVATE_TYPES = r.MODULESPECIFIER_TYPES = r.EXPORTDECLARATION_TYPES = r.MODULEDECLARATION_TYPES = r.CLASS_TYPES = r.PATTERN_TYPES = r.UNARYLIKE_TYPES = r.PROPERTY_TYPES = r.OBJECTMEMBER_TYPES = r.METHOD_TYPES = r.USERWHITESPACABLE_TYPES = r.IMMUTABLE_TYPES = r.LITERAL_TYPES = r.TSENTITYNAME_TYPES = r.LVAL_TYPES = r.PATTERNLIKE_TYPES = r.DECLARATION_TYPES = r.PUREISH_TYPES = r.FUNCTIONPARENT_TYPES = r.FUNCTION_TYPES = r.FORXSTATEMENT_TYPES = r.FOR_TYPES = r.EXPRESSIONWRAPPER_TYPES = r.WHILE_TYPES = r.LOOP_TYPES = r.CONDITIONAL_TYPES = r.COMPLETIONSTATEMENT_TYPES = r.TERMINATORLESS_TYPES = r.STATEMENT_TYPES = r.BLOCK_TYPES = r.BLOCKPARENT_TYPES = r.SCOPABLE_TYPES = r.BINARY_TYPES = r.EXPRESSION_TYPES = void 0;
        var a = i("Resm")
          , o = a.FLIPPED_ALIAS_KEYS.Expression;
        r.EXPRESSION_TYPES = o;
        var l = a.FLIPPED_ALIAS_KEYS.Binary;
        r.BINARY_TYPES = l;
        var u = a.FLIPPED_ALIAS_KEYS.Scopable;
        r.SCOPABLE_TYPES = u;
        var p = a.FLIPPED_ALIAS_KEYS.BlockParent;
        r.BLOCKPARENT_TYPES = p;
        var c = a.FLIPPED_ALIAS_KEYS.Block;
        r.BLOCK_TYPES = c;
        var d = a.FLIPPED_ALIAS_KEYS.Statement;
        r.STATEMENT_TYPES = d;
        var y = a.FLIPPED_ALIAS_KEYS.Terminatorless;
        r.TERMINATORLESS_TYPES = y;
        var h = a.FLIPPED_ALIAS_KEYS.CompletionStatement;
        r.COMPLETIONSTATEMENT_TYPES = h;
        var m = a.FLIPPED_ALIAS_KEYS.Conditional;
        r.CONDITIONAL_TYPES = m;
        var T = a.FLIPPED_ALIAS_KEYS.Loop;
        r.LOOP_TYPES = T;
        var S = a.FLIPPED_ALIAS_KEYS.While;
        r.WHILE_TYPES = S;
        var g = a.FLIPPED_ALIAS_KEYS.ExpressionWrapper;
        r.EXPRESSIONWRAPPER_TYPES = g;
        var b = a.FLIPPED_ALIAS_KEYS.For;
        r.FOR_TYPES = b;
        var v = a.FLIPPED_ALIAS_KEYS.ForXStatement;
        r.FORXSTATEMENT_TYPES = v;
        var E = a.FLIPPED_ALIAS_KEYS.Function;
        r.FUNCTION_TYPES = E;
        var P = a.FLIPPED_ALIAS_KEYS.FunctionParent;
        r.FUNCTIONPARENT_TYPES = P;
        var x = a.FLIPPED_ALIAS_KEYS.Pureish;
        r.PUREISH_TYPES = x;
        var A = a.FLIPPED_ALIAS_KEYS.Declaration;
        r.DECLARATION_TYPES = A;
        var O = a.FLIPPED_ALIAS_KEYS.PatternLike;
        r.PATTERNLIKE_TYPES = O;
        var I = a.FLIPPED_ALIAS_KEYS.LVal;
        r.LVAL_TYPES = I;
        var w = a.FLIPPED_ALIAS_KEYS.TSEntityName;
        r.TSENTITYNAME_TYPES = w;
        var C = a.FLIPPED_ALIAS_KEYS.Literal;
        r.LITERAL_TYPES = C;
        var N = a.FLIPPED_ALIAS_KEYS.Immutable;
        r.IMMUTABLE_TYPES = N;
        var D = a.FLIPPED_ALIAS_KEYS.UserWhitespacable;
        r.USERWHITESPACABLE_TYPES = D;
        var _ = a.FLIPPED_ALIAS_KEYS.Method;
        r.METHOD_TYPES = _;
        var L = a.FLIPPED_ALIAS_KEYS.ObjectMember;
        r.OBJECTMEMBER_TYPES = L;
        var k = a.FLIPPED_ALIAS_KEYS.Property;
        r.PROPERTY_TYPES = k;
        var M = a.FLIPPED_ALIAS_KEYS.UnaryLike;
        r.UNARYLIKE_TYPES = M;
        var j = a.FLIPPED_ALIAS_KEYS.Pattern;
        r.PATTERN_TYPES = j;
        var B = a.FLIPPED_ALIAS_KEYS.Class;
        r.CLASS_TYPES = B;
        var R = a.FLIPPED_ALIAS_KEYS.ModuleDeclaration;
        r.MODULEDECLARATION_TYPES = R;
        var K = a.FLIPPED_ALIAS_KEYS.ExportDeclaration;
        r.EXPORTDECLARATION_TYPES = K;
        var V = a.FLIPPED_ALIAS_KEYS.ModuleSpecifier;
        r.MODULESPECIFIER_TYPES = V;
        var U = a.FLIPPED_ALIAS_KEYS.Private;
        r.PRIVATE_TYPES = U;
        var Y = a.FLIPPED_ALIAS_KEYS.Flow;
        r.FLOW_TYPES = Y;
        var X = a.FLIPPED_ALIAS_KEYS.FlowType;
        r.FLOWTYPE_TYPES = X;
        var J = a.FLIPPED_ALIAS_KEYS.FlowBaseAnnotation;
        r.FLOWBASEANNOTATION_TYPES = J;
        var W = a.FLIPPED_ALIAS_KEYS.FlowDeclaration;
        r.FLOWDECLARATION_TYPES = W;
        var q = a.FLIPPED_ALIAS_KEYS.FlowPredicate;
        r.FLOWPREDICATE_TYPES = q;
        var H = a.FLIPPED_ALIAS_KEYS.EnumBody;
        r.ENUMBODY_TYPES = H;
        var G = a.FLIPPED_ALIAS_KEYS.EnumMember;
        r.ENUMMEMBER_TYPES = G;
        var z = a.FLIPPED_ALIAS_KEYS.JSX;
        r.JSX_TYPES = z;
        var Q = a.FLIPPED_ALIAS_KEYS.TSTypeElement;
        r.TSTYPEELEMENT_TYPES = Q;
        var $ = a.FLIPPED_ALIAS_KEYS.TSType;
        r.TSTYPE_TYPES = $;
        var Z = a.FLIPPED_ALIAS_KEYS.TSBaseType;
        r.TSBASETYPE_TYPES = Z
    },
    "z/7U": function(t, r, i) {
        "use strict";
        (function(t) {
            var a = i("TqRt")(i("cDf5"));
            function _createForOfIteratorHelper(t, r) {
                var i = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
                if (!i) {
                    if (Array.isArray(t) || (i = function _unsupportedIterableToArray(t, r) {
                        if (!t)
                            return;
                        if ("string" == typeof t)
                            return _arrayLikeToArray(t, r);
                        var i = Object.prototype.toString.call(t).slice(8, -1);
                        "Object" === i && t.constructor && (i = t.constructor.name);
                        if ("Map" === i || "Set" === i)
                            return Array.from(t);
                        if ("Arguments" === i || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i))
                            return _arrayLikeToArray(t, r)
                    }(t)) || r && t && "number" == typeof t.length) {
                        i && (t = i);
                        var a = 0
                          , o = function F() {};
                        return {
                            s: o,
                            n: function n() {
                                return a >= t.length ? {
                                    done: !0
                                } : {
                                    done: !1,
                                    value: t[a++]
                                }
                            },
                            e: function e(t) {
                                throw t
                            },
                            f: o
                        }
                    }
                    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                }
                var l, u = !0, p = !1;
                return {
                    s: function s() {
                        i = i.call(t)
                    },
                    n: function n() {
                        var t = i.next();
                        return u = t.done,
                        t
                    },
                    e: function e(t) {
                        p = !0,
                        l = t
                    },
                    f: function f() {
                        try {
                            u || null == i.return || i.return()
                        } finally {
                            if (p)
                                throw l
                        }
                    }
                }
            }
            function _arrayLikeToArray(t, r) {
                (null == r || r > t.length) && (r = t.length);
                for (var i = 0, a = new Array(r); i < r; i++)
                    a[i] = t[i];
                return a
            }
            Object.defineProperty(r, "__esModule", {
                value: !0
            }),
            r.evaluateTruthy = function evaluateTruthy() {
                var t = this.evaluate();
                if (t.confident)
                    return !!t.value
            }
            ,
            r.evaluate = function evaluate() {
                var t = {
                    confident: !0,
                    deoptPath: null,
                    seen: new Map
                }
                  , r = evaluateCached(this, t);
                t.confident || (r = void 0);
                return {
                    confident: t.confident,
                    deopt: t.deoptPath,
                    value: r
                }
            }
            ;
            var o = ["String", "Number", "Math"]
              , l = ["random"];
            function deopt(t, r) {
                r.confident && (r.deoptPath = t,
                r.confident = !1)
            }
            function evaluateCached(r, i) {
                var u = r.node
                  , p = i.seen;
                if (p.has(u)) {
                    var c = p.get(u);
                    return c.resolved ? c.value : void deopt(r, i)
                }
                var d = {
                    resolved: !1
                };
                p.set(u, d);
                var y = function _evaluate(r, i) {
                    if (!i.confident)
                        return;
                    if (r.isSequenceExpression()) {
                        var u = r.get("expressions");
                        return evaluateCached(u[u.length - 1], i)
                    }
                    if (r.isStringLiteral() || r.isNumericLiteral() || r.isBooleanLiteral())
                        return r.node.value;
                    if (r.isNullLiteral())
                        return null;
                    if (r.isTemplateLiteral())
                        return evaluateQuasis(r, r.node.quasis, i);
                    if (r.isTaggedTemplateExpression() && r.get("tag").isMemberExpression()) {
                        var p = r.get("tag.object")
                          , c = p.node.name
                          , d = r.get("tag.property");
                        if (p.isIdentifier() && "String" === c && !r.scope.getBinding(c) && d.isIdentifier() && "raw" === d.node.name)
                            return evaluateQuasis(r, r.node.quasi.quasis, i, !0)
                    }
                    if (r.isConditionalExpression()) {
                        var y = evaluateCached(r.get("test"), i);
                        if (!i.confident)
                            return;
                        return evaluateCached(y ? r.get("consequent") : r.get("alternate"), i)
                    }
                    if (r.isExpressionWrapper())
                        return evaluateCached(r.get("expression"), i);
                    if (r.isMemberExpression() && !r.parentPath.isCallExpression({
                        callee: r.node
                    })) {
                        var h = r.get("property")
                          , m = r.get("object");
                        if (m.isLiteral() && h.isIdentifier()) {
                            var T = m.node.value
                              , S = (0,
                            a.default)(T);
                            if ("number" === S || "string" === S)
                                return T[h.node.name]
                        }
                    }
                    if (r.isReferencedIdentifier()) {
                        var g = r.scope.getBinding(r.node.name);
                        if (g && g.constantViolations.length > 0)
                            return deopt(g.path, i);
                        if (g && r.node.start < g.path.node.end)
                            return deopt(g.path, i);
                        if (null != g && g.hasValue)
                            return g.value;
                        if ("undefined" === r.node.name)
                            return g ? deopt(g.path, i) : void 0;
                        if ("Infinity" === r.node.name)
                            return g ? deopt(g.path, i) : 1 / 0;
                        if ("NaN" === r.node.name)
                            return g ? deopt(g.path, i) : NaN;
                        var b = r.resolve();
                        return b === r ? deopt(r, i) : evaluateCached(b, i)
                    }
                    if (r.isUnaryExpression({
                        prefix: !0
                    })) {
                        if ("void" === r.node.operator)
                            return;
                        var v = r.get("argument");
                        if ("typeof" === r.node.operator && (v.isFunction() || v.isClass()))
                            return "function";
                        var E = evaluateCached(v, i);
                        if (!i.confident)
                            return;
                        switch (r.node.operator) {
                        case "!":
                            return !E;
                        case "+":
                            return +E;
                        case "-":
                            return -E;
                        case "~":
                            return ~E;
                        case "typeof":
                            return (0,
                            a.default)(E)
                        }
                    }
                    if (r.isArrayExpression()) {
                        var P, x = [], A = _createForOfIteratorHelper(r.get("elements"));
                        try {
                            for (A.s(); !(P = A.n()).done; ) {
                                var O = P.value.evaluate();
                                if (!O.confident)
                                    return deopt(O.deopt, i);
                                x.push(O.value)
                            }
                        } catch (t) {
                            A.e(t)
                        } finally {
                            A.f()
                        }
                        return x
                    }
                    if (r.isObjectExpression()) {
                        var I, w = {}, C = _createForOfIteratorHelper(r.get("properties"));
                        try {
                            for (C.s(); !(I = C.n()).done; ) {
                                var N = I.value;
                                if (N.isObjectMethod() || N.isSpreadElement())
                                    return deopt(N, i);
                                var D = N.get("key");
                                if (N.node.computed) {
                                    if (!(D = D.evaluate()).confident)
                                        return deopt(D.deopt, i);
                                    D = D.value
                                } else
                                    D = D.isIdentifier() ? D.node.name : D.node.value;
                                var _ = N.get("value").evaluate();
                                if (!_.confident)
                                    return deopt(_.deopt, i);
                                _ = _.value,
                                w[D] = _
                            }
                        } catch (t) {
                            C.e(t)
                        } finally {
                            C.f()
                        }
                        return w
                    }
                    if (r.isLogicalExpression()) {
                        var L = i.confident
                          , k = evaluateCached(r.get("left"), i)
                          , M = i.confident;
                        i.confident = L;
                        var j = evaluateCached(r.get("right"), i)
                          , B = i.confident;
                        switch (r.node.operator) {
                        case "||":
                            if (i.confident = M && (!!k || B),
                            !i.confident)
                                return;
                            return k || j;
                        case "&&":
                            if (i.confident = M && (!k || B),
                            !i.confident)
                                return;
                            return k && j
                        }
                    }
                    if (r.isBinaryExpression()) {
                        var R = evaluateCached(r.get("left"), i);
                        if (!i.confident)
                            return;
                        var K = evaluateCached(r.get("right"), i);
                        if (!i.confident)
                            return;
                        switch (r.node.operator) {
                        case "-":
                            return R - K;
                        case "+":
                            return R + K;
                        case "/":
                            return R / K;
                        case "*":
                            return R * K;
                        case "%":
                            return R % K;
                        case "**":
                            return Math.pow(R, K);
                        case "<":
                            return R < K;
                        case ">":
                            return R > K;
                        case "<=":
                            return R <= K;
                        case ">=":
                            return R >= K;
                        case "==":
                            return R == K;
                        case "!=":
                            return R != K;
                        case "===":
                            return R === K;
                        case "!==":
                            return R !== K;
                        case "|":
                            return R | K;
                        case "&":
                            return R & K;
                        case "^":
                            return R ^ K;
                        case "<<":
                            return R << K;
                        case ">>":
                            return R >> K;
                        case ">>>":
                            return R >>> K
                        }
                    }
                    if (r.isCallExpression()) {
                        var V, U, Y = r.get("callee");
                        if (Y.isIdentifier() && !r.scope.getBinding(Y.node.name) && o.indexOf(Y.node.name) >= 0 && (U = t[Y.node.name]),
                        Y.isMemberExpression()) {
                            var X = Y.get("object")
                              , J = Y.get("property");
                            if (X.isIdentifier() && J.isIdentifier() && o.indexOf(X.node.name) >= 0 && l.indexOf(J.node.name) < 0 && (V = t[X.node.name],
                            U = V[J.node.name]),
                            X.isLiteral() && J.isIdentifier()) {
                                var W = (0,
                                a.default)(X.node.value);
                                "string" !== W && "number" !== W || (V = X.node.value,
                                U = V[J.node.name])
                            }
                        }
                        if (U) {
                            var q = r.get("arguments").map((function(t) {
                                return evaluateCached(t, i)
                            }
                            ));
                            if (!i.confident)
                                return;
                            return U.apply(V, q)
                        }
                    }
                    deopt(r, i)
                }(r, i);
                return i.confident && (d.resolved = !0,
                d.value = y),
                y
            }
            function evaluateQuasis(t, r, i) {
                var a, o = arguments.length > 3 && void 0 !== arguments[3] && arguments[3], l = "", u = 0, p = t.get("expressions"), c = _createForOfIteratorHelper(r);
                try {
                    for (c.s(); !(a = c.n()).done; ) {
                        var d = a.value;
                        if (!i.confident)
                            break;
                        l += o ? d.value.raw : d.value.cooked;
                        var y = p[u++];
                        y && (l += String(evaluateCached(y, i)))
                    }
                } catch (t) {
                    c.e(t)
                } finally {
                    c.f()
                }
                if (i.confident)
                    return l
            }
        }
        ).call(this, i("yLpj"))
    },
    z0QK: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.PLACEHOLDERS_FLIPPED_ALIAS = r.PLACEHOLDERS_ALIAS = r.PLACEHOLDERS = void 0;
        var a = i("V97+");
        const o = ["Identifier", "StringLiteral", "Expression", "Statement", "Declaration", "BlockStatement", "ClassBody", "Pattern"];
        r.PLACEHOLDERS = o;
        const l = {
            Declaration: ["Statement"],
            Pattern: ["PatternLike", "LVal"]
        };
        r.PLACEHOLDERS_ALIAS = l;
        for (const t of o) {
            const r = a.ALIAS_KEYS[t];
            null != r && r.length && (l[t] = r)
        }
        const u = {};
        r.PLACEHOLDERS_FLIPPED_ALIAS = u,
        Object.keys(l).forEach(t=>{
            l[t].forEach(r=>{
                Object.hasOwnProperty.call(u, r) || (u[r] = []),
                u[r].push(t)
            }
            )
        }
        )
    },
    z1ss: function(t, r, i) {
        "use strict";
        function _createForOfIteratorHelper(t, r) {
            var i = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
            if (!i) {
                if (Array.isArray(t) || (i = function _unsupportedIterableToArray(t, r) {
                    if (!t)
                        return;
                    if ("string" == typeof t)
                        return _arrayLikeToArray(t, r);
                    var i = Object.prototype.toString.call(t).slice(8, -1);
                    "Object" === i && t.constructor && (i = t.constructor.name);
                    if ("Map" === i || "Set" === i)
                        return Array.from(t);
                    if ("Arguments" === i || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i))
                        return _arrayLikeToArray(t, r)
                }(t)) || r && t && "number" == typeof t.length) {
                    i && (t = i);
                    var a = 0
                      , o = function F() {};
                    return {
                        s: o,
                        n: function n() {
                            return a >= t.length ? {
                                done: !0
                            } : {
                                done: !1,
                                value: t[a++]
                            }
                        },
                        e: function e(t) {
                            throw t
                        },
                        f: o
                    }
                }
                throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
            }
            var l, u = !0, p = !1;
            return {
                s: function s() {
                    i = i.call(t)
                },
                n: function n() {
                    var t = i.next();
                    return u = t.done,
                    t
                },
                e: function e(t) {
                    p = !0,
                    l = t
                },
                f: function f() {
                    try {
                        u || null == i.return || i.return()
                    } finally {
                        if (p)
                            throw l
                    }
                }
            }
        }
        function _arrayLikeToArray(t, r) {
            (null == r || r > t.length) && (r = t.length);
            for (var i = 0, a = new Array(r); i < r; i++)
                a[i] = t[i];
            return a
        }
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function toIdentifier(t) {
            var r, i = "", l = _createForOfIteratorHelper(t += "");
            try {
                for (l.s(); !(r = l.n()).done; ) {
                    var u = r.value;
                    i += (0,
                    o.isIdentifierChar)(u.codePointAt(0)) ? u : "-"
                }
            } catch (t) {
                l.e(t)
            } finally {
                l.f()
            }
            i = (i = i.replace(/^[-0-9]+/, "")).replace(/[-\s]+(.)?/g, (function(t, r) {
                return r ? r.toUpperCase() : ""
            }
            )),
            (0,
            a.default)(i) || (i = "_".concat(i));
            return i || "_"
        }
        ;
        var a = i("yK+d")
          , o = i("KPS7")
    },
    z2IN: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function matchesPattern(t, r, i) {
            if (!(0,
            a.isMemberExpression)(t))
                return !1;
            var o, l = Array.isArray(r) ? r : r.split("."), u = [];
            for (o = t; (0,
            a.isMemberExpression)(o); o = o.object)
                u.push(o.property);
            if (u.push(o),
            u.length < l.length)
                return !1;
            if (!i && u.length > l.length)
                return !1;
            for (var p = 0, c = u.length - 1; p < l.length; p++,
            c--) {
                var d = u[c]
                  , y = void 0;
                if ((0,
                a.isIdentifier)(d))
                    y = d.name;
                else if ((0,
                a.isStringLiteral)(d))
                    y = d.value;
                else {
                    if (!(0,
                    a.isThisExpression)(d))
                        return !1;
                    y = "this"
                }
                if (l[p] !== y)
                    return !1
            }
            return !0
        }
        ;
        var a = i("FUES")
    },
    z6FP: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function isSpecifierDefault(t) {
            return (0,
            a.isImportDefaultSpecifier)(t) || (0,
            a.isIdentifier)(t.imported || t.exported, {
                name: "default"
            })
        }
        ;
        var a = i("FUES")
    },
    z6L1: function(t, r, i) {
        "use strict";
        (function(t) {
            var a = i("TqRt")
              , o = a(i("J4zp"))
              , l = a(i("RIqP"));
            Object.defineProperty(r, "__esModule", {
                value: !0
            }),
            r.patternLikeCommon = r.functionTypeAnnotationCommon = r.functionDeclarationCommon = r.functionCommon = r.classMethodOrPropertyCommon = r.classMethodOrDeclareMethodCommon = void 0;
            var u, p, c, d = i("ET4T"), y = i("Aniq"), h = i("KPS7"), m = i("M7ys"), T = i("aaMo"), S = (0,
            T.defineAliasedType)("Standardized");
            S("ArrayExpression", {
                fields: {
                    elements: {
                        validate: (0,
                        T.chain)((0,
                        T.assertValueType)("array"), (0,
                        T.assertEach)((0,
                        T.assertNodeOrValueType)("null", "Expression", "SpreadElement"))),
                        default: t.env.BABEL_TYPES_8_BREAKING ? void 0 : []
                    }
                },
                visitor: ["elements"],
                aliases: ["Expression"]
            }),
            S("AssignmentExpression", {
                fields: {
                    operator: {
                        validate: function() {
                            if (!t.env.BABEL_TYPES_8_BREAKING)
                                return (0,
                                T.assertValueType)("string");
                            var r = T.assertOneOf.apply(void 0, (0,
                            l.default)(m.ASSIGNMENT_OPERATORS))
                              , i = (0,
                            T.assertOneOf)("=");
                            return function(t, a, o) {
                                ((0,
                                d.default)("Pattern", t.left) ? i : r)(t, a, o)
                            }
                        }()
                    },
                    left: {
                        validate: t.env.BABEL_TYPES_8_BREAKING ? (0,
                        T.assertNodeType)("Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern") : (0,
                        T.assertNodeType)("LVal")
                    },
                    right: {
                        validate: (0,
                        T.assertNodeType)("Expression")
                    }
                },
                builder: ["operator", "left", "right"],
                visitor: ["left", "right"],
                aliases: ["Expression"]
            }),
            S("BinaryExpression", {
                builder: ["operator", "left", "right"],
                fields: {
                    operator: {
                        validate: T.assertOneOf.apply(void 0, (0,
                        l.default)(m.BINARY_OPERATORS))
                    },
                    left: {
                        validate: (u = (0,
                        T.assertNodeType)("Expression"),
                        p = (0,
                        T.assertNodeType)("Expression", "PrivateName"),
                        c = function validator(t, r, i) {
                            var validator = "in" === t.operator ? p : u;
                            validator(t, r, i)
                        }
                        ,
                        c.oneOfNodeTypes = ["Expression", "PrivateName"],
                        c)
                    },
                    right: {
                        validate: (0,
                        T.assertNodeType)("Expression")
                    }
                },
                visitor: ["left", "right"],
                aliases: ["Binary", "Expression"]
            }),
            S("InterpreterDirective", {
                builder: ["value"],
                fields: {
                    value: {
                        validate: (0,
                        T.assertValueType)("string")
                    }
                }
            }),
            S("Directive", {
                visitor: ["value"],
                fields: {
                    value: {
                        validate: (0,
                        T.assertNodeType)("DirectiveLiteral")
                    }
                }
            }),
            S("DirectiveLiteral", {
                builder: ["value"],
                fields: {
                    value: {
                        validate: (0,
                        T.assertValueType)("string")
                    }
                }
            }),
            S("BlockStatement", {
                builder: ["body", "directives"],
                visitor: ["directives", "body"],
                fields: {
                    directives: {
                        validate: (0,
                        T.chain)((0,
                        T.assertValueType)("array"), (0,
                        T.assertEach)((0,
                        T.assertNodeType)("Directive"))),
                        default: []
                    },
                    body: {
                        validate: (0,
                        T.chain)((0,
                        T.assertValueType)("array"), (0,
                        T.assertEach)((0,
                        T.assertNodeType)("Statement")))
                    }
                },
                aliases: ["Scopable", "BlockParent", "Block", "Statement"]
            }),
            S("BreakStatement", {
                visitor: ["label"],
                fields: {
                    label: {
                        validate: (0,
                        T.assertNodeType)("Identifier"),
                        optional: !0
                    }
                },
                aliases: ["Statement", "Terminatorless", "CompletionStatement"]
            }),
            S("CallExpression", {
                visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
                builder: ["callee", "arguments"],
                aliases: ["Expression"],
                fields: Object.assign({
                    callee: {
                        validate: (0,
                        T.assertNodeType)("Expression", "V8IntrinsicIdentifier")
                    },
                    arguments: {
                        validate: (0,
                        T.chain)((0,
                        T.assertValueType)("array"), (0,
                        T.assertEach)((0,
                        T.assertNodeType)("Expression", "SpreadElement", "JSXNamespacedName", "ArgumentPlaceholder")))
                    }
                }, t.env.BABEL_TYPES_8_BREAKING ? {} : {
                    optional: {
                        validate: (0,
                        T.assertOneOf)(!0, !1),
                        optional: !0
                    }
                }, {
                    typeArguments: {
                        validate: (0,
                        T.assertNodeType)("TypeParameterInstantiation"),
                        optional: !0
                    },
                    typeParameters: {
                        validate: (0,
                        T.assertNodeType)("TSTypeParameterInstantiation"),
                        optional: !0
                    }
                })
            }),
            S("CatchClause", {
                visitor: ["param", "body"],
                fields: {
                    param: {
                        validate: (0,
                        T.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern"),
                        optional: !0
                    },
                    body: {
                        validate: (0,
                        T.assertNodeType)("BlockStatement")
                    }
                },
                aliases: ["Scopable", "BlockParent"]
            }),
            S("ConditionalExpression", {
                visitor: ["test", "consequent", "alternate"],
                fields: {
                    test: {
                        validate: (0,
                        T.assertNodeType)("Expression")
                    },
                    consequent: {
                        validate: (0,
                        T.assertNodeType)("Expression")
                    },
                    alternate: {
                        validate: (0,
                        T.assertNodeType)("Expression")
                    }
                },
                aliases: ["Expression", "Conditional"]
            }),
            S("ContinueStatement", {
                visitor: ["label"],
                fields: {
                    label: {
                        validate: (0,
                        T.assertNodeType)("Identifier"),
                        optional: !0
                    }
                },
                aliases: ["Statement", "Terminatorless", "CompletionStatement"]
            }),
            S("DebuggerStatement", {
                aliases: ["Statement"]
            }),
            S("DoWhileStatement", {
                visitor: ["test", "body"],
                fields: {
                    test: {
                        validate: (0,
                        T.assertNodeType)("Expression")
                    },
                    body: {
                        validate: (0,
                        T.assertNodeType)("Statement")
                    }
                },
                aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"]
            }),
            S("EmptyStatement", {
                aliases: ["Statement"]
            }),
            S("ExpressionStatement", {
                visitor: ["expression"],
                fields: {
                    expression: {
                        validate: (0,
                        T.assertNodeType)("Expression")
                    }
                },
                aliases: ["Statement", "ExpressionWrapper"]
            }),
            S("File", {
                builder: ["program", "comments", "tokens"],
                visitor: ["program"],
                fields: {
                    program: {
                        validate: (0,
                        T.assertNodeType)("Program")
                    },
                    comments: {
                        validate: t.env.BABEL_TYPES_8_BREAKING ? (0,
                        T.assertEach)((0,
                        T.assertNodeType)("CommentBlock", "CommentLine")) : Object.assign((function() {}
                        ), {
                            each: {
                                oneOfNodeTypes: ["CommentBlock", "CommentLine"]
                            }
                        }),
                        optional: !0
                    },
                    tokens: {
                        validate: (0,
                        T.assertEach)(Object.assign((function() {}
                        ), {
                            type: "any"
                        })),
                        optional: !0
                    }
                }
            }),
            S("ForInStatement", {
                visitor: ["left", "right", "body"],
                aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
                fields: {
                    left: {
                        validate: t.env.BABEL_TYPES_8_BREAKING ? (0,
                        T.assertNodeType)("VariableDeclaration", "Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern") : (0,
                        T.assertNodeType)("VariableDeclaration", "LVal")
                    },
                    right: {
                        validate: (0,
                        T.assertNodeType)("Expression")
                    },
                    body: {
                        validate: (0,
                        T.assertNodeType)("Statement")
                    }
                }
            }),
            S("ForStatement", {
                visitor: ["init", "test", "update", "body"],
                aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop"],
                fields: {
                    init: {
                        validate: (0,
                        T.assertNodeType)("VariableDeclaration", "Expression"),
                        optional: !0
                    },
                    test: {
                        validate: (0,
                        T.assertNodeType)("Expression"),
                        optional: !0
                    },
                    update: {
                        validate: (0,
                        T.assertNodeType)("Expression"),
                        optional: !0
                    },
                    body: {
                        validate: (0,
                        T.assertNodeType)("Statement")
                    }
                }
            });
            var g = {
                params: {
                    validate: (0,
                    T.chain)((0,
                    T.assertValueType)("array"), (0,
                    T.assertEach)((0,
                    T.assertNodeType)("Identifier", "Pattern", "RestElement")))
                },
                generator: {
                    default: !1
                },
                async: {
                    default: !1
                }
            };
            r.functionCommon = g;
            var b = {
                returnType: {
                    validate: (0,
                    T.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
                    optional: !0
                },
                typeParameters: {
                    validate: (0,
                    T.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
                    optional: !0
                }
            };
            r.functionTypeAnnotationCommon = b;
            var v = Object.assign({}, g, {
                declare: {
                    validate: (0,
                    T.assertValueType)("boolean"),
                    optional: !0
                },
                id: {
                    validate: (0,
                    T.assertNodeType)("Identifier"),
                    optional: !0
                }
            });
            r.functionDeclarationCommon = v,
            S("FunctionDeclaration", {
                builder: ["id", "params", "body", "generator", "async"],
                visitor: ["id", "params", "body", "returnType", "typeParameters"],
                fields: Object.assign({}, v, b, {
                    body: {
                        validate: (0,
                        T.assertNodeType)("BlockStatement")
                    }
                }),
                aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Statement", "Pureish", "Declaration"],
                validate: function() {
                    if (!t.env.BABEL_TYPES_8_BREAKING)
                        return function() {}
                        ;
                    var r = (0,
                    T.assertNodeType)("Identifier");
                    return function(t, i, a) {
                        (0,
                        d.default)("ExportDefaultDeclaration", t) || r(a, "id", a.id)
                    }
                }()
            }),
            S("FunctionExpression", {
                inherits: "FunctionDeclaration",
                aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
                fields: Object.assign({}, g, b, {
                    id: {
                        validate: (0,
                        T.assertNodeType)("Identifier"),
                        optional: !0
                    },
                    body: {
                        validate: (0,
                        T.assertNodeType)("BlockStatement")
                    }
                })
            });
            var E, P, x, A = {
                typeAnnotation: {
                    validate: (0,
                    T.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
                    optional: !0
                },
                decorators: {
                    validate: (0,
                    T.chain)((0,
                    T.assertValueType)("array"), (0,
                    T.assertEach)((0,
                    T.assertNodeType)("Decorator")))
                }
            };
            r.patternLikeCommon = A,
            S("Identifier", {
                builder: ["name"],
                visitor: ["typeAnnotation", "decorators"],
                aliases: ["Expression", "PatternLike", "LVal", "TSEntityName"],
                fields: Object.assign({}, A, {
                    name: {
                        validate: (0,
                        T.chain)((0,
                        T.assertValueType)("string"), Object.assign((function(r, i, a) {
                            if (t.env.BABEL_TYPES_8_BREAKING && !(0,
                            y.default)(a, !1))
                                throw new TypeError('"'.concat(a, '" is not a valid identifier name'))
                        }
                        ), {
                            type: "string"
                        }))
                    },
                    optional: {
                        validate: (0,
                        T.assertValueType)("boolean"),
                        optional: !0
                    }
                }),
                validate: function validate(r, i, a) {
                    if (t.env.BABEL_TYPES_8_BREAKING) {
                        var l = /\.(\w+)$/.exec(i);
                        if (l) {
                            var u = (0,
                            o.default)(l, 2)[1]
                              , p = {
                                computed: !1
                            };
                            if ("property" === u) {
                                if ((0,
                                d.default)("MemberExpression", r, p))
                                    return;
                                if ((0,
                                d.default)("OptionalMemberExpression", r, p))
                                    return
                            } else if ("key" === u) {
                                if ((0,
                                d.default)("Property", r, p))
                                    return;
                                if ((0,
                                d.default)("Method", r, p))
                                    return
                            } else if ("exported" === u) {
                                if ((0,
                                d.default)("ExportSpecifier", r))
                                    return
                            } else if ("imported" === u) {
                                if ((0,
                                d.default)("ImportSpecifier", r, {
                                    imported: a
                                }))
                                    return
                            } else if ("meta" === u && (0,
                            d.default)("MetaProperty", r, {
                                meta: a
                            }))
                                return;
                            if (((0,
                            h.isKeyword)(a.name) || (0,
                            h.isReservedWord)(a.name, !1)) && "this" !== a.name)
                                throw new TypeError('"'.concat(a.name, '" is not a valid identifier'))
                        }
                    }
                }
            }),
            S("IfStatement", {
                visitor: ["test", "consequent", "alternate"],
                aliases: ["Statement", "Conditional"],
                fields: {
                    test: {
                        validate: (0,
                        T.assertNodeType)("Expression")
                    },
                    consequent: {
                        validate: (0,
                        T.assertNodeType)("Statement")
                    },
                    alternate: {
                        optional: !0,
                        validate: (0,
                        T.assertNodeType)("Statement")
                    }
                }
            }),
            S("LabeledStatement", {
                visitor: ["label", "body"],
                aliases: ["Statement"],
                fields: {
                    label: {
                        validate: (0,
                        T.assertNodeType)("Identifier")
                    },
                    body: {
                        validate: (0,
                        T.assertNodeType)("Statement")
                    }
                }
            }),
            S("StringLiteral", {
                builder: ["value"],
                fields: {
                    value: {
                        validate: (0,
                        T.assertValueType)("string")
                    }
                },
                aliases: ["Expression", "Pureish", "Literal", "Immutable"]
            }),
            S("NumericLiteral", {
                builder: ["value"],
                deprecatedAlias: "NumberLiteral",
                fields: {
                    value: {
                        validate: (0,
                        T.assertValueType)("number")
                    }
                },
                aliases: ["Expression", "Pureish", "Literal", "Immutable"]
            }),
            S("NullLiteral", {
                aliases: ["Expression", "Pureish", "Literal", "Immutable"]
            }),
            S("BooleanLiteral", {
                builder: ["value"],
                fields: {
                    value: {
                        validate: (0,
                        T.assertValueType)("boolean")
                    }
                },
                aliases: ["Expression", "Pureish", "Literal", "Immutable"]
            }),
            S("RegExpLiteral", {
                builder: ["pattern", "flags"],
                deprecatedAlias: "RegexLiteral",
                aliases: ["Expression", "Pureish", "Literal"],
                fields: {
                    pattern: {
                        validate: (0,
                        T.assertValueType)("string")
                    },
                    flags: {
                        validate: (0,
                        T.chain)((0,
                        T.assertValueType)("string"), Object.assign((function(r, i, a) {
                            if (t.env.BABEL_TYPES_8_BREAKING) {
                                var o = /[^gimsuy]/.exec(a);
                                if (o)
                                    throw new TypeError('"'.concat(o[0], '" is not a valid RegExp flag'))
                            }
                        }
                        ), {
                            type: "string"
                        })),
                        default: ""
                    }
                }
            }),
            S("LogicalExpression", {
                builder: ["operator", "left", "right"],
                visitor: ["left", "right"],
                aliases: ["Binary", "Expression"],
                fields: {
                    operator: {
                        validate: T.assertOneOf.apply(void 0, (0,
                        l.default)(m.LOGICAL_OPERATORS))
                    },
                    left: {
                        validate: (0,
                        T.assertNodeType)("Expression")
                    },
                    right: {
                        validate: (0,
                        T.assertNodeType)("Expression")
                    }
                }
            }),
            S("MemberExpression", {
                builder: ["object", "property", "computed"].concat((0,
                l.default)(t.env.BABEL_TYPES_8_BREAKING ? [] : ["optional"])),
                visitor: ["object", "property"],
                aliases: ["Expression", "LVal"],
                fields: Object.assign({
                    object: {
                        validate: (0,
                        T.assertNodeType)("Expression")
                    },
                    property: {
                        validate: function() {
                            var t = (0,
                            T.assertNodeType)("Identifier", "PrivateName")
                              , r = (0,
                            T.assertNodeType)("Expression")
                              , i = function validator(i, a, o) {
                                var validator = i.computed ? r : t;
                                validator(i, a, o)
                            };
                            return i.oneOfNodeTypes = ["Expression", "Identifier", "PrivateName"],
                            i
                        }()
                    },
                    computed: {
                        default: !1
                    }
                }, t.env.BABEL_TYPES_8_BREAKING ? {} : {
                    optional: {
                        validate: (0,
                        T.assertOneOf)(!0, !1),
                        optional: !0
                    }
                })
            }),
            S("NewExpression", {
                inherits: "CallExpression"
            }),
            S("Program", {
                visitor: ["directives", "body"],
                builder: ["body", "directives", "sourceType", "interpreter"],
                fields: {
                    sourceFile: {
                        validate: (0,
                        T.assertValueType)("string")
                    },
                    sourceType: {
                        validate: (0,
                        T.assertOneOf)("script", "module"),
                        default: "script"
                    },
                    interpreter: {
                        validate: (0,
                        T.assertNodeType)("InterpreterDirective"),
                        default: null,
                        optional: !0
                    },
                    directives: {
                        validate: (0,
                        T.chain)((0,
                        T.assertValueType)("array"), (0,
                        T.assertEach)((0,
                        T.assertNodeType)("Directive"))),
                        default: []
                    },
                    body: {
                        validate: (0,
                        T.chain)((0,
                        T.assertValueType)("array"), (0,
                        T.assertEach)((0,
                        T.assertNodeType)("Statement")))
                    }
                },
                aliases: ["Scopable", "BlockParent", "Block"]
            }),
            S("ObjectExpression", {
                visitor: ["properties"],
                aliases: ["Expression"],
                fields: {
                    properties: {
                        validate: (0,
                        T.chain)((0,
                        T.assertValueType)("array"), (0,
                        T.assertEach)((0,
                        T.assertNodeType)("ObjectMethod", "ObjectProperty", "SpreadElement")))
                    }
                }
            }),
            S("ObjectMethod", {
                builder: ["kind", "key", "params", "body", "computed", "generator", "async"],
                fields: Object.assign({}, g, b, {
                    kind: Object.assign({
                        validate: (0,
                        T.assertOneOf)("method", "get", "set")
                    }, t.env.BABEL_TYPES_8_BREAKING ? {} : {
                        default: "method"
                    }),
                    computed: {
                        default: !1
                    },
                    key: {
                        validate: function() {
                            var t = (0,
                            T.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral")
                              , r = (0,
                            T.assertNodeType)("Expression")
                              , i = function validator(i, a, o) {
                                var validator = i.computed ? r : t;
                                validator(i, a, o)
                            };
                            return i.oneOfNodeTypes = ["Expression", "Identifier", "StringLiteral", "NumericLiteral"],
                            i
                        }()
                    },
                    decorators: {
                        validate: (0,
                        T.chain)((0,
                        T.assertValueType)("array"), (0,
                        T.assertEach)((0,
                        T.assertNodeType)("Decorator"))),
                        optional: !0
                    },
                    body: {
                        validate: (0,
                        T.assertNodeType)("BlockStatement")
                    }
                }),
                visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
                aliases: ["UserWhitespacable", "Function", "Scopable", "BlockParent", "FunctionParent", "Method", "ObjectMember"]
            }),
            S("ObjectProperty", {
                builder: ["key", "value", "computed", "shorthand"].concat((0,
                l.default)(t.env.BABEL_TYPES_8_BREAKING ? [] : ["decorators"])),
                fields: {
                    computed: {
                        default: !1
                    },
                    key: {
                        validate: function() {
                            var t = (0,
                            T.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral")
                              , r = (0,
                            T.assertNodeType)("Expression")
                              , i = function validator(i, a, o) {
                                var validator = i.computed ? r : t;
                                validator(i, a, o)
                            };
                            return i.oneOfNodeTypes = ["Expression", "Identifier", "StringLiteral", "NumericLiteral"],
                            i
                        }()
                    },
                    value: {
                        validate: (0,
                        T.assertNodeType)("Expression", "PatternLike")
                    },
                    shorthand: {
                        validate: (0,
                        T.chain)((0,
                        T.assertValueType)("boolean"), Object.assign((function(r, i, a) {
                            if (t.env.BABEL_TYPES_8_BREAKING && a && r.computed)
                                throw new TypeError("Property shorthand of ObjectProperty cannot be true if computed is true")
                        }
                        ), {
                            type: "boolean"
                        }), (function(r, i, a) {
                            if (t.env.BABEL_TYPES_8_BREAKING && a && !(0,
                            d.default)("Identifier", r.key))
                                throw new TypeError("Property shorthand of ObjectProperty cannot be true if key is not an Identifier")
                        }
                        )),
                        default: !1
                    },
                    decorators: {
                        validate: (0,
                        T.chain)((0,
                        T.assertValueType)("array"), (0,
                        T.assertEach)((0,
                        T.assertNodeType)("Decorator"))),
                        optional: !0
                    }
                },
                visitor: ["key", "value", "decorators"],
                aliases: ["UserWhitespacable", "Property", "ObjectMember"],
                validate: function() {
                    var r = (0,
                    T.assertNodeType)("Identifier", "Pattern")
                      , i = (0,
                    T.assertNodeType)("Expression");
                    return function(a, o, l) {
                        t.env.BABEL_TYPES_8_BREAKING && ((0,
                        d.default)("ObjectPattern", a) ? r : i)(l, "value", l.value)
                    }
                }()
            }),
            S("RestElement", {
                visitor: ["argument", "typeAnnotation"],
                builder: ["argument"],
                aliases: ["LVal", "PatternLike"],
                deprecatedAlias: "RestProperty",
                fields: Object.assign({}, A, {
                    argument: {
                        validate: t.env.BABEL_TYPES_8_BREAKING ? (0,
                        T.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern", "MemberExpression") : (0,
                        T.assertNodeType)("LVal")
                    },
                    optional: {
                        validate: (0,
                        T.assertValueType)("boolean"),
                        optional: !0
                    }
                }),
                validate: function validate(r, i) {
                    if (t.env.BABEL_TYPES_8_BREAKING) {
                        var a = /(\w+)\[(\d+)\]/.exec(i);
                        if (!a)
                            throw new Error("Internal Babel error: malformed key.");
                        var l = (0,
                        o.default)(a, 3)
                          , u = l[1]
                          , p = l[2];
                        if (r[u].length > p + 1)
                            throw new TypeError("RestElement must be last element of ".concat(u))
                    }
                }
            }),
            S("ReturnStatement", {
                visitor: ["argument"],
                aliases: ["Statement", "Terminatorless", "CompletionStatement"],
                fields: {
                    argument: {
                        validate: (0,
                        T.assertNodeType)("Expression"),
                        optional: !0
                    }
                }
            }),
            S("SequenceExpression", {
                visitor: ["expressions"],
                fields: {
                    expressions: {
                        validate: (0,
                        T.chain)((0,
                        T.assertValueType)("array"), (0,
                        T.assertEach)((0,
                        T.assertNodeType)("Expression")))
                    }
                },
                aliases: ["Expression"]
            }),
            S("ParenthesizedExpression", {
                visitor: ["expression"],
                aliases: ["Expression", "ExpressionWrapper"],
                fields: {
                    expression: {
                        validate: (0,
                        T.assertNodeType)("Expression")
                    }
                }
            }),
            S("SwitchCase", {
                visitor: ["test", "consequent"],
                fields: {
                    test: {
                        validate: (0,
                        T.assertNodeType)("Expression"),
                        optional: !0
                    },
                    consequent: {
                        validate: (0,
                        T.chain)((0,
                        T.assertValueType)("array"), (0,
                        T.assertEach)((0,
                        T.assertNodeType)("Statement")))
                    }
                }
            }),
            S("SwitchStatement", {
                visitor: ["discriminant", "cases"],
                aliases: ["Statement", "BlockParent", "Scopable"],
                fields: {
                    discriminant: {
                        validate: (0,
                        T.assertNodeType)("Expression")
                    },
                    cases: {
                        validate: (0,
                        T.chain)((0,
                        T.assertValueType)("array"), (0,
                        T.assertEach)((0,
                        T.assertNodeType)("SwitchCase")))
                    }
                }
            }),
            S("ThisExpression", {
                aliases: ["Expression"]
            }),
            S("ThrowStatement", {
                visitor: ["argument"],
                aliases: ["Statement", "Terminatorless", "CompletionStatement"],
                fields: {
                    argument: {
                        validate: (0,
                        T.assertNodeType)("Expression")
                    }
                }
            }),
            S("TryStatement", {
                visitor: ["block", "handler", "finalizer"],
                aliases: ["Statement"],
                fields: {
                    block: {
                        validate: (0,
                        T.chain)((0,
                        T.assertNodeType)("BlockStatement"), Object.assign((function(r) {
                            if (t.env.BABEL_TYPES_8_BREAKING && !r.handler && !r.finalizer)
                                throw new TypeError("TryStatement expects either a handler or finalizer, or both")
                        }
                        ), {
                            oneOfNodeTypes: ["BlockStatement"]
                        }))
                    },
                    handler: {
                        optional: !0,
                        validate: (0,
                        T.assertNodeType)("CatchClause")
                    },
                    finalizer: {
                        optional: !0,
                        validate: (0,
                        T.assertNodeType)("BlockStatement")
                    }
                }
            }),
            S("UnaryExpression", {
                builder: ["operator", "argument", "prefix"],
                fields: {
                    prefix: {
                        default: !0
                    },
                    argument: {
                        validate: (0,
                        T.assertNodeType)("Expression")
                    },
                    operator: {
                        validate: T.assertOneOf.apply(void 0, (0,
                        l.default)(m.UNARY_OPERATORS))
                    }
                },
                visitor: ["argument"],
                aliases: ["UnaryLike", "Expression"]
            }),
            S("UpdateExpression", {
                builder: ["operator", "argument", "prefix"],
                fields: {
                    prefix: {
                        default: !1
                    },
                    argument: {
                        validate: t.env.BABEL_TYPES_8_BREAKING ? (0,
                        T.assertNodeType)("Identifier", "MemberExpression") : (0,
                        T.assertNodeType)("Expression")
                    },
                    operator: {
                        validate: T.assertOneOf.apply(void 0, (0,
                        l.default)(m.UPDATE_OPERATORS))
                    }
                },
                visitor: ["argument"],
                aliases: ["Expression"]
            }),
            S("VariableDeclaration", {
                builder: ["kind", "declarations"],
                visitor: ["declarations"],
                aliases: ["Statement", "Declaration"],
                fields: {
                    declare: {
                        validate: (0,
                        T.assertValueType)("boolean"),
                        optional: !0
                    },
                    kind: {
                        validate: (0,
                        T.assertOneOf)("var", "let", "const")
                    },
                    declarations: {
                        validate: (0,
                        T.chain)((0,
                        T.assertValueType)("array"), (0,
                        T.assertEach)((0,
                        T.assertNodeType)("VariableDeclarator")))
                    }
                },
                validate: function validate(r, i, a) {
                    if (t.env.BABEL_TYPES_8_BREAKING && (0,
                    d.default)("ForXStatement", r, {
                        left: a
                    }) && 1 !== a.declarations.length)
                        throw new TypeError("Exactly one VariableDeclarator is required in the VariableDeclaration of a ".concat(r.type))
                }
            }),
            S("VariableDeclarator", {
                visitor: ["id", "init"],
                fields: {
                    id: {
                        validate: function() {
                            if (!t.env.BABEL_TYPES_8_BREAKING)
                                return (0,
                                T.assertNodeType)("LVal");
                            var r = (0,
                            T.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern")
                              , i = (0,
                            T.assertNodeType)("Identifier");
                            return function(t, a, o) {
                                (t.init ? r : i)(t, a, o)
                            }
                        }()
                    },
                    definite: {
                        optional: !0,
                        validate: (0,
                        T.assertValueType)("boolean")
                    },
                    init: {
                        optional: !0,
                        validate: (0,
                        T.assertNodeType)("Expression")
                    }
                }
            }),
            S("WhileStatement", {
                visitor: ["test", "body"],
                aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"],
                fields: {
                    test: {
                        validate: (0,
                        T.assertNodeType)("Expression")
                    },
                    body: {
                        validate: (0,
                        T.assertNodeType)("Statement")
                    }
                }
            }),
            S("WithStatement", {
                visitor: ["object", "body"],
                aliases: ["Statement"],
                fields: {
                    object: {
                        validate: (0,
                        T.assertNodeType)("Expression")
                    },
                    body: {
                        validate: (0,
                        T.assertNodeType)("Statement")
                    }
                }
            }),
            S("AssignmentPattern", {
                visitor: ["left", "right", "decorators"],
                builder: ["left", "right"],
                aliases: ["Pattern", "PatternLike", "LVal"],
                fields: Object.assign({}, A, {
                    left: {
                        validate: (0,
                        T.assertNodeType)("Identifier", "ObjectPattern", "ArrayPattern", "MemberExpression")
                    },
                    right: {
                        validate: (0,
                        T.assertNodeType)("Expression")
                    },
                    decorators: {
                        validate: (0,
                        T.chain)((0,
                        T.assertValueType)("array"), (0,
                        T.assertEach)((0,
                        T.assertNodeType)("Decorator"))),
                        optional: !0
                    }
                })
            }),
            S("ArrayPattern", {
                visitor: ["elements", "typeAnnotation"],
                builder: ["elements"],
                aliases: ["Pattern", "PatternLike", "LVal"],
                fields: Object.assign({}, A, {
                    elements: {
                        validate: (0,
                        T.chain)((0,
                        T.assertValueType)("array"), (0,
                        T.assertEach)((0,
                        T.assertNodeOrValueType)("null", "PatternLike")))
                    },
                    decorators: {
                        validate: (0,
                        T.chain)((0,
                        T.assertValueType)("array"), (0,
                        T.assertEach)((0,
                        T.assertNodeType)("Decorator"))),
                        optional: !0
                    },
                    optional: {
                        validate: (0,
                        T.assertValueType)("boolean"),
                        optional: !0
                    }
                })
            }),
            S("ArrowFunctionExpression", {
                builder: ["params", "body", "async"],
                visitor: ["params", "body", "returnType", "typeParameters"],
                aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
                fields: Object.assign({}, g, b, {
                    expression: {
                        validate: (0,
                        T.assertValueType)("boolean")
                    },
                    body: {
                        validate: (0,
                        T.assertNodeType)("BlockStatement", "Expression")
                    }
                })
            }),
            S("ClassBody", {
                visitor: ["body"],
                fields: {
                    body: {
                        validate: (0,
                        T.chain)((0,
                        T.assertValueType)("array"), (0,
                        T.assertEach)((0,
                        T.assertNodeType)("ClassMethod", "ClassPrivateMethod", "ClassProperty", "ClassPrivateProperty", "TSDeclareMethod", "TSIndexSignature")))
                    }
                }
            }),
            S("ClassExpression", {
                builder: ["id", "superClass", "body", "decorators"],
                visitor: ["id", "body", "superClass", "mixins", "typeParameters", "superTypeParameters", "implements", "decorators"],
                aliases: ["Scopable", "Class", "Expression"],
                fields: {
                    id: {
                        validate: (0,
                        T.assertNodeType)("Identifier"),
                        optional: !0
                    },
                    typeParameters: {
                        validate: (0,
                        T.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
                        optional: !0
                    },
                    body: {
                        validate: (0,
                        T.assertNodeType)("ClassBody")
                    },
                    superClass: {
                        optional: !0,
                        validate: (0,
                        T.assertNodeType)("Expression")
                    },
                    superTypeParameters: {
                        validate: (0,
                        T.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
                        optional: !0
                    },
                    implements: {
                        validate: (0,
                        T.chain)((0,
                        T.assertValueType)("array"), (0,
                        T.assertEach)((0,
                        T.assertNodeType)("TSExpressionWithTypeArguments", "ClassImplements"))),
                        optional: !0
                    },
                    decorators: {
                        validate: (0,
                        T.chain)((0,
                        T.assertValueType)("array"), (0,
                        T.assertEach)((0,
                        T.assertNodeType)("Decorator"))),
                        optional: !0
                    },
                    mixins: {
                        validate: (0,
                        T.assertNodeType)("InterfaceExtends"),
                        optional: !0
                    }
                }
            }),
            S("ClassDeclaration", {
                inherits: "ClassExpression",
                aliases: ["Scopable", "Class", "Statement", "Declaration"],
                fields: {
                    id: {
                        validate: (0,
                        T.assertNodeType)("Identifier")
                    },
                    typeParameters: {
                        validate: (0,
                        T.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
                        optional: !0
                    },
                    body: {
                        validate: (0,
                        T.assertNodeType)("ClassBody")
                    },
                    superClass: {
                        optional: !0,
                        validate: (0,
                        T.assertNodeType)("Expression")
                    },
                    superTypeParameters: {
                        validate: (0,
                        T.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
                        optional: !0
                    },
                    implements: {
                        validate: (0,
                        T.chain)((0,
                        T.assertValueType)("array"), (0,
                        T.assertEach)((0,
                        T.assertNodeType)("TSExpressionWithTypeArguments", "ClassImplements"))),
                        optional: !0
                    },
                    decorators: {
                        validate: (0,
                        T.chain)((0,
                        T.assertValueType)("array"), (0,
                        T.assertEach)((0,
                        T.assertNodeType)("Decorator"))),
                        optional: !0
                    },
                    mixins: {
                        validate: (0,
                        T.assertNodeType)("InterfaceExtends"),
                        optional: !0
                    },
                    declare: {
                        validate: (0,
                        T.assertValueType)("boolean"),
                        optional: !0
                    },
                    abstract: {
                        validate: (0,
                        T.assertValueType)("boolean"),
                        optional: !0
                    }
                },
                validate: (E = (0,
                T.assertNodeType)("Identifier"),
                function(r, i, a) {
                    t.env.BABEL_TYPES_8_BREAKING && ((0,
                    d.default)("ExportDefaultDeclaration", r) || E(a, "id", a.id))
                }
                )
            }),
            S("ExportAllDeclaration", {
                visitor: ["source"],
                aliases: ["Statement", "Declaration", "ModuleDeclaration", "ExportDeclaration"],
                fields: {
                    source: {
                        validate: (0,
                        T.assertNodeType)("StringLiteral")
                    },
                    exportKind: (0,
                    T.validateOptional)((0,
                    T.assertOneOf)("type", "value")),
                    assertions: {
                        optional: !0,
                        validate: (0,
                        T.chain)((0,
                        T.assertValueType)("array"), (0,
                        T.assertEach)((0,
                        T.assertNodeType)("ImportAttribute")))
                    }
                }
            }),
            S("ExportDefaultDeclaration", {
                visitor: ["declaration"],
                aliases: ["Statement", "Declaration", "ModuleDeclaration", "ExportDeclaration"],
                fields: {
                    declaration: {
                        validate: (0,
                        T.assertNodeType)("FunctionDeclaration", "TSDeclareFunction", "ClassDeclaration", "Expression")
                    },
                    exportKind: (0,
                    T.validateOptional)((0,
                    T.assertOneOf)("value"))
                }
            }),
            S("ExportNamedDeclaration", {
                visitor: ["declaration", "specifiers", "source"],
                aliases: ["Statement", "Declaration", "ModuleDeclaration", "ExportDeclaration"],
                fields: {
                    declaration: {
                        optional: !0,
                        validate: (0,
                        T.chain)((0,
                        T.assertNodeType)("Declaration"), Object.assign((function(r, i, a) {
                            if (t.env.BABEL_TYPES_8_BREAKING && a && r.specifiers.length)
                                throw new TypeError("Only declaration or specifiers is allowed on ExportNamedDeclaration")
                        }
                        ), {
                            oneOfNodeTypes: ["Declaration"]
                        }), (function(r, i, a) {
                            if (t.env.BABEL_TYPES_8_BREAKING && a && r.source)
                                throw new TypeError("Cannot export a declaration from a source")
                        }
                        ))
                    },
                    assertions: {
                        optional: !0,
                        validate: (0,
                        T.chain)((0,
                        T.assertValueType)("array"), (0,
                        T.assertEach)((0,
                        T.assertNodeType)("ImportAttribute")))
                    },
                    specifiers: {
                        default: [],
                        validate: (0,
                        T.chain)((0,
                        T.assertValueType)("array"), (0,
                        T.assertEach)((P = (0,
                        T.assertNodeType)("ExportSpecifier", "ExportDefaultSpecifier", "ExportNamespaceSpecifier"),
                        x = (0,
                        T.assertNodeType)("ExportSpecifier"),
                        t.env.BABEL_TYPES_8_BREAKING ? function(t, r, i) {
                            (t.source ? P : x)(t, r, i)
                        }
                        : P)))
                    },
                    source: {
                        validate: (0,
                        T.assertNodeType)("StringLiteral"),
                        optional: !0
                    },
                    exportKind: (0,
                    T.validateOptional)((0,
                    T.assertOneOf)("type", "value"))
                }
            }),
            S("ExportSpecifier", {
                visitor: ["local", "exported"],
                aliases: ["ModuleSpecifier"],
                fields: {
                    local: {
                        validate: (0,
                        T.assertNodeType)("Identifier")
                    },
                    exported: {
                        validate: (0,
                        T.assertNodeType)("Identifier", "StringLiteral")
                    },
                    exportKind: {
                        validate: (0,
                        T.assertOneOf)("type", "value"),
                        optional: !0
                    }
                }
            }),
            S("ForOfStatement", {
                visitor: ["left", "right", "body"],
                builder: ["left", "right", "body", "await"],
                aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
                fields: {
                    left: {
                        validate: function() {
                            if (!t.env.BABEL_TYPES_8_BREAKING)
                                return (0,
                                T.assertNodeType)("VariableDeclaration", "LVal");
                            var r = (0,
                            T.assertNodeType)("VariableDeclaration")
                              , i = (0,
                            T.assertNodeType)("Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern");
                            return function(t, a, o) {
                                (0,
                                d.default)("VariableDeclaration", o) ? r(t, a, o) : i(t, a, o)
                            }
                        }()
                    },
                    right: {
                        validate: (0,
                        T.assertNodeType)("Expression")
                    },
                    body: {
                        validate: (0,
                        T.assertNodeType)("Statement")
                    },
                    await: {
                        default: !1
                    }
                }
            }),
            S("ImportDeclaration", {
                visitor: ["specifiers", "source"],
                aliases: ["Statement", "Declaration", "ModuleDeclaration"],
                fields: {
                    assertions: {
                        optional: !0,
                        validate: (0,
                        T.chain)((0,
                        T.assertValueType)("array"), (0,
                        T.assertEach)((0,
                        T.assertNodeType)("ImportAttribute")))
                    },
                    specifiers: {
                        validate: (0,
                        T.chain)((0,
                        T.assertValueType)("array"), (0,
                        T.assertEach)((0,
                        T.assertNodeType)("ImportSpecifier", "ImportDefaultSpecifier", "ImportNamespaceSpecifier")))
                    },
                    source: {
                        validate: (0,
                        T.assertNodeType)("StringLiteral")
                    },
                    importKind: {
                        validate: (0,
                        T.assertOneOf)("type", "typeof", "value"),
                        optional: !0
                    }
                }
            }),
            S("ImportDefaultSpecifier", {
                visitor: ["local"],
                aliases: ["ModuleSpecifier"],
                fields: {
                    local: {
                        validate: (0,
                        T.assertNodeType)("Identifier")
                    }
                }
            }),
            S("ImportNamespaceSpecifier", {
                visitor: ["local"],
                aliases: ["ModuleSpecifier"],
                fields: {
                    local: {
                        validate: (0,
                        T.assertNodeType)("Identifier")
                    }
                }
            }),
            S("ImportSpecifier", {
                visitor: ["local", "imported"],
                aliases: ["ModuleSpecifier"],
                fields: {
                    local: {
                        validate: (0,
                        T.assertNodeType)("Identifier")
                    },
                    imported: {
                        validate: (0,
                        T.assertNodeType)("Identifier", "StringLiteral")
                    },
                    importKind: {
                        validate: (0,
                        T.assertOneOf)("type", "typeof", "value"),
                        optional: !0
                    }
                }
            }),
            S("MetaProperty", {
                visitor: ["meta", "property"],
                aliases: ["Expression"],
                fields: {
                    meta: {
                        validate: (0,
                        T.chain)((0,
                        T.assertNodeType)("Identifier"), Object.assign((function(r, i, a) {
                            if (t.env.BABEL_TYPES_8_BREAKING) {
                                var o;
                                switch (a.name) {
                                case "function":
                                    o = "sent";
                                    break;
                                case "new":
                                    o = "target";
                                    break;
                                case "import":
                                    o = "meta"
                                }
                                if (!(0,
                                d.default)("Identifier", r.property, {
                                    name: o
                                }))
                                    throw new TypeError("Unrecognised MetaProperty")
                            }
                        }
                        ), {
                            oneOfNodeTypes: ["Identifier"]
                        }))
                    },
                    property: {
                        validate: (0,
                        T.assertNodeType)("Identifier")
                    }
                }
            });
            var O, I, w = {
                abstract: {
                    validate: (0,
                    T.assertValueType)("boolean"),
                    optional: !0
                },
                accessibility: {
                    validate: (0,
                    T.assertOneOf)("public", "private", "protected"),
                    optional: !0
                },
                static: {
                    default: !1
                },
                override: {
                    default: !1
                },
                computed: {
                    default: !1
                },
                optional: {
                    validate: (0,
                    T.assertValueType)("boolean"),
                    optional: !0
                },
                key: {
                    validate: (0,
                    T.chain)((O = (0,
                    T.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral"),
                    I = (0,
                    T.assertNodeType)("Expression"),
                    function(t, r, i) {
                        (t.computed ? I : O)(t, r, i)
                    }
                    ), (0,
                    T.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "Expression"))
                }
            };
            r.classMethodOrPropertyCommon = w;
            var C = Object.assign({}, g, w, {
                params: {
                    validate: (0,
                    T.chain)((0,
                    T.assertValueType)("array"), (0,
                    T.assertEach)((0,
                    T.assertNodeType)("Identifier", "Pattern", "RestElement", "TSParameterProperty")))
                },
                kind: {
                    validate: (0,
                    T.assertOneOf)("get", "set", "method", "constructor"),
                    default: "method"
                },
                access: {
                    validate: (0,
                    T.chain)((0,
                    T.assertValueType)("string"), (0,
                    T.assertOneOf)("public", "private", "protected")),
                    optional: !0
                },
                decorators: {
                    validate: (0,
                    T.chain)((0,
                    T.assertValueType)("array"), (0,
                    T.assertEach)((0,
                    T.assertNodeType)("Decorator"))),
                    optional: !0
                }
            });
            r.classMethodOrDeclareMethodCommon = C,
            S("ClassMethod", {
                aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method"],
                builder: ["kind", "key", "params", "body", "computed", "static", "generator", "async"],
                visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
                fields: Object.assign({}, C, b, {
                    body: {
                        validate: (0,
                        T.assertNodeType)("BlockStatement")
                    }
                })
            }),
            S("ObjectPattern", {
                visitor: ["properties", "typeAnnotation", "decorators"],
                builder: ["properties"],
                aliases: ["Pattern", "PatternLike", "LVal"],
                fields: Object.assign({}, A, {
                    properties: {
                        validate: (0,
                        T.chain)((0,
                        T.assertValueType)("array"), (0,
                        T.assertEach)((0,
                        T.assertNodeType)("RestElement", "ObjectProperty")))
                    }
                })
            }),
            S("SpreadElement", {
                visitor: ["argument"],
                aliases: ["UnaryLike"],
                deprecatedAlias: "SpreadProperty",
                fields: {
                    argument: {
                        validate: (0,
                        T.assertNodeType)("Expression")
                    }
                }
            }),
            S("Super", {
                aliases: ["Expression"]
            }),
            S("TaggedTemplateExpression", {
                visitor: ["tag", "quasi", "typeParameters"],
                builder: ["tag", "quasi"],
                aliases: ["Expression"],
                fields: {
                    tag: {
                        validate: (0,
                        T.assertNodeType)("Expression")
                    },
                    quasi: {
                        validate: (0,
                        T.assertNodeType)("TemplateLiteral")
                    },
                    typeParameters: {
                        validate: (0,
                        T.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
                        optional: !0
                    }
                }
            }),
            S("TemplateElement", {
                builder: ["value", "tail"],
                fields: {
                    value: {
                        validate: (0,
                        T.assertShape)({
                            raw: {
                                validate: (0,
                                T.assertValueType)("string")
                            },
                            cooked: {
                                validate: (0,
                                T.assertValueType)("string"),
                                optional: !0
                            }
                        })
                    },
                    tail: {
                        default: !1
                    }
                }
            }),
            S("TemplateLiteral", {
                visitor: ["quasis", "expressions"],
                aliases: ["Expression", "Literal"],
                fields: {
                    quasis: {
                        validate: (0,
                        T.chain)((0,
                        T.assertValueType)("array"), (0,
                        T.assertEach)((0,
                        T.assertNodeType)("TemplateElement")))
                    },
                    expressions: {
                        validate: (0,
                        T.chain)((0,
                        T.assertValueType)("array"), (0,
                        T.assertEach)((0,
                        T.assertNodeType)("Expression", "TSType")), (function(t, r, i) {
                            if (t.quasis.length !== i.length + 1)
                                throw new TypeError("Number of ".concat(t.type, " quasis should be exactly one more than the number of expressions.\nExpected ").concat(i.length + 1, " quasis but got ").concat(t.quasis.length))
                        }
                        ))
                    }
                }
            }),
            S("YieldExpression", {
                builder: ["argument", "delegate"],
                visitor: ["argument"],
                aliases: ["Expression", "Terminatorless"],
                fields: {
                    delegate: {
                        validate: (0,
                        T.chain)((0,
                        T.assertValueType)("boolean"), Object.assign((function(r, i, a) {
                            if (t.env.BABEL_TYPES_8_BREAKING && a && !r.argument)
                                throw new TypeError("Property delegate of YieldExpression cannot be true if there is no argument")
                        }
                        ), {
                            type: "boolean"
                        })),
                        default: !1
                    },
                    argument: {
                        optional: !0,
                        validate: (0,
                        T.assertNodeType)("Expression")
                    }
                }
            }),
            S("AwaitExpression", {
                builder: ["argument"],
                visitor: ["argument"],
                aliases: ["Expression", "Terminatorless"],
                fields: {
                    argument: {
                        validate: (0,
                        T.assertNodeType)("Expression")
                    }
                }
            }),
            S("Import", {
                aliases: ["Expression"]
            }),
            S("BigIntLiteral", {
                builder: ["value"],
                fields: {
                    value: {
                        validate: (0,
                        T.assertValueType)("string")
                    }
                },
                aliases: ["Expression", "Pureish", "Literal", "Immutable"]
            }),
            S("ExportNamespaceSpecifier", {
                visitor: ["exported"],
                aliases: ["ModuleSpecifier"],
                fields: {
                    exported: {
                        validate: (0,
                        T.assertNodeType)("Identifier")
                    }
                }
            }),
            S("OptionalMemberExpression", {
                builder: ["object", "property", "computed", "optional"],
                visitor: ["object", "property"],
                aliases: ["Expression"],
                fields: {
                    object: {
                        validate: (0,
                        T.assertNodeType)("Expression")
                    },
                    property: {
                        validate: function() {
                            var t = (0,
                            T.assertNodeType)("Identifier")
                              , r = (0,
                            T.assertNodeType)("Expression")
                              , i = function validator(i, a, o) {
                                var validator = i.computed ? r : t;
                                validator(i, a, o)
                            };
                            return i.oneOfNodeTypes = ["Expression", "Identifier"],
                            i
                        }()
                    },
                    computed: {
                        default: !1
                    },
                    optional: {
                        validate: t.env.BABEL_TYPES_8_BREAKING ? (0,
                        T.chain)((0,
                        T.assertValueType)("boolean"), (0,
                        T.assertOptionalChainStart)()) : (0,
                        T.assertValueType)("boolean")
                    }
                }
            }),
            S("OptionalCallExpression", {
                visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
                builder: ["callee", "arguments", "optional"],
                aliases: ["Expression"],
                fields: {
                    callee: {
                        validate: (0,
                        T.assertNodeType)("Expression")
                    },
                    arguments: {
                        validate: (0,
                        T.chain)((0,
                        T.assertValueType)("array"), (0,
                        T.assertEach)((0,
                        T.assertNodeType)("Expression", "SpreadElement", "JSXNamespacedName", "ArgumentPlaceholder")))
                    },
                    optional: {
                        validate: t.env.BABEL_TYPES_8_BREAKING ? (0,
                        T.chain)((0,
                        T.assertValueType)("boolean"), (0,
                        T.assertOptionalChainStart)()) : (0,
                        T.assertValueType)("boolean")
                    },
                    typeArguments: {
                        validate: (0,
                        T.assertNodeType)("TypeParameterInstantiation"),
                        optional: !0
                    },
                    typeParameters: {
                        validate: (0,
                        T.assertNodeType)("TSTypeParameterInstantiation"),
                        optional: !0
                    }
                }
            }),
            S("ClassProperty", {
                visitor: ["key", "value", "typeAnnotation", "decorators"],
                builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"],
                aliases: ["Property"],
                fields: Object.assign({}, w, {
                    value: {
                        validate: (0,
                        T.assertNodeType)("Expression"),
                        optional: !0
                    },
                    definite: {
                        validate: (0,
                        T.assertValueType)("boolean"),
                        optional: !0
                    },
                    typeAnnotation: {
                        validate: (0,
                        T.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
                        optional: !0
                    },
                    decorators: {
                        validate: (0,
                        T.chain)((0,
                        T.assertValueType)("array"), (0,
                        T.assertEach)((0,
                        T.assertNodeType)("Decorator"))),
                        optional: !0
                    },
                    readonly: {
                        validate: (0,
                        T.assertValueType)("boolean"),
                        optional: !0
                    },
                    declare: {
                        validate: (0,
                        T.assertValueType)("boolean"),
                        optional: !0
                    },
                    variance: {
                        validate: (0,
                        T.assertNodeType)("Variance"),
                        optional: !0
                    }
                })
            }),
            S("ClassPrivateProperty", {
                visitor: ["key", "value", "decorators", "typeAnnotation"],
                builder: ["key", "value", "decorators", "static"],
                aliases: ["Property", "Private"],
                fields: {
                    key: {
                        validate: (0,
                        T.assertNodeType)("PrivateName")
                    },
                    value: {
                        validate: (0,
                        T.assertNodeType)("Expression"),
                        optional: !0
                    },
                    typeAnnotation: {
                        validate: (0,
                        T.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
                        optional: !0
                    },
                    decorators: {
                        validate: (0,
                        T.chain)((0,
                        T.assertValueType)("array"), (0,
                        T.assertEach)((0,
                        T.assertNodeType)("Decorator"))),
                        optional: !0
                    },
                    readonly: {
                        validate: (0,
                        T.assertValueType)("boolean"),
                        optional: !0
                    },
                    definite: {
                        validate: (0,
                        T.assertValueType)("boolean"),
                        optional: !0
                    },
                    variance: {
                        validate: (0,
                        T.assertNodeType)("Variance"),
                        optional: !0
                    }
                }
            }),
            S("ClassPrivateMethod", {
                builder: ["kind", "key", "params", "body", "static"],
                visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
                aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method", "Private"],
                fields: Object.assign({}, C, b, {
                    key: {
                        validate: (0,
                        T.assertNodeType)("PrivateName")
                    },
                    body: {
                        validate: (0,
                        T.assertNodeType)("BlockStatement")
                    }
                })
            }),
            S("PrivateName", {
                visitor: ["id"],
                aliases: ["Private"],
                fields: {
                    id: {
                        validate: (0,
                        T.assertNodeType)("Identifier")
                    }
                }
            }),
            S("StaticBlock", {
                visitor: ["body"],
                fields: {
                    body: {
                        validate: (0,
                        T.chain)((0,
                        T.assertValueType)("array"), (0,
                        T.assertEach)((0,
                        T.assertNodeType)("Statement")))
                    }
                },
                aliases: ["Scopable", "BlockParent", "FunctionParent"]
            })
        }
        ).call(this, i("8oxB"))
    },
    zMfr: function(t, r, i) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.default = function cloneDeepWithoutLoc(t) {
            return (0,
            a.default)(t, !0, !0)
        }
        ;
        var a = i("v3g0")
    }
}]);
